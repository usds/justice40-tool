(self.webpackChunkjustice40_tool=self.webpackChunkjustice40_tool||[]).push([[98],{3022:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Il": function() { return /* binding */ Color; },\n/* harmony export */   "eG": function() { return /* binding */ derefLayers; },\n/* harmony export */   "th": function() { return /* binding */ expression$1; },\n/* harmony export */   "TE": function() { return /* binding */ createFilter; },\n/* harmony export */   "ZI": function() { return /* binding */ styleFunction; },\n/* harmony export */   "pA": function() { return /* binding */ v8; }\n/* harmony export */ });\n/* unused harmony exports ParsingError, ValidationError, composite, convertFilter, diff, format, migrate, v8, validate, validateMapboxApiSupported, visit */\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toArray__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9809);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5061);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8481);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5991);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6610);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(379);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6616);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7608);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5366);\n\n\n\n\n\n\n\n\n\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar $version = 8;\nvar $root = {\n  version: {\n    required: true,\n    type: "enum",\n    values: [8],\n    doc: "Style specification version number. Must be 8.",\n    example: 8\n  },\n  name: {\n    type: "string",\n    doc: "A human-readable name for the style.",\n    example: "Bright"\n  },\n  metadata: {\n    type: "*",\n    doc: "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like \'mapbox:\'."\n  },\n  center: {\n    type: "array",\n    value: "number",\n    doc: "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",\n    example: [-73.9749, 40.7736]\n  },\n  zoom: {\n    type: "number",\n    doc: "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",\n    example: 12.5\n  },\n  bearing: {\n    type: "number",\n    "default": 0,\n    period: 360,\n    units: "degrees",\n    doc: "Default bearing, in degrees. The bearing is the compass direction that is \\"up\\"; for example, a bearing of 90° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",\n    example: 29\n  },\n  pitch: {\n    type: "number",\n    "default": 0,\n    units: "degrees",\n    doc: "Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",\n    example: 50\n  },\n  light: {\n    type: "light",\n    doc: "The global light source.",\n    example: {\n      anchor: "viewport",\n      color: "white",\n      intensity: 0.4\n    }\n  },\n  terrain: {\n    type: "terrain",\n    doc: "A global modifier that elevates layers and markers based on a DEM data source."\n  },\n  fog: {\n    type: "fog",\n    doc: "A global effect that fades layers and markers based on their distance to the camera. The fog can be used to approximate the effect of atmosphere on distant objects and enhance the depth perception of the map when used with terrain or 3D features."\n  },\n  sources: {\n    required: true,\n    type: "sources",\n    doc: "Data source specifications.",\n    example: {\n      "mapbox-streets": {\n        type: "vector",\n        url: "mapbox://mapbox.mapbox-streets-v6"\n      }\n    }\n  },\n  sprite: {\n    type: "string",\n    doc: "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",\n    example: "mapbox://sprites/mapbox/bright-v8"\n  },\n  glyphs: {\n    type: "string",\n    doc: "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",\n    example: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"\n  },\n  transition: {\n    type: "transition",\n    doc: "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style\'s `transition` property.",\n    example: {\n      duration: 300,\n      delay: 0\n    }\n  },\n  layers: {\n    required: true,\n    type: "array",\n    value: "layer",\n    doc: "Layers will be drawn in the order of this array.",\n    example: [{\n      id: "water",\n      source: "mapbox-streets",\n      "source-layer": "water",\n      type: "fill",\n      paint: {\n        "fill-color": "#00ffff"\n      }\n    }]\n  }\n};\nvar sources = {\n  "*": {\n    type: "source",\n    doc: "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided."\n  }\n};\nvar source = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"];\nvar source_vector = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      vector: {\n        doc: "A vector tile source."\n      }\n    },\n    doc: "The type of the source."\n  },\n  url: {\n    type: "string",\n    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."\n  },\n  tiles: {\n    type: "array",\n    value: "string",\n    doc: "An array of one or more tile source URLs, as in the TileJSON spec."\n  },\n  bounds: {\n    type: "array",\n    value: "number",\n    length: 4,\n    "default": [-180, -85.051129, 180, 85.051129],\n    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source\'s bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."\n  },\n  scheme: {\n    type: "enum",\n    values: {\n      xyz: {\n        doc: "Slippy map tilenames scheme."\n      },\n      tms: {\n        doc: "OSGeo spec scheme."\n      }\n    },\n    "default": "xyz",\n    doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."\n  },\n  minzoom: {\n    type: "number",\n    "default": 0,\n    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."\n  },\n  maxzoom: {\n    type: "number",\n    "default": 22,\n    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."\n  },\n  attribution: {\n    type: "string",\n    doc: "Contains an attribution to be displayed when the map is shown to a user."\n  },\n  promoteId: {\n    type: "promoteId",\n    doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers."\n  },\n  volatile: {\n    type: "boolean",\n    "default": false,\n    doc: "A setting to determine whether a source\'s tiles are cached locally.",\n    "sdk-support": {\n      "basic functionality": {\n        android: "9.3.0",\n        ios: "5.10.0"\n      }\n    }\n  },\n  "*": {\n    type: "*",\n    doc: "Other keys to configure the data source."\n  }\n};\nvar source_raster = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      raster: {\n        doc: "A raster tile source."\n      }\n    },\n    doc: "The type of the source."\n  },\n  url: {\n    type: "string",\n    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."\n  },\n  tiles: {\n    type: "array",\n    value: "string",\n    doc: "An array of one or more tile source URLs, as in the TileJSON spec."\n  },\n  bounds: {\n    type: "array",\n    value: "number",\n    length: 4,\n    "default": [-180, -85.051129, 180, 85.051129],\n    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source\'s bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."\n  },\n  minzoom: {\n    type: "number",\n    "default": 0,\n    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."\n  },\n  maxzoom: {\n    type: "number",\n    "default": 22,\n    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."\n  },\n  tileSize: {\n    type: "number",\n    "default": 512,\n    units: "pixels",\n    doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."\n  },\n  scheme: {\n    type: "enum",\n    values: {\n      xyz: {\n        doc: "Slippy map tilenames scheme."\n      },\n      tms: {\n        doc: "OSGeo spec scheme."\n      }\n    },\n    "default": "xyz",\n    doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."\n  },\n  attribution: {\n    type: "string",\n    doc: "Contains an attribution to be displayed when the map is shown to a user."\n  },\n  volatile: {\n    type: "boolean",\n    "default": false,\n    doc: "A setting to determine whether a source\'s tiles are cached locally.",\n    "sdk-support": {\n      "basic functionality": {\n        android: "9.3.0",\n        ios: "5.10.0"\n      }\n    }\n  },\n  "*": {\n    type: "*",\n    doc: "Other keys to configure the data source."\n  }\n};\nvar source_raster_dem = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      "raster-dem": {\n        doc: "A RGB-encoded raster DEM source"\n      }\n    },\n    doc: "The type of the source."\n  },\n  url: {\n    type: "string",\n    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."\n  },\n  tiles: {\n    type: "array",\n    value: "string",\n    doc: "An array of one or more tile source URLs, as in the TileJSON spec."\n  },\n  bounds: {\n    type: "array",\n    value: "number",\n    length: 4,\n    "default": [-180, -85.051129, 180, 85.051129],\n    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source\'s bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."\n  },\n  minzoom: {\n    type: "number",\n    "default": 0,\n    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."\n  },\n  maxzoom: {\n    type: "number",\n    "default": 22,\n    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."\n  },\n  tileSize: {\n    type: "number",\n    "default": 512,\n    units: "pixels",\n    doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."\n  },\n  attribution: {\n    type: "string",\n    doc: "Contains an attribution to be displayed when the map is shown to a user."\n  },\n  encoding: {\n    type: "enum",\n    values: {\n      terrarium: {\n        doc: "Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info."\n      },\n      mapbox: {\n        doc: "Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info."\n      }\n    },\n    "default": "mapbox",\n    doc: "The encoding used by this source. Mapbox Terrain RGB is used by default"\n  },\n  volatile: {\n    type: "boolean",\n    "default": false,\n    doc: "A setting to determine whether a source\'s tiles are cached locally.",\n    "sdk-support": {\n      "basic functionality": {\n        android: "9.3.0",\n        ios: "5.10.0"\n      }\n    }\n  },\n  "*": {\n    type: "*",\n    doc: "Other keys to configure the data source."\n  }\n};\nvar source_geojson = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      geojson: {\n        doc: "A GeoJSON data source."\n      }\n    },\n    doc: "The data type of the GeoJSON source."\n  },\n  data: {\n    type: "*",\n    doc: "A URL to a GeoJSON file, or inline GeoJSON."\n  },\n  maxzoom: {\n    type: "number",\n    "default": 18,\n    doc: "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."\n  },\n  attribution: {\n    type: "string",\n    doc: "Contains an attribution to be displayed when the map is shown to a user."\n  },\n  buffer: {\n    type: "number",\n    "default": 128,\n    maximum: 512,\n    minimum: 0,\n    doc: "Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance."\n  },\n  filter: {\n    type: "*",\n    doc: "An expression for filtering features prior to processing them for rendering."\n  },\n  tolerance: {\n    type: "number",\n    "default": 0.375,\n    doc: "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."\n  },\n  cluster: {\n    type: "boolean",\n    "default": false,\n    doc: "If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\\n * `cluster` Is `true` if the point is a cluster \\n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\\n * `point_count` Number of original points grouped into this cluster\\n * `point_count_abbreviated` An abbreviated point count"\n  },\n  clusterRadius: {\n    type: "number",\n    "default": 50,\n    minimum: 0,\n    doc: "Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile."\n  },\n  clusterMaxZoom: {\n    type: "number",\n    doc: "Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered). Clusters are re-evaluated at integer zoom levels so setting clusterMaxZoom to 14 means the clusters will be displayed until z15."\n  },\n  clusterMinPoints: {\n    type: "number",\n    doc: "Minimum number of points necessary to form a cluster if clustering is enabled. Defaults to `2`."\n  },\n  clusterProperties: {\n    type: "*",\n    doc: "An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{\\"property_name\\": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `\\"+\\"` or `\\"max\\"`) — it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\\n\\nExample: `{\\"sum\\": [\\"+\\", [\\"get\\", \\"scalerank\\"]]}`.\\n\\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `[\\"accumulated\\"]` value, e.g.:\\n`{\\"sum\\": [[\\"+\\", [\\"accumulated\\"], [\\"get\\", \\"sum\\"]], [\\"get\\", \\"scalerank\\"]]}`"\n  },\n  lineMetrics: {\n    type: "boolean",\n    "default": false,\n    doc: "Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values."\n  },\n  generateId: {\n    type: "boolean",\n    "default": false,\n    doc: "Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values."\n  },\n  promoteId: {\n    type: "promoteId",\n    doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`."\n  }\n};\nvar source_video = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      video: {\n        doc: "A video data source."\n      }\n    },\n    doc: "The data type of the video source."\n  },\n  urls: {\n    required: true,\n    type: "array",\n    value: "string",\n    doc: "URLs to video content in order of preferred format."\n  },\n  coordinates: {\n    required: true,\n    doc: "Corners of video specified in longitude, latitude pairs.",\n    type: "array",\n    length: 4,\n    value: {\n      type: "array",\n      length: 2,\n      value: "number",\n      doc: "A single longitude, latitude pair."\n    }\n  }\n};\nvar source_image = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      image: {\n        doc: "An image data source."\n      }\n    },\n    doc: "The data type of the image source."\n  },\n  url: {\n    required: true,\n    type: "string",\n    doc: "URL that points to an image."\n  },\n  coordinates: {\n    required: true,\n    doc: "Corners of image specified in longitude, latitude pairs.",\n    type: "array",\n    length: 4,\n    value: {\n      type: "array",\n      length: 2,\n      value: "number",\n      doc: "A single longitude, latitude pair."\n    }\n  }\n};\nvar layer = {\n  id: {\n    type: "string",\n    doc: "Unique layer name.",\n    required: true\n  },\n  type: {\n    type: "enum",\n    values: {\n      fill: {\n        doc: "A filled polygon with an optional stroked border.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      line: {\n        doc: "A stroked line.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      symbol: {\n        doc: "An icon or a text label.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      circle: {\n        doc: "A filled circle.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      heatmap: {\n        doc: "A heatmap.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.41.0",\n            android: "6.0.0",\n            ios: "4.0.0",\n            macos: "0.7.0"\n          }\n        }\n      },\n      "fill-extrusion": {\n        doc: "An extruded (3D) polygon.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.27.0",\n            android: "5.1.0",\n            ios: "3.6.0",\n            macos: "0.5.0"\n          }\n        }\n      },\n      raster: {\n        doc: "Raster map textures such as satellite imagery.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      hillshade: {\n        doc: "Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.43.0",\n            android: "6.0.0",\n            ios: "4.0.0",\n            macos: "0.7.0"\n          }\n        }\n      },\n      background: {\n        doc: "The background color or pattern of the map.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      sky: {\n        doc: "A spherical dome around the map that is always rendered behind all other layers.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "2.0.0"\n          }\n        }\n      }\n    },\n    doc: "Rendering type of this layer.",\n    required: true\n  },\n  metadata: {\n    type: "*",\n    doc: "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like \'mapbox:\'."\n  },\n  source: {\n    type: "string",\n    doc: "Name of a source description to be used for this layer. Required for all layer types except `background`."\n  },\n  "source-layer": {\n    type: "string",\n    doc: "Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources."\n  },\n  minzoom: {\n    type: "number",\n    minimum: 0,\n    maximum: 24,\n    doc: "The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden."\n  },\n  maxzoom: {\n    type: "number",\n    minimum: 0,\n    maximum: 24,\n    doc: "The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden."\n  },\n  filter: {\n    type: "filter",\n    doc: "A expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `feature-state` expression is not supported in filter expressions."\n  },\n  layout: {\n    type: "layout",\n    doc: "Layout properties for the layer."\n  },\n  paint: {\n    type: "paint",\n    doc: "Default paint properties for this layer."\n  }\n};\nvar layout = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background", "layout_sky"];\nvar layout_background = {\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_sky = {\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_fill = {\n  "fill-sort-key": {\n    type: "number",\n    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "1.2.0",\n        android: "9.1.0",\n        ios: "5.8.0",\n        macos: "0.15.0"\n      },\n      "data-driven styling": {\n        js: "1.2.0",\n        android: "9.1.0",\n        ios: "5.8.0",\n        macos: "0.15.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_circle = {\n  "circle-sort-key": {\n    type: "number",\n    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "1.2.0",\n        android: "9.2.0",\n        ios: "5.9.0",\n        macos: "0.16.0"\n      },\n      "data-driven styling": {\n        js: "1.2.0",\n        android: "9.2.0",\n        ios: "5.9.0",\n        macos: "0.16.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_heatmap = {\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_line = {\n  "line-cap": {\n    type: "enum",\n    values: {\n      butt: {\n        doc: "A cap with a squared-off end which is drawn to the exact endpoint of the line."\n      },\n      round: {\n        doc: "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line\'s width and centered on the endpoint of the line."\n      },\n      square: {\n        doc: "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line\'s width."\n      }\n    },\n    "default": "butt",\n    doc: "The display of line endings.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "2.3.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-join": {\n    type: "enum",\n    values: {\n      bevel: {\n        doc: "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line\'s width."\n      },\n      round: {\n        doc: "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line\'s width and centered on the endpoint of the line."\n      },\n      miter: {\n        doc: "A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet."\n      }\n    },\n    "default": "miter",\n    doc: "The display of lines when joining.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.40.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-miter-limit": {\n    type: "number",\n    "default": 2,\n    doc: "Used to automatically convert miter joins to bevel joins for sharp angles.",\n    requires: [{\n      "line-join": "miter"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "line-round-limit": {\n    type: "number",\n    "default": 1.05,\n    doc: "Used to automatically convert round joins to miter joins for shallow angles.",\n    requires: [{\n      "line-join": "round"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "line-sort-key": {\n    type: "number",\n    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "1.2.0",\n        android: "9.1.0",\n        ios: "5.8.0",\n        macos: "0.15.0"\n      },\n      "data-driven styling": {\n        js: "1.2.0",\n        android: "9.1.0",\n        ios: "5.8.0",\n        macos: "0.15.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_symbol = {\n  "symbol-placement": {\n    type: "enum",\n    values: {\n      point: {\n        doc: "The label is placed at the point where the geometry is located."\n      },\n      line: {\n        doc: "The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries."\n      },\n      "line-center": {\n        doc: "The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries."\n      }\n    },\n    "default": "point",\n    doc: "Label placement relative to its geometry.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "`line-center` value": {\n        js: "0.47.0",\n        android: "6.4.0",\n        ios: "4.3.0",\n        macos: "0.10.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "symbol-spacing": {\n    type: "number",\n    "default": 250,\n    minimum: 1,\n    units: "pixels",\n    doc: "Distance between two symbol anchors.",\n    requires: [{\n      "symbol-placement": "line"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "symbol-avoid-edges": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don\'t have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "symbol-sort-key": {\n    type: "number",\n    doc: "Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.53.0",\n        android: "7.4.0",\n        ios: "4.11.0",\n        macos: "0.14.0"\n      },\n      "data-driven styling": {\n        js: "0.53.0",\n        android: "7.4.0",\n        ios: "4.11.0",\n        macos: "0.14.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "symbol-z-order": {\n    type: "enum",\n    values: {\n      auto: {\n        doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."\n      },\n      "viewport-y": {\n        doc: "Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."\n      },\n      source: {\n        doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data."\n      }\n    },\n    "default": "auto",\n    doc: "Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.49.0",\n        android: "6.6.0",\n        ios: "4.5.0",\n        macos: "0.12.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-allow-overlap": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, the icon will be visible even if it collides with other previously drawn symbols.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-ignore-placement": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, other symbols can be visible even if they collide with the icon.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-optional": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",\n    requires: ["icon-image", "text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-rotation-alignment": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line."\n      },\n      viewport: {\n        doc: "Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."\n      },\n      auto: {\n        doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."\n      }\n    },\n    "default": "auto",\n    doc: "In combination with `symbol-placement`, determines the rotation behavior of icons.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "`auto` value": {\n        js: "0.25.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.3.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-size": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    units: "factor of the original icon size",\n    doc: "Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.35.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-text-fit": {\n    type: "enum",\n    values: {\n      none: {\n        doc: "The icon is displayed at its intrinsic aspect ratio."\n      },\n      width: {\n        doc: "The icon is scaled in the x-dimension to fit the width of the text."\n      },\n      height: {\n        doc: "The icon is scaled in the y-dimension to fit the height of the text."\n      },\n      both: {\n        doc: "The icon is scaled in both x- and y-dimensions."\n      }\n    },\n    "default": "none",\n    doc: "Scales the icon to fit around the associated text.",\n    requires: ["icon-image", "text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.21.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.2.1"\n      },\n      "stretchable icons": {\n        js: "1.6.0",\n        android: "9.2.0",\n        ios: "5.8.0",\n        macos: "0.15.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-text-fit-padding": {\n    type: "array",\n    value: "number",\n    length: 4,\n    "default": [0, 0, 0, 0],\n    units: "pixels",\n    doc: "Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.",\n    requires: ["icon-image", "text-field", {\n      "icon-text-fit": ["both", "width", "height"]\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.21.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.2.1"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-image": {\n    type: "resolvedImage",\n    doc: "Name of image in sprite to use for drawing an image background.",\n    tokens: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.35.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-rotate": {\n    type: "number",\n    "default": 0,\n    period: 360,\n    units: "degrees",\n    doc: "Rotates the icon clockwise.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.21.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-padding": {\n    type: "number",\n    "default": 2,\n    minimum: 0,\n    units: "pixels",\n    doc: "Size of the additional area around the icon bounding box used for detecting symbol collisions.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-keep-upright": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, the icon may be flipped to prevent it from being rendered upside-down.",\n    requires: ["icon-image", {\n      "icon-rotation-alignment": "map"\n    }, {\n      "symbol-placement": ["line", "line-center"]\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-offset": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    doc: "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-anchor": {\n    type: "enum",\n    values: {\n      center: {\n        doc: "The center of the icon is placed closest to the anchor."\n      },\n      left: {\n        doc: "The left side of the icon is placed closest to the anchor."\n      },\n      right: {\n        doc: "The right side of the icon is placed closest to the anchor."\n      },\n      top: {\n        doc: "The top of the icon is placed closest to the anchor."\n      },\n      bottom: {\n        doc: "The bottom of the icon is placed closest to the anchor."\n      },\n      "top-left": {\n        doc: "The top left corner of the icon is placed closest to the anchor."\n      },\n      "top-right": {\n        doc: "The top right corner of the icon is placed closest to the anchor."\n      },\n      "bottom-left": {\n        doc: "The bottom left corner of the icon is placed closest to the anchor."\n      },\n      "bottom-right": {\n        doc: "The bottom right corner of the icon is placed closest to the anchor."\n      }\n    },\n    "default": "center",\n    doc: "Part of the icon placed closest to the anchor.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.40.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      },\n      "data-driven styling": {\n        js: "0.40.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-pitch-alignment": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The icon is aligned to the plane of the map."\n      },\n      viewport: {\n        doc: "The icon is aligned to the plane of the viewport."\n      },\n      auto: {\n        doc: "Automatically matches the value of `icon-rotation-alignment`."\n      }\n    },\n    "default": "auto",\n    doc: "Orientation of icon when map is pitched.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.39.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-pitch-alignment": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The text is aligned to the plane of the map."\n      },\n      viewport: {\n        doc: "The text is aligned to the plane of the viewport."\n      },\n      auto: {\n        doc: "Automatically matches the value of `text-rotation-alignment`."\n      }\n    },\n    "default": "auto",\n    doc: "Orientation of text when map is pitched.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.21.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.2.1"\n      },\n      "`auto` value": {\n        js: "0.25.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.3.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-rotation-alignment": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line."\n      },\n      viewport: {\n        doc: "Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."\n      },\n      auto: {\n        doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."\n      }\n    },\n    "default": "auto",\n    doc: "In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "`auto` value": {\n        js: "0.25.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.3.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-field": {\n    type: "formatted",\n    "default": "",\n    tokens: true,\n    doc: "Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-font": {\n    type: "array",\n    value: "string",\n    "default": ["Open Sans Regular", "Arial Unicode MS Regular"],\n    doc: "Font stack to use for displaying text.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-size": {\n    type: "number",\n    "default": 16,\n    minimum: 0,\n    units: "pixels",\n    doc: "Font size.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.35.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-max-width": {\n    type: "number",\n    "default": 10,\n    minimum: 0,\n    units: "ems",\n    doc: "The maximum line width for text wrapping.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.40.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-line-height": {\n    type: "number",\n    "default": 1.2,\n    units: "ems",\n    doc: "Text leading value for multi-line text.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "2.3.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-letter-spacing": {\n    type: "number",\n    "default": 0,\n    units: "ems",\n    doc: "Text tracking amount.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.40.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-justify": {\n    type: "enum",\n    values: {\n      auto: {\n        doc: "The text is aligned towards the anchor position."\n      },\n      left: {\n        doc: "The text is aligned to the left."\n      },\n      center: {\n        doc: "The text is centered."\n      },\n      right: {\n        doc: "The text is aligned to the right."\n      }\n    },\n    "default": "center",\n    doc: "Text justification options.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.39.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      },\n      auto: {\n        js: "0.54.0",\n        android: "7.4.0",\n        ios: "4.10.0",\n        macos: "0.14.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-radial-offset": {\n    type: "number",\n    units: "ems",\n    "default": 0,\n    doc: "Radial offset of text, in the direction of the symbol\'s anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.54.0",\n        android: "7.4.0",\n        ios: "4.10.0",\n        macos: "0.14.0"\n      },\n      "data-driven styling": {\n        js: "0.54.0",\n        android: "7.4.0",\n        ios: "4.10.0",\n        macos: "0.14.0"\n      }\n    },\n    requires: ["text-field"],\n    "property-type": "data-driven",\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    }\n  },\n  "text-variable-anchor": {\n    type: "array",\n    value: "enum",\n    values: {\n      center: {\n        doc: "The center of the text is placed closest to the anchor."\n      },\n      left: {\n        doc: "The left side of the text is placed closest to the anchor."\n      },\n      right: {\n        doc: "The right side of the text is placed closest to the anchor."\n      },\n      top: {\n        doc: "The top of the text is placed closest to the anchor."\n      },\n      bottom: {\n        doc: "The bottom of the text is placed closest to the anchor."\n      },\n      "top-left": {\n        doc: "The top left corner of the text is placed closest to the anchor."\n      },\n      "top-right": {\n        doc: "The top right corner of the text is placed closest to the anchor."\n      },\n      "bottom-left": {\n        doc: "The bottom left corner of the text is placed closest to the anchor."\n      },\n      "bottom-right": {\n        doc: "The bottom right corner of the text is placed closest to the anchor."\n      }\n    },\n    requires: ["text-field", {\n      "symbol-placement": ["point"]\n    }],\n    doc: "To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.54.0",\n        android: "7.4.0",\n        ios: "4.10.0",\n        macos: "0.14.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-anchor": {\n    type: "enum",\n    values: {\n      center: {\n        doc: "The center of the text is placed closest to the anchor."\n      },\n      left: {\n        doc: "The left side of the text is placed closest to the anchor."\n      },\n      right: {\n        doc: "The right side of the text is placed closest to the anchor."\n      },\n      top: {\n        doc: "The top of the text is placed closest to the anchor."\n      },\n      bottom: {\n        doc: "The bottom of the text is placed closest to the anchor."\n      },\n      "top-left": {\n        doc: "The top left corner of the text is placed closest to the anchor."\n      },\n      "top-right": {\n        doc: "The top right corner of the text is placed closest to the anchor."\n      },\n      "bottom-left": {\n        doc: "The bottom left corner of the text is placed closest to the anchor."\n      },\n      "bottom-right": {\n        doc: "The bottom right corner of the text is placed closest to the anchor."\n      }\n    },\n    "default": "center",\n    doc: "Part of the text placed closest to the anchor.",\n    requires: ["text-field", {\n      "!": "text-variable-anchor"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.39.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-max-angle": {\n    type: "number",\n    "default": 45,\n    units: "degrees",\n    doc: "Maximum angle change between adjacent characters.",\n    requires: ["text-field", {\n      "symbol-placement": ["line", "line-center"]\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-writing-mode": {\n    type: "array",\n    value: "enum",\n    values: {\n      horizontal: {\n        doc: "If a text\'s language supports horizontal writing mode, symbols with point placement would be laid out horizontally."\n      },\n      vertical: {\n        doc: "If a text\'s language supports vertical writing mode, symbols with point placement would be laid out vertically."\n      }\n    },\n    doc: "The property allows control over a symbol\'s orientation. Note that the property values act as a hint, so that a symbol whose language doesn’t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single \'vertical\' enum value. The order of elements in an array define priority order for the placement of an orientation variant.",\n    requires: ["text-field", {\n      "symbol-placement": ["point"]\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "1.3.0",\n        android: "8.3.0",\n        ios: "5.3.0",\n        macos: "0.15.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-rotate": {\n    type: "number",\n    "default": 0,\n    period: 360,\n    units: "degrees",\n    doc: "Rotates the text clockwise.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.35.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-padding": {\n    type: "number",\n    "default": 2,\n    minimum: 0,\n    units: "pixels",\n    doc: "Size of the additional area around the text bounding box used for detecting symbol collisions.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-keep-upright": {\n    type: "boolean",\n    "default": true,\n    doc: "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",\n    requires: ["text-field", {\n      "text-rotation-alignment": "map"\n    }, {\n      "symbol-placement": ["line", "line-center"]\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-transform": {\n    type: "enum",\n    values: {\n      none: {\n        doc: "The text is not altered."\n      },\n      uppercase: {\n        doc: "Forces all letters to be displayed in uppercase."\n      },\n      lowercase: {\n        doc: "Forces all letters to be displayed in lowercase."\n      }\n    },\n    "default": "none",\n    doc: "Specifies how to capitalize text, similar to the CSS `text-transform` property.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-offset": {\n    type: "array",\n    doc: "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.",\n    value: "number",\n    units: "ems",\n    length: 2,\n    "default": [0, 0],\n    requires: ["text-field", {\n      "!": "text-radial-offset"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.35.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-allow-overlap": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, the text will be visible even if it collides with other previously drawn symbols.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-ignore-placement": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, other symbols can be visible even if they collide with the text.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-optional": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",\n    requires: ["text-field", "icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_raster = {\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_hillshade = {\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar filter = {\n  type: "array",\n  value: "*",\n  doc: "A filter selects specific features from a layer."\n};\nvar filter_operator = {\n  type: "enum",\n  values: {\n    "==": {\n      doc: "`[\\"==\\", key, value]` equality: `feature[key] = value`"\n    },\n    "!=": {\n      doc: "`[\\"!=\\", key, value]` inequality: `feature[key] ≠ value`"\n    },\n    ">": {\n      doc: "`[\\">\\", key, value]` greater than: `feature[key] > value`"\n    },\n    ">=": {\n      doc: "`[\\">=\\", key, value]` greater than or equal: `feature[key] ≥ value`"\n    },\n    "<": {\n      doc: "`[\\"<\\", key, value]` less than: `feature[key] < value`"\n    },\n    "<=": {\n      doc: "`[\\"<=\\", key, value]` less than or equal: `feature[key] ≤ value`"\n    },\n    "in": {\n      doc: "`[\\"in\\", key, v0, ..., vn]` set inclusion: `feature[key] ∈ {v0, ..., vn}`"\n    },\n    "!in": {\n      doc: "`[\\"!in\\", key, v0, ..., vn]` set exclusion: `feature[key] ∉ {v0, ..., vn}`"\n    },\n    all: {\n      doc: "`[\\"all\\", f0, ..., fn]` logical `AND`: `f0 ∧ ... ∧ fn`"\n    },\n    any: {\n      doc: "`[\\"any\\", f0, ..., fn]` logical `OR`: `f0 ∨ ... ∨ fn`"\n    },\n    none: {\n      doc: "`[\\"none\\", f0, ..., fn]` logical `NOR`: `¬f0 ∧ ... ∧ ¬fn`"\n    },\n    has: {\n      doc: "`[\\"has\\", key]` `feature[key]` exists"\n    },\n    "!has": {\n      doc: "`[\\"!has\\", key]` `feature[key]` does not exist"\n    },\n    within: {\n      doc: "`[\\"within\\", object]` feature geometry is within object geometry"\n    }\n  },\n  doc: "The filter operator."\n};\nvar geometry_type = {\n  type: "enum",\n  values: {\n    Point: {\n      doc: "Filter to point geometries."\n    },\n    LineString: {\n      doc: "Filter to line geometries."\n    },\n    Polygon: {\n      doc: "Filter to polygon geometries."\n    }\n  },\n  doc: "The geometry type for the filter to select."\n};\nvar function_stop = {\n  type: "array",\n  minimum: 0,\n  maximum: 24,\n  value: ["number", "color"],\n  length: 2,\n  doc: "Zoom level and value pair."\n};\nvar expression = {\n  type: "array",\n  value: "*",\n  minimum: 1,\n  doc: "An expression defines a function that can be used for data-driven style properties or feature filters."\n};\nvar expression_name = {\n  doc: "",\n  type: "enum",\n  values: {\n    "let": {\n      doc: "Binds expressions to named variables, which can then be referenced in the result expression using [\\"var\\", \\"variable_name\\"].",\n      group: "Variable binding",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "var": {\n      doc: "References variable bound using \\"let\\".",\n      group: "Variable binding",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    literal: {\n      doc: "Provides a literal array or object value.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    array: {\n      doc: "Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    at: {\n      doc: "Retrieves an item from an array.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "in": {\n      doc: "Determines whether an item exists in an array or a substring exists in a string.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "1.6.0",\n          android: "9.1.0",\n          ios: "5.8.0",\n          macos: "0.15.0"\n        }\n      }\n    },\n    "index-of": {\n      doc: "Returns the first position at which an item can be found in an array or a substring can be found in a string, or `-1` if the input cannot be found. Accepts an optional index from where to begin the search.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "1.10.0"\n        }\n      }\n    },\n    slice: {\n      doc: "Returns an item from an array or a substring from a string from a specified start index, or between a start index and an end index if set. The return value is inclusive of the start index but not of the end index.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "1.10.0"\n        }\n      }\n    },\n    "case": {\n      doc: "Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    match: {\n      doc: "Selects the output for which the label value matches the input value, or the fallback value if no match is found. The input can be any expression (for example, `[\\"get\\", \\"building_type\\"]`). Each label must be unique, and must be either:\\n - a single literal value; or\\n - an array of literal values, the values of which must be all strings or all numbers (for example `[100, 101]` or `[\\"c\\", \\"b\\"]`).\\n\\nThe input matches if any of the values in the array matches using strict equality, similar to the `\\"in\\"` operator.\\nIf the input type does not match the type of the labels, the result will be the fallback value.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    coalesce: {\n      doc: "Evaluates each expression in turn until the first non-null value is obtained, and returns that value.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    step: {\n      doc: "Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values (\\"stops\\"). The `input` may be any numeric expression (e.g., `[\\"get\\", \\"population\\"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.",\n      group: "Ramps, scales, curves",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.42.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    interpolate: {\n      doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\\"stops\\"). The `input` may be any numeric expression (e.g., `[\\"get\\", \\"population\\"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\\n\\nInterpolation types:\\n- `[\\"linear\\"]`: Interpolates linearly between the pair of stops just less than and just greater than the input.\\n- `[\\"exponential\\", base]`: Interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\\n- `[\\"cubic-bezier\\", x1, y1, x2, y2]`: Interpolates using the cubic bezier curve defined by the given control points.",\n      group: "Ramps, scales, curves",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.42.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "interpolate-hcl": {\n      doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\\"stops\\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.",\n      group: "Ramps, scales, curves",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.49.0"\n        }\n      }\n    },\n    "interpolate-lab": {\n      doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\\"stops\\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.",\n      group: "Ramps, scales, curves",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.49.0"\n        }\n      }\n    },\n    ln2: {\n      doc: "Returns mathematical constant ln(2).",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    pi: {\n      doc: "Returns the mathematical constant pi.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    e: {\n      doc: "Returns the mathematical constant e.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "typeof": {\n      doc: "Returns a string describing the type of the given value.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    string: {\n      doc: "Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    number: {\n      doc: "Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    boolean: {\n      doc: "Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    object: {\n      doc: "Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    collator: {\n      doc: "Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    format: {\n      doc: "Returns a `formatted` string for displaying mixed-format text in the `text-field` property. The input may contain a string literal or expression, including an [`\'image\'`](#types-image) expression. Strings may be followed by a style override object that supports the following properties:\\n- `\\"text-font\\"`: Overrides the font stack specified by the root layout property.\\n- `\\"text-color\\"`: Overrides the color specified by the root paint property.\\n- `\\"font-scale\\"`: Applies a scaling factor on `text-size` as specified by the root layout property.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.48.0",\n          android: "6.7.0",\n          ios: "4.6.0",\n          macos: "0.12.0"\n        },\n        "text-font": {\n          js: "0.48.0",\n          android: "6.7.0",\n          ios: "4.6.0",\n          macos: "0.12.0"\n        },\n        "font-scale": {\n          js: "0.48.0",\n          android: "6.7.0",\n          ios: "4.6.0",\n          macos: "0.12.0"\n        },\n        "text-color": {\n          js: "1.3.0",\n          android: "7.3.0",\n          ios: "4.10.0",\n          macos: "0.14.0"\n        },\n        image: {\n          js: "1.6.0",\n          android: "8.6.0",\n          ios: "5.7.0",\n          macos: "0.15.0"\n        }\n      }\n    },\n    image: {\n      doc: "Returns an `image` type for use in `icon-image`, `*-pattern` entries and as a section in the `format` expression. If set, the `image` argument will check that the requested image exists in the style and will return either the resolved image name or `null`, depending on whether or not the image is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `image` argument.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "1.4.0",\n          android: "8.6.0",\n          ios: "5.7.0",\n          macos: "0.15.0"\n        }\n      }\n    },\n    "number-format": {\n      doc: "Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.54.0"\n        }\n      }\n    },\n    "to-string": {\n      doc: "Converts the input value to a string. If the input is `null`, the result is `\\"\\"`. If the input is a boolean, the result is `\\"true\\"` or `\\"false\\"`. If the input is a number, it is converted to a string as specified by the [\\"NumberToString\\" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a color, it is converted to a string of the form `\\"rgba(r,g,b,a)\\"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "to-number": {\n      doc: "Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the [\\"ToNumber Applied to the String Type\\" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "to-boolean": {\n      doc: "Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "to-rgba": {\n      doc: "Returns a four-element array containing the input color\'s red, green, blue, and alpha components, in that order.",\n      group: "Color",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "to-color": {\n      doc: "Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    rgb: {\n      doc: "Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.",\n      group: "Color",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    rgba: {\n      doc: "Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.",\n      group: "Color",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    get: {\n      doc: "Retrieves a property value from the current feature\'s properties, or from another object if a second argument is provided. Returns null if the requested property is missing.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    has: {\n      doc: "Tests for the presence of an property value in the current feature\'s properties, or from another object if a second argument is provided.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    length: {\n      doc: "Gets the length of an array or string.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    properties: {\n      doc: "Gets the feature properties object.  Note that in some cases, it may be more efficient to use [\\"get\\", \\"property_name\\"] directly.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "feature-state": {\n      doc: "Retrieves a property value from the current feature\'s state. Returns null if the requested property is not present on the feature\'s state. A feature\'s state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\\"feature-state\\"] can only be used with paint properties that support data-driven styling.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.46.0"\n        }\n      }\n    },\n    "geometry-type": {\n      doc: "Gets the feature\'s geometry type: `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    id: {\n      doc: "Gets the feature\'s id, if it has one.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    zoom: {\n      doc: "Gets the current zoom level.  Note that in style layout and paint properties, [\\"zoom\\"] may only appear as the input to a top-level \\"step\\" or \\"interpolate\\" expression.",\n      group: "Zoom",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "heatmap-density": {\n      doc: "Gets the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.",\n      group: "Heatmap",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "line-progress": {\n      doc: "Gets the progress along a gradient line. Can only be used in the `line-gradient` property.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.6.0",\n          macos: "0.12.0"\n        }\n      }\n    },\n    "sky-radial-progress": {\n      doc: "Gets the distance of a point on the sky from the sun position. Returns 0 at sun position and 1 when the distance reaches `sky-gradient-radius`. Can only be used in the `sky-gradient` property.",\n      group: "sky",\n      "sdk-support": {\n        "basic functionality": {\n          js: "2.0.0"\n        }\n      }\n    },\n    accumulated: {\n      doc: "Gets the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.53.0"\n        }\n      }\n    },\n    "+": {\n      doc: "Returns the sum of the inputs.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "*": {\n      doc: "Returns the product of the inputs.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "-": {\n      doc: "For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "/": {\n      doc: "Returns the result of floating point division of the first input by the second.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "%": {\n      doc: "Returns the remainder after integer division of the first input by the second.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "^": {\n      doc: "Returns the result of raising the first input to the power specified by the second.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    sqrt: {\n      doc: "Returns the square root of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.42.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    log10: {\n      doc: "Returns the base-ten logarithm of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    ln: {\n      doc: "Returns the natural logarithm of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    log2: {\n      doc: "Returns the base-two logarithm of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    sin: {\n      doc: "Returns the sine of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    cos: {\n      doc: "Returns the cosine of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    tan: {\n      doc: "Returns the tangent of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    asin: {\n      doc: "Returns the arcsine of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    acos: {\n      doc: "Returns the arccosine of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    atan: {\n      doc: "Returns the arctangent of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    min: {\n      doc: "Returns the minimum value of the inputs.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    max: {\n      doc: "Returns the maximum value of the inputs.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    round: {\n      doc: "Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `[\\"round\\", -1.5]` evaluates to -2.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    abs: {\n      doc: "Returns the absolute value of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    ceil: {\n      doc: "Returns the smallest integer that is greater than or equal to the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    floor: {\n      doc: "Returns the largest integer that is less than or equal to the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    distance: {\n      doc: "Returns the shortest distance in meters between the evaluated feature and the input geometry. The input value can be a valid GeoJSON of type `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Distance values returned may vary in precision due to loss in precision from encoding geometries, particularly below zoom level 13.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          android: "9.2.0",\n          ios: "5.9.0",\n          macos: "0.16.0"\n        }\n      }\n    },\n    "==": {\n      doc: "Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    "!=": {\n      doc: "Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    ">": {\n      doc: "Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    "<": {\n      doc: "Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    ">=": {\n      doc: "Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    "<=": {\n      doc: "Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    all: {\n      doc: "Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    any: {\n      doc: "Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "!": {\n      doc: "Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    within: {\n      doc: "Returns `true` if the evaluated feature is fully contained inside a boundary of the input geometry, `false` otherwise. The input value can be a valid GeoJSON of type `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Supported features for evaluation:\\n- `Point`: Returns `false` if a point is on the boundary or falls outside the boundary.\\n- `LineString`: Returns `false` if any part of a line falls outside the boundary, the line intersects the boundary, or a line\'s endpoint is on the boundary.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "1.9.0",\n          android: "9.1.0",\n          ios: "5.8.0",\n          macos: "0.15.0"\n        }\n      }\n    },\n    "is-supported-script": {\n      doc: "Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).",\n      group: "String",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.6.0"\n        }\n      }\n    },\n    upcase: {\n      doc: "Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",\n      group: "String",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    downcase: {\n      doc: "Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",\n      group: "String",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    concat: {\n      doc: "Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.",\n      group: "String",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "resolved-locale": {\n      doc: "Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.",\n      group: "String",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    }\n  }\n};\nvar fog = {\n  range: {\n    type: "array",\n    "default": [0.5, 10],\n    minimum: -20,\n    maximum: 20,\n    length: 2,\n    value: "number",\n    "property-type": "data-constant",\n    transition: true,\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    doc: "The start and end distance range in which fog fades from fully transparent to fully opaque. The distance to the point at the center of the map is defined as zero, so that negative range values are closer to the camera, and positive values are farther away.",\n    example: [0.5, 10],\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.3.0"\n      }\n    }\n  },\n  color: {\n    type: "color",\n    "property-type": "data-constant",\n    "default": "#ffffff",\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    transition: true,\n    doc: "The color of the fog. Using opacity is recommended only for smoothly transitioning fog on/off as anything less than 100% opacity results in more tiles loaded and drawn.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.3.0"\n      }\n    }\n  },\n  "horizon-blend": {\n    type: "number",\n    "property-type": "data-constant",\n    "default": 0.1,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    transition: true,\n    doc: "Horizon blend applies a smooth fade from the color of the fog to the color of the sky. A value of zero leaves a sharp transition from fog to sky. Increasing the value blends the color of fog into increasingly high angles of the sky.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.3.0"\n      }\n    }\n  }\n};\nvar light = {\n  anchor: {\n    type: "enum",\n    "default": "viewport",\n    values: {\n      map: {\n        doc: "The position of the light source is aligned to the rotation of the map."\n      },\n      viewport: {\n        doc: "The position of the light source is aligned to the rotation of the viewport."\n      }\n    },\n    "property-type": "data-constant",\n    transition: false,\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    doc: "Whether extruded geometries are lit relative to the map or viewport.",\n    example: "map",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.27.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    }\n  },\n  position: {\n    type: "array",\n    "default": [1.15, 210, 30],\n    length: 3,\n    value: "number",\n    "property-type": "data-constant",\n    transition: true,\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    doc: "Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0° (0° when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0° when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0°, directly above, to 180°, directly below).",\n    example: [1.5, 90, 80],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.27.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    }\n  },\n  color: {\n    type: "color",\n    "property-type": "data-constant",\n    "default": "#ffffff",\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    transition: true,\n    doc: "Color tint for lighting extruded geometries.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.27.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    }\n  },\n  intensity: {\n    type: "number",\n    "property-type": "data-constant",\n    "default": 0.5,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    transition: true,\n    doc: "Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.27.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    }\n  }\n};\nvar terrain = {\n  source: {\n    type: "string",\n    doc: "Name of a source of `raster_dem` type to be used for terrain elevation.",\n    required: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    }\n  },\n  exaggeration: {\n    type: "number",\n    "property-type": "data-constant",\n    "default": 1,\n    minimum: 0,\n    maximum: 1000,\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    transition: true,\n    doc: "Exaggerates the elevation of the terrain by multiplying the data from the DEM with this value.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    }\n  }\n};\nvar paint = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background", "paint_sky"];\nvar paint_fill = {\n  "fill-antialias": {\n    type: "boolean",\n    "default": true,\n    doc: "Whether or not the fill should be antialiased.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "fill-opacity": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    doc: "The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.21.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "fill-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color\'s opacity will not affect the opacity of the 1px stroke, if it is used.",\n    transition: true,\n    requires: [{\n      "!": "fill-pattern"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.19.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "fill-outline-color": {\n    type: "color",\n    doc: "The outline color of the fill. Matches the value of `fill-color` if unspecified.",\n    transition: true,\n    requires: [{\n      "!": "fill-pattern"\n    }, {\n      "fill-antialias": true\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.19.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "fill-translate": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    transition: true,\n    units: "pixels",\n    doc: "The geometry\'s offset. Values are [x, y] where negatives indicate left and up, respectively.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "fill-translate-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The fill is translated relative to the map."\n      },\n      viewport: {\n        doc: "The fill is translated relative to the viewport."\n      }\n    },\n    doc: "Controls the frame of reference for `fill-translate`.",\n    "default": "map",\n    requires: ["fill-translate"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "fill-pattern": {\n    type: "resolvedImage",\n    transition: true,\n    doc: "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.49.0",\n        android: "6.5.0",\n        macos: "0.11.0",\n        ios: "4.4.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "cross-faded-data-driven"\n  }\n};\nvar paint_line = {\n  "line-opacity": {\n    type: "number",\n    doc: "The opacity at which the line will be drawn.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-color": {\n    type: "color",\n    doc: "The color with which the line will be drawn.",\n    "default": "#000000",\n    transition: true,\n    requires: [{\n      "!": "line-pattern"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.23.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-translate": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    transition: true,\n    units: "pixels",\n    doc: "The geometry\'s offset. Values are [x, y] where negatives indicate left and up, respectively.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "line-translate-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The line is translated relative to the map."\n      },\n      viewport: {\n        doc: "The line is translated relative to the viewport."\n      }\n    },\n    doc: "Controls the frame of reference for `line-translate`.",\n    "default": "map",\n    requires: ["line-translate"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "line-width": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Stroke thickness.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.39.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-gap-width": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    doc: "Draws a line casing outside of a line\'s actual path. Value indicates the width of the inner gap.",\n    transition: true,\n    units: "pixels",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-offset": {\n    type: "number",\n    "default": 0,\n    doc: "The line\'s offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",\n    transition: true,\n    units: "pixels",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.12.1",\n        android: "3.0.0",\n        ios: "3.1.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-blur": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Blur applied to the line, in pixels.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-dasharray": {\n    type: "array",\n    value: "number",\n    doc: "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won\'t render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",\n    minimum: 0,\n    transition: true,\n    units: "line widths",\n    requires: [{\n      "!": "line-pattern"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "2.3.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "cross-faded-data-driven"\n  },\n  "line-pattern": {\n    type: "resolvedImage",\n    transition: true,\n    doc: "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.49.0",\n        android: "6.5.0",\n        macos: "0.11.0",\n        ios: "4.4.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "cross-faded-data-driven"\n  },\n  "line-gradient": {\n    type: "color",\n    doc: "Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `\\"lineMetrics\\": true`.",\n    transition: false,\n    requires: [{\n      "!": "line-dasharray"\n    }, {\n      "!": "line-pattern"\n    }, {\n      source: "geojson",\n      has: {\n        lineMetrics: true\n      }\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.45.0",\n        android: "6.5.0",\n        ios: "4.4.0",\n        macos: "0.11.0"\n      },\n      "data-driven styling": {}\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["line-progress"]\n    },\n    "property-type": "color-ramp"\n  }\n};\nvar paint_circle = {\n  "circle-radius": {\n    type: "number",\n    "default": 5,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Circle radius.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.18.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The fill color of the circle.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.18.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-blur": {\n    type: "number",\n    "default": 0,\n    doc: "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.20.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-opacity": {\n    type: "number",\n    doc: "The opacity at which the circle will be drawn.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.20.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-translate": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    transition: true,\n    units: "pixels",\n    doc: "The geometry\'s offset. Values are [x, y] where negatives indicate left and up, respectively.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "circle-translate-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The circle is translated relative to the map."\n      },\n      viewport: {\n        doc: "The circle is translated relative to the viewport."\n      }\n    },\n    doc: "Controls the frame of reference for `circle-translate`.",\n    "default": "map",\n    requires: ["circle-translate"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "circle-pitch-scale": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "Circles are scaled according to their apparent distance to the camera."\n      },\n      viewport: {\n        doc: "Circles are not scaled."\n      }\n    },\n    "default": "map",\n    doc: "Controls the scaling behavior of the circle when the map is pitched.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.21.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.2.1"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "circle-pitch-alignment": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The circle is aligned to the plane of the map."\n      },\n      viewport: {\n        doc: "The circle is aligned to the plane of the viewport."\n      }\n    },\n    "default": "viewport",\n    doc: "Orientation of circle when map is pitched.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.39.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "circle-stroke-width": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "The width of the circle\'s stroke. Strokes are placed outside of the `circle-radius`.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-stroke-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The stroke color of the circle.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-stroke-opacity": {\n    type: "number",\n    doc: "The opacity of the circle\'s stroke.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  }\n};\nvar paint_heatmap = {\n  "heatmap-radius": {\n    type: "number",\n    "default": 30,\n    minimum: 1,\n    transition: true,\n    units: "pixels",\n    doc: "Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      },\n      "data-driven styling": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "heatmap-weight": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    transition: false,\n    doc: "A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      },\n      "data-driven styling": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "heatmap-intensity": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    transition: true,\n    doc: "Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "heatmap-color": {\n    type: "color",\n    "default": ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"],\n    doc: "Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `[\\"heatmap-density\\"]` as input.",\n    transition: false,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      },\n      "data-driven styling": {}\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["heatmap-density"]\n    },\n    "property-type": "color-ramp"\n  },\n  "heatmap-opacity": {\n    type: "number",\n    doc: "The global opacity at which the heatmap layer will be drawn.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar paint_symbol = {\n  "icon-opacity": {\n    doc: "The opacity at which the icon will be drawn.",\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-color": {\n    type: "color",\n    "default": "#000000",\n    transition: true,\n    doc: "The color of the icon. This can only be used with sdf icons.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-halo-color": {\n    type: "color",\n    "default": "rgba(0, 0, 0, 0)",\n    transition: true,\n    doc: "The color of the icon\'s halo. Icon halos can only be used with SDF icons.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-halo-width": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Distance of halo to the icon outline.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-halo-blur": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Fade out the halo towards the outside.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-translate": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    transition: true,\n    units: "pixels",\n    doc: "Distance that the icon\'s anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-translate-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "Icons are translated relative to the map."\n      },\n      viewport: {\n        doc: "Icons are translated relative to the viewport."\n      }\n    },\n    doc: "Controls the frame of reference for `icon-translate`.",\n    "default": "map",\n    requires: ["icon-image", "icon-translate"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-opacity": {\n    type: "number",\n    doc: "The opacity at which the text will be drawn.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-color": {\n    type: "color",\n    doc: "The color with which the text will be drawn.",\n    "default": "#000000",\n    transition: true,\n    overridable: true,\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-halo-color": {\n    type: "color",\n    "default": "rgba(0, 0, 0, 0)",\n    transition: true,\n    doc: "The color of the text\'s halo, which helps it stand out from backgrounds.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-halo-width": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-halo-blur": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "The halo\'s fadeout distance towards the outside.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-translate": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    transition: true,\n    units: "pixels",\n    doc: "Distance that the text\'s anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-translate-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The text is translated relative to the map."\n      },\n      viewport: {\n        doc: "The text is translated relative to the viewport."\n      }\n    },\n    doc: "Controls the frame of reference for `text-translate`.",\n    "default": "map",\n    requires: ["text-field", "text-translate"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar paint_raster = {\n  "raster-opacity": {\n    type: "number",\n    doc: "The opacity at which the image will be drawn.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-hue-rotate": {\n    type: "number",\n    "default": 0,\n    period: 360,\n    transition: true,\n    units: "degrees",\n    doc: "Rotates hues around the color wheel.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-brightness-min": {\n    type: "number",\n    doc: "Increase or reduce the brightness of the image. The value is the minimum brightness.",\n    "default": 0,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-brightness-max": {\n    type: "number",\n    doc: "Increase or reduce the brightness of the image. The value is the maximum brightness.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-saturation": {\n    type: "number",\n    doc: "Increase or reduce the saturation of the image.",\n    "default": 0,\n    minimum: -1,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-contrast": {\n    type: "number",\n    doc: "Increase or reduce the contrast of the image.",\n    "default": 0,\n    minimum: -1,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-resampling": {\n    type: "enum",\n    doc: "The resampling/interpolation method to use for overscaling, also known as texture magnification filter",\n    values: {\n      linear: {\n        doc: "(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled"\n      },\n      nearest: {\n        doc: "Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled"\n      }\n    },\n    "default": "linear",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.47.0",\n        android: "6.3.0",\n        ios: "4.2.0",\n        macos: "0.9.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-fade-duration": {\n    type: "number",\n    "default": 300,\n    minimum: 0,\n    transition: false,\n    units: "milliseconds",\n    doc: "Fade duration when a new tile is added.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar paint_hillshade = {\n  "hillshade-illumination-direction": {\n    type: "number",\n    "default": 335,\n    minimum: 0,\n    maximum: 359,\n    doc: "The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.",\n    transition: false,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "hillshade-illumination-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The hillshade illumination is relative to the north direction."\n      },\n      viewport: {\n        doc: "The hillshade illumination is relative to the top of the viewport."\n      }\n    },\n    "default": "viewport",\n    doc: "Direction of light source when map is rotated.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "hillshade-exaggeration": {\n    type: "number",\n    doc: "Intensity of the hillshade",\n    "default": 0.5,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "hillshade-shadow-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The shading color of areas that face away from the light source.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "hillshade-highlight-color": {\n    type: "color",\n    "default": "#FFFFFF",\n    doc: "The shading color of areas that faces towards the light source.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "hillshade-accent-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The shading color used to accentuate rugged terrain like sharp cliffs and gorges.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar paint_background = {\n  "background-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The color with which the background will be drawn.",\n    transition: true,\n    requires: [{\n      "!": "background-pattern"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "background-pattern": {\n    type: "resolvedImage",\n    transition: true,\n    doc: "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {}\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "cross-faded"\n  },\n  "background-opacity": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    doc: "The opacity at which the background will be drawn.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar paint_sky = {\n  "sky-type": {\n    type: "enum",\n    values: {\n      gradient: {\n        doc: "Renders the sky with a gradient that can be configured with `sky-gradient-radius` and `sky-gradient`."\n      },\n      atmosphere: {\n        doc: "Renders the sky with a simulated atmospheric scattering algorithm, the sun direction can be attached to the light position or explicitly set through `sky-atmosphere-sun`."\n      }\n    },\n    "default": "atmosphere",\n    doc: "The type of the sky",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "sky-atmosphere-sun": {\n    type: "array",\n    value: "number",\n    length: 2,\n    units: "degrees",\n    minimum: [0, 0],\n    maximum: [360, 180],\n    transition: false,\n    doc: "Position of the sun center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the sun relative to 0° north, where degrees proceed clockwise. The polar angle indicates the height of the sun, where 0° is directly above, at zenith, and 90° at the horizon. When this property is ommitted, the sun center is directly inherited from the light position.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    requires: [{\n      "sky-type": "atmosphere"\n    }],\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "sky-atmosphere-sun-intensity": {\n    type: "number",\n    requires: [{\n      "sky-type": "atmosphere"\n    }],\n    "default": 10,\n    minimum: 0,\n    maximum: 100,\n    transition: false,\n    doc: "Intensity of the sun as a light source in the atmosphere (on a scale from 0 to a 100). Setting higher values will brighten up the sky.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    "property-type": "data-constant"\n  },\n  "sky-gradient-center": {\n    type: "array",\n    requires: [{\n      "sky-type": "gradient"\n    }],\n    value: "number",\n    "default": [0, 0],\n    length: 2,\n    units: "degrees",\n    minimum: [0, 0],\n    maximum: [360, 180],\n    transition: false,\n    doc: "Position of the gradient center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the gradient center relative to 0° north, where degrees proceed clockwise. The polar angle indicates the height of the gradient center, where 0° is directly above, at zenith, and 90° at the horizon.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "sky-gradient-radius": {\n    type: "number",\n    requires: [{\n      "sky-type": "gradient"\n    }],\n    "default": 90,\n    minimum: 0,\n    maximum: 180,\n    transition: false,\n    doc: "The angular distance (measured in degrees) from `sky-gradient-center` up to which the gradient extends. A value of 180 causes the gradient to wrap around to the opposite direction from `sky-gradient-center`.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "sky-gradient": {\n    type: "color",\n    "default": ["interpolate", ["linear"], ["sky-radial-progress"], 0.8, "#87ceeb", 1, "white"],\n    doc: "Defines a radial color gradient with which to color the sky. The color values can be interpolated with an expression using `sky-radial-progress`. The range [0, 1] for the interpolant covers a radial distance (in degrees) of [0, `sky-gradient-radius`] centered at the position specified by `sky-gradient-center`.",\n    transition: false,\n    requires: [{\n      "sky-type": "gradient"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      },\n      "data-driven styling": {}\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["sky-radial-progress"]\n    },\n    "property-type": "color-ramp"\n  },\n  "sky-atmosphere-halo-color": {\n    type: "color",\n    "default": "white",\n    doc: "A color applied to the atmosphere sun halo. The alpha channel describes how strongly the sun halo is represented in an atmosphere sky layer.",\n    transition: false,\n    requires: [{\n      "sky-type": "atmosphere"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    "property-type": "data-constant"\n  },\n  "sky-atmosphere-color": {\n    type: "color",\n    "default": "white",\n    doc: "A color used to tweak the main atmospheric scattering coefficients. Using white applies the default coefficients giving the natural blue color to the atmosphere. This color affects how heavily the corresponding wavelength is represented during scattering. The alpha channel describes the density of the atmosphere, with 1 maximum density and 0 no density.",\n    transition: false,\n    requires: [{\n      "sky-type": "atmosphere"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    "property-type": "data-constant"\n  },\n  "sky-opacity": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    doc: "The opacity of the entire sky layer.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar transition = {\n  duration: {\n    type: "number",\n    "default": 300,\n    minimum: 0,\n    units: "milliseconds",\n    doc: "Time allotted for transitions to complete."\n  },\n  delay: {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    units: "milliseconds",\n    doc: "Length of time before a transition begins."\n  }\n};\nvar promoteId = {\n  "*": {\n    type: "string",\n    doc: "A name of a feature property to use as ID for feature state."\n  }\n};\nvar v8 = {\n  $version: $version,\n  $root: $root,\n  sources: sources,\n  source: source,\n  source_vector: source_vector,\n  source_raster: source_raster,\n  source_raster_dem: source_raster_dem,\n  source_geojson: source_geojson,\n  source_video: source_video,\n  source_image: source_image,\n  layer: layer,\n  layout: layout,\n  layout_background: layout_background,\n  layout_sky: layout_sky,\n  layout_fill: layout_fill,\n  layout_circle: layout_circle,\n  layout_heatmap: layout_heatmap,\n  "layout_fill-extrusion": {\n    visibility: {\n      type: "enum",\n      values: {\n        visible: {\n          doc: "The layer is shown."\n        },\n        none: {\n          doc: "The layer is not shown."\n        }\n      },\n      "default": "visible",\n      doc: "Whether this layer is displayed.",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      "property-type": "constant"\n    }\n  },\n  layout_line: layout_line,\n  layout_symbol: layout_symbol,\n  layout_raster: layout_raster,\n  layout_hillshade: layout_hillshade,\n  filter: filter,\n  filter_operator: filter_operator,\n  geometry_type: geometry_type,\n  "function": {\n    expression: {\n      type: "expression",\n      doc: "An expression."\n    },\n    stops: {\n      type: "array",\n      doc: "An array of stops.",\n      value: "function_stop"\n    },\n    base: {\n      type: "number",\n      "default": 1,\n      minimum: 0,\n      doc: "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."\n    },\n    property: {\n      type: "string",\n      doc: "The name of a feature property to use as the function input.",\n      "default": "$zoom"\n    },\n    type: {\n      type: "enum",\n      values: {\n        identity: {\n          doc: "Return the input value as the output value."\n        },\n        exponential: {\n          doc: "Generate an output by interpolating between stops just less than and just greater than the function input."\n        },\n        interval: {\n          doc: "Return the output value of the stop just less than the function input."\n        },\n        categorical: {\n          doc: "Return the output value of the stop equal to the function input."\n        }\n      },\n      doc: "The interpolation strategy to use in function evaluation.",\n      "default": "exponential"\n    },\n    colorSpace: {\n      type: "enum",\n      values: {\n        rgb: {\n          doc: "Use the RGB color space to interpolate color values"\n        },\n        lab: {\n          doc: "Use the LAB color space to interpolate color values."\n        },\n        hcl: {\n          doc: "Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually."\n        }\n      },\n      doc: "The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.",\n      "default": "rgb"\n    },\n    "default": {\n      type: "*",\n      required: false,\n      doc: "A value to serve as a fallback function result when a value isn\'t otherwise available. It is used in the following circumstances:\\n* In categorical functions, when the feature value does not match any of the stop domain values.\\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\\nIf no default is provided, the style property\'s default is used in these circumstances."\n    }\n  },\n  function_stop: function_stop,\n  expression: expression,\n  expression_name: expression_name,\n  fog: fog,\n  light: light,\n  terrain: terrain,\n  paint: paint,\n  paint_fill: paint_fill,\n  "paint_fill-extrusion": {\n    "fill-extrusion-opacity": {\n      type: "number",\n      "default": 1,\n      minimum: 0,\n      maximum: 1,\n      doc: "The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.",\n      transition: true,\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: true,\n        parameters: ["zoom"]\n      },\n      "property-type": "data-constant"\n    },\n    "fill-extrusion-color": {\n      type: "color",\n      "default": "#000000",\n      doc: "The base color of the extruded fill. The extrusion\'s surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",\n      transition: true,\n      requires: [{\n        "!": "fill-extrusion-pattern"\n      }],\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        },\n        "data-driven styling": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: true,\n        parameters: ["zoom", "feature", "feature-state"]\n      },\n      "property-type": "data-driven"\n    },\n    "fill-extrusion-translate": {\n      type: "array",\n      value: "number",\n      length: 2,\n      "default": [0, 0],\n      transition: true,\n      units: "pixels",\n      doc: "The geometry\'s offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: true,\n        parameters: ["zoom"]\n      },\n      "property-type": "data-constant"\n    },\n    "fill-extrusion-translate-anchor": {\n      type: "enum",\n      values: {\n        map: {\n          doc: "The fill extrusion is translated relative to the map."\n        },\n        viewport: {\n          doc: "The fill extrusion is translated relative to the viewport."\n        }\n      },\n      doc: "Controls the frame of reference for `fill-extrusion-translate`.",\n      "default": "map",\n      requires: ["fill-extrusion-translate"],\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: false,\n        parameters: ["zoom"]\n      },\n      "property-type": "data-constant"\n    },\n    "fill-extrusion-pattern": {\n      type: "resolvedImage",\n      transition: true,\n      doc: "Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        },\n        "data-driven styling": {\n          js: "0.49.0",\n          android: "6.5.0",\n          macos: "0.11.0",\n          ios: "4.4.0"\n        }\n      },\n      expression: {\n        interpolated: false,\n        parameters: ["zoom", "feature"]\n      },\n      "property-type": "cross-faded-data-driven"\n    },\n    "fill-extrusion-height": {\n      type: "number",\n      "default": 0,\n      minimum: 0,\n      units: "meters",\n      doc: "The height with which to extrude this layer.",\n      transition: true,\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        },\n        "data-driven styling": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: true,\n        parameters: ["zoom", "feature", "feature-state"]\n      },\n      "property-type": "data-driven"\n    },\n    "fill-extrusion-base": {\n      type: "number",\n      "default": 0,\n      minimum: 0,\n      units: "meters",\n      doc: "The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.",\n      transition: true,\n      requires: ["fill-extrusion-height"],\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        },\n        "data-driven styling": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: true,\n        parameters: ["zoom", "feature", "feature-state"]\n      },\n      "property-type": "data-driven"\n    },\n    "fill-extrusion-vertical-gradient": {\n      type: "boolean",\n      "default": true,\n      doc: "Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.",\n      transition: false,\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.50.0",\n          ios: "4.7.0",\n          macos: "0.13.0"\n        }\n      },\n      expression: {\n        interpolated: false,\n        parameters: ["zoom"]\n      },\n      "property-type": "data-constant"\n    }\n  },\n  paint_line: paint_line,\n  paint_circle: paint_circle,\n  paint_heatmap: paint_heatmap,\n  paint_symbol: paint_symbol,\n  paint_raster: paint_raster,\n  paint_hillshade: paint_hillshade,\n  paint_background: paint_background,\n  paint_sky: paint_sky,\n  transition: transition,\n  "property-type": {\n    "data-driven": {\n      type: "property-type",\n      doc: "Property is interpolable and can be represented using a property expression."\n    },\n    "cross-faded": {\n      type: "property-type",\n      doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms."\n    },\n    "cross-faded-data-driven": {\n      type: "property-type",\n      doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression."\n    },\n    "color-ramp": {\n      type: "property-type",\n      doc: "Property should be specified using a color ramp from which the output color can be sampled based on a property calculation."\n    },\n    "data-constant": {\n      type: "property-type",\n      doc: "Property is interpolable but cannot be represented using a property expression."\n    },\n    constant: {\n      type: "property-type",\n      doc: "Property is constant across all zoom levels and property values."\n    }\n  },\n  promoteId: promoteId\n}; // Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\n\nvar stringOrChar = /("(?:[^\\\\"]|\\\\.)*")|[:,]/g;\n\nvar jsonStringifyPrettyCompact = function stringify(passedObj, options) {\n  var indent, maxLength, replacer;\n  options = options || {};\n  indent = JSON.stringify([1], undefined, options.indent === undefined ? 2 : options.indent).slice(2, -3);\n  maxLength = indent === "" ? Infinity : options.maxLength === undefined ? 80 : options.maxLength;\n  replacer = options.replacer;\n  return function _stringify(obj, currentIndent, reserved) {\n    // prettier-ignore\n    var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;\n\n    if (obj && typeof obj.toJSON === "function") {\n      obj = obj.toJSON();\n    }\n\n    string = JSON.stringify(obj, replacer);\n\n    if (string === undefined) {\n      return string;\n    }\n\n    length = maxLength - currentIndent.length - reserved;\n\n    if (string.length <= length) {\n      prettified = string.replace(stringOrChar, function (match, stringLiteral) {\n        return stringLiteral || match + " ";\n      });\n\n      if (prettified.length <= length) {\n        return prettified;\n      }\n    }\n\n    if (replacer != null) {\n      obj = JSON.parse(string);\n      replacer = undefined;\n    }\n\n    if (typeof obj === "object" && obj !== null) {\n      nextIndent = currentIndent + indent;\n      items = [];\n      index = 0;\n\n      if (Array.isArray(obj)) {\n        start = "[";\n        end = "]";\n        length = obj.length;\n\n        for (; index < length; index++) {\n          items.push(_stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || "null");\n        }\n      } else {\n        start = "{";\n        end = "}";\n        keys = Object.keys(obj);\n        length = keys.length;\n\n        for (; index < length; index++) {\n          key = keys[index];\n          keyPart = JSON.stringify(key) + ": ";\n          value = _stringify(obj[key], nextIndent, keyPart.length + (index === length - 1 ? 0 : 1));\n\n          if (value !== undefined) {\n            items.push(keyPart + value);\n          }\n        }\n      }\n\n      if (items.length > 0) {\n        return [start, indent + items.join(",\\n" + nextIndent), end].join("\\n" + currentIndent);\n      }\n    }\n\n    return string;\n  }(passedObj, "", 0);\n};\n\nfunction sortKeysBy(obj, reference) {\n  var result = {};\n\n  for (var key in reference) {\n    if (obj[key] !== undefined) {\n      result[key] = obj[key];\n    }\n  }\n\n  for (var _key in obj) {\n    if (result[_key] === undefined) {\n      result[_key] = obj[_key];\n    }\n  }\n\n  return result;\n}\n\nfunction format(style) {\n  var space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  style = sortKeysBy(style, v8.$root);\n\n  if (style.layers) {\n    style.layers = style.layers.map(function (layer) {\n      return sortKeysBy(layer, v8.layer);\n    });\n  }\n\n  return jsonStringifyPrettyCompact(style, {\n    indent: space\n  });\n}\n\nvar commonjsGlobal = typeof globalThis !== \'undefined\' ? globalThis : typeof window !== \'undefined\' ? window : typeof __webpack_require__.g !== \'undefined\' ? __webpack_require__.g : typeof self !== \'undefined\' ? self : {};\n\nfunction createCommonjsModule(fn) {\n  var module = {\n    exports: {}\n  };\n  return fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire(target) {\n  throw new Error(\'Could not dynamically require "\' + target + \'". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.\');\n}\n/*! https://mths.be/punycode v1.3.2 by @mathias */\n\n\nvar punycode = createCommonjsModule(function (module, exports) {\n  (function (root) {\n    /** Detect free variables */\n    var freeExports = exports && !exports.nodeType && exports;\n    var freeModule = module && !module.nodeType && module;\n    var freeGlobal = typeof commonjsGlobal == \'object\' && commonjsGlobal;\n\n    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n      root = freeGlobal;\n    }\n    /**\n     * The `punycode` object.\n     * @name punycode\n     * @type Object\n     */\n\n\n    var punycode,\n\n    /** Highest positive signed 32-bit float value */\n    maxInt = 2147483647,\n        // aka. 0x7FFFFFFF or 2^31-1\n\n    /** Bootstring parameters */\n    base = 36,\n        tMin = 1,\n        tMax = 26,\n        skew = 38,\n        damp = 700,\n        initialBias = 72,\n        initialN = 128,\n        // 0x80\n    delimiter = \'-\',\n        // \'\\x2D\'\n\n    /** Regular expressions */\n    regexPunycode = /^xn--/,\n        regexNonASCII = /[^\\x20-\\x7E]/,\n        // unprintable ASCII chars + non-ASCII chars\n    regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n        // RFC 3490 separators\n\n    /** Error messages */\n    errors = {\n      \'overflow\': \'Overflow: input needs wider integers to process\',\n      \'not-basic\': \'Illegal input >= 0x80 (not a basic code point)\',\n      \'invalid-input\': \'Invalid input\'\n    },\n\n    /** Convenience shortcuts */\n    baseMinusTMin = base - tMin,\n        floor = Math.floor,\n        stringFromCharCode = String.fromCharCode,\n\n    /** Temporary variable */\n    key;\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * A generic error utility function.\n     * @private\n     * @param {String} type The error type.\n     * @returns {Error} Throws a `RangeError` with the applicable error message.\n     */\n\n    function error(type) {\n      throw RangeError(errors[type]);\n    }\n    /**\n     * A generic `Array#map` utility function.\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} callback The function that gets called for every array\n     * item.\n     * @returns {Array} A new array of values returned by the callback function.\n     */\n\n\n    function map(array, fn) {\n      var length = array.length;\n      var result = [];\n\n      while (length--) {\n        result[length] = fn(array[length]);\n      }\n\n      return result;\n    }\n    /**\n     * A simple `Array#map`-like wrapper to work with domain name strings or email\n     * addresses.\n     * @private\n     * @param {String} domain The domain name or email address.\n     * @param {Function} callback The function that gets called for every\n     * character.\n     * @returns {Array} A new string of characters returned by the callback\n     * function.\n     */\n\n\n    function mapDomain(string, fn) {\n      var parts = string.split(\'@\');\n      var result = \'\';\n\n      if (parts.length > 1) {\n        // In email addresses, only the domain name should be punycoded. Leave\n        // the local part (i.e. everything up to `@`) intact.\n        result = parts[0] + \'@\';\n        string = parts[1];\n      } // Avoid `split(regex)` for IE8 compatibility. See #17.\n\n\n      string = string.replace(regexSeparators, \'\\x2E\');\n      var labels = string.split(\'.\');\n      var encoded = map(labels, fn).join(\'.\');\n      return result + encoded;\n    }\n    /**\n     * Creates an array containing the numeric code points of each Unicode\n     * character in the string. While JavaScript uses UCS-2 internally,\n     * this function will convert a pair of surrogate halves (each of which\n     * UCS-2 exposes as separate characters) into a single code point,\n     * matching UTF-16.\n     * @see `punycode.ucs2.encode`\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n     * @memberOf punycode.ucs2\n     * @name decode\n     * @param {String} string The Unicode input string (UCS-2).\n     * @returns {Array} The new array of code points.\n     */\n\n\n    function ucs2decode(string) {\n      var output = [],\n          counter = 0,\n          length = string.length,\n          value,\n          extra;\n\n      while (counter < length) {\n        value = string.charCodeAt(counter++);\n\n        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n          // high surrogate, and there is a next character\n          extra = string.charCodeAt(counter++);\n\n          if ((extra & 0xFC00) == 0xDC00) {\n            // low surrogate\n            output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n          } else {\n            // unmatched surrogate; only append this code unit, in case the next\n            // code unit is the high surrogate of a surrogate pair\n            output.push(value);\n            counter--;\n          }\n        } else {\n          output.push(value);\n        }\n      }\n\n      return output;\n    }\n    /**\n     * Creates a string based on an array of numeric code points.\n     * @see `punycode.ucs2.decode`\n     * @memberOf punycode.ucs2\n     * @name encode\n     * @param {Array} codePoints The array of numeric code points.\n     * @returns {String} The new Unicode string (UCS-2).\n     */\n\n\n    function ucs2encode(array) {\n      return map(array, function (value) {\n        var output = \'\';\n\n        if (value > 0xFFFF) {\n          value -= 0x10000;\n          output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n          value = 0xDC00 | value & 0x3FF;\n        }\n\n        output += stringFromCharCode(value);\n        return output;\n      }).join(\'\');\n    }\n    /**\n     * Converts a basic code point into a digit/integer.\n     * @see `digitToBasic()`\n     * @private\n     * @param {Number} codePoint The basic numeric code point value.\n     * @returns {Number} The numeric value of a basic code point (for use in\n     * representing integers) in the range `0` to `base - 1`, or `base` if\n     * the code point does not represent a value.\n     */\n\n\n    function basicToDigit(codePoint) {\n      if (codePoint - 48 < 10) {\n        return codePoint - 22;\n      }\n\n      if (codePoint - 65 < 26) {\n        return codePoint - 65;\n      }\n\n      if (codePoint - 97 < 26) {\n        return codePoint - 97;\n      }\n\n      return base;\n    }\n    /**\n     * Converts a digit/integer into a basic code point.\n     * @see `basicToDigit()`\n     * @private\n     * @param {Number} digit The numeric value of a basic code point.\n     * @returns {Number} The basic code point whose value (when used for\n     * representing integers) is `digit`, which needs to be in the range\n     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n     * used; else, the lowercase form is used. The behavior is undefined\n     * if `flag` is non-zero and `digit` has no uppercase form.\n     */\n\n\n    function digitToBasic(digit, flag) {\n      //  0..25 map to ASCII a..z or A..Z\n      // 26..35 map to ASCII 0..9\n      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    }\n    /**\n     * Bias adaptation function as per section 3.4 of RFC 3492.\n     * http://tools.ietf.org/html/rfc3492#section-3.4\n     * @private\n     */\n\n\n    function adapt(delta, numPoints, firstTime) {\n      var k = 0;\n      delta = firstTime ? floor(delta / damp) : delta >> 1;\n      delta += floor(delta / numPoints);\n\n      for (;\n      /* no initialization */\n      delta > baseMinusTMin * tMax >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n      }\n\n      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    }\n    /**\n     * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n     * symbols.\n     * @memberOf punycode\n     * @param {String} input The Punycode string of ASCII-only symbols.\n     * @returns {String} The resulting string of Unicode symbols.\n     */\n\n\n    function decode(input) {\n      // Don\'t use UCS-2\n      var output = [],\n          inputLength = input.length,\n          out,\n          i = 0,\n          n = initialN,\n          bias = initialBias,\n          basic,\n          j,\n          index,\n          oldi,\n          w,\n          k,\n          digit,\n          t,\n\n      /** Cached calculation results */\n      baseMinusT; // Handle the basic code points: let `basic` be the number of input code\n      // points before the last delimiter, or `0` if there is none, then copy\n      // the first basic code points to the output.\n\n      basic = input.lastIndexOf(delimiter);\n\n      if (basic < 0) {\n        basic = 0;\n      }\n\n      for (j = 0; j < basic; ++j) {\n        // if it\'s not a basic code point\n        if (input.charCodeAt(j) >= 0x80) {\n          error(\'not-basic\');\n        }\n\n        output.push(input.charCodeAt(j));\n      } // Main decoding loop: start just after the last delimiter if any basic code\n      // points were copied; start at the beginning otherwise.\n\n\n      for (index = basic > 0 ? basic + 1 : 0; index < inputLength;)\n      /* no final expression */\n      {\n        // `index` is the index of the next character to be consumed.\n        // Decode a generalized variable-length integer into `delta`,\n        // which gets added to `i`. The overflow checking is easier\n        // if we increase `i` as we go, then subtract off its starting\n        // value at the end to obtain `delta`.\n        for (oldi = i, w = 1, k = base;;\n        /* no condition */\n        k += base) {\n          if (index >= inputLength) {\n            error(\'invalid-input\');\n          }\n\n          digit = basicToDigit(input.charCodeAt(index++));\n\n          if (digit >= base || digit > floor((maxInt - i) / w)) {\n            error(\'overflow\');\n          }\n\n          i += digit * w;\n          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n          if (digit < t) {\n            break;\n          }\n\n          baseMinusT = base - t;\n\n          if (w > floor(maxInt / baseMinusT)) {\n            error(\'overflow\');\n          }\n\n          w *= baseMinusT;\n        }\n\n        out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,\n        // incrementing `n` each time, so we\'ll fix that now:\n\n        if (floor(i / out) > maxInt - n) {\n          error(\'overflow\');\n        }\n\n        n += floor(i / out);\n        i %= out; // Insert `n` at position `i` of the output\n\n        output.splice(i++, 0, n);\n      }\n\n      return ucs2encode(output);\n    }\n    /**\n     * Converts a string of Unicode symbols (e.g. a domain name label) to a\n     * Punycode string of ASCII-only symbols.\n     * @memberOf punycode\n     * @param {String} input The string of Unicode symbols.\n     * @returns {String} The resulting Punycode string of ASCII-only symbols.\n     */\n\n\n    function encode(input) {\n      var n,\n          delta,\n          handledCPCount,\n          basicLength,\n          bias,\n          j,\n          m,\n          q,\n          k,\n          t,\n          currentValue,\n          output = [],\n\n      /** `inputLength` will hold the number of code points in `input`. */\n      inputLength,\n\n      /** Cached calculation results */\n      handledCPCountPlusOne,\n          baseMinusT,\n          qMinusT; // Convert the input in UCS-2 to Unicode\n\n      input = ucs2decode(input); // Cache the length\n\n      inputLength = input.length; // Initialize the state\n\n      n = initialN;\n      delta = 0;\n      bias = initialBias; // Handle the basic code points\n\n      for (j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n\n        if (currentValue < 0x80) {\n          output.push(stringFromCharCode(currentValue));\n        }\n      }\n\n      handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;\n      // `basicLength` is the number of basic code points.\n      // Finish the basic string - if it is not empty - with a delimiter\n\n      if (basicLength) {\n        output.push(delimiter);\n      } // Main encoding loop:\n\n\n      while (handledCPCount < inputLength) {\n        // All non-basic code points < n have been handled already. Find the next\n        // larger one:\n        for (m = maxInt, j = 0; j < inputLength; ++j) {\n          currentValue = input[j];\n\n          if (currentValue >= n && currentValue < m) {\n            m = currentValue;\n          }\n        } // Increase `delta` enough to advance the decoder\'s <n,i> state to <m,0>,\n        // but guard against overflow\n\n\n        handledCPCountPlusOne = handledCPCount + 1;\n\n        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n          error(\'overflow\');\n        }\n\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n\n        for (j = 0; j < inputLength; ++j) {\n          currentValue = input[j];\n\n          if (currentValue < n && ++delta > maxInt) {\n            error(\'overflow\');\n          }\n\n          if (currentValue == n) {\n            // Represent delta as a generalized variable-length integer\n            for (q = delta, k = base;;\n            /* no condition */\n            k += base) {\n              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n              if (q < t) {\n                break;\n              }\n\n              qMinusT = q - t;\n              baseMinusT = base - t;\n              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n              q = floor(qMinusT / baseMinusT);\n            }\n\n            output.push(stringFromCharCode(digitToBasic(q, 0)));\n            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n            delta = 0;\n            ++handledCPCount;\n          }\n        }\n\n        ++delta;\n        ++n;\n      }\n\n      return output.join(\'\');\n    }\n    /**\n     * Converts a Punycode string representing a domain name or an email address\n     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n     * it doesn\'t matter if you call it on a string that has already been\n     * converted to Unicode.\n     * @memberOf punycode\n     * @param {String} input The Punycoded domain name or email address to\n     * convert to Unicode.\n     * @returns {String} The Unicode representation of the given Punycode\n     * string.\n     */\n\n\n    function toUnicode(input) {\n      return mapDomain(input, function (string) {\n        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n      });\n    }\n    /**\n     * Converts a Unicode string representing a domain name or an email address to\n     * Punycode. Only the non-ASCII parts of the domain name will be converted,\n     * i.e. it doesn\'t matter if you call it with a domain that\'s already in\n     * ASCII.\n     * @memberOf punycode\n     * @param {String} input The domain name or email address to convert, as a\n     * Unicode string.\n     * @returns {String} The Punycode representation of the given domain name or\n     * email address.\n     */\n\n\n    function toASCII(input) {\n      return mapDomain(input, function (string) {\n        return regexNonASCII.test(string) ? \'xn--\' + encode(string) : string;\n      });\n    }\n    /*--------------------------------------------------------------------------*/\n\n    /** Define the public API */\n\n\n    punycode = {\n      /**\n       * A string representing the current Punycode.js version number.\n       * @memberOf punycode\n       * @type String\n       */\n      \'version\': \'1.3.2\',\n\n      /**\n       * An object of methods to convert from JavaScript\'s internal character\n       * representation (UCS-2) to Unicode code points, and back.\n       * @see <https://mathiasbynens.be/notes/javascript-encoding>\n       * @memberOf punycode\n       * @type Object\n       */\n      \'ucs2\': {\n        \'decode\': ucs2decode,\n        \'encode\': ucs2encode\n      },\n      \'decode\': decode,\n      \'encode\': encode,\n      \'toASCII\': toASCII,\n      \'toUnicode\': toUnicode\n    };\n    /** Expose `punycode` */\n    // Some AMD build optimizers, like r.js, check for specific condition patterns\n    // like the following:\n\n    if (freeExports && freeModule) {\n      if (module.exports == freeExports) {\n        // in Node.js or RingoJS v0.8.0+\n        freeModule.exports = punycode;\n      } else {\n        // in Narwhal or RingoJS v0.7.0-\n        for (key in punycode) {\n          punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n        }\n      }\n    } else {\n      // in Rhino or a web browser\n      root.punycode = punycode;\n    }\n  })(commonjsGlobal);\n});\nvar util = {\n  isString: function isString(arg) {\n    return typeof arg === \'string\';\n  },\n  isObject: function isObject(arg) {\n    return typeof arg === \'object\' && arg !== null;\n  },\n  isNull: function isNull(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function isNullOrUndefined(arg) {\n    return arg == null;\n  }\n}; // Copyright Joyent, Inc. and other Node contributors.\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar decode = function decode(qs, sep, eq, options) {\n  sep = sep || \'&\';\n  eq = eq || \'=\';\n  var obj = {};\n\n  if (typeof qs !== \'string\' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n  var maxKeys = 1000;\n\n  if (options && typeof options.maxKeys === \'number\') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count\n\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, \'%20\'),\n        idx = x.indexOf(eq),\n        kstr,\n        vstr,\n        k,\n        v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = \'\';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n}; // Copyright Joyent, Inc. and other Node contributors.\n\n\nvar stringifyPrimitive = function stringifyPrimitive(v) {\n  switch (typeof v) {\n    case \'string\':\n      return v;\n\n    case \'boolean\':\n      return v ? \'true\' : \'false\';\n\n    case \'number\':\n      return isFinite(v) ? v : \'\';\n\n    default:\n      return \'\';\n  }\n};\n\nvar encode = function encode(obj, sep, eq, name) {\n  sep = sep || \'&\';\n  eq = eq || \'=\';\n\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === \'object\') {\n    return Object.keys(obj).map(function (k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function (v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n  }\n\n  if (!name) return \'\';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar querystring = createCommonjsModule(function (module, exports) {\n  exports.decode = exports.parse = decode;\n  exports.encode = exports.stringify = encode;\n});\nvar parse = urlParse;\nvar resolve = urlResolve;\nvar resolveObject = urlResolveObject;\nvar format$1 = urlFormat;\nvar Url_1 = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n} // Reference: RFC 3986, RFC 1808, RFC 2396\n// define these here so at least they only have to be\n// compiled once on the first module load.\n\n\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n    // Special case for a simple path URL\nsimplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n    // RFC 2396: characters reserved for delimiting URLs.\n// We actually just auto-escape these.\ndelims = [\'<\', \'>\', \'"\', \'`\', \' \', \'\\r\', \'\\n\', \'\\t\'],\n    // RFC 2396: characters not allowed for various reasons.\nunwise = [\'{\', \'}\', \'|\', \'\\\\\', \'^\', \'`\'].concat(delims),\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\nautoEscape = [\'\\\'\'].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n// Note that any invalid chars are also handled, but these\n// are the ones that are *expected* to be seen, so we fast-path\n// them.\nnonHostChars = [\'%\', \'/\', \'?\', \';\', \'#\'].concat(autoEscape),\n    hostEndingChars = [\'/\', \'?\', \'#\'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow "unsafe" and "unwise" chars.\nunsafeProtocol = {\n  \'javascript\': true,\n  \'javascript:\': true\n},\n    // protocols that never have a hostname.\nhostlessProtocol = {\n  \'javascript\': true,\n  \'javascript:\': true\n},\n    // protocols that always contain a // bit.\nslashedProtocol = {\n  \'http\': true,\n  \'https\': true,\n  \'ftp\': true,\n  \'gopher\': true,\n  \'file\': true,\n  \'http:\': true,\n  \'https:\': true,\n  \'ftp:\': true,\n  \'gopher:\': true,\n  \'file:\': true\n};\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n  var u = new Url();\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError("Parameter \'url\' must be a string, not " + typeof url);\n  } // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n\n\n  var queryIndex = url.indexOf(\'?\'),\n      splitter = queryIndex !== -1 && queryIndex < url.indexOf(\'#\') ? \'?\' : \'#\',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, \'/\');\n  url = uSplit.join(splitter);\n  var rest = url; // trim before proceeding.\n  // This is to support parse stuff like "  http://foo.com  \\n"\n\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split(\'#\').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = \'\';\n        this.query = {};\n      }\n\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  } // figure out if it\'s got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that\'s\n  // how the browser resolves relative URLs.\n\n\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === \'//\';\n\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n    // there\'s a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n    } // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n\n\n    var auth, atSign;\n\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf(\'@\');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf(\'@\', hostEnd);\n    } // Now we have a portion which is definitely the auth.\n    // Pull that off.\n\n\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    } // the host is the remaining to the left of the first non-host char\n\n\n    hostEnd = -1;\n\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n    } // if we still have not hit it, then the entire thing is a host.\n\n\n    if (hostEnd === -1) hostEnd = rest.length;\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd); // pull out port.\n\n    this.parseHost(); // we\'ve indicated that there is a hostname,\n    // so even if it\'s empty, it has to be present.\n\n    this.hostname = this.hostname || \'\'; // if hostname begins with [ and ends with ]\n    // assume that it\'s an IPv6 address.\n\n    var ipv6Hostname = this.hostname[0] === \'[\' && this.hostname[this.hostname.length - 1] === \']\'; // validate a little.\n\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = \'\';\n\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += \'x\';\n            } else {\n              newpart += part[j];\n            }\n          } // we test again with ASCII char only\n\n\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n\n            if (notHost.length) {\n              rest = \'/\' + notHost.join(\'.\') + rest;\n            }\n\n            this.hostname = validParts.join(\'.\');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = \'\';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of "domain".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn\'t matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? \':\' + this.port : \'\';\n    var h = this.hostname || \'\';\n    this.host = h + p;\n    this.href += this.host; // strip [ and ] from the hostname\n    // the host field still retains them, though\n\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n\n      if (rest[0] !== \'/\') {\n        rest = \'/\' + rest;\n      }\n    }\n  } // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n\n\n  if (!unsafeProtocol[lowerProto]) {\n    // First, make 100% sure that any "autoEscape" chars get\n    // escaped, even if encodeURIComponent doesn\'t think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1) continue;\n      var esc = encodeURIComponent(ae);\n\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n\n      rest = rest.split(ae).join(esc);\n    }\n  } // chop off from the tail first.\n\n\n  var hash = rest.indexOf(\'#\');\n\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n\n  var qm = rest.indexOf(\'?\');\n\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = \'\';\n    this.query = {};\n  }\n\n  if (rest) this.pathname = rest;\n\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = \'/\';\n  } //to support http.request\n\n\n  if (this.pathname || this.search) {\n    var p = this.pathname || \'\';\n    var s = this.search || \'\';\n    this.path = p + s;\n  } // finally, reconstruct the href based on what has been validated.\n\n\n  this.href = this.format();\n  return this;\n}; // format a parsed object into a url string\n\n\nfunction urlFormat(obj) {\n  // ensure it\'s an object, and not a string url.\n  // If it\'s an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function () {\n  var auth = this.auth || \'\';\n\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, \':\');\n    auth += \'@\';\n  }\n\n  var protocol = this.protocol || \'\',\n      pathname = this.pathname || \'\',\n      hash = this.hash || \'\',\n      host = false,\n      query = \'\';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(\':\') === -1 ? this.hostname : \'[\' + this.hostname + \']\');\n\n    if (this.port) {\n      host += \':\' + this.port;\n    }\n  }\n\n  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || query && \'?\' + query || \'\';\n  if (protocol && protocol.substr(-1) !== \':\') protocol += \':\'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = \'//\' + (host || \'\');\n    if (pathname && pathname.charAt(0) !== \'/\') pathname = \'/\' + pathname;\n  } else if (!host) {\n    host = \'\';\n  }\n\n  if (hash && hash.charAt(0) !== \'#\') hash = \'#\' + hash;\n  if (search && search.charAt(0) !== \'?\') search = \'?\' + search;\n  pathname = pathname.replace(/[?#]/g, function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace(\'#\', \'%23\');\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function (relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function (relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  } // hash is always overridden, no matter what.\n  // even href="" will remove it.\n\n\n  result.hash = relative.hash; // if the relative url is empty, then there\'s nothing left to do here.\n\n  if (relative.href === \'\') {\n    result.href = result.format();\n    return result;\n  } // hrefs like //foo/bar always cut to the protocol.\n\n\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== \'protocol\') result[rkey] = relative[rkey];\n    } //urlParse appends trailing / to urls like http://www.example.com\n\n\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n      result.path = result.pathname = \'/\';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it\'s a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it\'s not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that\'s known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || \'\').split(\'/\');\n\n      while (relPath.length && !(relative.host = relPath.shift())) {\n        ;\n      }\n\n      if (!relative.host) relative.host = \'\';\n      if (!relative.hostname) relative.hostname = \'\';\n      if (relPath[0] !== \'\') relPath.unshift(\'\');\n      if (relPath.length < 2) relPath.unshift(\'\');\n      result.pathname = relPath.join(\'/\');\n    } else {\n      result.pathname = relative.pathname;\n    }\n\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || \'\';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port; // to support http.request\n\n    if (result.pathname || result.search) {\n      var p = result.pathname || \'\';\n      var s = result.search || \'\';\n      result.path = p + s;\n    }\n\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === \'/\',\n      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === \'/\',\n      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split(\'/\') || [],\n      relPath = relative.pathname && relative.pathname.split(\'/\') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n\n  if (psychotic) {\n    result.hostname = \'\';\n    result.port = null;\n\n    if (result.host) {\n      if (srcPath[0] === \'\') srcPath[0] = result.host;else srcPath.unshift(result.host);\n    }\n\n    result.host = \'\';\n\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n\n      if (relative.host) {\n        if (relPath[0] === \'\') relPath[0] = relative.host;else relPath.unshift(relative.host);\n      }\n\n      relative.host = null;\n    }\n\n    mustEndAbs = mustEndAbs && (relPath[0] === \'\' || srcPath[0] === \'\');\n  }\n\n  if (isRelAbs) {\n    // it\'s absolute.\n    result.host = relative.host || relative.host === \'\' ? relative.host : result.host;\n    result.hostname = relative.hostname || relative.hostname === \'\' ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath; // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it\'s relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href=\'?foo\'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject(\'mailto:local1@domain1\', \'local2@domain2\')\n\n      var authInHost = result.host && result.host.indexOf(\'@\') > 0 ? result.host.split(\'@\') : false;\n\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n\n    result.search = relative.search;\n    result.query = relative.query; //to support http.request\n\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : \'\') + (result.search ? result.search : \'\');\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we\'ve already handled the other stuff above.\n    result.pathname = null; //to support http.request\n\n    if (result.search) {\n      result.path = \'/\' + result.search;\n    } else {\n      result.path = null;\n    }\n\n    result.href = result.format();\n    return result;\n  } // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n\n\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === \'.\' || last === \'..\') || last === \'\'; // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n\n  var up = 0;\n\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n\n    if (last === \'.\') {\n      srcPath.splice(i, 1);\n    } else if (last === \'..\') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  } // if the path is allowed to go above the root, restore leading ..s\n\n\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift(\'..\');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== \'\' && (!srcPath[0] || srcPath[0].charAt(0) !== \'/\')) {\n    srcPath.unshift(\'\');\n  }\n\n  if (hasTrailingSlash && srcPath.join(\'/\').substr(-1) !== \'/\') {\n    srcPath.push(\'\');\n  }\n\n  var isAbsolute = srcPath[0] === \'\' || srcPath[0] && srcPath[0].charAt(0) === \'/\'; // put the host back\n\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? \'\' : srcPath.length ? srcPath.shift() : \'\'; //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject(\'mailto:local1@domain1\', \'local2@domain2\')\n\n    var authInHost = result.host && result.host.indexOf(\'@\') > 0 ? result.host.split(\'@\') : false;\n\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift(\'\');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join(\'/\');\n  } //to support request.http\n\n\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : \'\') + (result.search ? result.search : \'\');\n  }\n\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function () {\n  var host = this.host;\n  var port = portPattern.exec(host);\n\n  if (port) {\n    port = port[0];\n\n    if (port !== \':\') {\n      this.port = port.substr(1);\n    }\n\n    host = host.substr(0, host.length - port.length);\n  }\n\n  if (host) this.hostname = host;\n};\n\nvar url = {\n  parse: parse,\n  resolve: resolve,\n  resolveObject: resolveObject,\n  format: format$1,\n  Url: Url_1\n};\n\nfunction getPropertyReference(propertyName) {\n  for (var i = 0; i < v8.layout.length; i++) {\n    for (var key in v8[v8.layout[i]]) {\n      if (key === propertyName) return v8[v8.layout[i]][key];\n    }\n  }\n\n  for (var _i = 0; _i < v8.paint.length; _i++) {\n    for (var _key2 in v8[v8.paint[_i]]) {\n      if (_key2 === propertyName) return v8[v8.paint[_i]][_key2];\n    }\n  }\n\n  return null;\n}\n\nfunction eachSource(style, callback) {\n  for (var k in style.sources) {\n    callback(style.sources[k]);\n  }\n}\n\nfunction eachLayer(style, callback) {\n  var _iterator = _createForOfIteratorHelper(style.layers),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _layer = _step.value;\n      callback(_layer);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction eachProperty(style, options, callback) {\n  function inner(layer, propertyType) {\n    var properties = layer[propertyType];\n    if (!properties) return;\n    Object.keys(properties).forEach(function (key) {\n      callback({\n        path: [layer.id, propertyType, key],\n        key: key,\n        value: properties[key],\n        reference: getPropertyReference(key),\n        set: function set(x) {\n          properties[key] = x;\n        }\n      });\n    });\n  }\n\n  eachLayer(style, function (layer) {\n    if (options.paint) {\n      inner(layer, \'paint\');\n    }\n\n    if (options.layout) {\n      inner(layer, \'layout\');\n    }\n  });\n}\n\nfunction eachLayout(layer, callback) {\n  for (var k in layer) {\n    if (k.indexOf(\'layout\') === 0) {\n      callback(layer[k], k);\n    }\n  }\n}\n\nfunction eachPaint(layer, callback) {\n  for (var k in layer) {\n    if (k.indexOf(\'paint\') === 0) {\n      callback(layer[k], k);\n    }\n  }\n}\n\nfunction resolveConstant(style, value) {\n  if (typeof value === \'string\' && value[0] === \'@\') {\n    return resolveConstant(style, style.constants[value]);\n  } else {\n    return value;\n  }\n}\n\nfunction isFunction(value) {\n  return Array.isArray(value.stops);\n}\n\nfunction renameProperty(obj, from, to) {\n  obj[to] = obj[from];\n  delete obj[from];\n}\n\nfunction migrateToV8(style) {\n  style.version = 8;\n  eachSource(style, function (source) {\n    if (source.type === \'video\' && source.url !== undefined) {\n      renameProperty(source, \'url\', \'urls\');\n    }\n\n    if (source.type === \'video\') {\n      source.coordinates.forEach(function (coord) {\n        return coord.reverse();\n      });\n    }\n  });\n  eachLayer(style, function (layer) {\n    eachLayout(layer, function (layout) {\n      if (layout[\'symbol-min-distance\'] !== undefined) {\n        renameProperty(layout, \'symbol-min-distance\', \'symbol-spacing\');\n      }\n    });\n    eachPaint(layer, function (paint) {\n      if (paint[\'background-image\'] !== undefined) {\n        renameProperty(paint, \'background-image\', \'background-pattern\');\n      }\n\n      if (paint[\'line-image\'] !== undefined) {\n        renameProperty(paint, \'line-image\', \'line-pattern\');\n      }\n\n      if (paint[\'fill-image\'] !== undefined) {\n        renameProperty(paint, \'fill-image\', \'fill-pattern\');\n      }\n    });\n  });\n  eachProperty(style, {\n    paint: true,\n    layout: true\n  }, function (property) {\n    var value = resolveConstant(style, property.value);\n\n    if (isFunction(value)) {\n      value.stops.forEach(function (stop) {\n        stop[1] = resolveConstant(style, stop[1]);\n      });\n    }\n\n    property.set(value);\n  });\n  delete style.constants;\n  eachLayer(style, function (layer) {\n    eachLayout(layer, function (layout) {\n      delete layout[\'text-max-size\'];\n      delete layout[\'icon-max-size\'];\n    });\n    eachPaint(layer, function (paint) {\n      if (paint[\'text-size\']) {\n        if (!layer.layout) layer.layout = {};\n        layer.layout[\'text-size\'] = paint[\'text-size\'];\n        delete paint[\'text-size\'];\n      }\n\n      if (paint[\'icon-size\']) {\n        if (!layer.layout) layer.layout = {};\n        layer.layout[\'icon-size\'] = paint[\'icon-size\'];\n        delete paint[\'icon-size\'];\n      }\n    });\n  });\n\n  function migrateFontstackURL(input) {\n    var inputParsed = url.parse(input);\n    var inputPathnameParts = inputParsed.pathname.split(\'/\');\n\n    if (inputParsed.protocol !== \'mapbox:\') {\n      return input;\n    } else if (inputParsed.hostname === \'fontstack\') {\n      return \'mapbox://fonts/mapbox/{fontstack}/{range}.pbf\';\n    } else if (inputParsed.hostname === \'fonts\') {\n      return "mapbox://fonts/".concat(inputPathnameParts[2], "/{fontstack}/{range}.pbf");\n    } else ;\n  }\n\n  if (style.glyphs) {\n    style.glyphs = migrateFontstackURL(style.glyphs);\n  }\n\n  function migrateFontStack(font) {\n    function splitAndTrim(string) {\n      return string.split(\',\').map(function (s) {\n        return s.trim();\n      });\n    }\n\n    if (Array.isArray(font)) {\n      return font;\n    } else if (typeof font === \'string\') {\n      return splitAndTrim(font);\n    } else if (typeof font === \'object\') {\n      font.stops.forEach(function (stop) {\n        stop[1] = splitAndTrim(stop[1]);\n      });\n      return font;\n    } else {\n      throw new Error(\'unexpected font value\');\n    }\n  }\n\n  eachLayer(style, function (layer) {\n    eachLayout(layer, function (layout) {\n      if (layout[\'text-font\']) {\n        layout[\'text-font\'] = migrateFontStack(layout[\'text-font\']);\n      }\n    });\n  });\n  var firstSymbolLayer = 0;\n\n  for (var i = style.layers.length - 1; i >= 0; i--) {\n    var _layer2 = style.layers[i];\n\n    if (_layer2.type !== \'symbol\') {\n      firstSymbolLayer = i + 1;\n      break;\n    }\n  }\n\n  var symbolLayers = style.layers.splice(firstSymbolLayer);\n  symbolLayers.reverse();\n  style.layers = style.layers.concat(symbolLayers);\n  return style;\n}\n\nfunction extend(output) {\n  for (var _len = arguments.length, inputs = new Array(_len > 1 ? _len - 1 : 0), _key3 = 1; _key3 < _len; _key3++) {\n    inputs[_key3 - 1] = arguments[_key3];\n  }\n\n  for (var _i2 = 0, _inputs = inputs; _i2 < _inputs.length; _i2++) {\n    var input = _inputs[_i2];\n\n    for (var k in input) {\n      output[k] = input[k];\n    }\n  }\n\n  return output;\n}\n\nvar ParsingError = /*#__PURE__*/function (_Error) {\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z)(ParsingError, _Error);\n\n  var _super = _createSuper(ParsingError);\n\n  function ParsingError(key, message) {\n    var _this;\n\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ParsingError);\n\n    _this = _super.call(this, message);\n    _this.message = message;\n    _this.key = key;\n    return _this;\n  }\n\n  return ParsingError;\n}( /*#__PURE__*/(0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__/* .default */ .Z)(Error));\n\nvar Scope = /*#__PURE__*/function () {\n  function Scope(parent) {\n    var bindings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Scope);\n\n    this.parent = parent;\n    this.bindings = {};\n\n    var _iterator2 = _createForOfIteratorHelper(bindings),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step2.value, 2),\n            name = _step2$value[0],\n            _expression = _step2$value[1];\n\n        this.bindings[name] = _expression;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Scope, [{\n    key: "concat",\n    value: function concat(bindings) {\n      return new Scope(this, bindings);\n    }\n  }, {\n    key: "get",\n    value: function get(name) {\n      if (this.bindings[name]) {\n        return this.bindings[name];\n      }\n\n      if (this.parent) {\n        return this.parent.get(name);\n      }\n\n      throw new Error("".concat(name, " not found in scope."));\n    }\n  }, {\n    key: "has",\n    value: function has(name) {\n      if (this.bindings[name]) return true;\n      return this.parent ? this.parent.has(name) : false;\n    }\n  }]);\n\n  return Scope;\n}();\n\nvar NullType = {\n  kind: \'null\'\n};\nvar NumberType = {\n  kind: \'number\'\n};\nvar StringType = {\n  kind: \'string\'\n};\nvar BooleanType = {\n  kind: \'boolean\'\n};\nvar ColorType = {\n  kind: \'color\'\n};\nvar ObjectType = {\n  kind: \'object\'\n};\nvar ValueType = {\n  kind: \'value\'\n};\nvar ErrorType = {\n  kind: \'error\'\n};\nvar CollatorType = {\n  kind: \'collator\'\n};\nvar FormattedType = {\n  kind: \'formatted\'\n};\nvar ResolvedImageType = {\n  kind: \'resolvedImage\'\n};\n\nfunction array(itemType, N) {\n  return {\n    kind: \'array\',\n    itemType: itemType,\n    N: N\n  };\n}\n\nfunction toString(type) {\n  if (type.kind === \'array\') {\n    var itemType = toString(type.itemType);\n    return typeof type.N === \'number\' ? "array<".concat(itemType, ", ").concat(type.N, ">") : type.itemType.kind === \'value\' ? \'array\' : "array<".concat(itemType, ">");\n  } else {\n    return type.kind;\n  }\n}\n\nvar valueMemberTypes = [NullType, NumberType, StringType, BooleanType, ColorType, FormattedType, ObjectType, array(ValueType), ResolvedImageType];\n\nfunction _checkSubtype(expected, t) {\n  if (t.kind === \'error\') {\n    return null;\n  } else if (expected.kind === \'array\') {\n    if (t.kind === \'array\' && (t.N === 0 && t.itemType.kind === \'value\' || !_checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== \'number\' || expected.N === t.N)) {\n      return null;\n    }\n  } else if (expected.kind === t.kind) {\n    return null;\n  } else if (expected.kind === \'value\') {\n    var _iterator3 = _createForOfIteratorHelper(valueMemberTypes),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var memberType = _step3.value;\n\n        if (!_checkSubtype(memberType, t)) {\n          return null;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  return "Expected ".concat(toString(expected), " but found ").concat(toString(t), " instead.");\n}\n\nfunction isValidType(provided, allowedTypes) {\n  return allowedTypes.some(function (t) {\n    return t.kind === provided.kind;\n  });\n}\n\nfunction isValidNativeType(provided, allowedTypes) {\n  return allowedTypes.some(function (t) {\n    if (t === \'null\') {\n      return provided === null;\n    } else if (t === \'array\') {\n      return Array.isArray(provided);\n    } else if (t === \'object\') {\n      return provided && !Array.isArray(provided) && typeof provided === \'object\';\n    } else {\n      return t === typeof provided;\n    }\n  });\n}\n\nvar csscolorparser = createCommonjsModule(function (module, exports) {\n  // (c) Dean McNamee <dean@gmail.com>, 2012.\n  //\n  // https://github.com/deanm/css-color-parser-js\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a copy\n  // of this software and associated documentation files (the "Software"), to\n  // deal in the Software without restriction, including without limitation the\n  // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n  // sell copies of the Software, and to permit persons to whom the Software is\n  // furnished to do so, subject to the following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included in\n  // all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  // IN THE SOFTWARE.\n  // http://www.w3.org/TR/css3-color/\n  var kCSSColorTable = {\n    "transparent": [0, 0, 0, 0],\n    "aliceblue": [240, 248, 255, 1],\n    "antiquewhite": [250, 235, 215, 1],\n    "aqua": [0, 255, 255, 1],\n    "aquamarine": [127, 255, 212, 1],\n    "azure": [240, 255, 255, 1],\n    "beige": [245, 245, 220, 1],\n    "bisque": [255, 228, 196, 1],\n    "black": [0, 0, 0, 1],\n    "blanchedalmond": [255, 235, 205, 1],\n    "blue": [0, 0, 255, 1],\n    "blueviolet": [138, 43, 226, 1],\n    "brown": [165, 42, 42, 1],\n    "burlywood": [222, 184, 135, 1],\n    "cadetblue": [95, 158, 160, 1],\n    "chartreuse": [127, 255, 0, 1],\n    "chocolate": [210, 105, 30, 1],\n    "coral": [255, 127, 80, 1],\n    "cornflowerblue": [100, 149, 237, 1],\n    "cornsilk": [255, 248, 220, 1],\n    "crimson": [220, 20, 60, 1],\n    "cyan": [0, 255, 255, 1],\n    "darkblue": [0, 0, 139, 1],\n    "darkcyan": [0, 139, 139, 1],\n    "darkgoldenrod": [184, 134, 11, 1],\n    "darkgray": [169, 169, 169, 1],\n    "darkgreen": [0, 100, 0, 1],\n    "darkgrey": [169, 169, 169, 1],\n    "darkkhaki": [189, 183, 107, 1],\n    "darkmagenta": [139, 0, 139, 1],\n    "darkolivegreen": [85, 107, 47, 1],\n    "darkorange": [255, 140, 0, 1],\n    "darkorchid": [153, 50, 204, 1],\n    "darkred": [139, 0, 0, 1],\n    "darksalmon": [233, 150, 122, 1],\n    "darkseagreen": [143, 188, 143, 1],\n    "darkslateblue": [72, 61, 139, 1],\n    "darkslategray": [47, 79, 79, 1],\n    "darkslategrey": [47, 79, 79, 1],\n    "darkturquoise": [0, 206, 209, 1],\n    "darkviolet": [148, 0, 211, 1],\n    "deeppink": [255, 20, 147, 1],\n    "deepskyblue": [0, 191, 255, 1],\n    "dimgray": [105, 105, 105, 1],\n    "dimgrey": [105, 105, 105, 1],\n    "dodgerblue": [30, 144, 255, 1],\n    "firebrick": [178, 34, 34, 1],\n    "floralwhite": [255, 250, 240, 1],\n    "forestgreen": [34, 139, 34, 1],\n    "fuchsia": [255, 0, 255, 1],\n    "gainsboro": [220, 220, 220, 1],\n    "ghostwhite": [248, 248, 255, 1],\n    "gold": [255, 215, 0, 1],\n    "goldenrod": [218, 165, 32, 1],\n    "gray": [128, 128, 128, 1],\n    "green": [0, 128, 0, 1],\n    "greenyellow": [173, 255, 47, 1],\n    "grey": [128, 128, 128, 1],\n    "honeydew": [240, 255, 240, 1],\n    "hotpink": [255, 105, 180, 1],\n    "indianred": [205, 92, 92, 1],\n    "indigo": [75, 0, 130, 1],\n    "ivory": [255, 255, 240, 1],\n    "khaki": [240, 230, 140, 1],\n    "lavender": [230, 230, 250, 1],\n    "lavenderblush": [255, 240, 245, 1],\n    "lawngreen": [124, 252, 0, 1],\n    "lemonchiffon": [255, 250, 205, 1],\n    "lightblue": [173, 216, 230, 1],\n    "lightcoral": [240, 128, 128, 1],\n    "lightcyan": [224, 255, 255, 1],\n    "lightgoldenrodyellow": [250, 250, 210, 1],\n    "lightgray": [211, 211, 211, 1],\n    "lightgreen": [144, 238, 144, 1],\n    "lightgrey": [211, 211, 211, 1],\n    "lightpink": [255, 182, 193, 1],\n    "lightsalmon": [255, 160, 122, 1],\n    "lightseagreen": [32, 178, 170, 1],\n    "lightskyblue": [135, 206, 250, 1],\n    "lightslategray": [119, 136, 153, 1],\n    "lightslategrey": [119, 136, 153, 1],\n    "lightsteelblue": [176, 196, 222, 1],\n    "lightyellow": [255, 255, 224, 1],\n    "lime": [0, 255, 0, 1],\n    "limegreen": [50, 205, 50, 1],\n    "linen": [250, 240, 230, 1],\n    "magenta": [255, 0, 255, 1],\n    "maroon": [128, 0, 0, 1],\n    "mediumaquamarine": [102, 205, 170, 1],\n    "mediumblue": [0, 0, 205, 1],\n    "mediumorchid": [186, 85, 211, 1],\n    "mediumpurple": [147, 112, 219, 1],\n    "mediumseagreen": [60, 179, 113, 1],\n    "mediumslateblue": [123, 104, 238, 1],\n    "mediumspringgreen": [0, 250, 154, 1],\n    "mediumturquoise": [72, 209, 204, 1],\n    "mediumvioletred": [199, 21, 133, 1],\n    "midnightblue": [25, 25, 112, 1],\n    "mintcream": [245, 255, 250, 1],\n    "mistyrose": [255, 228, 225, 1],\n    "moccasin": [255, 228, 181, 1],\n    "navajowhite": [255, 222, 173, 1],\n    "navy": [0, 0, 128, 1],\n    "oldlace": [253, 245, 230, 1],\n    "olive": [128, 128, 0, 1],\n    "olivedrab": [107, 142, 35, 1],\n    "orange": [255, 165, 0, 1],\n    "orangered": [255, 69, 0, 1],\n    "orchid": [218, 112, 214, 1],\n    "palegoldenrod": [238, 232, 170, 1],\n    "palegreen": [152, 251, 152, 1],\n    "paleturquoise": [175, 238, 238, 1],\n    "palevioletred": [219, 112, 147, 1],\n    "papayawhip": [255, 239, 213, 1],\n    "peachpuff": [255, 218, 185, 1],\n    "peru": [205, 133, 63, 1],\n    "pink": [255, 192, 203, 1],\n    "plum": [221, 160, 221, 1],\n    "powderblue": [176, 224, 230, 1],\n    "purple": [128, 0, 128, 1],\n    "rebeccapurple": [102, 51, 153, 1],\n    "red": [255, 0, 0, 1],\n    "rosybrown": [188, 143, 143, 1],\n    "royalblue": [65, 105, 225, 1],\n    "saddlebrown": [139, 69, 19, 1],\n    "salmon": [250, 128, 114, 1],\n    "sandybrown": [244, 164, 96, 1],\n    "seagreen": [46, 139, 87, 1],\n    "seashell": [255, 245, 238, 1],\n    "sienna": [160, 82, 45, 1],\n    "silver": [192, 192, 192, 1],\n    "skyblue": [135, 206, 235, 1],\n    "slateblue": [106, 90, 205, 1],\n    "slategray": [112, 128, 144, 1],\n    "slategrey": [112, 128, 144, 1],\n    "snow": [255, 250, 250, 1],\n    "springgreen": [0, 255, 127, 1],\n    "steelblue": [70, 130, 180, 1],\n    "tan": [210, 180, 140, 1],\n    "teal": [0, 128, 128, 1],\n    "thistle": [216, 191, 216, 1],\n    "tomato": [255, 99, 71, 1],\n    "turquoise": [64, 224, 208, 1],\n    "violet": [238, 130, 238, 1],\n    "wheat": [245, 222, 179, 1],\n    "white": [255, 255, 255, 1],\n    "whitesmoke": [245, 245, 245, 1],\n    "yellow": [255, 255, 0, 1],\n    "yellowgreen": [154, 205, 50, 1]\n  };\n\n  function clamp_css_byte(i) {\n    // Clamp to integer 0 .. 255.\n    i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n    return i < 0 ? 0 : i > 255 ? 255 : i;\n  }\n\n  function clamp_css_float(f) {\n    // Clamp to float 0.0 .. 1.0.\n    return f < 0 ? 0 : f > 1 ? 1 : f;\n  }\n\n  function parse_css_int(str) {\n    // int or percentage.\n    if (str[str.length - 1] === \'%\') return clamp_css_byte(parseFloat(str) / 100 * 255);\n    return clamp_css_byte(parseInt(str));\n  }\n\n  function parse_css_float(str) {\n    // float or percentage.\n    if (str[str.length - 1] === \'%\') return clamp_css_float(parseFloat(str) / 100);\n    return clamp_css_float(parseFloat(str));\n  }\n\n  function css_hue_to_rgb(m1, m2, h) {\n    if (h < 0) h += 1;else if (h > 1) h -= 1;\n    if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;\n    if (h * 2 < 1) return m2;\n    if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n    return m1;\n  }\n\n  function parseCSSColor(css_str) {\n    // Remove all whitespace, not compliant, but should just be more accepting.\n    var str = css_str.replace(/ /g, \'\').toLowerCase(); // Color keywords (and transparent) lookup.\n\n    if (str in kCSSColorTable) return kCSSColorTable[str].slice(); // dup.\n    // #abc and #abc123 syntax.\n\n    if (str[0] === \'#\') {\n      if (str.length === 4) {\n        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n        if (!(iv >= 0 && iv <= 0xfff)) return null; // Covers NaN.\n\n        return [(iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1];\n      } else if (str.length === 7) {\n        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n        if (!(iv >= 0 && iv <= 0xffffff)) return null; // Covers NaN.\n\n        return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];\n      }\n\n      return null;\n    }\n\n    var op = str.indexOf(\'(\'),\n        ep = str.indexOf(\')\');\n\n    if (op !== -1 && ep + 1 === str.length) {\n      var fname = str.substr(0, op);\n      var params = str.substr(op + 1, ep - (op + 1)).split(\',\');\n      var alpha = 1; // To allow case fallthrough.\n\n      switch (fname) {\n        case \'rgba\':\n          if (params.length !== 4) return null;\n          alpha = parse_css_float(params.pop());\n        // Fall through.\n\n        case \'rgb\':\n          if (params.length !== 3) return null;\n          return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];\n\n        case \'hsla\':\n          if (params.length !== 4) return null;\n          alpha = parse_css_float(params.pop());\n        // Fall through.\n\n        case \'hsl\':\n          if (params.length !== 3) return null;\n          var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n          // NOTE(deanm): According to the CSS spec s/l should only be\n          // percentages, but we don\'t bother and let float or percentage.\n\n          var s = parse_css_float(params[1]);\n          var l = parse_css_float(params[2]);\n          var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n          var m1 = l * 2 - m2;\n          return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];\n\n        default:\n          return null;\n      }\n    }\n\n    return null;\n  }\n\n  try {\n    exports.parseCSSColor = parseCSSColor;\n  } catch (e) {}\n});\n\nvar Color = /*#__PURE__*/function () {\n  function Color(r, g, b) {\n    var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Color);\n\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Color, [{\n    key: "toString",\n    value: function toString() {\n      var _this$toArray = this.toArray(),\n          _this$toArray2 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_this$toArray, 4),\n          r = _this$toArray2[0],\n          g = _this$toArray2[1],\n          b = _this$toArray2[2],\n          a = _this$toArray2[3];\n\n      return "rgba(".concat(Math.round(r), ",").concat(Math.round(g), ",").concat(Math.round(b), ",").concat(a, ")");\n    }\n  }, {\n    key: "toArray",\n    value: function toArray() {\n      var r = this.r,\n          g = this.g,\n          b = this.b,\n          a = this.a;\n      return a === 0 ? [0, 0, 0, 0] : [r * 255 / a, g * 255 / a, b * 255 / a, a];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(input) {\n      if (!input) {\n        return undefined;\n      }\n\n      if (input instanceof Color) {\n        return input;\n      }\n\n      if (typeof input !== \'string\') {\n        return undefined;\n      }\n\n      var rgba = csscolorparser.parseCSSColor(input);\n\n      if (!rgba) {\n        return undefined;\n      }\n\n      return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);\n    }\n  }]);\n\n  return Color;\n}();\n\nColor.black = new Color(0, 0, 0, 1);\nColor.white = new Color(1, 1, 1, 1);\nColor.transparent = new Color(0, 0, 0, 0);\nColor.red = new Color(1, 0, 0, 1);\nColor.blue = new Color(0, 0, 1, 1);\n\nvar Collator = /*#__PURE__*/function () {\n  function Collator(caseSensitive, diacriticSensitive, locale) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Collator);\n\n    if (caseSensitive) this.sensitivity = diacriticSensitive ? \'variant\' : \'case\';else this.sensitivity = diacriticSensitive ? \'accent\' : \'base\';\n    this.locale = locale;\n    this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n      sensitivity: this.sensitivity,\n      usage: \'search\'\n    });\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Collator, [{\n    key: "compare",\n    value: function compare(lhs, rhs) {\n      return this.collator.compare(lhs, rhs);\n    }\n  }, {\n    key: "resolvedLocale",\n    value: function resolvedLocale() {\n      return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n    }\n  }]);\n\n  return Collator;\n}();\n\nvar FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, FormattedSection);\n\n  this.text = text;\n  this.image = image;\n  this.scale = scale;\n  this.fontStack = fontStack;\n  this.textColor = textColor;\n};\n\nvar Formatted = /*#__PURE__*/function () {\n  function Formatted(sections) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Formatted);\n\n    this.sections = sections;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Formatted, [{\n    key: "isEmpty",\n    value: function isEmpty() {\n      if (this.sections.length === 0) return true;\n      return !this.sections.some(function (section) {\n        return section.text.length !== 0 || section.image && section.image.name.length !== 0;\n      });\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      if (this.sections.length === 0) return \'\';\n      return this.sections.map(function (section) {\n        return section.text;\n      }).join(\'\');\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'format\'];\n\n      var _iterator4 = _createForOfIteratorHelper(this.sections),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var section = _step4.value;\n\n          if (section.image) {\n            serialized.push([\'image\', section.image.name]);\n            continue;\n          }\n\n          serialized.push(section.text);\n          var options = {};\n\n          if (section.fontStack) {\n            options[\'text-font\'] = [\'literal\', section.fontStack.split(\',\')];\n          }\n\n          if (section.scale) {\n            options[\'font-scale\'] = section.scale;\n          }\n\n          if (section.textColor) {\n            options[\'text-color\'] = [\'rgba\'].concat(section.textColor.toArray());\n          }\n\n          serialized.push(options);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return serialized;\n    }\n  }], [{\n    key: "fromString",\n    value: function fromString(unformatted) {\n      return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);\n    }\n  }, {\n    key: "factory",\n    value: function factory(text) {\n      if (text instanceof Formatted) {\n        return text;\n      } else {\n        return Formatted.fromString(text);\n      }\n    }\n  }]);\n\n  return Formatted;\n}();\n\nvar ResolvedImage = /*#__PURE__*/function () {\n  function ResolvedImage(options) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ResolvedImage);\n\n    this.name = options.name;\n    this.available = options.available;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(ResolvedImage, [{\n    key: "toString",\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'image\', this.name];\n    }\n  }], [{\n    key: "fromString",\n    value: function fromString(name) {\n      if (!name) return null;\n      return new ResolvedImage({\n        name: name,\n        available: false\n      });\n    }\n  }]);\n\n  return ResolvedImage;\n}();\n\nfunction validateRGBA(r, g, b, a) {\n  if (!(typeof r === \'number\' && r >= 0 && r <= 255 && typeof g === \'number\' && g >= 0 && g <= 255 && typeof b === \'number\' && b >= 0 && b <= 255)) {\n    var value = typeof a === \'number\' ? [r, g, b, a] : [r, g, b];\n    return "Invalid rgba value [".concat(value.join(\', \'), "]: \'r\', \'g\', and \'b\' must be between 0 and 255.");\n  }\n\n  if (!(typeof a === \'undefined\' || typeof a === \'number\' && a >= 0 && a <= 1)) {\n    return "Invalid rgba value [".concat([r, g, b, a].join(\', \'), "]: \'a\' must be between 0 and 1.");\n  }\n\n  return null;\n}\n\nfunction isValue(mixed) {\n  if (mixed === null) {\n    return true;\n  } else if (typeof mixed === \'string\') {\n    return true;\n  } else if (typeof mixed === \'boolean\') {\n    return true;\n  } else if (typeof mixed === \'number\') {\n    return true;\n  } else if (mixed instanceof Color) {\n    return true;\n  } else if (mixed instanceof Collator) {\n    return true;\n  } else if (mixed instanceof Formatted) {\n    return true;\n  } else if (mixed instanceof ResolvedImage) {\n    return true;\n  } else if (Array.isArray(mixed)) {\n    var _iterator5 = _createForOfIteratorHelper(mixed),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var item = _step5.value;\n\n        if (!isValue(item)) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    return true;\n  } else if (typeof mixed === \'object\') {\n    for (var key in mixed) {\n      if (!isValue(mixed[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction typeOf(value) {\n  if (value === null) {\n    return NullType;\n  } else if (typeof value === \'string\') {\n    return StringType;\n  } else if (typeof value === \'boolean\') {\n    return BooleanType;\n  } else if (typeof value === \'number\') {\n    return NumberType;\n  } else if (value instanceof Color) {\n    return ColorType;\n  } else if (value instanceof Collator) {\n    return CollatorType;\n  } else if (value instanceof Formatted) {\n    return FormattedType;\n  } else if (value instanceof ResolvedImage) {\n    return ResolvedImageType;\n  } else if (Array.isArray(value)) {\n    var length = value.length;\n    var itemType;\n\n    var _iterator6 = _createForOfIteratorHelper(value),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var item = _step6.value;\n        var t = typeOf(item);\n\n        if (!itemType) {\n          itemType = t;\n        } else if (itemType === t) {\n          continue;\n        } else {\n          itemType = ValueType;\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    return array(itemType || ValueType, length);\n  } else {\n    return ObjectType;\n  }\n}\n\nfunction toString$1(value) {\n  var type = typeof value;\n\n  if (value === null) {\n    return \'\';\n  } else if (type === \'string\' || type === \'number\' || type === \'boolean\') {\n    return String(value);\n  } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {\n    return value.toString();\n  } else {\n    return JSON.stringify(value);\n  }\n}\n\nvar Literal = /*#__PURE__*/function () {\n  function Literal(type, value) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Literal);\n\n    this.type = type;\n    this.value = value;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Literal, [{\n    key: "evaluate",\n    value: function evaluate() {\n      return this.value;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild() {}\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return true;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      if (this.type.kind === \'array\' || this.type.kind === \'object\') {\n        return [\'literal\', this.value];\n      } else if (this.value instanceof Color) {\n        return [\'rgba\'].concat(this.value.toArray());\n      } else if (this.value instanceof Formatted) {\n        return this.value.serialize();\n      } else {\n        return this.value;\n      }\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2) return context.error("\'literal\' expression requires exactly one argument, but found ".concat(args.length - 1, " instead."));\n      if (!isValue(args[1])) return context.error("invalid value");\n      var value = args[1];\n      var type = typeOf(value);\n      var expected = context.expectedType;\n\n      if (type.kind === \'array\' && type.N === 0 && expected && expected.kind === \'array\' && (typeof expected.N !== \'number\' || expected.N === 0)) {\n        type = expected;\n      }\n\n      return new Literal(type, value);\n    }\n  }]);\n\n  return Literal;\n}();\n\nvar RuntimeError = /*#__PURE__*/function () {\n  function RuntimeError(message) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, RuntimeError);\n\n    this.name = \'ExpressionEvaluationError\';\n    this.message = message;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(RuntimeError, [{\n    key: "toJSON",\n    value: function toJSON() {\n      return this.message;\n    }\n  }]);\n\n  return RuntimeError;\n}();\n\nvar types = {\n  string: StringType,\n  number: NumberType,\n  boolean: BooleanType,\n  object: ObjectType\n};\n\nvar Assertion = /*#__PURE__*/function () {\n  function Assertion(type, args) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Assertion);\n\n    this.type = type;\n    this.args = args;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Assertion, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      for (var i = 0; i < this.args.length; i++) {\n        var value = this.args[i].evaluate(ctx);\n\n        var _error = _checkSubtype(this.type, typeOf(value));\n\n        if (!_error) {\n          return value;\n        } else if (i === this.args.length - 1) {\n          throw new RuntimeError("Expected value to be of type ".concat(toString(this.type), ", but found ").concat(toString(typeOf(value)), " instead."));\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      this.args.forEach(fn);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.args.every(function (arg) {\n        return arg.outputDefined();\n      });\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var type = this.type;\n      var serialized = [type.kind];\n\n      if (type.kind === \'array\') {\n        var itemType = type.itemType;\n\n        if (itemType.kind === \'string\' || itemType.kind === \'number\' || itemType.kind === \'boolean\') {\n          serialized.push(itemType.kind);\n          var N = type.N;\n\n          if (typeof N === \'number\' || this.args.length > 1) {\n            serialized.push(N);\n          }\n        }\n      }\n\n      return serialized.concat(this.args.map(function (arg) {\n        return arg.serialize();\n      }));\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 2) return context.error("Expected at least one argument.");\n      var i = 1;\n      var type;\n      var name = args[0];\n\n      if (name === \'array\') {\n        var itemType;\n\n        if (args.length > 2) {\n          var _type = args[1];\n          if (typeof _type !== \'string\' || !(_type in types) || _type === \'object\') return context.error(\'The item type argument of "array" must be one of string, number, boolean\', 1);\n          itemType = types[_type];\n          i++;\n        } else {\n          itemType = ValueType;\n        }\n\n        var N;\n\n        if (args.length > 3) {\n          if (args[2] !== null && (typeof args[2] !== \'number\' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {\n            return context.error(\'The length argument to "array" must be a positive integer literal\', 2);\n          }\n\n          N = args[2];\n          i++;\n        }\n\n        type = array(itemType, N);\n      } else {\n        type = types[name];\n      }\n\n      var parsed = [];\n\n      for (; i < args.length; i++) {\n        var input = context.parse(args[i], i, ValueType);\n        if (!input) return null;\n        parsed.push(input);\n      }\n\n      return new Assertion(type, parsed);\n    }\n  }]);\n\n  return Assertion;\n}();\n\nvar FormatExpression = /*#__PURE__*/function () {\n  function FormatExpression(sections) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, FormatExpression);\n\n    this.type = FormattedType;\n    this.sections = sections;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(FormatExpression, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var evaluateSection = function evaluateSection(section) {\n        var evaluatedContent = section.content.evaluate(ctx);\n\n        if (typeOf(evaluatedContent) === ResolvedImageType) {\n          return new FormattedSection(\'\', evaluatedContent, null, null, null);\n        }\n\n        return new FormattedSection(toString$1(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(\',\') : null, section.textColor ? section.textColor.evaluate(ctx) : null);\n      };\n\n      return new Formatted(this.sections.map(evaluateSection));\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      var _iterator7 = _createForOfIteratorHelper(this.sections),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var section = _step7.value;\n          fn(section.content);\n\n          if (section.scale) {\n            fn(section.scale);\n          }\n\n          if (section.font) {\n            fn(section.font);\n          }\n\n          if (section.textColor) {\n            fn(section.textColor);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'format\'];\n\n      var _iterator8 = _createForOfIteratorHelper(this.sections),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var section = _step8.value;\n          serialized.push(section.content.serialize());\n          var options = {};\n\n          if (section.scale) {\n            options[\'font-scale\'] = section.scale.serialize();\n          }\n\n          if (section.font) {\n            options[\'text-font\'] = section.font.serialize();\n          }\n\n          if (section.textColor) {\n            options[\'text-color\'] = section.textColor.serialize();\n          }\n\n          serialized.push(options);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 2) {\n        return context.error("Expected at least one argument.");\n      }\n\n      var firstArg = args[1];\n\n      if (!Array.isArray(firstArg) && typeof firstArg === \'object\') {\n        return context.error("First argument must be an image or text section.");\n      }\n\n      var sections = [];\n      var nextTokenMayBeObject = false;\n\n      for (var i = 1; i <= args.length - 1; ++i) {\n        var arg = args[i];\n\n        if (nextTokenMayBeObject && typeof arg === \'object\' && !Array.isArray(arg)) {\n          nextTokenMayBeObject = false;\n          var scale = null;\n\n          if (arg[\'font-scale\']) {\n            scale = context.parse(arg[\'font-scale\'], 1, NumberType);\n            if (!scale) return null;\n          }\n\n          var font = null;\n\n          if (arg[\'text-font\']) {\n            font = context.parse(arg[\'text-font\'], 1, array(StringType));\n            if (!font) return null;\n          }\n\n          var textColor = null;\n\n          if (arg[\'text-color\']) {\n            textColor = context.parse(arg[\'text-color\'], 1, ColorType);\n            if (!textColor) return null;\n          }\n\n          var lastExpression = sections[sections.length - 1];\n          lastExpression.scale = scale;\n          lastExpression.font = font;\n          lastExpression.textColor = textColor;\n        } else {\n          var content = context.parse(args[i], 1, ValueType);\n          if (!content) return null;\n          var kind = content.type.kind;\n          if (kind !== \'string\' && kind !== \'value\' && kind !== \'null\' && kind !== \'resolvedImage\') return context.error("Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.");\n          nextTokenMayBeObject = true;\n          sections.push({\n            content: content,\n            scale: null,\n            font: null,\n            textColor: null\n          });\n        }\n      }\n\n      return new FormatExpression(sections);\n    }\n  }]);\n\n  return FormatExpression;\n}();\n\nvar ImageExpression = /*#__PURE__*/function () {\n  function ImageExpression(input) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ImageExpression);\n\n    this.type = ResolvedImageType;\n    this.input = input;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(ImageExpression, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var evaluatedImageName = this.input.evaluate(ctx);\n      var value = ResolvedImage.fromString(evaluatedImageName);\n      if (value && ctx.availableImages) value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;\n      return value;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'image\', this.input.serialize()];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2) {\n        return context.error("Expected two arguments.");\n      }\n\n      var name = context.parse(args[1], 1, StringType);\n      if (!name) return context.error("No image name provided.");\n      return new ImageExpression(name);\n    }\n  }]);\n\n  return ImageExpression;\n}();\n\nvar types$1 = {\n  \'to-boolean\': BooleanType,\n  \'to-color\': ColorType,\n  \'to-number\': NumberType,\n  \'to-string\': StringType\n};\n\nvar Coercion = /*#__PURE__*/function () {\n  function Coercion(type, args) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Coercion);\n\n    this.type = type;\n    this.args = args;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Coercion, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      if (this.type.kind === \'boolean\') {\n        return Boolean(this.args[0].evaluate(ctx));\n      } else if (this.type.kind === \'color\') {\n        var input;\n\n        var _error2;\n\n        var _iterator9 = _createForOfIteratorHelper(this.args),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var arg = _step9.value;\n            input = arg.evaluate(ctx);\n            _error2 = null;\n\n            if (input instanceof Color) {\n              return input;\n            } else if (typeof input === \'string\') {\n              var c = ctx.parseColor(input);\n              if (c) return c;\n            } else if (Array.isArray(input)) {\n              if (input.length < 3 || input.length > 4) {\n                _error2 = "Invalid rbga value ".concat(JSON.stringify(input), ": expected an array containing either three or four numeric values.");\n              } else {\n                _error2 = validateRGBA(input[0], input[1], input[2], input[3]);\n              }\n\n              if (!_error2) {\n                return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);\n              }\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        throw new RuntimeError(_error2 || "Could not parse color from value \'".concat(typeof input === \'string\' ? input : String(JSON.stringify(input)), "\'"));\n      } else if (this.type.kind === \'number\') {\n        var value = null;\n\n        var _iterator10 = _createForOfIteratorHelper(this.args),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var _arg = _step10.value;\n            value = _arg.evaluate(ctx);\n            if (value === null) return 0;\n            var num = Number(value);\n            if (isNaN(num)) continue;\n            return num;\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        throw new RuntimeError("Could not convert ".concat(JSON.stringify(value), " to number."));\n      } else if (this.type.kind === \'formatted\') {\n        return Formatted.fromString(toString$1(this.args[0].evaluate(ctx)));\n      } else if (this.type.kind === \'resolvedImage\') {\n        return ResolvedImage.fromString(toString$1(this.args[0].evaluate(ctx)));\n      } else {\n        return toString$1(this.args[0].evaluate(ctx));\n      }\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      this.args.forEach(fn);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.args.every(function (arg) {\n        return arg.outputDefined();\n      });\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      if (this.type.kind === \'formatted\') {\n        return new FormatExpression([{\n          content: this.args[0],\n          scale: null,\n          font: null,\n          textColor: null\n        }]).serialize();\n      }\n\n      if (this.type.kind === \'resolvedImage\') {\n        return new ImageExpression(this.args[0]).serialize();\n      }\n\n      var serialized = ["to-".concat(this.type.kind)];\n      this.eachChild(function (child) {\n        serialized.push(child.serialize());\n      });\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 2) return context.error("Expected at least one argument.");\n      var name = args[0];\n      if ((name === \'to-boolean\' || name === \'to-string\') && args.length !== 2) return context.error("Expected one argument.");\n      var type = types$1[name];\n      var parsed = [];\n\n      for (var i = 1; i < args.length; i++) {\n        var input = context.parse(args[i], i, ValueType);\n        if (!input) return null;\n        parsed.push(input);\n      }\n\n      return new Coercion(type, parsed);\n    }\n  }]);\n\n  return Coercion;\n}();\n\nvar geometryTypes = [\'Unknown\', \'Point\', \'LineString\', \'Polygon\'];\n\nvar EvaluationContext = /*#__PURE__*/function () {\n  function EvaluationContext() {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, EvaluationContext);\n\n    this.globals = null;\n    this.feature = null;\n    this.featureState = null;\n    this.formattedSection = null;\n    this._parseColorCache = {};\n    this.availableImages = null;\n    this.canonical = null;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(EvaluationContext, [{\n    key: "id",\n    value: function id() {\n      return this.feature && \'id\' in this.feature ? this.feature.id : null;\n    }\n  }, {\n    key: "geometryType",\n    value: function geometryType() {\n      return this.feature ? typeof this.feature.type === \'number\' ? geometryTypes[this.feature.type] : this.feature.type : null;\n    }\n  }, {\n    key: "geometry",\n    value: function geometry() {\n      return this.feature && \'geometry\' in this.feature ? this.feature.geometry : null;\n    }\n  }, {\n    key: "canonicalID",\n    value: function canonicalID() {\n      return this.canonical;\n    }\n  }, {\n    key: "properties",\n    value: function properties() {\n      return this.feature && this.feature.properties || {};\n    }\n  }, {\n    key: "parseColor",\n    value: function parseColor(input) {\n      var cached = this._parseColorCache[input];\n\n      if (!cached) {\n        cached = this._parseColorCache[input] = Color.parse(input);\n      }\n\n      return cached;\n    }\n  }]);\n\n  return EvaluationContext;\n}();\n\nvar CompoundExpression = /*#__PURE__*/function () {\n  function CompoundExpression(name, type, evaluate, args) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, CompoundExpression);\n\n    this.name = name;\n    this.type = type;\n    this._evaluate = evaluate;\n    this.args = args;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(CompoundExpression, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      return this._evaluate(ctx, this.args);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      this.args.forEach(fn);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [this.name].concat(this.args.map(function (arg) {\n        return arg.serialize();\n      }));\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      var op = args[0];\n      var definition = CompoundExpression.definitions[op];\n\n      if (!definition) {\n        return context.error("Unknown expression \\"".concat(op, "\\". If you wanted a literal array, use [\\"literal\\", [...]]."), 0);\n      }\n\n      var type = Array.isArray(definition) ? definition[0] : definition.type;\n      var availableOverloads = Array.isArray(definition) ? [[definition[1], definition[2]]] : definition.overloads;\n      var overloads = availableOverloads.filter(function (_ref) {\n        var _ref2 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref, 1),\n            signature = _ref2[0];\n\n        return !Array.isArray(signature) || signature.length === args.length - 1;\n      });\n      var signatureContext = null;\n\n      var _iterator11 = _createForOfIteratorHelper(overloads),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var _step11$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step11.value, 2),\n              params = _step11$value[0],\n              evaluate = _step11$value[1];\n\n          signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);\n          var parsedArgs = [];\n          var argParseFailed = false;\n\n          for (var _i3 = 1; _i3 < args.length; _i3++) {\n            var arg = args[_i3];\n            var expectedType = Array.isArray(params) ? params[_i3 - 1] : params.type;\n\n            var _parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);\n\n            if (!_parsed) {\n              argParseFailed = true;\n              break;\n            }\n\n            parsedArgs.push(_parsed);\n          }\n\n          if (argParseFailed) {\n            continue;\n          }\n\n          if (Array.isArray(params)) {\n            if (params.length !== parsedArgs.length) {\n              signatureContext.error("Expected ".concat(params.length, " arguments, but found ").concat(parsedArgs.length, " instead."));\n              continue;\n            }\n          }\n\n          for (var _i4 = 0; _i4 < parsedArgs.length; _i4++) {\n            var _expected = Array.isArray(params) ? params[_i4] : params.type;\n\n            var _arg2 = parsedArgs[_i4];\n            signatureContext.concat(_i4 + 1).checkSubtype(_expected, _arg2.type);\n          }\n\n          if (signatureContext.errors.length === 0) {\n            return new CompoundExpression(op, type, evaluate, parsedArgs);\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      if (overloads.length === 1) {\n        var _context$errors;\n\n        (_context$errors = context.errors).push.apply(_context$errors, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(signatureContext.errors));\n      } else {\n        var expected = overloads.length ? overloads : availableOverloads;\n        var signatures = expected.map(function (_ref3) {\n          var _ref4 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref3, 1),\n              params = _ref4[0];\n\n          return stringifySignature(params);\n        }).join(\' | \');\n        var actualTypes = [];\n\n        for (var i = 1; i < args.length; i++) {\n          var parsed = context.parse(args[i], 1 + actualTypes.length);\n          if (!parsed) return null;\n          actualTypes.push(toString(parsed.type));\n        }\n\n        context.error("Expected arguments of type ".concat(signatures, ", but found (").concat(actualTypes.join(\', \'), ") instead."));\n      }\n\n      return null;\n    }\n  }, {\n    key: "register",\n    value: function register(registry, definitions) {\n      CompoundExpression.definitions = definitions;\n\n      for (var name in definitions) {\n        registry[name] = CompoundExpression;\n      }\n    }\n  }]);\n\n  return CompoundExpression;\n}();\n\nfunction stringifySignature(signature) {\n  if (Array.isArray(signature)) {\n    return "(".concat(signature.map(toString).join(\', \'), ")");\n  } else {\n    return "(".concat(toString(signature.type), "...)");\n  }\n}\n\nvar CollatorExpression = /*#__PURE__*/function () {\n  function CollatorExpression(caseSensitive, diacriticSensitive, locale) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, CollatorExpression);\n\n    this.type = CollatorType;\n    this.locale = locale;\n    this.caseSensitive = caseSensitive;\n    this.diacriticSensitive = diacriticSensitive;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(CollatorExpression, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.caseSensitive);\n      fn(this.diacriticSensitive);\n\n      if (this.locale) {\n        fn(this.locale);\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var options = {};\n      options[\'case-sensitive\'] = this.caseSensitive.serialize();\n      options[\'diacritic-sensitive\'] = this.diacriticSensitive.serialize();\n\n      if (this.locale) {\n        options[\'locale\'] = this.locale.serialize();\n      }\n\n      return [\'collator\', options];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2) return context.error("Expected one argument.");\n      var options = args[1];\n      if (typeof options !== \'object\' || Array.isArray(options)) return context.error("Collator options argument must be an object.");\n      var caseSensitive = context.parse(options[\'case-sensitive\'] === undefined ? false : options[\'case-sensitive\'], 1, BooleanType);\n      if (!caseSensitive) return null;\n      var diacriticSensitive = context.parse(options[\'diacritic-sensitive\'] === undefined ? false : options[\'diacritic-sensitive\'], 1, BooleanType);\n      if (!diacriticSensitive) return null;\n      var locale = null;\n\n      if (options[\'locale\']) {\n        locale = context.parse(options[\'locale\'], 1, StringType);\n        if (!locale) return null;\n      }\n\n      return new CollatorExpression(caseSensitive, diacriticSensitive, locale);\n    }\n  }]);\n\n  return CollatorExpression;\n}();\n\nvar EXTENT = 8192;\n\nfunction updateBBox(bbox, coord) {\n  bbox[0] = Math.min(bbox[0], coord[0]);\n  bbox[1] = Math.min(bbox[1], coord[1]);\n  bbox[2] = Math.max(bbox[2], coord[0]);\n  bbox[3] = Math.max(bbox[3], coord[1]);\n}\n\nfunction mercatorXfromLng(lng) {\n  return (180 + lng) / 360;\n}\n\nfunction mercatorYfromLat(lat) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;\n}\n\nfunction boxWithinBox(bbox1, bbox2) {\n  if (bbox1[0] <= bbox2[0]) return false;\n  if (bbox1[2] >= bbox2[2]) return false;\n  if (bbox1[1] <= bbox2[1]) return false;\n  if (bbox1[3] >= bbox2[3]) return false;\n  return true;\n}\n\nfunction getTileCoordinates(p, canonical) {\n  var x = mercatorXfromLng(p[0]);\n  var y = mercatorYfromLat(p[1]);\n  var tilesAtZoom = Math.pow(2, canonical.z);\n  return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];\n}\n\nfunction onBoundary(p, p1, p2) {\n  var x1 = p[0] - p1[0];\n  var y1 = p[1] - p1[1];\n  var x2 = p[0] - p2[0];\n  var y2 = p[1] - p2[1];\n  return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;\n}\n\nfunction rayIntersect(p, p1, p2) {\n  return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];\n}\n\nfunction pointWithinPolygon(point, rings) {\n  var inside = false;\n\n  for (var i = 0, len = rings.length; i < len; i++) {\n    var ring = rings[i];\n\n    for (var j = 0, len2 = ring.length; j < len2 - 1; j++) {\n      if (onBoundary(point, ring[j], ring[j + 1])) return false;\n      if (rayIntersect(point, ring[j], ring[j + 1])) inside = !inside;\n    }\n  }\n\n  return inside;\n}\n\nfunction pointWithinPolygons(point, polygons) {\n  for (var i = 0; i < polygons.length; i++) {\n    if (pointWithinPolygon(point, polygons[i])) return true;\n  }\n\n  return false;\n}\n\nfunction perp(v1, v2) {\n  return v1[0] * v2[1] - v1[1] * v2[0];\n}\n\nfunction twoSided(p1, p2, q1, q2) {\n  var x1 = p1[0] - q1[0];\n  var y1 = p1[1] - q1[1];\n  var x2 = p2[0] - q1[0];\n  var y2 = p2[1] - q1[1];\n  var x3 = q2[0] - q1[0];\n  var y3 = q2[1] - q1[1];\n  var det1 = x1 * y3 - x3 * y1;\n  var det2 = x2 * y3 - x3 * y2;\n  if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) return true;\n  return false;\n}\n\nfunction lineIntersectLine(a, b, c, d) {\n  var vectorP = [b[0] - a[0], b[1] - a[1]];\n  var vectorQ = [d[0] - c[0], d[1] - c[1]];\n  if (perp(vectorQ, vectorP) === 0) return false;\n  if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) return true;\n  return false;\n}\n\nfunction lineIntersectPolygon(p1, p2, polygon) {\n  var _iterator12 = _createForOfIteratorHelper(polygon),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var ring = _step12.value;\n\n      for (var j = 0; j < ring.length - 1; ++j) {\n        if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {\n          return true;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  return false;\n}\n\nfunction lineStringWithinPolygon(line, polygon) {\n  for (var i = 0; i < line.length; ++i) {\n    if (!pointWithinPolygon(line[i], polygon)) {\n      return false;\n    }\n  }\n\n  for (var _i5 = 0; _i5 < line.length - 1; ++_i5) {\n    if (lineIntersectPolygon(line[_i5], line[_i5 + 1], polygon)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction lineStringWithinPolygons(line, polygons) {\n  for (var i = 0; i < polygons.length; i++) {\n    if (lineStringWithinPolygon(line, polygons[i])) return true;\n  }\n\n  return false;\n}\n\nfunction getTilePolygon(coordinates, bbox, canonical) {\n  var polygon = [];\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var ring = [];\n\n    for (var j = 0; j < coordinates[i].length; j++) {\n      var coord = getTileCoordinates(coordinates[i][j], canonical);\n      updateBBox(bbox, coord);\n      ring.push(coord);\n    }\n\n    polygon.push(ring);\n  }\n\n  return polygon;\n}\n\nfunction getTilePolygons(coordinates, bbox, canonical) {\n  var polygons = [];\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var polygon = getTilePolygon(coordinates[i], bbox, canonical);\n    polygons.push(polygon);\n  }\n\n  return polygons;\n}\n\nfunction updatePoint(p, bbox, polyBBox, worldSize) {\n  if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {\n    var halfWorldSize = worldSize * 0.5;\n    var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;\n\n    if (shift === 0) {\n      shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;\n    }\n\n    p[0] += shift;\n  }\n\n  updateBBox(bbox, p);\n}\n\nfunction resetBBox(bbox) {\n  bbox[0] = bbox[1] = Infinity;\n  bbox[2] = bbox[3] = -Infinity;\n}\n\nfunction getTilePoints(geometry, pointBBox, polyBBox, canonical) {\n  var worldSize = Math.pow(2, canonical.z) * EXTENT;\n  var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];\n  var tilePoints = [];\n\n  var _iterator13 = _createForOfIteratorHelper(geometry),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var points = _step13.value;\n\n      var _iterator14 = _createForOfIteratorHelper(points),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var point = _step14.value;\n          var p = [point.x + shifts[0], point.y + shifts[1]];\n          updatePoint(p, pointBBox, polyBBox, worldSize);\n          tilePoints.push(p);\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n\n  return tilePoints;\n}\n\nfunction getTileLines(geometry, lineBBox, polyBBox, canonical) {\n  var worldSize = Math.pow(2, canonical.z) * EXTENT;\n  var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];\n  var tileLines = [];\n\n  var _iterator15 = _createForOfIteratorHelper(geometry),\n      _step15;\n\n  try {\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      var _line = _step15.value;\n      var tileLine = [];\n\n      var _iterator18 = _createForOfIteratorHelper(_line),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var point = _step18.value;\n          var _p = [point.x + shifts[0], point.y + shifts[1]];\n          updateBBox(lineBBox, _p);\n          tileLine.push(_p);\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      tileLines.push(tileLine);\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n\n  if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {\n    resetBBox(lineBBox);\n\n    var _iterator16 = _createForOfIteratorHelper(tileLines),\n        _step16;\n\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var line = _step16.value;\n\n        var _iterator17 = _createForOfIteratorHelper(line),\n            _step17;\n\n        try {\n          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n            var p = _step17.value;\n            updatePoint(p, lineBBox, polyBBox, worldSize);\n          }\n        } catch (err) {\n          _iterator17.e(err);\n        } finally {\n          _iterator17.f();\n        }\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n  }\n\n  return tileLines;\n}\n\nfunction pointsWithinPolygons(ctx, polygonGeometry) {\n  var pointBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var canonical = ctx.canonicalID();\n\n  if (polygonGeometry.type === \'Polygon\') {\n    var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);\n    var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);\n    if (!boxWithinBox(pointBBox, polyBBox)) return false;\n\n    var _iterator19 = _createForOfIteratorHelper(tilePoints),\n        _step19;\n\n    try {\n      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n        var point = _step19.value;\n        if (!pointWithinPolygon(point, tilePolygon)) return false;\n      }\n    } catch (err) {\n      _iterator19.e(err);\n    } finally {\n      _iterator19.f();\n    }\n  }\n\n  if (polygonGeometry.type === \'MultiPolygon\') {\n    var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);\n\n    var _tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);\n\n    if (!boxWithinBox(pointBBox, polyBBox)) return false;\n\n    var _iterator20 = _createForOfIteratorHelper(_tilePoints),\n        _step20;\n\n    try {\n      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n        var _point = _step20.value;\n        if (!pointWithinPolygons(_point, tilePolygons)) return false;\n      }\n    } catch (err) {\n      _iterator20.e(err);\n    } finally {\n      _iterator20.f();\n    }\n  }\n\n  return true;\n}\n\nfunction linesWithinPolygons(ctx, polygonGeometry) {\n  var lineBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var canonical = ctx.canonicalID();\n\n  if (polygonGeometry.type === \'Polygon\') {\n    var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);\n    var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);\n    if (!boxWithinBox(lineBBox, polyBBox)) return false;\n\n    var _iterator21 = _createForOfIteratorHelper(tileLines),\n        _step21;\n\n    try {\n      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n        var line = _step21.value;\n        if (!lineStringWithinPolygon(line, tilePolygon)) return false;\n      }\n    } catch (err) {\n      _iterator21.e(err);\n    } finally {\n      _iterator21.f();\n    }\n  }\n\n  if (polygonGeometry.type === \'MultiPolygon\') {\n    var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);\n\n    var _tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);\n\n    if (!boxWithinBox(lineBBox, polyBBox)) return false;\n\n    var _iterator22 = _createForOfIteratorHelper(_tileLines),\n        _step22;\n\n    try {\n      for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n        var _line2 = _step22.value;\n        if (!lineStringWithinPolygons(_line2, tilePolygons)) return false;\n      }\n    } catch (err) {\n      _iterator22.e(err);\n    } finally {\n      _iterator22.f();\n    }\n  }\n\n  return true;\n}\n\nvar Within = /*#__PURE__*/function () {\n  function Within(geojson, geometries) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Within);\n\n    this.type = BooleanType;\n    this.geojson = geojson;\n    this.geometries = geometries;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Within, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      if (ctx.geometry() != null && ctx.canonicalID() != null) {\n        if (ctx.geometryType() === \'Point\') {\n          return pointsWithinPolygons(ctx, this.geometries);\n        } else if (ctx.geometryType() === \'LineString\') {\n          return linesWithinPolygons(ctx, this.geometries);\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild() {}\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return true;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'within\', this.geojson];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2) return context.error("\'within\' expression requires exactly one argument, but found ".concat(args.length - 1, " instead."));\n\n      if (isValue(args[1])) {\n        var geojson = args[1];\n\n        if (geojson.type === \'FeatureCollection\') {\n          for (var i = 0; i < geojson.features.length; ++i) {\n            var type = geojson.features[i].geometry.type;\n\n            if (type === \'Polygon\' || type === \'MultiPolygon\') {\n              return new Within(geojson, geojson.features[i].geometry);\n            }\n          }\n        } else if (geojson.type === \'Feature\') {\n          var _type2 = geojson.geometry.type;\n\n          if (_type2 === \'Polygon\' || _type2 === \'MultiPolygon\') {\n            return new Within(geojson, geojson.geometry);\n          }\n        } else if (geojson.type === \'Polygon\' || geojson.type === \'MultiPolygon\') {\n          return new Within(geojson, geojson);\n        }\n      }\n\n      return context.error("\'within\' expression requires valid geojson object that contains polygon geometry type.");\n    }\n  }]);\n\n  return Within;\n}();\n\nfunction isFeatureConstant(e) {\n  if (e instanceof CompoundExpression) {\n    if (e.name === \'get\' && e.args.length === 1) {\n      return false;\n    } else if (e.name === \'feature-state\') {\n      return false;\n    } else if (e.name === \'has\' && e.args.length === 1) {\n      return false;\n    } else if (e.name === \'properties\' || e.name === \'geometry-type\' || e.name === \'id\') {\n      return false;\n    } else if (/^filter-/.test(e.name)) {\n      return false;\n    }\n  }\n\n  if (e instanceof Within) {\n    return false;\n  }\n\n  var result = true;\n  e.eachChild(function (arg) {\n    if (result && !isFeatureConstant(arg)) {\n      result = false;\n    }\n  });\n  return result;\n}\n\nfunction isStateConstant(e) {\n  if (e instanceof CompoundExpression) {\n    if (e.name === \'feature-state\') {\n      return false;\n    }\n  }\n\n  var result = true;\n  e.eachChild(function (arg) {\n    if (result && !isStateConstant(arg)) {\n      result = false;\n    }\n  });\n  return result;\n}\n\nfunction isGlobalPropertyConstant(e, properties) {\n  if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {\n    return false;\n  }\n\n  var result = true;\n  e.eachChild(function (arg) {\n    if (result && !isGlobalPropertyConstant(arg, properties)) {\n      result = false;\n    }\n  });\n  return result;\n}\n\nvar Var = /*#__PURE__*/function () {\n  function Var(name, boundExpression) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Var);\n\n    this.type = boundExpression.type;\n    this.name = name;\n    this.boundExpression = boundExpression;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Var, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      return this.boundExpression.evaluate(ctx);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild() {}\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'var\', this.name];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2 || typeof args[1] !== \'string\') return context.error("\'var\' expression requires exactly one string literal argument.");\n      var name = args[1];\n\n      if (!context.scope.has(name)) {\n        return context.error("Unknown variable \\"".concat(name, "\\". Make sure \\"").concat(name, "\\" has been bound in an enclosing \\"let\\" expression before using it."), 1);\n      }\n\n      return new Var(name, context.scope.get(name));\n    }\n  }]);\n\n  return Var;\n}();\n\nvar ParsingContext = /*#__PURE__*/function () {\n  function ParsingContext(registry) {\n    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var expectedType = arguments.length > 2 ? arguments[2] : undefined;\n    var scope = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Scope();\n    var errors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ParsingContext);\n\n    this.registry = registry;\n    this.path = path;\n    this.key = path.map(function (part) {\n      return "[".concat(part, "]");\n    }).join(\'\');\n    this.scope = scope;\n    this.errors = errors;\n    this.expectedType = expectedType;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(ParsingContext, [{\n    key: "parse",\n    value: function parse(expr, index, expectedType, bindings) {\n      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n      if (index) {\n        return this.concat(index, expectedType, bindings)._parse(expr, options);\n      }\n\n      return this._parse(expr, options);\n    }\n  }, {\n    key: "_parse",\n    value: function _parse(expr, options) {\n      if (expr === null || typeof expr === \'string\' || typeof expr === \'boolean\' || typeof expr === \'number\') {\n        expr = [\'literal\', expr];\n      }\n\n      function annotate(parsed, type, typeAnnotation) {\n        if (typeAnnotation === \'assert\') {\n          return new Assertion(type, [parsed]);\n        } else if (typeAnnotation === \'coerce\') {\n          return new Coercion(type, [parsed]);\n        } else {\n          return parsed;\n        }\n      }\n\n      if (Array.isArray(expr)) {\n        if (expr.length === 0) {\n          return this.error("Expected an array with at least one element. If you wanted a literal array, use [\\"literal\\", []].");\n        }\n\n        var op = expr[0];\n\n        if (typeof op !== \'string\') {\n          this.error("Expression name must be a string, but found ".concat(typeof op, " instead. If you wanted a literal array, use [\\"literal\\", [...]]."), 0);\n          return null;\n        }\n\n        var Expr = this.registry[op];\n\n        if (Expr) {\n          var parsed = Expr.parse(expr, this);\n          if (!parsed) return null;\n\n          if (this.expectedType) {\n            var expected = this.expectedType;\n            var actual = parsed.type;\n\n            if ((expected.kind === \'string\' || expected.kind === \'number\' || expected.kind === \'boolean\' || expected.kind === \'object\' || expected.kind === \'array\') && actual.kind === \'value\') {\n              parsed = annotate(parsed, expected, options.typeAnnotation || \'assert\');\n            } else if ((expected.kind === \'color\' || expected.kind === \'formatted\' || expected.kind === \'resolvedImage\') && (actual.kind === \'value\' || actual.kind === \'string\')) {\n              parsed = annotate(parsed, expected, options.typeAnnotation || \'coerce\');\n            } else if (this.checkSubtype(expected, actual)) {\n              return null;\n            }\n          }\n\n          if (!(parsed instanceof Literal) && parsed.type.kind !== \'resolvedImage\' && isConstant(parsed)) {\n            var ec = new EvaluationContext();\n\n            try {\n              parsed = new Literal(parsed.type, parsed.evaluate(ec));\n            } catch (e) {\n              this.error(e.message);\n              return null;\n            }\n          }\n\n          return parsed;\n        }\n\n        return this.error("Unknown expression \\"".concat(op, "\\". If you wanted a literal array, use [\\"literal\\", [...]]."), 0);\n      } else if (typeof expr === \'undefined\') {\n        return this.error("\'undefined\' value invalid. Use null instead.");\n      } else if (typeof expr === \'object\') {\n        return this.error("Bare objects invalid. Use [\\"literal\\", {...}] instead.");\n      } else {\n        return this.error("Expected an array, but found ".concat(typeof expr, " instead."));\n      }\n    }\n  }, {\n    key: "concat",\n    value: function concat(index, expectedType, bindings) {\n      var path = typeof index === \'number\' ? this.path.concat(index) : this.path;\n      var scope = bindings ? this.scope.concat(bindings) : this.scope;\n      return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);\n    }\n  }, {\n    key: "error",\n    value: function error(_error3) {\n      for (var _len2 = arguments.length, keys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key4 = 1; _key4 < _len2; _key4++) {\n        keys[_key4 - 1] = arguments[_key4];\n      }\n\n      var key = "".concat(this.key).concat(keys.map(function (k) {\n        return "[".concat(k, "]");\n      }).join(\'\'));\n      this.errors.push(new ParsingError(key, _error3));\n    }\n  }, {\n    key: "checkSubtype",\n    value: function checkSubtype(expected, t) {\n      var error = _checkSubtype(expected, t);\n\n      if (error) this.error(error);\n      return error;\n    }\n  }]);\n\n  return ParsingContext;\n}();\n\nfunction isConstant(expression) {\n  if (expression instanceof Var) {\n    return isConstant(expression.boundExpression);\n  } else if (expression instanceof CompoundExpression && expression.name === \'error\') {\n    return false;\n  } else if (expression instanceof CollatorExpression) {\n    return false;\n  } else if (expression instanceof Within) {\n    return false;\n  }\n\n  var isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;\n  var childrenConstant = true;\n  expression.eachChild(function (child) {\n    if (isTypeAnnotation) {\n      childrenConstant = childrenConstant && isConstant(child);\n    } else {\n      childrenConstant = childrenConstant && child instanceof Literal;\n    }\n  });\n\n  if (!childrenConstant) {\n    return false;\n  }\n\n  return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, [\'zoom\', \'heatmap-density\', \'line-progress\', \'sky-radial-progress\', \'accumulated\', \'is-supported-script\']);\n}\n\nfunction findStopLessThanOrEqualTo(stops, input) {\n  var lastIndex = stops.length - 1;\n  var lowerIndex = 0;\n  var upperIndex = lastIndex;\n  var currentIndex = 0;\n  var currentValue, nextValue;\n\n  while (lowerIndex <= upperIndex) {\n    currentIndex = Math.floor((lowerIndex + upperIndex) / 2);\n    currentValue = stops[currentIndex];\n    nextValue = stops[currentIndex + 1];\n\n    if (currentValue <= input) {\n      if (currentIndex === lastIndex || input < nextValue) {\n        return currentIndex;\n      }\n\n      lowerIndex = currentIndex + 1;\n    } else if (currentValue > input) {\n      upperIndex = currentIndex - 1;\n    } else {\n      throw new RuntimeError(\'Input is not a number.\');\n    }\n  }\n\n  return 0;\n}\n\nvar Step = /*#__PURE__*/function () {\n  function Step(type, input, stops) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Step);\n\n    this.type = type;\n    this.input = input;\n    this.labels = [];\n    this.outputs = [];\n\n    var _iterator23 = _createForOfIteratorHelper(stops),\n        _step23;\n\n    try {\n      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n        var _step23$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step23.value, 2),\n            label = _step23$value[0],\n            _expression2 = _step23$value[1];\n\n        this.labels.push(label);\n        this.outputs.push(_expression2);\n      }\n    } catch (err) {\n      _iterator23.e(err);\n    } finally {\n      _iterator23.f();\n    }\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Step, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var labels = this.labels;\n      var outputs = this.outputs;\n\n      if (labels.length === 1) {\n        return outputs[0].evaluate(ctx);\n      }\n\n      var value = this.input.evaluate(ctx);\n\n      if (value <= labels[0]) {\n        return outputs[0].evaluate(ctx);\n      }\n\n      var stopCount = labels.length;\n\n      if (value >= labels[stopCount - 1]) {\n        return outputs[stopCount - 1].evaluate(ctx);\n      }\n\n      var index = findStopLessThanOrEqualTo(labels, value);\n      return outputs[index].evaluate(ctx);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n\n      var _iterator24 = _createForOfIteratorHelper(this.outputs),\n          _step24;\n\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var _expression3 = _step24.value;\n          fn(_expression3);\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.outputs.every(function (out) {\n        return out.outputDefined();\n      });\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'step\', this.input.serialize()];\n\n      for (var i = 0; i < this.labels.length; i++) {\n        if (i > 0) {\n          serialized.push(this.labels[i]);\n        }\n\n        serialized.push(this.outputs[i].serialize());\n      }\n\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length - 1 < 4) {\n        return context.error("Expected at least 4 arguments, but found only ".concat(args.length - 1, "."));\n      }\n\n      if ((args.length - 1) % 2 !== 0) {\n        return context.error("Expected an even number of arguments.");\n      }\n\n      var input = context.parse(args[1], 1, NumberType);\n      if (!input) return null;\n      var stops = [];\n      var outputType = null;\n\n      if (context.expectedType && context.expectedType.kind !== \'value\') {\n        outputType = context.expectedType;\n      }\n\n      for (var i = 1; i < args.length; i += 2) {\n        var label = i === 1 ? -Infinity : args[i];\n        var value = args[i + 1];\n        var labelKey = i;\n        var valueKey = i + 1;\n\n        if (typeof label !== \'number\') {\n          return context.error(\'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.\', labelKey);\n        }\n\n        if (stops.length && stops[stops.length - 1][0] >= label) {\n          return context.error(\'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.\', labelKey);\n        }\n\n        var parsed = context.parse(value, valueKey, outputType);\n        if (!parsed) return null;\n        outputType = outputType || parsed.type;\n        stops.push([label, parsed]);\n      }\n\n      return new Step(outputType, input, stops);\n    }\n  }]);\n\n  return Step;\n}();\n/*\n * Copyright (C) 2008 Apple Inc. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS\'\' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Ported from Webkit\n * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h\n */\n\n\nvar unitbezier = UnitBezier;\n\nfunction UnitBezier(p1x, p1y, p2x, p2y) {\n  // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).\n  this.cx = 3.0 * p1x;\n  this.bx = 3.0 * (p2x - p1x) - this.cx;\n  this.ax = 1.0 - this.cx - this.bx;\n  this.cy = 3.0 * p1y;\n  this.by = 3.0 * (p2y - p1y) - this.cy;\n  this.ay = 1.0 - this.cy - this.by;\n  this.p1x = p1x;\n  this.p1y = p2y;\n  this.p2x = p2x;\n  this.p2y = p2y;\n}\n\nUnitBezier.prototype.sampleCurveX = function (t) {\n  // `ax t^3 + bx t^2 + cx t\' expanded using Horner\'s rule.\n  return ((this.ax * t + this.bx) * t + this.cx) * t;\n};\n\nUnitBezier.prototype.sampleCurveY = function (t) {\n  return ((this.ay * t + this.by) * t + this.cy) * t;\n};\n\nUnitBezier.prototype.sampleCurveDerivativeX = function (t) {\n  return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n};\n\nUnitBezier.prototype.solveCurveX = function (x, epsilon) {\n  if (typeof epsilon === \'undefined\') epsilon = 1e-6;\n  var t0, t1, t2, x2, i; // First try a few iterations of Newton\'s method -- normally very fast.\n\n  for (t2 = x, i = 0; i < 8; i++) {\n    x2 = this.sampleCurveX(t2) - x;\n    if (Math.abs(x2) < epsilon) return t2;\n    var d2 = this.sampleCurveDerivativeX(t2);\n    if (Math.abs(d2) < 1e-6) break;\n    t2 = t2 - x2 / d2;\n  } // Fall back to the bisection method for reliability.\n\n\n  t0 = 0.0;\n  t1 = 1.0;\n  t2 = x;\n  if (t2 < t0) return t0;\n  if (t2 > t1) return t1;\n\n  while (t0 < t1) {\n    x2 = this.sampleCurveX(t2);\n    if (Math.abs(x2 - x) < epsilon) return t2;\n\n    if (x > x2) {\n      t0 = t2;\n    } else {\n      t1 = t2;\n    }\n\n    t2 = (t1 - t0) * 0.5 + t0;\n  } // Failure.\n\n\n  return t2;\n};\n\nUnitBezier.prototype.solve = function (x, epsilon) {\n  return this.sampleCurveY(this.solveCurveX(x, epsilon));\n};\n\nfunction number(a, b, t) {\n  return a * (1 - t) + b * t;\n}\n\nfunction color(from, to, t) {\n  return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));\n}\n\nfunction array$1(from, to, t) {\n  return from.map(function (d, i) {\n    return number(d, to[i], t);\n  });\n}\n\nvar interpolate = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  number: number,\n  color: color,\n  array: array$1\n});\nvar Xn = 0.95047,\n    Yn = 1,\n    Zn = 1.08883,\n    t0 = 4 / 29,\n    t1 = 6 / 29,\n    t2 = 3 * t1 * t1,\n    t3 = t1 * t1 * t1,\n    deg2rad = Math.PI / 180,\n    rad2deg = 180 / Math.PI;\n\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\n\nfunction lab2xyz(t) {\n  return t > t1 ? t * t * t : t2 * (t - t0);\n}\n\nfunction xyz2rgb(x) {\n  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\n\nfunction rgb2xyz(x) {\n  x /= 255;\n  return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n\nfunction rgbToLab(rgbColor) {\n  var b = rgb2xyz(rgbColor.r),\n      a = rgb2xyz(rgbColor.g),\n      l = rgb2xyz(rgbColor.b),\n      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),\n      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn),\n      z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);\n  return {\n    l: 116 * y - 16,\n    a: 500 * (x - y),\n    b: 200 * (y - z),\n    alpha: rgbColor.a\n  };\n}\n\nfunction labToRgb(labColor) {\n  var y = (labColor.l + 16) / 116,\n      x = isNaN(labColor.a) ? y : y + labColor.a / 500,\n      z = isNaN(labColor.b) ? y : y - labColor.b / 200;\n  y = Yn * lab2xyz(y);\n  x = Xn * lab2xyz(x);\n  z = Zn * lab2xyz(z);\n  return new Color(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);\n}\n\nfunction interpolateLab(from, to, t) {\n  return {\n    l: number(from.l, to.l, t),\n    a: number(from.a, to.a, t),\n    b: number(from.b, to.b, t),\n    alpha: number(from.alpha, to.alpha, t)\n  };\n}\n\nfunction rgbToHcl(rgbColor) {\n  var _rgbToLab = rgbToLab(rgbColor),\n      l = _rgbToLab.l,\n      a = _rgbToLab.a,\n      b = _rgbToLab.b;\n\n  var h = Math.atan2(b, a) * rad2deg;\n  return {\n    h: h < 0 ? h + 360 : h,\n    c: Math.sqrt(a * a + b * b),\n    l: l,\n    alpha: rgbColor.a\n  };\n}\n\nfunction hclToRgb(hclColor) {\n  var h = hclColor.h * deg2rad,\n      c = hclColor.c,\n      l = hclColor.l;\n  return labToRgb({\n    l: l,\n    a: Math.cos(h) * c,\n    b: Math.sin(h) * c,\n    alpha: hclColor.alpha\n  });\n}\n\nfunction interpolateHue(a, b, t) {\n  var d = b - a;\n  return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);\n}\n\nfunction interpolateHcl(from, to, t) {\n  return {\n    h: interpolateHue(from.h, to.h, t),\n    c: number(from.c, to.c, t),\n    l: number(from.l, to.l, t),\n    alpha: number(from.alpha, to.alpha, t)\n  };\n}\n\nvar lab = {\n  forward: rgbToLab,\n  reverse: labToRgb,\n  interpolate: interpolateLab\n};\nvar hcl = {\n  forward: rgbToHcl,\n  reverse: hclToRgb,\n  interpolate: interpolateHcl\n};\nvar colorSpaces = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  lab: lab,\n  hcl: hcl\n});\n\nvar Interpolate = /*#__PURE__*/function () {\n  function Interpolate(type, operator, interpolation, input, stops) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Interpolate);\n\n    this.type = type;\n    this.operator = operator;\n    this.interpolation = interpolation;\n    this.input = input;\n    this.labels = [];\n    this.outputs = [];\n\n    var _iterator25 = _createForOfIteratorHelper(stops),\n        _step25;\n\n    try {\n      for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n        var _step25$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step25.value, 2),\n            label = _step25$value[0],\n            _expression4 = _step25$value[1];\n\n        this.labels.push(label);\n        this.outputs.push(_expression4);\n      }\n    } catch (err) {\n      _iterator25.e(err);\n    } finally {\n      _iterator25.f();\n    }\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Interpolate, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var labels = this.labels;\n      var outputs = this.outputs;\n\n      if (labels.length === 1) {\n        return outputs[0].evaluate(ctx);\n      }\n\n      var value = this.input.evaluate(ctx);\n\n      if (value <= labels[0]) {\n        return outputs[0].evaluate(ctx);\n      }\n\n      var stopCount = labels.length;\n\n      if (value >= labels[stopCount - 1]) {\n        return outputs[stopCount - 1].evaluate(ctx);\n      }\n\n      var index = findStopLessThanOrEqualTo(labels, value);\n      var lower = labels[index];\n      var upper = labels[index + 1];\n      var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);\n      var outputLower = outputs[index].evaluate(ctx);\n      var outputUpper = outputs[index + 1].evaluate(ctx);\n\n      if (this.operator === \'interpolate\') {\n        return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);\n      } else if (this.operator === \'interpolate-hcl\') {\n        return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));\n      } else {\n        return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));\n      }\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n\n      var _iterator26 = _createForOfIteratorHelper(this.outputs),\n          _step26;\n\n      try {\n        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n          var _expression5 = _step26.value;\n          fn(_expression5);\n        }\n      } catch (err) {\n        _iterator26.e(err);\n      } finally {\n        _iterator26.f();\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.outputs.every(function (out) {\n        return out.outputDefined();\n      });\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var interpolation;\n\n      if (this.interpolation.name === \'linear\') {\n        interpolation = [\'linear\'];\n      } else if (this.interpolation.name === \'exponential\') {\n        if (this.interpolation.base === 1) {\n          interpolation = [\'linear\'];\n        } else {\n          interpolation = [\'exponential\', this.interpolation.base];\n        }\n      } else {\n        interpolation = [\'cubic-bezier\'].concat(this.interpolation.controlPoints);\n      }\n\n      var serialized = [this.operator, interpolation, this.input.serialize()];\n\n      for (var i = 0; i < this.labels.length; i++) {\n        serialized.push(this.labels[i], this.outputs[i].serialize());\n      }\n\n      return serialized;\n    }\n  }], [{\n    key: "interpolationFactor",\n    value: function interpolationFactor(interpolation, input, lower, upper) {\n      var t = 0;\n\n      if (interpolation.name === \'exponential\') {\n        t = exponentialInterpolation(input, interpolation.base, lower, upper);\n      } else if (interpolation.name === \'linear\') {\n        t = exponentialInterpolation(input, 1, lower, upper);\n      } else if (interpolation.name === \'cubic-bezier\') {\n        var c = interpolation.controlPoints;\n        var ub = new unitbezier(c[0], c[1], c[2], c[3]);\n        t = ub.solve(exponentialInterpolation(input, 1, lower, upper));\n      }\n\n      return t;\n    }\n  }, {\n    key: "parse",\n    value: function parse(args, context) {\n      var _args = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toArray__WEBPACK_IMPORTED_MODULE_8__/* .default */ .Z)(args),\n          operator = _args[0],\n          interpolation = _args[1],\n          input = _args[2],\n          rest = _args.slice(3);\n\n      if (!Array.isArray(interpolation) || interpolation.length === 0) {\n        return context.error("Expected an interpolation type expression.", 1);\n      }\n\n      if (interpolation[0] === \'linear\') {\n        interpolation = {\n          name: \'linear\'\n        };\n      } else if (interpolation[0] === \'exponential\') {\n        var base = interpolation[1];\n        if (typeof base !== \'number\') return context.error("Exponential interpolation requires a numeric base.", 1, 1);\n        interpolation = {\n          name: \'exponential\',\n          base: base\n        };\n      } else if (interpolation[0] === \'cubic-bezier\') {\n        var controlPoints = interpolation.slice(1);\n\n        if (controlPoints.length !== 4 || controlPoints.some(function (t) {\n          return typeof t !== \'number\' || t < 0 || t > 1;\n        })) {\n          return context.error(\'Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\', 1);\n        }\n\n        interpolation = {\n          name: \'cubic-bezier\',\n          controlPoints: controlPoints\n        };\n      } else {\n        return context.error("Unknown interpolation type ".concat(String(interpolation[0])), 1, 0);\n      }\n\n      if (args.length - 1 < 4) {\n        return context.error("Expected at least 4 arguments, but found only ".concat(args.length - 1, "."));\n      }\n\n      if ((args.length - 1) % 2 !== 0) {\n        return context.error("Expected an even number of arguments.");\n      }\n\n      input = context.parse(input, 2, NumberType);\n      if (!input) return null;\n      var stops = [];\n      var outputType = null;\n\n      if (operator === \'interpolate-hcl\' || operator === \'interpolate-lab\') {\n        outputType = ColorType;\n      } else if (context.expectedType && context.expectedType.kind !== \'value\') {\n        outputType = context.expectedType;\n      }\n\n      for (var i = 0; i < rest.length; i += 2) {\n        var label = rest[i];\n        var value = rest[i + 1];\n        var labelKey = i + 3;\n        var valueKey = i + 4;\n\n        if (typeof label !== \'number\') {\n          return context.error(\'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.\', labelKey);\n        }\n\n        if (stops.length && stops[stops.length - 1][0] >= label) {\n          return context.error(\'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.\', labelKey);\n        }\n\n        var parsed = context.parse(value, valueKey, outputType);\n        if (!parsed) return null;\n        outputType = outputType || parsed.type;\n        stops.push([label, parsed]);\n      }\n\n      if (outputType.kind !== \'number\' && outputType.kind !== \'color\' && !(outputType.kind === \'array\' && outputType.itemType.kind === \'number\' && typeof outputType.N === \'number\')) {\n        return context.error("Type ".concat(toString(outputType), " is not interpolatable."));\n      }\n\n      return new Interpolate(outputType, operator, interpolation, input, stops);\n    }\n  }]);\n\n  return Interpolate;\n}();\n\nfunction exponentialInterpolation(input, base, lowerValue, upperValue) {\n  var difference = upperValue - lowerValue;\n  var progress = input - lowerValue;\n\n  if (difference === 0) {\n    return 0;\n  } else if (base === 1) {\n    return progress / difference;\n  } else {\n    return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n  }\n}\n\nvar Coalesce = /*#__PURE__*/function () {\n  function Coalesce(type, args) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Coalesce);\n\n    this.type = type;\n    this.args = args;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Coalesce, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var result = null;\n      var argCount = 0;\n      var requestedImageName;\n\n      var _iterator27 = _createForOfIteratorHelper(this.args),\n          _step27;\n\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var arg = _step27.value;\n          argCount++;\n          result = arg.evaluate(ctx);\n\n          if (result && result instanceof ResolvedImage && !result.available) {\n            if (!requestedImageName) {\n              requestedImageName = result.name;\n            }\n\n            result = null;\n\n            if (argCount === this.args.length) {\n              result = requestedImageName;\n            }\n          }\n\n          if (result !== null) break;\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      this.args.forEach(fn);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.args.every(function (arg) {\n        return arg.outputDefined();\n      });\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'coalesce\'];\n      this.eachChild(function (child) {\n        serialized.push(child.serialize());\n      });\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 2) {\n        return context.error(\'Expectected at least one argument.\');\n      }\n\n      var outputType = null;\n      var expectedType = context.expectedType;\n\n      if (expectedType && expectedType.kind !== \'value\') {\n        outputType = expectedType;\n      }\n\n      var parsedArgs = [];\n\n      var _iterator28 = _createForOfIteratorHelper(args.slice(1)),\n          _step28;\n\n      try {\n        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n          var arg = _step28.value;\n          var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, {\n            typeAnnotation: \'omit\'\n          });\n          if (!parsed) return null;\n          outputType = outputType || parsed.type;\n          parsedArgs.push(parsed);\n        }\n      } catch (err) {\n        _iterator28.e(err);\n      } finally {\n        _iterator28.f();\n      }\n\n      var needsAnnotation = expectedType && parsedArgs.some(function (arg) {\n        return _checkSubtype(expectedType, arg.type);\n      });\n      return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);\n    }\n  }]);\n\n  return Coalesce;\n}();\n\nvar Let = /*#__PURE__*/function () {\n  function Let(bindings, result) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Let);\n\n    this.type = result.type;\n    this.bindings = [].concat(bindings);\n    this.result = result;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Let, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      return this.result.evaluate(ctx);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      var _iterator29 = _createForOfIteratorHelper(this.bindings),\n          _step29;\n\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var binding = _step29.value;\n          fn(binding[1]);\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n\n      fn(this.result);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.result.outputDefined();\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'let\'];\n\n      var _iterator30 = _createForOfIteratorHelper(this.bindings),\n          _step30;\n\n      try {\n        for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n          var _step30$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step30.value, 2),\n              name = _step30$value[0],\n              expr = _step30$value[1];\n\n          serialized.push(name, expr.serialize());\n        }\n      } catch (err) {\n        _iterator30.e(err);\n      } finally {\n        _iterator30.f();\n      }\n\n      serialized.push(this.result.serialize());\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 4) return context.error("Expected at least 3 arguments, but found ".concat(args.length - 1, " instead."));\n      var bindings = [];\n\n      for (var i = 1; i < args.length - 1; i += 2) {\n        var name = args[i];\n\n        if (typeof name !== \'string\') {\n          return context.error("Expected string, but found ".concat(typeof name, " instead."), i);\n        }\n\n        if (/[^a-zA-Z0-9_]/.test(name)) {\n          return context.error("Variable names must contain only alphanumeric characters or \'_\'.", i);\n        }\n\n        var value = context.parse(args[i + 1], i + 1);\n        if (!value) return null;\n        bindings.push([name, value]);\n      }\n\n      var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);\n      if (!result) return null;\n      return new Let(bindings, result);\n    }\n  }]);\n\n  return Let;\n}();\n\nvar At = /*#__PURE__*/function () {\n  function At(type, index, input) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, At);\n\n    this.type = type;\n    this.index = index;\n    this.input = input;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(At, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var index = this.index.evaluate(ctx);\n      var array = this.input.evaluate(ctx);\n\n      if (index < 0) {\n        throw new RuntimeError("Array index out of bounds: ".concat(index, " < 0."));\n      }\n\n      if (index >= array.length) {\n        throw new RuntimeError("Array index out of bounds: ".concat(index, " > ").concat(array.length - 1, "."));\n      }\n\n      if (index !== Math.floor(index)) {\n        throw new RuntimeError("Array index must be an integer, but found ".concat(index, " instead."));\n      }\n\n      return array[index];\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.index);\n      fn(this.input);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'at\', this.index.serialize(), this.input.serialize()];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 3) return context.error("Expected 2 arguments, but found ".concat(args.length - 1, " instead."));\n      var index = context.parse(args[1], 1, NumberType);\n      var input = context.parse(args[2], 2, array(context.expectedType || ValueType));\n      if (!index || !input) return null;\n      var t = input.type;\n      return new At(t.itemType, index, input);\n    }\n  }]);\n\n  return At;\n}();\n\nvar In = /*#__PURE__*/function () {\n  function In(needle, haystack) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, In);\n\n    this.type = BooleanType;\n    this.needle = needle;\n    this.haystack = haystack;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(In, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var needle = this.needle.evaluate(ctx);\n      var haystack = this.haystack.evaluate(ctx);\n      if (!haystack) return false;\n\n      if (!isValidNativeType(needle, [\'boolean\', \'string\', \'number\', \'null\'])) {\n        throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(typeOf(needle)), " instead."));\n      }\n\n      if (!isValidNativeType(haystack, [\'string\', \'array\'])) {\n        throw new RuntimeError("Expected second argument to be of type array or string, but found ".concat(toString(typeOf(haystack)), " instead."));\n      }\n\n      return haystack.indexOf(needle) >= 0;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.needle);\n      fn(this.haystack);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return true;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'in\', this.needle.serialize(), this.haystack.serialize()];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 3) {\n        return context.error("Expected 2 arguments, but found ".concat(args.length - 1, " instead."));\n      }\n\n      var needle = context.parse(args[1], 1, ValueType);\n      var haystack = context.parse(args[2], 2, ValueType);\n      if (!needle || !haystack) return null;\n\n      if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {\n        return context.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(needle.type), " instead"));\n      }\n\n      return new In(needle, haystack);\n    }\n  }]);\n\n  return In;\n}();\n\nvar IndexOf = /*#__PURE__*/function () {\n  function IndexOf(needle, haystack, fromIndex) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, IndexOf);\n\n    this.type = NumberType;\n    this.needle = needle;\n    this.haystack = haystack;\n    this.fromIndex = fromIndex;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(IndexOf, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var needle = this.needle.evaluate(ctx);\n      var haystack = this.haystack.evaluate(ctx);\n\n      if (!isValidNativeType(needle, [\'boolean\', \'string\', \'number\', \'null\'])) {\n        throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(typeOf(needle)), " instead."));\n      }\n\n      if (!isValidNativeType(haystack, [\'string\', \'array\'])) {\n        throw new RuntimeError("Expected second argument to be of type array or string, but found ".concat(toString(typeOf(haystack)), " instead."));\n      }\n\n      if (this.fromIndex) {\n        var fromIndex = this.fromIndex.evaluate(ctx);\n        return haystack.indexOf(needle, fromIndex);\n      }\n\n      return haystack.indexOf(needle);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.needle);\n      fn(this.haystack);\n\n      if (this.fromIndex) {\n        fn(this.fromIndex);\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      if (this.fromIndex != null && this.fromIndex !== undefined) {\n        var fromIndex = this.fromIndex.serialize();\n        return [\'index-of\', this.needle.serialize(), this.haystack.serialize(), fromIndex];\n      }\n\n      return [\'index-of\', this.needle.serialize(), this.haystack.serialize()];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length <= 2 || args.length >= 5) {\n        return context.error("Expected 3 or 4 arguments, but found ".concat(args.length - 1, " instead."));\n      }\n\n      var needle = context.parse(args[1], 1, ValueType);\n      var haystack = context.parse(args[2], 2, ValueType);\n      if (!needle || !haystack) return null;\n\n      if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {\n        return context.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(needle.type), " instead"));\n      }\n\n      if (args.length === 4) {\n        var fromIndex = context.parse(args[3], 3, NumberType);\n        if (!fromIndex) return null;\n        return new IndexOf(needle, haystack, fromIndex);\n      } else {\n        return new IndexOf(needle, haystack);\n      }\n    }\n  }]);\n\n  return IndexOf;\n}();\n\nvar Match = /*#__PURE__*/function () {\n  function Match(inputType, outputType, input, cases, outputs, otherwise) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Match);\n\n    this.inputType = inputType;\n    this.type = outputType;\n    this.input = input;\n    this.cases = cases;\n    this.outputs = outputs;\n    this.otherwise = otherwise;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Match, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var input = this.input.evaluate(ctx);\n      var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;\n      return output.evaluate(ctx);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n      this.outputs.forEach(fn);\n      fn(this.otherwise);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.outputs.every(function (out) {\n        return out.outputDefined();\n      }) && this.otherwise.outputDefined();\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var _this2 = this;\n\n      var serialized = [\'match\', this.input.serialize()];\n      var sortedLabels = Object.keys(this.cases).sort();\n      var groupedByOutput = [];\n      var outputLookup = {};\n\n      var _iterator31 = _createForOfIteratorHelper(sortedLabels),\n          _step31;\n\n      try {\n        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n          var label = _step31.value;\n          var _outputIndex = outputLookup[this.cases[label]];\n\n          if (_outputIndex === undefined) {\n            outputLookup[this.cases[label]] = groupedByOutput.length;\n            groupedByOutput.push([this.cases[label], [label]]);\n          } else {\n            groupedByOutput[_outputIndex][1].push(label);\n          }\n        }\n      } catch (err) {\n        _iterator31.e(err);\n      } finally {\n        _iterator31.f();\n      }\n\n      var coerceLabel = function coerceLabel(label) {\n        return _this2.inputType.kind === \'number\' ? Number(label) : label;\n      };\n\n      for (var _i6 = 0, _groupedByOutput = groupedByOutput; _i6 < _groupedByOutput.length; _i6++) {\n        var _groupedByOutput$_i = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_groupedByOutput[_i6], 2),\n            outputIndex = _groupedByOutput$_i[0],\n            labels = _groupedByOutput$_i[1];\n\n        if (labels.length === 1) {\n          serialized.push(coerceLabel(labels[0]));\n        } else {\n          serialized.push(labels.map(coerceLabel));\n        }\n\n        serialized.push(this.outputs[outputIndex].serialize());\n      }\n\n      serialized.push(this.otherwise.serialize());\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 5) return context.error("Expected at least 4 arguments, but found only ".concat(args.length - 1, "."));\n      if (args.length % 2 !== 1) return context.error("Expected an even number of arguments.");\n      var inputType;\n      var outputType;\n\n      if (context.expectedType && context.expectedType.kind !== \'value\') {\n        outputType = context.expectedType;\n      }\n\n      var cases = {};\n      var outputs = [];\n\n      for (var i = 2; i < args.length - 1; i += 2) {\n        var labels = args[i];\n        var value = args[i + 1];\n\n        if (!Array.isArray(labels)) {\n          labels = [labels];\n        }\n\n        var labelContext = context.concat(i);\n\n        if (labels.length === 0) {\n          return labelContext.error(\'Expected at least one branch label.\');\n        }\n\n        var _iterator32 = _createForOfIteratorHelper(labels),\n            _step32;\n\n        try {\n          for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n            var label = _step32.value;\n\n            if (typeof label !== \'number\' && typeof label !== \'string\') {\n              return labelContext.error("Branch labels must be numbers or strings.");\n            } else if (typeof label === \'number\' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {\n              return labelContext.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER, "."));\n            } else if (typeof label === \'number\' && Math.floor(label) !== label) {\n              return labelContext.error("Numeric branch labels must be integer values.");\n            } else if (!inputType) {\n              inputType = typeOf(label);\n            } else if (labelContext.checkSubtype(inputType, typeOf(label))) {\n              return null;\n            }\n\n            if (typeof cases[String(label)] !== \'undefined\') {\n              return labelContext.error(\'Branch labels must be unique.\');\n            }\n\n            cases[String(label)] = outputs.length;\n          }\n        } catch (err) {\n          _iterator32.e(err);\n        } finally {\n          _iterator32.f();\n        }\n\n        var result = context.parse(value, i, outputType);\n        if (!result) return null;\n        outputType = outputType || result.type;\n        outputs.push(result);\n      }\n\n      var input = context.parse(args[1], 1, ValueType);\n      if (!input) return null;\n      var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n      if (!otherwise) return null;\n\n      if (input.type.kind !== \'value\' && context.concat(1).checkSubtype(inputType, input.type)) {\n        return null;\n      }\n\n      return new Match(inputType, outputType, input, cases, outputs, otherwise);\n    }\n  }]);\n\n  return Match;\n}();\n\nvar Case = /*#__PURE__*/function () {\n  function Case(type, branches, otherwise) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Case);\n\n    this.type = type;\n    this.branches = branches;\n    this.otherwise = otherwise;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Case, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var _iterator33 = _createForOfIteratorHelper(this.branches),\n          _step33;\n\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var _step33$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step33.value, 2),\n              test = _step33$value[0],\n              _expression6 = _step33$value[1];\n\n          if (test.evaluate(ctx)) {\n            return _expression6.evaluate(ctx);\n          }\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n\n      return this.otherwise.evaluate(ctx);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      var _iterator34 = _createForOfIteratorHelper(this.branches),\n          _step34;\n\n      try {\n        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n          var _step34$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step34.value, 2),\n              test = _step34$value[0],\n              _expression7 = _step34$value[1];\n\n          fn(test);\n          fn(_expression7);\n        }\n      } catch (err) {\n        _iterator34.e(err);\n      } finally {\n        _iterator34.f();\n      }\n\n      fn(this.otherwise);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.branches.every(function (_ref5) {\n        var _ref6 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref5, 2),\n            _ = _ref6[0],\n            out = _ref6[1];\n\n        return out.outputDefined();\n      }) && this.otherwise.outputDefined();\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'case\'];\n      this.eachChild(function (child) {\n        serialized.push(child.serialize());\n      });\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 4) return context.error("Expected at least 3 arguments, but found only ".concat(args.length - 1, "."));\n      if (args.length % 2 !== 0) return context.error("Expected an odd number of arguments.");\n      var outputType;\n\n      if (context.expectedType && context.expectedType.kind !== \'value\') {\n        outputType = context.expectedType;\n      }\n\n      var branches = [];\n\n      for (var i = 1; i < args.length - 1; i += 2) {\n        var test = context.parse(args[i], i, BooleanType);\n        if (!test) return null;\n        var result = context.parse(args[i + 1], i + 1, outputType);\n        if (!result) return null;\n        branches.push([test, result]);\n        outputType = outputType || result.type;\n      }\n\n      var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n      if (!otherwise) return null;\n      return new Case(outputType, branches, otherwise);\n    }\n  }]);\n\n  return Case;\n}();\n\nvar Slice = /*#__PURE__*/function () {\n  function Slice(type, input, beginIndex, endIndex) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Slice);\n\n    this.type = type;\n    this.input = input;\n    this.beginIndex = beginIndex;\n    this.endIndex = endIndex;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Slice, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var input = this.input.evaluate(ctx);\n      var beginIndex = this.beginIndex.evaluate(ctx);\n\n      if (!isValidNativeType(input, [\'string\', \'array\'])) {\n        throw new RuntimeError("Expected first argument to be of type array or string, but found ".concat(toString(typeOf(input)), " instead."));\n      }\n\n      if (this.endIndex) {\n        var endIndex = this.endIndex.evaluate(ctx);\n        return input.slice(beginIndex, endIndex);\n      }\n\n      return input.slice(beginIndex);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n      fn(this.beginIndex);\n\n      if (this.endIndex) {\n        fn(this.endIndex);\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      if (this.endIndex != null && this.endIndex !== undefined) {\n        var endIndex = this.endIndex.serialize();\n        return [\'slice\', this.input.serialize(), this.beginIndex.serialize(), endIndex];\n      }\n\n      return [\'slice\', this.input.serialize(), this.beginIndex.serialize()];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length <= 2 || args.length >= 5) {\n        return context.error("Expected 3 or 4 arguments, but found ".concat(args.length - 1, " instead."));\n      }\n\n      var input = context.parse(args[1], 1, ValueType);\n      var beginIndex = context.parse(args[2], 2, NumberType);\n      if (!input || !beginIndex) return null;\n\n      if (!isValidType(input.type, [array(ValueType), StringType, ValueType])) {\n        return context.error("Expected first argument to be of type array or string, but found ".concat(toString(input.type), " instead"));\n      }\n\n      if (args.length === 4) {\n        var endIndex = context.parse(args[3], 3, NumberType);\n        if (!endIndex) return null;\n        return new Slice(input.type, input, beginIndex, endIndex);\n      } else {\n        return new Slice(input.type, input, beginIndex);\n      }\n    }\n  }]);\n\n  return Slice;\n}();\n\nfunction isComparableType(op, type) {\n  if (op === \'==\' || op === \'!=\') {\n    return type.kind === \'boolean\' || type.kind === \'string\' || type.kind === \'number\' || type.kind === \'null\' || type.kind === \'value\';\n  } else {\n    return type.kind === \'string\' || type.kind === \'number\' || type.kind === \'value\';\n  }\n}\n\nfunction eq(ctx, a, b) {\n  return a === b;\n}\n\nfunction neq(ctx, a, b) {\n  return a !== b;\n}\n\nfunction lt(ctx, a, b) {\n  return a < b;\n}\n\nfunction gt(ctx, a, b) {\n  return a > b;\n}\n\nfunction lteq(ctx, a, b) {\n  return a <= b;\n}\n\nfunction gteq(ctx, a, b) {\n  return a >= b;\n}\n\nfunction eqCollate(ctx, a, b, c) {\n  return c.compare(a, b) === 0;\n}\n\nfunction neqCollate(ctx, a, b, c) {\n  return !eqCollate(ctx, a, b, c);\n}\n\nfunction ltCollate(ctx, a, b, c) {\n  return c.compare(a, b) < 0;\n}\n\nfunction gtCollate(ctx, a, b, c) {\n  return c.compare(a, b) > 0;\n}\n\nfunction lteqCollate(ctx, a, b, c) {\n  return c.compare(a, b) <= 0;\n}\n\nfunction gteqCollate(ctx, a, b, c) {\n  return c.compare(a, b) >= 0;\n}\n\nfunction makeComparison(op, compareBasic, compareWithCollator) {\n  var isOrderComparison = op !== \'==\' && op !== \'!=\';\n  return /*#__PURE__*/function () {\n    function Comparison(lhs, rhs, collator) {\n      (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Comparison);\n\n      this.type = BooleanType;\n      this.lhs = lhs;\n      this.rhs = rhs;\n      this.collator = collator;\n      this.hasUntypedArgument = lhs.type.kind === \'value\' || rhs.type.kind === \'value\';\n    }\n\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Comparison, [{\n      key: "evaluate",\n      value: function evaluate(ctx) {\n        var lhs = this.lhs.evaluate(ctx);\n        var rhs = this.rhs.evaluate(ctx);\n\n        if (isOrderComparison && this.hasUntypedArgument) {\n          var _lt = typeOf(lhs);\n\n          var rt = typeOf(rhs);\n\n          if (_lt.kind !== rt.kind || !(_lt.kind === \'string\' || _lt.kind === \'number\')) {\n            throw new RuntimeError("Expected arguments for \\"".concat(op, "\\" to be (string, string) or (number, number), but found (").concat(_lt.kind, ", ").concat(rt.kind, ") instead."));\n          }\n        }\n\n        if (this.collator && !isOrderComparison && this.hasUntypedArgument) {\n          var _lt2 = typeOf(lhs);\n\n          var _rt = typeOf(rhs);\n\n          if (_lt2.kind !== \'string\' || _rt.kind !== \'string\') {\n            return compareBasic(ctx, lhs, rhs);\n          }\n        }\n\n        return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);\n      }\n    }, {\n      key: "eachChild",\n      value: function eachChild(fn) {\n        fn(this.lhs);\n        fn(this.rhs);\n\n        if (this.collator) {\n          fn(this.collator);\n        }\n      }\n    }, {\n      key: "outputDefined",\n      value: function outputDefined() {\n        return true;\n      }\n    }, {\n      key: "serialize",\n      value: function serialize() {\n        var serialized = [op];\n        this.eachChild(function (child) {\n          serialized.push(child.serialize());\n        });\n        return serialized;\n      }\n    }], [{\n      key: "parse",\n      value: function parse(args, context) {\n        if (args.length !== 3 && args.length !== 4) return context.error("Expected two or three arguments.");\n        var op = args[0];\n        var lhs = context.parse(args[1], 1, ValueType);\n        if (!lhs) return null;\n\n        if (!isComparableType(op, lhs.type)) {\n          return context.concat(1).error("\\"".concat(op, "\\" comparisons are not supported for type \'").concat(toString(lhs.type), "\'."));\n        }\n\n        var rhs = context.parse(args[2], 2, ValueType);\n        if (!rhs) return null;\n\n        if (!isComparableType(op, rhs.type)) {\n          return context.concat(2).error("\\"".concat(op, "\\" comparisons are not supported for type \'").concat(toString(rhs.type), "\'."));\n        }\n\n        if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== \'value\' && rhs.type.kind !== \'value\') {\n          return context.error("Cannot compare types \'".concat(toString(lhs.type), "\' and \'").concat(toString(rhs.type), "\'."));\n        }\n\n        if (isOrderComparison) {\n          if (lhs.type.kind === \'value\' && rhs.type.kind !== \'value\') {\n            lhs = new Assertion(rhs.type, [lhs]);\n          } else if (lhs.type.kind !== \'value\' && rhs.type.kind === \'value\') {\n            rhs = new Assertion(lhs.type, [rhs]);\n          }\n        }\n\n        var collator = null;\n\n        if (args.length === 4) {\n          if (lhs.type.kind !== \'string\' && rhs.type.kind !== \'string\' && lhs.type.kind !== \'value\' && rhs.type.kind !== \'value\') {\n            return context.error("Cannot use collator to compare non-string types.");\n          }\n\n          collator = context.parse(args[3], 3, CollatorType);\n          if (!collator) return null;\n        }\n\n        return new Comparison(lhs, rhs, collator);\n      }\n    }]);\n\n    return Comparison;\n  }();\n}\n\nvar Equals = makeComparison(\'==\', eq, eqCollate);\nvar NotEquals = makeComparison(\'!=\', neq, neqCollate);\nvar LessThan = makeComparison(\'<\', lt, ltCollate);\nvar GreaterThan = makeComparison(\'>\', gt, gtCollate);\nvar LessThanOrEqual = makeComparison(\'<=\', lteq, lteqCollate);\nvar GreaterThanOrEqual = makeComparison(\'>=\', gteq, gteqCollate);\n\nvar NumberFormat = /*#__PURE__*/function () {\n  function NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, NumberFormat);\n\n    this.type = StringType;\n    this.number = number;\n    this.locale = locale;\n    this.currency = currency;\n    this.minFractionDigits = minFractionDigits;\n    this.maxFractionDigits = maxFractionDigits;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(NumberFormat, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {\n        style: this.currency ? \'currency\' : \'decimal\',\n        currency: this.currency ? this.currency.evaluate(ctx) : undefined,\n        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,\n        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined\n      }).format(this.number.evaluate(ctx));\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.number);\n\n      if (this.locale) {\n        fn(this.locale);\n      }\n\n      if (this.currency) {\n        fn(this.currency);\n      }\n\n      if (this.minFractionDigits) {\n        fn(this.minFractionDigits);\n      }\n\n      if (this.maxFractionDigits) {\n        fn(this.maxFractionDigits);\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var options = {};\n\n      if (this.locale) {\n        options[\'locale\'] = this.locale.serialize();\n      }\n\n      if (this.currency) {\n        options[\'currency\'] = this.currency.serialize();\n      }\n\n      if (this.minFractionDigits) {\n        options[\'min-fraction-digits\'] = this.minFractionDigits.serialize();\n      }\n\n      if (this.maxFractionDigits) {\n        options[\'max-fraction-digits\'] = this.maxFractionDigits.serialize();\n      }\n\n      return [\'number-format\', this.number.serialize(), options];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 3) return context.error("Expected two arguments.");\n      var number = context.parse(args[1], 1, NumberType);\n      if (!number) return null;\n      var options = args[2];\n      if (typeof options !== \'object\' || Array.isArray(options)) return context.error("NumberFormat options argument must be an object.");\n      var locale = null;\n\n      if (options[\'locale\']) {\n        locale = context.parse(options[\'locale\'], 1, StringType);\n        if (!locale) return null;\n      }\n\n      var currency = null;\n\n      if (options[\'currency\']) {\n        currency = context.parse(options[\'currency\'], 1, StringType);\n        if (!currency) return null;\n      }\n\n      var minFractionDigits = null;\n\n      if (options[\'min-fraction-digits\']) {\n        minFractionDigits = context.parse(options[\'min-fraction-digits\'], 1, NumberType);\n        if (!minFractionDigits) return null;\n      }\n\n      var maxFractionDigits = null;\n\n      if (options[\'max-fraction-digits\']) {\n        maxFractionDigits = context.parse(options[\'max-fraction-digits\'], 1, NumberType);\n        if (!maxFractionDigits) return null;\n      }\n\n      return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);\n    }\n  }]);\n\n  return NumberFormat;\n}();\n\nvar Length = /*#__PURE__*/function () {\n  function Length(input) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Length);\n\n    this.type = NumberType;\n    this.input = input;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Length, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var input = this.input.evaluate(ctx);\n\n      if (typeof input === \'string\') {\n        return input.length;\n      } else if (Array.isArray(input)) {\n        return input.length;\n      } else {\n        throw new RuntimeError("Expected value to be of type string or array, but found ".concat(toString(typeOf(input)), " instead."));\n      }\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'length\'];\n      this.eachChild(function (child) {\n        serialized.push(child.serialize());\n      });\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2) return context.error("Expected 1 argument, but found ".concat(args.length - 1, " instead."));\n      var input = context.parse(args[1], 1);\n      if (!input) return null;\n      if (input.type.kind !== \'array\' && input.type.kind !== \'string\' && input.type.kind !== \'value\') return context.error("Expected argument of type string or array, but found ".concat(toString(input.type), " instead."));\n      return new Length(input);\n    }\n  }]);\n\n  return Length;\n}();\n\nvar expressions = {\n  \'==\': Equals,\n  \'!=\': NotEquals,\n  \'>\': GreaterThan,\n  \'<\': LessThan,\n  \'>=\': GreaterThanOrEqual,\n  \'<=\': LessThanOrEqual,\n  \'array\': Assertion,\n  \'at\': At,\n  \'boolean\': Assertion,\n  \'case\': Case,\n  \'coalesce\': Coalesce,\n  \'collator\': CollatorExpression,\n  \'format\': FormatExpression,\n  \'image\': ImageExpression,\n  \'in\': In,\n  \'index-of\': IndexOf,\n  \'interpolate\': Interpolate,\n  \'interpolate-hcl\': Interpolate,\n  \'interpolate-lab\': Interpolate,\n  \'length\': Length,\n  \'let\': Let,\n  \'literal\': Literal,\n  \'match\': Match,\n  \'number\': Assertion,\n  \'number-format\': NumberFormat,\n  \'object\': Assertion,\n  \'slice\': Slice,\n  \'step\': Step,\n  \'string\': Assertion,\n  \'to-boolean\': Coercion,\n  \'to-color\': Coercion,\n  \'to-number\': Coercion,\n  \'to-string\': Coercion,\n  \'var\': Var,\n  \'within\': Within\n};\n\nfunction rgba(ctx, _ref7) {\n  var _ref8 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref7, 4),\n      r = _ref8[0],\n      g = _ref8[1],\n      b = _ref8[2],\n      a = _ref8[3];\n\n  r = r.evaluate(ctx);\n  g = g.evaluate(ctx);\n  b = b.evaluate(ctx);\n  var alpha = a ? a.evaluate(ctx) : 1;\n  var error = validateRGBA(r, g, b, alpha);\n  if (error) throw new RuntimeError(error);\n  return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);\n}\n\nfunction has(key, obj) {\n  return key in obj;\n}\n\nfunction get(key, obj) {\n  var v = obj[key];\n  return typeof v === \'undefined\' ? null : v;\n}\n\nfunction binarySearch(v, a, i, j) {\n  while (i <= j) {\n    var m = i + j >> 1;\n    if (a[m] === v) return true;\n    if (a[m] > v) j = m - 1;else i = m + 1;\n  }\n\n  return false;\n}\n\nfunction varargs(type) {\n  return {\n    type: type\n  };\n}\n\nCompoundExpression.register(expressions, {\n  \'error\': [ErrorType, [StringType], function (ctx, _ref9) {\n    var _ref10 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref9, 1),\n        v = _ref10[0];\n\n    throw new RuntimeError(v.evaluate(ctx));\n  }],\n  \'typeof\': [StringType, [ValueType], function (ctx, _ref11) {\n    var _ref12 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref11, 1),\n        v = _ref12[0];\n\n    return toString(typeOf(v.evaluate(ctx)));\n  }],\n  \'to-rgba\': [array(NumberType, 4), [ColorType], function (ctx, _ref13) {\n    var _ref14 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref13, 1),\n        v = _ref14[0];\n\n    return v.evaluate(ctx).toArray();\n  }],\n  \'rgb\': [ColorType, [NumberType, NumberType, NumberType], rgba],\n  \'rgba\': [ColorType, [NumberType, NumberType, NumberType, NumberType], rgba],\n  \'has\': {\n    type: BooleanType,\n    overloads: [[[StringType], function (ctx, _ref15) {\n      var _ref16 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref15, 1),\n          key = _ref16[0];\n\n      return has(key.evaluate(ctx), ctx.properties());\n    }], [[StringType, ObjectType], function (ctx, _ref17) {\n      var _ref18 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref17, 2),\n          key = _ref18[0],\n          obj = _ref18[1];\n\n      return has(key.evaluate(ctx), obj.evaluate(ctx));\n    }]]\n  },\n  \'get\': {\n    type: ValueType,\n    overloads: [[[StringType], function (ctx, _ref19) {\n      var _ref20 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref19, 1),\n          key = _ref20[0];\n\n      return get(key.evaluate(ctx), ctx.properties());\n    }], [[StringType, ObjectType], function (ctx, _ref21) {\n      var _ref22 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref21, 2),\n          key = _ref22[0],\n          obj = _ref22[1];\n\n      return get(key.evaluate(ctx), obj.evaluate(ctx));\n    }]]\n  },\n  \'feature-state\': [ValueType, [StringType], function (ctx, _ref23) {\n    var _ref24 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref23, 1),\n        key = _ref24[0];\n\n    return get(key.evaluate(ctx), ctx.featureState || {});\n  }],\n  \'properties\': [ObjectType, [], function (ctx) {\n    return ctx.properties();\n  }],\n  \'geometry-type\': [StringType, [], function (ctx) {\n    return ctx.geometryType();\n  }],\n  \'id\': [ValueType, [], function (ctx) {\n    return ctx.id();\n  }],\n  \'zoom\': [NumberType, [], function (ctx) {\n    return ctx.globals.zoom;\n  }],\n  \'heatmap-density\': [NumberType, [], function (ctx) {\n    return ctx.globals.heatmapDensity || 0;\n  }],\n  \'line-progress\': [NumberType, [], function (ctx) {\n    return ctx.globals.lineProgress || 0;\n  }],\n  \'sky-radial-progress\': [NumberType, [], function (ctx) {\n    return ctx.globals.skyRadialProgress || 0;\n  }],\n  \'accumulated\': [ValueType, [], function (ctx) {\n    return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;\n  }],\n  \'+\': [NumberType, varargs(NumberType), function (ctx, args) {\n    var result = 0;\n\n    var _iterator35 = _createForOfIteratorHelper(args),\n        _step35;\n\n    try {\n      for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n        var arg = _step35.value;\n        result += arg.evaluate(ctx);\n      }\n    } catch (err) {\n      _iterator35.e(err);\n    } finally {\n      _iterator35.f();\n    }\n\n    return result;\n  }],\n  \'*\': [NumberType, varargs(NumberType), function (ctx, args) {\n    var result = 1;\n\n    var _iterator36 = _createForOfIteratorHelper(args),\n        _step36;\n\n    try {\n      for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n        var arg = _step36.value;\n        result *= arg.evaluate(ctx);\n      }\n    } catch (err) {\n      _iterator36.e(err);\n    } finally {\n      _iterator36.f();\n    }\n\n    return result;\n  }],\n  \'-\': {\n    type: NumberType,\n    overloads: [[[NumberType, NumberType], function (ctx, _ref25) {\n      var _ref26 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref25, 2),\n          a = _ref26[0],\n          b = _ref26[1];\n\n      return a.evaluate(ctx) - b.evaluate(ctx);\n    }], [[NumberType], function (ctx, _ref27) {\n      var _ref28 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref27, 1),\n          a = _ref28[0];\n\n      return -a.evaluate(ctx);\n    }]]\n  },\n  \'/\': [NumberType, [NumberType, NumberType], function (ctx, _ref29) {\n    var _ref30 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref29, 2),\n        a = _ref30[0],\n        b = _ref30[1];\n\n    return a.evaluate(ctx) / b.evaluate(ctx);\n  }],\n  \'%\': [NumberType, [NumberType, NumberType], function (ctx, _ref31) {\n    var _ref32 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref31, 2),\n        a = _ref32[0],\n        b = _ref32[1];\n\n    return a.evaluate(ctx) % b.evaluate(ctx);\n  }],\n  \'ln2\': [NumberType, [], function () {\n    return Math.LN2;\n  }],\n  \'pi\': [NumberType, [], function () {\n    return Math.PI;\n  }],\n  \'e\': [NumberType, [], function () {\n    return Math.E;\n  }],\n  \'^\': [NumberType, [NumberType, NumberType], function (ctx, _ref33) {\n    var _ref34 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref33, 2),\n        b = _ref34[0],\n        e = _ref34[1];\n\n    return Math.pow(b.evaluate(ctx), e.evaluate(ctx));\n  }],\n  \'sqrt\': [NumberType, [NumberType], function (ctx, _ref35) {\n    var _ref36 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref35, 1),\n        x = _ref36[0];\n\n    return Math.sqrt(x.evaluate(ctx));\n  }],\n  \'log10\': [NumberType, [NumberType], function (ctx, _ref37) {\n    var _ref38 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref37, 1),\n        n = _ref38[0];\n\n    return Math.log(n.evaluate(ctx)) / Math.LN10;\n  }],\n  \'ln\': [NumberType, [NumberType], function (ctx, _ref39) {\n    var _ref40 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref39, 1),\n        n = _ref40[0];\n\n    return Math.log(n.evaluate(ctx));\n  }],\n  \'log2\': [NumberType, [NumberType], function (ctx, _ref41) {\n    var _ref42 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref41, 1),\n        n = _ref42[0];\n\n    return Math.log(n.evaluate(ctx)) / Math.LN2;\n  }],\n  \'sin\': [NumberType, [NumberType], function (ctx, _ref43) {\n    var _ref44 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref43, 1),\n        n = _ref44[0];\n\n    return Math.sin(n.evaluate(ctx));\n  }],\n  \'cos\': [NumberType, [NumberType], function (ctx, _ref45) {\n    var _ref46 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref45, 1),\n        n = _ref46[0];\n\n    return Math.cos(n.evaluate(ctx));\n  }],\n  \'tan\': [NumberType, [NumberType], function (ctx, _ref47) {\n    var _ref48 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref47, 1),\n        n = _ref48[0];\n\n    return Math.tan(n.evaluate(ctx));\n  }],\n  \'asin\': [NumberType, [NumberType], function (ctx, _ref49) {\n    var _ref50 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref49, 1),\n        n = _ref50[0];\n\n    return Math.asin(n.evaluate(ctx));\n  }],\n  \'acos\': [NumberType, [NumberType], function (ctx, _ref51) {\n    var _ref52 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref51, 1),\n        n = _ref52[0];\n\n    return Math.acos(n.evaluate(ctx));\n  }],\n  \'atan\': [NumberType, [NumberType], function (ctx, _ref53) {\n    var _ref54 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref53, 1),\n        n = _ref54[0];\n\n    return Math.atan(n.evaluate(ctx));\n  }],\n  \'min\': [NumberType, varargs(NumberType), function (ctx, args) {\n    return Math.min.apply(Math, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(args.map(function (arg) {\n      return arg.evaluate(ctx);\n    })));\n  }],\n  \'max\': [NumberType, varargs(NumberType), function (ctx, args) {\n    return Math.max.apply(Math, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(args.map(function (arg) {\n      return arg.evaluate(ctx);\n    })));\n  }],\n  \'abs\': [NumberType, [NumberType], function (ctx, _ref55) {\n    var _ref56 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref55, 1),\n        n = _ref56[0];\n\n    return Math.abs(n.evaluate(ctx));\n  }],\n  \'round\': [NumberType, [NumberType], function (ctx, _ref57) {\n    var _ref58 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref57, 1),\n        n = _ref58[0];\n\n    var v = n.evaluate(ctx);\n    return v < 0 ? -Math.round(-v) : Math.round(v);\n  }],\n  \'floor\': [NumberType, [NumberType], function (ctx, _ref59) {\n    var _ref60 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref59, 1),\n        n = _ref60[0];\n\n    return Math.floor(n.evaluate(ctx));\n  }],\n  \'ceil\': [NumberType, [NumberType], function (ctx, _ref61) {\n    var _ref62 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref61, 1),\n        n = _ref62[0];\n\n    return Math.ceil(n.evaluate(ctx));\n  }],\n  \'filter-==\': [BooleanType, [StringType, ValueType], function (ctx, _ref63) {\n    var _ref64 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref63, 2),\n        k = _ref64[0],\n        v = _ref64[1];\n\n    return ctx.properties()[k.value] === v.value;\n  }],\n  \'filter-id-==\': [BooleanType, [ValueType], function (ctx, _ref65) {\n    var _ref66 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref65, 1),\n        v = _ref66[0];\n\n    return ctx.id() === v.value;\n  }],\n  \'filter-type-==\': [BooleanType, [StringType], function (ctx, _ref67) {\n    var _ref68 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref67, 1),\n        v = _ref68[0];\n\n    return ctx.geometryType() === v.value;\n  }],\n  \'filter-<\': [BooleanType, [StringType, ValueType], function (ctx, _ref69) {\n    var _ref70 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref69, 2),\n        k = _ref70[0],\n        v = _ref70[1];\n\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a < b;\n  }],\n  \'filter-id-<\': [BooleanType, [ValueType], function (ctx, _ref71) {\n    var _ref72 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref71, 1),\n        v = _ref72[0];\n\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a < b;\n  }],\n  \'filter->\': [BooleanType, [StringType, ValueType], function (ctx, _ref73) {\n    var _ref74 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref73, 2),\n        k = _ref74[0],\n        v = _ref74[1];\n\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a > b;\n  }],\n  \'filter-id->\': [BooleanType, [ValueType], function (ctx, _ref75) {\n    var _ref76 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref75, 1),\n        v = _ref76[0];\n\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a > b;\n  }],\n  \'filter-<=\': [BooleanType, [StringType, ValueType], function (ctx, _ref77) {\n    var _ref78 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref77, 2),\n        k = _ref78[0],\n        v = _ref78[1];\n\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a <= b;\n  }],\n  \'filter-id-<=\': [BooleanType, [ValueType], function (ctx, _ref79) {\n    var _ref80 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref79, 1),\n        v = _ref80[0];\n\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a <= b;\n  }],\n  \'filter->=\': [BooleanType, [StringType, ValueType], function (ctx, _ref81) {\n    var _ref82 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref81, 2),\n        k = _ref82[0],\n        v = _ref82[1];\n\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a >= b;\n  }],\n  \'filter-id->=\': [BooleanType, [ValueType], function (ctx, _ref83) {\n    var _ref84 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref83, 1),\n        v = _ref84[0];\n\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a >= b;\n  }],\n  \'filter-has\': [BooleanType, [ValueType], function (ctx, _ref85) {\n    var _ref86 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref85, 1),\n        k = _ref86[0];\n\n    return k.value in ctx.properties();\n  }],\n  \'filter-has-id\': [BooleanType, [], function (ctx) {\n    return ctx.id() !== null && ctx.id() !== undefined;\n  }],\n  \'filter-type-in\': [BooleanType, [array(StringType)], function (ctx, _ref87) {\n    var _ref88 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref87, 1),\n        v = _ref88[0];\n\n    return v.value.indexOf(ctx.geometryType()) >= 0;\n  }],\n  \'filter-id-in\': [BooleanType, [array(ValueType)], function (ctx, _ref89) {\n    var _ref90 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref89, 1),\n        v = _ref90[0];\n\n    return v.value.indexOf(ctx.id()) >= 0;\n  }],\n  \'filter-in-small\': [BooleanType, [StringType, array(ValueType)], function (ctx, _ref91) {\n    var _ref92 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref91, 2),\n        k = _ref92[0],\n        v = _ref92[1];\n\n    return v.value.indexOf(ctx.properties()[k.value]) >= 0;\n  }],\n  \'filter-in-large\': [BooleanType, [StringType, array(ValueType)], function (ctx, _ref93) {\n    var _ref94 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref93, 2),\n        k = _ref94[0],\n        v = _ref94[1];\n\n    return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);\n  }],\n  \'all\': {\n    type: BooleanType,\n    overloads: [[[BooleanType, BooleanType], function (ctx, _ref95) {\n      var _ref96 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref95, 2),\n          a = _ref96[0],\n          b = _ref96[1];\n\n      return a.evaluate(ctx) && b.evaluate(ctx);\n    }], [varargs(BooleanType), function (ctx, args) {\n      var _iterator37 = _createForOfIteratorHelper(args),\n          _step37;\n\n      try {\n        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n          var arg = _step37.value;\n          if (!arg.evaluate(ctx)) return false;\n        }\n      } catch (err) {\n        _iterator37.e(err);\n      } finally {\n        _iterator37.f();\n      }\n\n      return true;\n    }]]\n  },\n  \'any\': {\n    type: BooleanType,\n    overloads: [[[BooleanType, BooleanType], function (ctx, _ref97) {\n      var _ref98 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref97, 2),\n          a = _ref98[0],\n          b = _ref98[1];\n\n      return a.evaluate(ctx) || b.evaluate(ctx);\n    }], [varargs(BooleanType), function (ctx, args) {\n      var _iterator38 = _createForOfIteratorHelper(args),\n          _step38;\n\n      try {\n        for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n          var arg = _step38.value;\n          if (arg.evaluate(ctx)) return true;\n        }\n      } catch (err) {\n        _iterator38.e(err);\n      } finally {\n        _iterator38.f();\n      }\n\n      return false;\n    }]]\n  },\n  \'!\': [BooleanType, [BooleanType], function (ctx, _ref99) {\n    var _ref100 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref99, 1),\n        b = _ref100[0];\n\n    return !b.evaluate(ctx);\n  }],\n  \'is-supported-script\': [BooleanType, [StringType], function (ctx, _ref101) {\n    var _ref102 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref101, 1),\n        s = _ref102[0];\n\n    var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;\n\n    if (isSupportedScript) {\n      return isSupportedScript(s.evaluate(ctx));\n    }\n\n    return true;\n  }],\n  \'upcase\': [StringType, [StringType], function (ctx, _ref103) {\n    var _ref104 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref103, 1),\n        s = _ref104[0];\n\n    return s.evaluate(ctx).toUpperCase();\n  }],\n  \'downcase\': [StringType, [StringType], function (ctx, _ref105) {\n    var _ref106 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref105, 1),\n        s = _ref106[0];\n\n    return s.evaluate(ctx).toLowerCase();\n  }],\n  \'concat\': [StringType, varargs(ValueType), function (ctx, args) {\n    return args.map(function (arg) {\n      return toString$1(arg.evaluate(ctx));\n    }).join(\'\');\n  }],\n  \'resolved-locale\': [StringType, [CollatorType], function (ctx, _ref107) {\n    var _ref108 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref107, 1),\n        collator = _ref108[0];\n\n    return collator.evaluate(ctx).resolvedLocale();\n  }]\n});\n\nfunction success(value) {\n  return {\n    result: \'success\',\n    value: value\n  };\n}\n\nfunction error(value) {\n  return {\n    result: \'error\',\n    value: value\n  };\n}\n\nfunction supportsPropertyExpression(spec) {\n  return spec[\'property-type\'] === \'data-driven\' || spec[\'property-type\'] === \'cross-faded-data-driven\';\n}\n\nfunction supportsZoomExpression(spec) {\n  return !!spec.expression && spec.expression.parameters.indexOf(\'zoom\') > -1;\n}\n\nfunction supportsInterpolation(spec) {\n  return !!spec.expression && spec.expression.interpolated;\n}\n\nfunction getType(val) {\n  if (val instanceof Number) {\n    return \'number\';\n  } else if (val instanceof String) {\n    return \'string\';\n  } else if (val instanceof Boolean) {\n    return \'boolean\';\n  } else if (Array.isArray(val)) {\n    return \'array\';\n  } else if (val === null) {\n    return \'null\';\n  } else {\n    return typeof val;\n  }\n}\n\nfunction isFunction$1(value) {\n  return typeof value === \'object\' && value !== null && !Array.isArray(value);\n}\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction createFunction(parameters, propertySpec) {\n  var isColor = propertySpec.type === \'color\';\n  var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === \'object\';\n  var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n  var zoomDependent = zoomAndFeatureDependent || !featureDependent;\n  var type = parameters.type || (supportsInterpolation(propertySpec) ? \'exponential\' : \'interval\');\n\n  if (isColor) {\n    parameters = extend({}, parameters);\n\n    if (parameters.stops) {\n      parameters.stops = parameters.stops.map(function (stop) {\n        return [stop[0], Color.parse(stop[1])];\n      });\n    }\n\n    if (parameters.default) {\n      parameters.default = Color.parse(parameters.default);\n    } else {\n      parameters.default = Color.parse(propertySpec.default);\n    }\n  }\n\n  if (parameters.colorSpace && parameters.colorSpace !== \'rgb\' && !colorSpaces[parameters.colorSpace]) {\n    throw new Error("Unknown color space: ".concat(parameters.colorSpace));\n  }\n\n  var innerFun;\n  var hashedStops;\n  var categoricalKeyType;\n\n  if (type === \'exponential\') {\n    innerFun = evaluateExponentialFunction;\n  } else if (type === \'interval\') {\n    innerFun = evaluateIntervalFunction;\n  } else if (type === \'categorical\') {\n    innerFun = evaluateCategoricalFunction;\n    hashedStops = Object.create(null);\n\n    var _iterator39 = _createForOfIteratorHelper(parameters.stops),\n        _step39;\n\n    try {\n      for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n        var stop = _step39.value;\n        hashedStops[stop[0]] = stop[1];\n      }\n    } catch (err) {\n      _iterator39.e(err);\n    } finally {\n      _iterator39.f();\n    }\n\n    categoricalKeyType = typeof parameters.stops[0][0];\n  } else if (type === \'identity\') {\n    innerFun = evaluateIdentityFunction;\n  } else {\n    throw new Error("Unknown function type \\"".concat(type, "\\""));\n  }\n\n  if (zoomAndFeatureDependent) {\n    var featureFunctions = {};\n    var zoomStops = [];\n\n    for (var s = 0; s < parameters.stops.length; s++) {\n      var _stop = parameters.stops[s];\n      var zoom = _stop[0].zoom;\n\n      if (featureFunctions[zoom] === undefined) {\n        featureFunctions[zoom] = {\n          zoom: zoom,\n          type: parameters.type,\n          property: parameters.property,\n          default: parameters.default,\n          stops: []\n        };\n        zoomStops.push(zoom);\n      }\n\n      featureFunctions[zoom].stops.push([_stop[0].value, _stop[1]]);\n    }\n\n    var featureFunctionStops = [];\n\n    for (var _i7 = 0, _zoomStops = zoomStops; _i7 < _zoomStops.length; _i7++) {\n      var z = _zoomStops[_i7];\n      featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);\n    }\n\n    var interpolationType = {\n      name: \'linear\'\n    };\n    return {\n      kind: \'composite\',\n      interpolationType: interpolationType,\n      interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),\n      zoomStops: featureFunctionStops.map(function (s) {\n        return s[0];\n      }),\n      evaluate: function evaluate(_ref109, properties) {\n        var zoom = _ref109.zoom;\n        return evaluateExponentialFunction({\n          stops: featureFunctionStops,\n          base: parameters.base\n        }, propertySpec, zoom).evaluate(zoom, properties);\n      }\n    };\n  } else if (zoomDependent) {\n    var _interpolationType = type === \'exponential\' ? {\n      name: \'exponential\',\n      base: parameters.base !== undefined ? parameters.base : 1\n    } : null;\n\n    return {\n      kind: \'camera\',\n      interpolationType: _interpolationType,\n      interpolationFactor: Interpolate.interpolationFactor.bind(undefined, _interpolationType),\n      zoomStops: parameters.stops.map(function (s) {\n        return s[0];\n      }),\n      evaluate: function evaluate(_ref110) {\n        var zoom = _ref110.zoom;\n        return innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType);\n      }\n    };\n  } else {\n    return {\n      kind: \'source\',\n      evaluate: function evaluate(_, feature) {\n        var value = feature && feature.properties ? feature.properties[parameters.property] : undefined;\n\n        if (value === undefined) {\n          return coalesce(parameters.default, propertySpec.default);\n        }\n\n        return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);\n      }\n    };\n  }\n}\n\nfunction coalesce(a, b, c) {\n  if (a !== undefined) return a;\n  if (b !== undefined) return b;\n  if (c !== undefined) return c;\n}\n\nfunction evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {\n  var evaluated = typeof input === keyType ? hashedStops[input] : undefined;\n  return coalesce(evaluated, parameters.default, propertySpec.default);\n}\n\nfunction evaluateIntervalFunction(parameters, propertySpec, input) {\n  if (getType(input) !== \'number\') return coalesce(parameters.default, propertySpec.default);\n  var n = parameters.stops.length;\n  if (n === 1) return parameters.stops[0][1];\n  if (input <= parameters.stops[0][0]) return parameters.stops[0][1];\n  if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];\n  var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {\n    return stop[0];\n  }), input);\n  return parameters.stops[index][1];\n}\n\nfunction evaluateExponentialFunction(parameters, propertySpec, input) {\n  var base = parameters.base !== undefined ? parameters.base : 1;\n  if (getType(input) !== \'number\') return coalesce(parameters.default, propertySpec.default);\n  var n = parameters.stops.length;\n  if (n === 1) return parameters.stops[0][1];\n  if (input <= parameters.stops[0][0]) return parameters.stops[0][1];\n  if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];\n  var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {\n    return stop[0];\n  }), input);\n  var t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);\n  var outputLower = parameters.stops[index][1];\n  var outputUpper = parameters.stops[index + 1][1];\n  var interp = interpolate[propertySpec.type] || identityFunction;\n\n  if (parameters.colorSpace && parameters.colorSpace !== \'rgb\') {\n    var colorspace = colorSpaces[parameters.colorSpace];\n\n    interp = function interp(a, b) {\n      return colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));\n    };\n  }\n\n  if (typeof outputLower.evaluate === \'function\') {\n    return {\n      evaluate: function evaluate() {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key5 = 0; _key5 < _len3; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n\n        var evaluatedLower = outputLower.evaluate.apply(undefined, args);\n        var evaluatedUpper = outputUpper.evaluate.apply(undefined, args);\n\n        if (evaluatedLower === undefined || evaluatedUpper === undefined) {\n          return undefined;\n        }\n\n        return interp(evaluatedLower, evaluatedUpper, t);\n      }\n    };\n  }\n\n  return interp(outputLower, outputUpper, t);\n}\n\nfunction evaluateIdentityFunction(parameters, propertySpec, input) {\n  if (propertySpec.type === \'color\') {\n    input = Color.parse(input);\n  } else if (propertySpec.type === \'formatted\') {\n    input = Formatted.fromString(input.toString());\n  } else if (propertySpec.type === \'resolvedImage\') {\n    input = ResolvedImage.fromString(input.toString());\n  } else if (getType(input) !== propertySpec.type && (propertySpec.type !== \'enum\' || !propertySpec.values[input])) {\n    input = undefined;\n  }\n\n  return coalesce(input, parameters.default, propertySpec.default);\n}\n\nfunction interpolationFactor(input, base, lowerValue, upperValue) {\n  var difference = upperValue - lowerValue;\n  var progress = input - lowerValue;\n\n  if (difference === 0) {\n    return 0;\n  } else if (base === 1) {\n    return progress / difference;\n  } else {\n    return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n  }\n}\n\nvar StyleExpression = /*#__PURE__*/function () {\n  function StyleExpression(expression, propertySpec) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, StyleExpression);\n\n    this.expression = expression;\n    this._warningHistory = {};\n    this._evaluator = new EvaluationContext();\n    this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;\n    this._enumValues = propertySpec && propertySpec.type === \'enum\' ? propertySpec.values : null;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(StyleExpression, [{\n    key: "evaluateWithoutErrorHandling",\n    value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      this._evaluator.globals = globals;\n      this._evaluator.feature = feature;\n      this._evaluator.featureState = featureState;\n      this._evaluator.canonical = canonical;\n      this._evaluator.availableImages = availableImages || null;\n      this._evaluator.formattedSection = formattedSection;\n      return this.expression.evaluate(this._evaluator);\n    }\n  }, {\n    key: "evaluate",\n    value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      this._evaluator.globals = globals;\n      this._evaluator.feature = feature || null;\n      this._evaluator.featureState = featureState || null;\n      this._evaluator.canonical = canonical;\n      this._evaluator.availableImages = availableImages || null;\n      this._evaluator.formattedSection = formattedSection || null;\n\n      try {\n        var val = this.expression.evaluate(this._evaluator);\n\n        if (val === null || val === undefined || typeof val === \'number\' && val !== val) {\n          return this._defaultValue;\n        }\n\n        if (this._enumValues && !(val in this._enumValues)) {\n          throw new RuntimeError("Expected value to be one of ".concat(Object.keys(this._enumValues).map(function (v) {\n            return JSON.stringify(v);\n          }).join(\', \'), ", but found ").concat(JSON.stringify(val), " instead."));\n        }\n\n        return val;\n      } catch (e) {\n        if (!this._warningHistory[e.message]) {\n          this._warningHistory[e.message] = true;\n\n          if (typeof console !== \'undefined\') {\n            console.warn(e.message);\n          }\n        }\n\n        return this._defaultValue;\n      }\n    }\n  }]);\n\n  return StyleExpression;\n}();\n\nfunction isExpression(expression) {\n  return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === \'string\' && expression[0] in expressions;\n}\n\nfunction createExpression(expression, propertySpec) {\n  var parser = new ParsingContext(expressions, [], propertySpec ? getExpectedType(propertySpec) : undefined);\n  var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === \'string\' ? {\n    typeAnnotation: \'coerce\'\n  } : undefined);\n\n  if (!parsed) {\n    return error(parser.errors);\n  }\n\n  return success(new StyleExpression(parsed, propertySpec));\n}\n\nvar ZoomConstantExpression = /*#__PURE__*/function () {\n  function ZoomConstantExpression(kind, expression) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ZoomConstantExpression);\n\n    this.kind = kind;\n    this._styleExpression = expression;\n    this.isStateDependent = kind !== \'constant\' && !isStateConstant(expression.expression);\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(ZoomConstantExpression, [{\n    key: "evaluateWithoutErrorHandling",\n    value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n  }, {\n    key: "evaluate",\n    value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n  }]);\n\n  return ZoomConstantExpression;\n}();\n\nvar ZoomDependentExpression = /*#__PURE__*/function () {\n  function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ZoomDependentExpression);\n\n    this.kind = kind;\n    this.zoomStops = zoomStops;\n    this._styleExpression = expression;\n    this.isStateDependent = kind !== \'camera\' && !isStateConstant(expression.expression);\n    this.interpolationType = interpolationType;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(ZoomDependentExpression, [{\n    key: "evaluateWithoutErrorHandling",\n    value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n  }, {\n    key: "evaluate",\n    value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n  }, {\n    key: "interpolationFactor",\n    value: function interpolationFactor(input, lower, upper) {\n      if (this.interpolationType) {\n        return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);\n      } else {\n        return 0;\n      }\n    }\n  }]);\n\n  return ZoomDependentExpression;\n}();\n\nfunction createPropertyExpression(expression, propertySpec) {\n  expression = createExpression(expression, propertySpec);\n\n  if (expression.result === \'error\') {\n    return expression;\n  }\n\n  var parsed = expression.value.expression;\n  var isFeatureConstant$1 = isFeatureConstant(parsed);\n\n  if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {\n    return error([new ParsingError(\'\', \'data expressions not supported\')]);\n  }\n\n  var isZoomConstant = isGlobalPropertyConstant(parsed, [\'zoom\']);\n\n  if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {\n    return error([new ParsingError(\'\', \'zoom expressions not supported\')]);\n  }\n\n  var zoomCurve = findZoomCurve(parsed);\n\n  if (!zoomCurve && !isZoomConstant) {\n    return error([new ParsingError(\'\', \'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\')]);\n  } else if (zoomCurve instanceof ParsingError) {\n    return error([zoomCurve]);\n  } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {\n    return error([new ParsingError(\'\', \'"interpolate" expressions cannot be used with this property\')]);\n  }\n\n  if (!zoomCurve) {\n    return success(isFeatureConstant$1 ? new ZoomConstantExpression(\'constant\', expression.value) : new ZoomConstantExpression(\'source\', expression.value));\n  }\n\n  var interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;\n  return success(isFeatureConstant$1 ? new ZoomDependentExpression(\'camera\', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression(\'composite\', expression.value, zoomCurve.labels, interpolationType));\n}\n\nvar StylePropertyFunction = /*#__PURE__*/function () {\n  function StylePropertyFunction(parameters, specification) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, StylePropertyFunction);\n\n    this._parameters = parameters;\n    this._specification = specification;\n    extend(this, createFunction(this._parameters, this._specification));\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(StylePropertyFunction, null, [{\n    key: "deserialize",\n    value: function deserialize(serialized) {\n      return new StylePropertyFunction(serialized._parameters, serialized._specification);\n    }\n  }, {\n    key: "serialize",\n    value: function serialize(input) {\n      return {\n        _parameters: input._parameters,\n        _specification: input._specification\n      };\n    }\n  }]);\n\n  return StylePropertyFunction;\n}();\n\nfunction normalizePropertyExpression(value, specification) {\n  if (isFunction$1(value)) {\n    return new StylePropertyFunction(value, specification);\n  } else if (isExpression(value)) {\n    var _expression8 = createPropertyExpression(value, specification);\n\n    if (_expression8.result === \'error\') {\n      throw new Error(_expression8.value.map(function (err) {\n        return "".concat(err.key, ": ").concat(err.message);\n      }).join(\', \'));\n    }\n\n    return _expression8.value;\n  } else {\n    var constant = value;\n\n    if (typeof value === \'string\' && specification.type === \'color\') {\n      constant = Color.parse(value);\n    }\n\n    return {\n      kind: \'constant\',\n      evaluate: function evaluate() {\n        return constant;\n      }\n    };\n  }\n}\n\nfunction findZoomCurve(expression) {\n  var result = null;\n\n  if (expression instanceof Let) {\n    result = findZoomCurve(expression.result);\n  } else if (expression instanceof Coalesce) {\n    var _iterator40 = _createForOfIteratorHelper(expression.args),\n        _step40;\n\n    try {\n      for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n        var arg = _step40.value;\n        result = findZoomCurve(arg);\n\n        if (result) {\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator40.e(err);\n    } finally {\n      _iterator40.f();\n    }\n  } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === \'zoom\') {\n    result = expression;\n  }\n\n  if (result instanceof ParsingError) {\n    return result;\n  }\n\n  expression.eachChild(function (child) {\n    var childResult = findZoomCurve(child);\n\n    if (childResult instanceof ParsingError) {\n      result = childResult;\n    } else if (!result && childResult) {\n      result = new ParsingError(\'\', \'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\');\n    } else if (result && childResult && result !== childResult) {\n      result = new ParsingError(\'\', \'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.\');\n    }\n  });\n  return result;\n}\n\nfunction getExpectedType(spec) {\n  var types = {\n    color: ColorType,\n    string: StringType,\n    number: NumberType,\n    enum: StringType,\n    boolean: BooleanType,\n    formatted: FormattedType,\n    resolvedImage: ResolvedImageType\n  };\n\n  if (spec.type === \'array\') {\n    return array(types[spec.value] || ValueType, spec.length);\n  }\n\n  return types[spec.type];\n}\n\nfunction getDefaultValue(spec) {\n  if (spec.type === \'color\' && isFunction$1(spec.default)) {\n    return new Color(0, 0, 0, 0);\n  } else if (spec.type === \'color\') {\n    return Color.parse(spec.default) || null;\n  } else if (spec.default === undefined) {\n    return null;\n  } else {\n    return spec.default;\n  }\n}\n\nfunction convertLiteral(value) {\n  return typeof value === \'object\' ? [\'literal\', value] : value;\n}\n\nfunction convertFunction(parameters, propertySpec) {\n  var stops = parameters.stops;\n\n  if (!stops) {\n    return convertIdentityFunction(parameters, propertySpec);\n  }\n\n  var zoomAndFeatureDependent = stops && typeof stops[0][0] === \'object\';\n  var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n  var zoomDependent = zoomAndFeatureDependent || !featureDependent;\n  stops = stops.map(function (stop) {\n    if (!featureDependent && propertySpec.tokens && typeof stop[1] === \'string\') {\n      return [stop[0], convertTokenString(stop[1])];\n    }\n\n    return [stop[0], convertLiteral(stop[1])];\n  });\n\n  if (zoomAndFeatureDependent) {\n    return convertZoomAndPropertyFunction(parameters, propertySpec, stops);\n  } else if (zoomDependent) {\n    return convertZoomFunction(parameters, propertySpec, stops);\n  } else {\n    return convertPropertyFunction(parameters, propertySpec, stops);\n  }\n}\n\nfunction convertIdentityFunction(parameters, propertySpec) {\n  var get = [\'get\', parameters.property];\n\n  if (parameters.default === undefined) {\n    return propertySpec.type === \'string\' ? [\'string\', get] : get;\n  } else if (propertySpec.type === \'enum\') {\n    return [\'match\', get, Object.keys(propertySpec.values), get, parameters.default];\n  } else {\n    var _expression9 = [propertySpec.type === \'color\' ? \'to-color\' : propertySpec.type, get, convertLiteral(parameters.default)];\n\n    if (propertySpec.type === \'array\') {\n      _expression9.splice(1, 0, propertySpec.value, propertySpec.length || null);\n    }\n\n    return _expression9;\n  }\n}\n\nfunction getInterpolateOperator(parameters) {\n  switch (parameters.colorSpace) {\n    case \'hcl\':\n      return \'interpolate-hcl\';\n\n    case \'lab\':\n      return \'interpolate-lab\';\n\n    default:\n      return \'interpolate\';\n  }\n}\n\nfunction convertZoomAndPropertyFunction(parameters, propertySpec, stops) {\n  var featureFunctionParameters = {};\n  var featureFunctionStops = {};\n  var zoomStops = [];\n\n  for (var s = 0; s < stops.length; s++) {\n    var stop = stops[s];\n    var zoom = stop[0].zoom;\n\n    if (featureFunctionParameters[zoom] === undefined) {\n      featureFunctionParameters[zoom] = {\n        zoom: zoom,\n        type: parameters.type,\n        property: parameters.property,\n        default: parameters.default\n      };\n      featureFunctionStops[zoom] = [];\n      zoomStops.push(zoom);\n    }\n\n    featureFunctionStops[zoom].push([stop[0].value, stop[1]]);\n  }\n\n  var functionType = getFunctionType({}, propertySpec);\n\n  if (functionType === \'exponential\') {\n    var _expression10 = [getInterpolateOperator(parameters), [\'linear\'], [\'zoom\']];\n\n    var _iterator41 = _createForOfIteratorHelper(zoomStops),\n        _step41;\n\n    try {\n      for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n        var z = _step41.value;\n        var output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);\n        appendStopPair(_expression10, z, output, false);\n      }\n    } catch (err) {\n      _iterator41.e(err);\n    } finally {\n      _iterator41.f();\n    }\n\n    return _expression10;\n  } else {\n    var _expression11 = [\'step\', [\'zoom\']];\n\n    var _iterator42 = _createForOfIteratorHelper(zoomStops),\n        _step42;\n\n    try {\n      for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n        var _z = _step42.value;\n\n        var _output = convertPropertyFunction(featureFunctionParameters[_z], propertySpec, featureFunctionStops[_z]);\n\n        appendStopPair(_expression11, _z, _output, true);\n      }\n    } catch (err) {\n      _iterator42.e(err);\n    } finally {\n      _iterator42.f();\n    }\n\n    fixupDegenerateStepCurve(_expression11);\n    return _expression11;\n  }\n}\n\nfunction coalesce$1(a, b) {\n  if (a !== undefined) return a;\n  if (b !== undefined) return b;\n}\n\nfunction getFallback(parameters, propertySpec) {\n  var defaultValue = convertLiteral(coalesce$1(parameters.default, propertySpec.default));\n\n  if (defaultValue === undefined && propertySpec.type === \'resolvedImage\') {\n    return \'\';\n  }\n\n  return defaultValue;\n}\n\nfunction convertPropertyFunction(parameters, propertySpec, stops) {\n  var type = getFunctionType(parameters, propertySpec);\n  var get = [\'get\', parameters.property];\n\n  if (type === \'categorical\' && typeof stops[0][0] === \'boolean\') {\n    var _expression12 = [\'case\'];\n\n    var _iterator43 = _createForOfIteratorHelper(stops),\n        _step43;\n\n    try {\n      for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n        var stop = _step43.value;\n\n        _expression12.push([\'==\', get, stop[0]], stop[1]);\n      }\n    } catch (err) {\n      _iterator43.e(err);\n    } finally {\n      _iterator43.f();\n    }\n\n    _expression12.push(getFallback(parameters, propertySpec));\n\n    return _expression12;\n  } else if (type === \'categorical\') {\n    var _expression13 = [\'match\', get];\n\n    var _iterator44 = _createForOfIteratorHelper(stops),\n        _step44;\n\n    try {\n      for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n        var _stop2 = _step44.value;\n        appendStopPair(_expression13, _stop2[0], _stop2[1], false);\n      }\n    } catch (err) {\n      _iterator44.e(err);\n    } finally {\n      _iterator44.f();\n    }\n\n    _expression13.push(getFallback(parameters, propertySpec));\n\n    return _expression13;\n  } else if (type === \'interval\') {\n    var _expression14 = [\'step\', [\'number\', get]];\n\n    var _iterator45 = _createForOfIteratorHelper(stops),\n        _step45;\n\n    try {\n      for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n        var _stop3 = _step45.value;\n        appendStopPair(_expression14, _stop3[0], _stop3[1], true);\n      }\n    } catch (err) {\n      _iterator45.e(err);\n    } finally {\n      _iterator45.f();\n    }\n\n    fixupDegenerateStepCurve(_expression14);\n    return parameters.default === undefined ? _expression14 : [\'case\', [\'==\', [\'typeof\', get], \'number\'], _expression14, convertLiteral(parameters.default)];\n  } else if (type === \'exponential\') {\n    var base = parameters.base !== undefined ? parameters.base : 1;\n    var _expression15 = [getInterpolateOperator(parameters), base === 1 ? [\'linear\'] : [\'exponential\', base], [\'number\', get]];\n\n    var _iterator46 = _createForOfIteratorHelper(stops),\n        _step46;\n\n    try {\n      for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {\n        var _stop4 = _step46.value;\n        appendStopPair(_expression15, _stop4[0], _stop4[1], false);\n      }\n    } catch (err) {\n      _iterator46.e(err);\n    } finally {\n      _iterator46.f();\n    }\n\n    return parameters.default === undefined ? _expression15 : [\'case\', [\'==\', [\'typeof\', get], \'number\'], _expression15, convertLiteral(parameters.default)];\n  } else {\n    throw new Error("Unknown property function type ".concat(type));\n  }\n}\n\nfunction convertZoomFunction(parameters, propertySpec, stops) {\n  var input = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [\'zoom\'];\n  var type = getFunctionType(parameters, propertySpec);\n  var expression;\n  var isStep = false;\n\n  if (type === \'interval\') {\n    expression = [\'step\', input];\n    isStep = true;\n  } else if (type === \'exponential\') {\n    var base = parameters.base !== undefined ? parameters.base : 1;\n    expression = [getInterpolateOperator(parameters), base === 1 ? [\'linear\'] : [\'exponential\', base], input];\n  } else {\n    throw new Error("Unknown zoom function type \\"".concat(type, "\\""));\n  }\n\n  var _iterator47 = _createForOfIteratorHelper(stops),\n      _step47;\n\n  try {\n    for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {\n      var stop = _step47.value;\n      appendStopPair(expression, stop[0], stop[1], isStep);\n    }\n  } catch (err) {\n    _iterator47.e(err);\n  } finally {\n    _iterator47.f();\n  }\n\n  fixupDegenerateStepCurve(expression);\n  return expression;\n}\n\nfunction fixupDegenerateStepCurve(expression) {\n  if (expression[0] === \'step\' && expression.length === 3) {\n    expression.push(0);\n    expression.push(expression[3]);\n  }\n}\n\nfunction appendStopPair(curve, input, output, isStep) {\n  if (curve.length > 3 && input === curve[curve.length - 2]) {\n    return;\n  }\n\n  if (!(isStep && curve.length === 2)) {\n    curve.push(input);\n  }\n\n  curve.push(output);\n}\n\nfunction getFunctionType(parameters, propertySpec) {\n  if (parameters.type) {\n    return parameters.type;\n  } else {\n    return propertySpec.expression.interpolated ? \'exponential\' : \'interval\';\n  }\n}\n\nfunction convertTokenString(s) {\n  var result = [\'concat\'];\n  var re = /{([^{}]+)}/g;\n  var pos = 0;\n\n  for (var match = re.exec(s); match !== null; match = re.exec(s)) {\n    var literal = s.slice(pos, re.lastIndex - match[0].length);\n    pos = re.lastIndex;\n    if (literal.length > 0) result.push(literal);\n    result.push([\'get\', match[1]]);\n  }\n\n  if (result.length === 1) {\n    return s;\n  }\n\n  if (pos < s.length) {\n    result.push(s.slice(pos));\n  } else if (result.length === 2) {\n    return [\'to-string\', result[1]];\n  }\n\n  return result;\n}\n\nfunction isExpressionFilter(filter) {\n  if (filter === true || filter === false) {\n    return true;\n  }\n\n  if (!Array.isArray(filter) || filter.length === 0) {\n    return false;\n  }\n\n  switch (filter[0]) {\n    case \'has\':\n      return filter.length >= 2 && filter[1] !== \'$id\' && filter[1] !== \'$type\';\n\n    case \'in\':\n      return filter.length >= 3 && (typeof filter[1] !== \'string\' || Array.isArray(filter[2]));\n\n    case \'!in\':\n    case \'!has\':\n    case \'none\':\n      return false;\n\n    case \'==\':\n    case \'!=\':\n    case \'>\':\n    case \'>=\':\n    case \'<\':\n    case \'<=\':\n      return filter.length !== 3 || Array.isArray(filter[1]) || Array.isArray(filter[2]);\n\n    case \'any\':\n    case \'all\':\n      var _iterator48 = _createForOfIteratorHelper(filter.slice(1)),\n          _step48;\n\n      try {\n        for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {\n          var f = _step48.value;\n\n          if (!isExpressionFilter(f) && typeof f !== \'boolean\') {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator48.e(err);\n      } finally {\n        _iterator48.f();\n      }\n\n      return true;\n\n    default:\n      return true;\n  }\n}\n\nvar filterSpec = {\n  \'type\': \'boolean\',\n  \'default\': false,\n  \'transition\': false,\n  \'property-type\': \'data-driven\',\n  \'expression\': {\n    \'interpolated\': false,\n    \'parameters\': [\'zoom\', \'feature\']\n  }\n};\n\nfunction createFilter(filter) {\n  if (filter === null || filter === undefined) {\n    return {\n      filter: function filter() {\n        return true;\n      },\n      needGeometry: false\n    };\n  }\n\n  if (!isExpressionFilter(filter)) {\n    filter = convertFilter(filter);\n  }\n\n  var compiled = createExpression(filter, filterSpec);\n\n  if (compiled.result === \'error\') {\n    throw new Error(compiled.value.map(function (err) {\n      return "".concat(err.key, ": ").concat(err.message);\n    }).join(\', \'));\n  } else {\n    var needGeometry = geometryNeeded(filter);\n    return {\n      filter: function filter(globalProperties, feature, canonical) {\n        return compiled.value.evaluate(globalProperties, feature, {}, canonical);\n      },\n      needGeometry: needGeometry\n    };\n  }\n}\n\nfunction compare(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction geometryNeeded(filter) {\n  if (!Array.isArray(filter)) return false;\n  if (filter[0] === \'within\') return true;\n\n  for (var index = 1; index < filter.length; index++) {\n    if (geometryNeeded(filter[index])) return true;\n  }\n\n  return false;\n}\n\nfunction convertFilter(filter) {\n  if (!filter) return true;\n  var op = filter[0];\n  if (filter.length <= 1) return op !== \'any\';\n  var converted = op === \'==\' ? convertComparisonOp(filter[1], filter[2], \'==\') : op === \'!=\' ? convertNegation(convertComparisonOp(filter[1], filter[2], \'==\')) : op === \'<\' || op === \'>\' || op === \'<=\' || op === \'>=\' ? convertComparisonOp(filter[1], filter[2], op) : op === \'any\' ? convertDisjunctionOp(filter.slice(1)) : op === \'all\' ? [\'all\'].concat(filter.slice(1).map(convertFilter)) : op === \'none\' ? [\'all\'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === \'in\' ? convertInOp(filter[1], filter.slice(2)) : op === \'!in\' ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === \'has\' ? convertHasOp(filter[1]) : op === \'!has\' ? convertNegation(convertHasOp(filter[1])) : op === \'within\' ? filter : true;\n  return converted;\n}\n\nfunction convertComparisonOp(property, value, op) {\n  switch (property) {\n    case \'$type\':\n      return ["filter-type-".concat(op), value];\n\n    case \'$id\':\n      return ["filter-id-".concat(op), value];\n\n    default:\n      return ["filter-".concat(op), property, value];\n  }\n}\n\nfunction convertDisjunctionOp(filters) {\n  return [\'any\'].concat(filters.map(convertFilter));\n}\n\nfunction convertInOp(property, values) {\n  if (values.length === 0) {\n    return false;\n  }\n\n  switch (property) {\n    case \'$type\':\n      return ["filter-type-in", [\'literal\', values]];\n\n    case \'$id\':\n      return ["filter-id-in", [\'literal\', values]];\n\n    default:\n      if (values.length > 200 && !values.some(function (v) {\n        return typeof v !== typeof values[0];\n      })) {\n        return [\'filter-in-large\', property, [\'literal\', values.sort(compare)]];\n      } else {\n        return [\'filter-in-small\', property, [\'literal\', values]];\n      }\n\n  }\n}\n\nfunction convertHasOp(property) {\n  switch (property) {\n    case \'$type\':\n      return true;\n\n    case \'$id\':\n      return ["filter-has-id"];\n\n    default:\n      return ["filter-has", property];\n  }\n}\n\nfunction convertNegation(filter) {\n  return [\'!\', filter];\n}\n\nfunction convertFilter$1(filter) {\n  return _convertFilter(filter, {});\n}\n\nfunction _convertFilter(filter, expectedTypes) {\n  if (isExpressionFilter(filter)) {\n    return filter;\n  }\n\n  if (!filter) return true;\n  var op = filter[0];\n  if (filter.length <= 1) return op !== \'any\';\n  var converted;\n\n  if (op === \'==\' || op === \'!=\' || op === \'<\' || op === \'>\' || op === \'<=\' || op === \'>=\') {\n    var _filter = _slicedToArray(filter, 3),\n        property = _filter[1],\n        value = _filter[2];\n\n    converted = convertComparisonOp$1(property, value, op, expectedTypes);\n  } else if (op === \'any\') {\n    var children = filter.slice(1).map(function (f) {\n      var types = {};\n\n      var child = _convertFilter(f, types);\n\n      var typechecks = runtimeTypeChecks(types);\n      return typechecks === true ? child : [\'case\', typechecks, child, false];\n    });\n    return [\'any\'].concat(children);\n  } else if (op === \'all\') {\n    var _ref111;\n\n    var _children = filter.slice(1).map(function (f) {\n      return _convertFilter(f, expectedTypes);\n    });\n\n    return _children.length > 1 ? [\'all\'].concat(_children) : (_ref111 = []).concat.apply(_ref111, _toConsumableArray(_children));\n  } else if (op === \'none\') {\n    return [\'!\', _convertFilter([\'any\'].concat(filter.slice(1)), {})];\n  } else if (op === \'in\') {\n    converted = convertInOp$1(filter[1], filter.slice(2));\n  } else if (op === \'!in\') {\n    converted = convertInOp$1(filter[1], filter.slice(2), true);\n  } else if (op === \'has\') {\n    converted = convertHasOp$1(filter[1]);\n  } else if (op === \'!has\') {\n    converted = [\'!\', convertHasOp$1(filter[1])];\n  } else {\n    converted = true;\n  }\n\n  return converted;\n}\n\nfunction runtimeTypeChecks(expectedTypes) {\n  var conditions = [];\n\n  for (var property in expectedTypes) {\n    var _get = property === \'$id\' ? [\'id\'] : [\'get\', property];\n\n    conditions.push([\'==\', [\'typeof\', _get], expectedTypes[property]]);\n  }\n\n  if (conditions.length === 0) return true;\n  if (conditions.length === 1) return conditions[0];\n  return [\'all\'].concat(conditions);\n}\n\nfunction convertComparisonOp$1(property, value, op, expectedTypes) {\n  var get;\n\n  if (property === \'$type\') {\n    return [op, [\'geometry-type\'], value];\n  } else if (property === \'$id\') {\n    get = [\'id\'];\n  } else {\n    get = [\'get\', property];\n  }\n\n  if (expectedTypes && value !== null) {\n    var type = typeof value;\n    expectedTypes[property] = type;\n  }\n\n  if (op === \'==\' && property !== \'$id\' && value === null) {\n    return [\'all\', [\'has\', property], [\'==\', get, null]];\n  } else if (op === \'!=\' && property !== \'$id\' && value === null) {\n    return [\'any\', [\'!\', [\'has\', property]], [\'!=\', get, null]];\n  }\n\n  return [op, get, value];\n}\n\nfunction convertInOp$1(property, values) {\n  var negate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (values.length === 0) return negate;\n  var get;\n\n  if (property === \'$type\') {\n    get = [\'geometry-type\'];\n  } else if (property === \'$id\') {\n    get = [\'id\'];\n  } else {\n    get = [\'get\', property];\n  }\n\n  var uniformTypes = true;\n  var type = typeof values[0];\n\n  var _iterator49 = _createForOfIteratorHelper(values),\n      _step49;\n\n  try {\n    for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {\n      var value = _step49.value;\n\n      if (typeof value !== type) {\n        uniformTypes = false;\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator49.e(err);\n  } finally {\n    _iterator49.f();\n  }\n\n  if (uniformTypes && (type === \'string\' || type === \'number\')) {\n    var uniqueValues = values.sort().filter(function (v, i) {\n      return i === 0 || values[i - 1] !== v;\n    });\n    return [\'match\', get, uniqueValues, !negate, negate];\n  }\n\n  return [negate ? \'all\' : \'any\'].concat(values.map(function (v) {\n    return [negate ? \'!=\' : \'==\', get, v];\n  }));\n}\n\nfunction convertHasOp$1(property) {\n  if (property === \'$type\') {\n    return true;\n  } else if (property === \'$id\') {\n    return [\'!=\', [\'id\'], null];\n  } else {\n    return [\'has\', property];\n  }\n}\n\nfunction migrateToExpressions(style) {\n  var converted = [];\n  eachLayer(style, function (layer) {\n    if (layer.filter) {\n      layer.filter = convertFilter$1(layer.filter);\n    }\n  });\n  eachProperty(style, {\n    paint: true,\n    layout: true\n  }, function (_ref112) {\n    var path = _ref112.path,\n        value = _ref112.value,\n        reference = _ref112.reference,\n        set = _ref112.set;\n    if (isExpression(value)) return;\n\n    if (typeof value === \'object\' && !Array.isArray(value)) {\n      set(convertFunction(value, reference));\n      converted.push(path.join(\'.\'));\n    } else if (reference.tokens && typeof value === \'string\') {\n      set(convertTokenString(value));\n    }\n  });\n  return style;\n}\n\nfunction migrate(style) {\n  var migrated = false;\n\n  if (style.version === 7) {\n    style = migrateToV8(style);\n    migrated = true;\n  }\n\n  if (style.version === 8) {\n    migrated = migrateToExpressions(style);\n    migrated = true;\n  }\n\n  if (!migrated) {\n    throw new Error(\'cannot migrate from\', style.version);\n  }\n\n  return style;\n}\n\nfunction composite(style) {\n  var styleIDs = [];\n  var sourceIDs = [];\n  var compositedSourceLayers = [];\n\n  for (var id in style.sources) {\n    var _source = style.sources[id];\n    if (_source.type !== \'vector\') continue;\n    var match = /^mapbox:\\/\\/(.*)/.exec(_source.url);\n    if (!match) continue;\n    styleIDs.push(id);\n    sourceIDs.push(match[1]);\n  }\n\n  if (styleIDs.length < 2) return style;\n  styleIDs.forEach(function (id) {\n    delete style.sources[id];\n  });\n  var compositeID = sourceIDs.join(\',\');\n  style.sources[compositeID] = {\n    \'type\': \'vector\',\n    \'url\': "mapbox://".concat(compositeID)\n  };\n  style.layers.forEach(function (layer) {\n    if (styleIDs.indexOf(layer.source) >= 0) {\n      layer.source = compositeID;\n\n      if (\'source-layer\' in layer) {\n        if (compositedSourceLayers.indexOf(layer[\'source-layer\']) >= 0) {\n          throw new Error(\'Conflicting source layer names\');\n        } else {\n          compositedSourceLayers.push(layer[\'source-layer\']);\n        }\n      }\n    }\n  });\n  return style;\n}\n\nvar refProperties = [\'type\', \'source\', \'source-layer\', \'minzoom\', \'maxzoom\', \'filter\', \'layout\'];\n\nfunction deref(layer, parent) {\n  var result = {};\n\n  for (var k in layer) {\n    if (k !== \'ref\') {\n      result[k] = layer[k];\n    }\n  }\n\n  refProperties.forEach(function (k) {\n    if (k in parent) {\n      result[k] = parent[k];\n    }\n  });\n  return result;\n}\n\nfunction derefLayers(layers) {\n  layers = layers.slice();\n  var map = Object.create(null);\n\n  for (var i = 0; i < layers.length; i++) {\n    map[layers[i].id] = layers[i];\n  }\n\n  for (var _i8 = 0; _i8 < layers.length; _i8++) {\n    if (\'ref\' in layers[_i8]) {\n      layers[_i8] = deref(layers[_i8], map[layers[_i8].ref]);\n    }\n  }\n\n  return layers;\n}\n\nfunction deepEqual(a, b) {\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n\n    return true;\n  }\n\n  if (typeof a === \'object\' && a !== null && b !== null) {\n    if (!(typeof b === \'object\')) return false;\n    var keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length) return false;\n\n    for (var key in a) {\n      if (!deepEqual(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a === b;\n}\n\nvar operations = {\n  setStyle: \'setStyle\',\n  addLayer: \'addLayer\',\n  removeLayer: \'removeLayer\',\n  setPaintProperty: \'setPaintProperty\',\n  setLayoutProperty: \'setLayoutProperty\',\n  setFilter: \'setFilter\',\n  addSource: \'addSource\',\n  removeSource: \'removeSource\',\n  setGeoJSONSourceData: \'setGeoJSONSourceData\',\n  setLayerZoomRange: \'setLayerZoomRange\',\n  setLayerProperty: \'setLayerProperty\',\n  setCenter: \'setCenter\',\n  setZoom: \'setZoom\',\n  setBearing: \'setBearing\',\n  setPitch: \'setPitch\',\n  setSprite: \'setSprite\',\n  setGlyphs: \'setGlyphs\',\n  setTransition: \'setTransition\',\n  setLight: \'setLight\',\n  setTerrain: \'setTerrain\',\n  setFog: \'setFog\'\n};\n\nfunction addSource(sourceId, after, commands) {\n  commands.push({\n    command: operations.addSource,\n    args: [sourceId, after[sourceId]]\n  });\n}\n\nfunction removeSource(sourceId, commands, sourcesRemoved) {\n  commands.push({\n    command: operations.removeSource,\n    args: [sourceId]\n  });\n  sourcesRemoved[sourceId] = true;\n}\n\nfunction updateSource(sourceId, after, commands, sourcesRemoved) {\n  removeSource(sourceId, commands, sourcesRemoved);\n  addSource(sourceId, after, commands);\n}\n\nfunction canUpdateGeoJSON(before, after, sourceId) {\n  var prop;\n\n  for (prop in before[sourceId]) {\n    if (!before[sourceId].hasOwnProperty(prop)) continue;\n\n    if (prop !== \'data\' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {\n      return false;\n    }\n  }\n\n  for (prop in after[sourceId]) {\n    if (!after[sourceId].hasOwnProperty(prop)) continue;\n\n    if (prop !== \'data\' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction diffSources(before, after, commands, sourcesRemoved) {\n  before = before || {};\n  after = after || {};\n  var sourceId;\n\n  for (sourceId in before) {\n    if (!before.hasOwnProperty(sourceId)) continue;\n\n    if (!after.hasOwnProperty(sourceId)) {\n      removeSource(sourceId, commands, sourcesRemoved);\n    }\n  }\n\n  for (sourceId in after) {\n    if (!after.hasOwnProperty(sourceId)) continue;\n\n    if (!before.hasOwnProperty(sourceId)) {\n      addSource(sourceId, after, commands);\n    } else if (!deepEqual(before[sourceId], after[sourceId])) {\n      if (before[sourceId].type === \'geojson\' && after[sourceId].type === \'geojson\' && canUpdateGeoJSON(before, after, sourceId)) {\n        commands.push({\n          command: operations.setGeoJSONSourceData,\n          args: [sourceId, after[sourceId].data]\n        });\n      } else {\n        updateSource(sourceId, after, commands, sourcesRemoved);\n      }\n    }\n  }\n}\n\nfunction diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {\n  before = before || {};\n  after = after || {};\n  var prop;\n\n  for (prop in before) {\n    if (!before.hasOwnProperty(prop)) continue;\n\n    if (!deepEqual(before[prop], after[prop])) {\n      commands.push({\n        command: command,\n        args: [layerId, prop, after[prop], klass]\n      });\n    }\n  }\n\n  for (prop in after) {\n    if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) continue;\n\n    if (!deepEqual(before[prop], after[prop])) {\n      commands.push({\n        command: command,\n        args: [layerId, prop, after[prop], klass]\n      });\n    }\n  }\n}\n\nfunction pluckId(layer) {\n  return layer.id;\n}\n\nfunction indexById(group, layer) {\n  group[layer.id] = layer;\n  return group;\n}\n\nfunction diffLayers(before, after, commands) {\n  before = before || [];\n  after = after || [];\n  var beforeOrder = before.map(pluckId);\n  var afterOrder = after.map(pluckId);\n  var beforeIndex = before.reduce(indexById, {});\n  var afterIndex = after.reduce(indexById, {});\n  var tracker = beforeOrder.slice();\n  var clean = Object.create(null);\n  var i, d, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;\n\n  for (i = 0, d = 0; i < beforeOrder.length; i++) {\n    layerId = beforeOrder[i];\n\n    if (!afterIndex.hasOwnProperty(layerId)) {\n      commands.push({\n        command: operations.removeLayer,\n        args: [layerId]\n      });\n      tracker.splice(tracker.indexOf(layerId, d), 1);\n    } else {\n      d++;\n    }\n  }\n\n  for (i = 0, d = 0; i < afterOrder.length; i++) {\n    layerId = afterOrder[afterOrder.length - 1 - i];\n    if (tracker[tracker.length - 1 - i] === layerId) continue;\n\n    if (beforeIndex.hasOwnProperty(layerId)) {\n      commands.push({\n        command: operations.removeLayer,\n        args: [layerId]\n      });\n      tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);\n    } else {\n      d++;\n    }\n\n    insertBeforeLayerId = tracker[tracker.length - i];\n    commands.push({\n      command: operations.addLayer,\n      args: [afterIndex[layerId], insertBeforeLayerId]\n    });\n    tracker.splice(tracker.length - i, 0, layerId);\n    clean[layerId] = true;\n  }\n\n  for (i = 0; i < afterOrder.length; i++) {\n    layerId = afterOrder[i];\n    beforeLayer = beforeIndex[layerId];\n    afterLayer = afterIndex[layerId];\n    if (clean[layerId] || deepEqual(beforeLayer, afterLayer)) continue;\n\n    if (!deepEqual(beforeLayer.source, afterLayer.source) || !deepEqual(beforeLayer[\'source-layer\'], afterLayer[\'source-layer\']) || !deepEqual(beforeLayer.type, afterLayer.type)) {\n      commands.push({\n        command: operations.removeLayer,\n        args: [layerId]\n      });\n      insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];\n      commands.push({\n        command: operations.addLayer,\n        args: [afterLayer, insertBeforeLayerId]\n      });\n      continue;\n    }\n\n    diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);\n    diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);\n\n    if (!deepEqual(beforeLayer.filter, afterLayer.filter)) {\n      commands.push({\n        command: operations.setFilter,\n        args: [layerId, afterLayer.filter]\n      });\n    }\n\n    if (!deepEqual(beforeLayer.minzoom, afterLayer.minzoom) || !deepEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {\n      commands.push({\n        command: operations.setLayerZoomRange,\n        args: [layerId, afterLayer.minzoom, afterLayer.maxzoom]\n      });\n    }\n\n    for (prop in beforeLayer) {\n      if (!beforeLayer.hasOwnProperty(prop)) continue;\n      if (prop === \'layout\' || prop === \'paint\' || prop === \'filter\' || prop === \'metadata\' || prop === \'minzoom\' || prop === \'maxzoom\') continue;\n\n      if (prop.indexOf(\'paint.\') === 0) {\n        diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);\n      } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {\n        commands.push({\n          command: operations.setLayerProperty,\n          args: [layerId, prop, afterLayer[prop]]\n        });\n      }\n    }\n\n    for (prop in afterLayer) {\n      if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) continue;\n      if (prop === \'layout\' || prop === \'paint\' || prop === \'filter\' || prop === \'metadata\' || prop === \'minzoom\' || prop === \'maxzoom\') continue;\n\n      if (prop.indexOf(\'paint.\') === 0) {\n        diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);\n      } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {\n        commands.push({\n          command: operations.setLayerProperty,\n          args: [layerId, prop, afterLayer[prop]]\n        });\n      }\n    }\n  }\n}\n\nfunction diffStyles(before, after) {\n  if (!before) return [{\n    command: operations.setStyle,\n    args: [after]\n  }];\n  var commands = [];\n\n  try {\n    if (!deepEqual(before.version, after.version)) {\n      return [{\n        command: operations.setStyle,\n        args: [after]\n      }];\n    }\n\n    if (!deepEqual(before.center, after.center)) {\n      commands.push({\n        command: operations.setCenter,\n        args: [after.center]\n      });\n    }\n\n    if (!deepEqual(before.zoom, after.zoom)) {\n      commands.push({\n        command: operations.setZoom,\n        args: [after.zoom]\n      });\n    }\n\n    if (!deepEqual(before.bearing, after.bearing)) {\n      commands.push({\n        command: operations.setBearing,\n        args: [after.bearing]\n      });\n    }\n\n    if (!deepEqual(before.pitch, after.pitch)) {\n      commands.push({\n        command: operations.setPitch,\n        args: [after.pitch]\n      });\n    }\n\n    if (!deepEqual(before.sprite, after.sprite)) {\n      commands.push({\n        command: operations.setSprite,\n        args: [after.sprite]\n      });\n    }\n\n    if (!deepEqual(before.glyphs, after.glyphs)) {\n      commands.push({\n        command: operations.setGlyphs,\n        args: [after.glyphs]\n      });\n    }\n\n    if (!deepEqual(before.transition, after.transition)) {\n      commands.push({\n        command: operations.setTransition,\n        args: [after.transition]\n      });\n    }\n\n    if (!deepEqual(before.light, after.light)) {\n      commands.push({\n        command: operations.setLight,\n        args: [after.light]\n      });\n    }\n\n    if (!deepEqual(before.fog, after.fog)) {\n      commands.push({\n        command: operations.setFog,\n        args: [after.fog]\n      });\n    }\n\n    var sourcesRemoved = {};\n    var removeOrAddSourceCommands = [];\n    diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);\n    var beforeLayers = [];\n\n    if (before.layers) {\n      before.layers.forEach(function (layer) {\n        if (sourcesRemoved[layer.source]) {\n          commands.push({\n            command: operations.removeLayer,\n            args: [layer.id]\n          });\n        } else {\n          beforeLayers.push(layer);\n        }\n      });\n    }\n\n    var beforeTerrain = before.terrain;\n\n    if (beforeTerrain) {\n      if (sourcesRemoved[beforeTerrain.source]) {\n        commands.push({\n          command: operations.setTerrain,\n          args: [undefined]\n        });\n        beforeTerrain = undefined;\n      }\n    }\n\n    commands = commands.concat(removeOrAddSourceCommands);\n\n    if (!deepEqual(beforeTerrain, after.terrain)) {\n      commands.push({\n        command: operations.setTerrain,\n        args: [after.terrain]\n      });\n    }\n\n    diffLayers(beforeLayers, after.layers, commands);\n  } catch (e) {\n    console.warn(\'Unable to compute style diff:\', e);\n    commands = [{\n      command: operations.setStyle,\n      args: [after]\n    }];\n  }\n\n  return commands;\n}\n\nvar ValidationError = function ValidationError(key, value, message, identifier) {\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ValidationError);\n\n  this.message = (key ? "".concat(key, ": ") : \'\') + message;\n  if (identifier) this.identifier = identifier;\n\n  if (value !== null && value !== undefined && value.__line__) {\n    this.line = value.__line__;\n  }\n};\n\nvar ParsingError$1 = function ParsingError$1(error) {\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ParsingError$1);\n\n  this.error = error;\n  this.message = error.message;\n  var match = error.message.match(/line (\\d+)/);\n  this.line = match ? parseInt(match[1], 10) : 0;\n};\n\nfunction validateConstants(options) {\n  var key = options.key;\n  var constants = options.value;\n\n  if (constants) {\n    return [new ValidationError(key, constants, \'constants have been deprecated as of v8\')];\n  } else {\n    return [];\n  }\n}\n\nfunction unbundle(value) {\n  if (value instanceof Number || value instanceof String || value instanceof Boolean) {\n    return value.valueOf();\n  } else {\n    return value;\n  }\n}\n\nfunction deepUnbundle(value) {\n  if (Array.isArray(value)) {\n    return value.map(deepUnbundle);\n  } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {\n    var unbundledValue = {};\n\n    for (var key in value) {\n      unbundledValue[key] = deepUnbundle(value[key]);\n    }\n\n    return unbundledValue;\n  }\n\n  return unbundle(value);\n}\n\nfunction validateObject(options) {\n  var key = options.key;\n  var object = options.value;\n  var elementSpecs = options.valueSpec || {};\n  var elementValidators = options.objectElementValidators || {};\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n  var errors = [];\n  var type = getType(object);\n\n  if (type !== \'object\') {\n    return [new ValidationError(key, object, "object expected, ".concat(type, " found"))];\n  }\n\n  for (var objectKey in object) {\n    var elementSpecKey = objectKey.split(\'.\')[0];\n    var elementSpec = elementSpecs[elementSpecKey] || elementSpecs[\'*\'];\n    var validateElement = void 0;\n\n    if (elementValidators[elementSpecKey]) {\n      validateElement = elementValidators[elementSpecKey];\n    } else if (elementSpecs[elementSpecKey]) {\n      validateElement = validate;\n    } else if (elementValidators[\'*\']) {\n      validateElement = elementValidators[\'*\'];\n    } else if (elementSpecs[\'*\']) {\n      validateElement = validate;\n    } else {\n      errors.push(new ValidationError(key, object[objectKey], "unknown property \\"".concat(objectKey, "\\"")));\n      continue;\n    }\n\n    errors = errors.concat(validateElement({\n      key: (key ? "".concat(key, ".") : key) + objectKey,\n      value: object[objectKey],\n      valueSpec: elementSpec,\n      style: style,\n      styleSpec: styleSpec,\n      object: object,\n      objectKey: objectKey\n    }, object));\n  }\n\n  for (var _elementSpecKey in elementSpecs) {\n    if (elementValidators[_elementSpecKey]) {\n      continue;\n    }\n\n    if (elementSpecs[_elementSpecKey].required && elementSpecs[_elementSpecKey][\'default\'] === undefined && object[_elementSpecKey] === undefined) {\n      errors.push(new ValidationError(key, object, "missing required property \\"".concat(_elementSpecKey, "\\"")));\n    }\n  }\n\n  return errors;\n}\n\nfunction validateArray(options) {\n  var array = options.value;\n  var arraySpec = options.valueSpec;\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n  var key = options.key;\n  var validateArrayElement = options.arrayElementValidator || validate;\n\n  if (getType(array) !== \'array\') {\n    return [new ValidationError(key, array, "array expected, ".concat(getType(array), " found"))];\n  }\n\n  if (arraySpec.length && array.length !== arraySpec.length) {\n    return [new ValidationError(key, array, "array length ".concat(arraySpec.length, " expected, length ").concat(array.length, " found"))];\n  }\n\n  if (arraySpec[\'min-length\'] && array.length < arraySpec[\'min-length\']) {\n    return [new ValidationError(key, array, "array length at least ".concat(arraySpec[\'min-length\'], " expected, length ").concat(array.length, " found"))];\n  }\n\n  var arrayElementSpec = {\n    \'type\': arraySpec.value,\n    \'values\': arraySpec.values,\n    \'minimum\': arraySpec.minimum,\n    \'maximum\': arraySpec.maximum\n  };\n\n  if (styleSpec.$version < 7) {\n    arrayElementSpec.function = arraySpec.function;\n  }\n\n  if (getType(arraySpec.value) === \'object\') {\n    arrayElementSpec = arraySpec.value;\n  }\n\n  var errors = [];\n\n  for (var i = 0; i < array.length; i++) {\n    errors = errors.concat(validateArrayElement({\n      array: array,\n      arrayIndex: i,\n      value: array[i],\n      valueSpec: arrayElementSpec,\n      style: style,\n      styleSpec: styleSpec,\n      key: "".concat(key, "[").concat(i, "]")\n    }));\n  }\n\n  return errors;\n}\n\nfunction validateNumber(options) {\n  var key = options.key;\n  var value = options.value;\n  var valueSpec = options.valueSpec;\n  var type = getType(value);\n\n  if (type === \'number\' && value !== value) {\n    type = \'NaN\';\n  }\n\n  if (type !== \'number\') {\n    return [new ValidationError(key, value, "number expected, ".concat(type, " found"))];\n  }\n\n  if (\'minimum\' in valueSpec) {\n    var specMin = valueSpec.minimum;\n\n    if (getType(valueSpec.minimum) === \'array\') {\n      var i = options.arrayIndex;\n      specMin = valueSpec.minimum[i];\n    }\n\n    if (value < specMin) {\n      return [new ValidationError(key, value, "".concat(value, " is less than the minimum value ").concat(specMin))];\n    }\n  }\n\n  if (\'maximum\' in valueSpec) {\n    var specMax = valueSpec.maximum;\n\n    if (getType(valueSpec.maximum) === \'array\') {\n      var _i9 = options.arrayIndex;\n      specMax = valueSpec.maximum[_i9];\n    }\n\n    if (value > specMax) {\n      return [new ValidationError(key, value, "".concat(value, " is greater than the maximum value ").concat(specMax))];\n    }\n  }\n\n  return [];\n}\n\nfunction validateFunction(options) {\n  var functionValueSpec = options.valueSpec;\n  var functionType = unbundle(options.value.type);\n  var stopKeyType;\n  var stopDomainValues = {};\n  var previousStopDomainValue;\n  var previousStopDomainZoom;\n  var isZoomFunction = functionType !== \'categorical\' && options.value.property === undefined;\n  var isPropertyFunction = !isZoomFunction;\n  var isZoomAndPropertyFunction = getType(options.value.stops) === \'array\' && getType(options.value.stops[0]) === \'array\' && getType(options.value.stops[0][0]) === \'object\';\n  var errors = validateObject({\n    key: options.key,\n    value: options.value,\n    valueSpec: options.styleSpec.function,\n    style: options.style,\n    styleSpec: options.styleSpec,\n    objectElementValidators: {\n      stops: validateFunctionStops,\n      default: validateFunctionDefault\n    }\n  });\n\n  if (functionType === \'identity\' && isZoomFunction) {\n    errors.push(new ValidationError(options.key, options.value, \'missing required property "property"\'));\n  }\n\n  if (functionType !== \'identity\' && !options.value.stops) {\n    errors.push(new ValidationError(options.key, options.value, \'missing required property "stops"\'));\n  }\n\n  if (functionType === \'exponential\' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {\n    errors.push(new ValidationError(options.key, options.value, \'exponential functions not supported\'));\n  }\n\n  if (options.styleSpec.$version >= 8) {\n    if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {\n      errors.push(new ValidationError(options.key, options.value, \'property functions not supported\'));\n    } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {\n      errors.push(new ValidationError(options.key, options.value, \'zoom functions not supported\'));\n    }\n  }\n\n  if ((functionType === \'categorical\' || isZoomAndPropertyFunction) && options.value.property === undefined) {\n    errors.push(new ValidationError(options.key, options.value, \'"property" property is required\'));\n  }\n\n  return errors;\n\n  function validateFunctionStops(options) {\n    if (functionType === \'identity\') {\n      return [new ValidationError(options.key, options.value, \'identity function may not have a "stops" property\')];\n    }\n\n    var errors = [];\n    var value = options.value;\n    errors = errors.concat(validateArray({\n      key: options.key,\n      value: value,\n      valueSpec: options.valueSpec,\n      style: options.style,\n      styleSpec: options.styleSpec,\n      arrayElementValidator: validateFunctionStop\n    }));\n\n    if (getType(value) === \'array\' && value.length === 0) {\n      errors.push(new ValidationError(options.key, value, \'array must have at least one stop\'));\n    }\n\n    return errors;\n  }\n\n  function validateFunctionStop(options) {\n    var errors = [];\n    var value = options.value;\n    var key = options.key;\n\n    if (getType(value) !== \'array\') {\n      return [new ValidationError(key, value, "array expected, ".concat(getType(value), " found"))];\n    }\n\n    if (value.length !== 2) {\n      return [new ValidationError(key, value, "array length 2 expected, length ".concat(value.length, " found"))];\n    }\n\n    if (isZoomAndPropertyFunction) {\n      if (getType(value[0]) !== \'object\') {\n        return [new ValidationError(key, value, "object expected, ".concat(getType(value[0]), " found"))];\n      }\n\n      if (value[0].zoom === undefined) {\n        return [new ValidationError(key, value, \'object stop key must have zoom\')];\n      }\n\n      if (value[0].value === undefined) {\n        return [new ValidationError(key, value, \'object stop key must have value\')];\n      }\n\n      if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {\n        return [new ValidationError(key, value[0].zoom, \'stop zoom values must appear in ascending order\')];\n      }\n\n      if (unbundle(value[0].zoom) !== previousStopDomainZoom) {\n        previousStopDomainZoom = unbundle(value[0].zoom);\n        previousStopDomainValue = undefined;\n        stopDomainValues = {};\n      }\n\n      errors = errors.concat(validateObject({\n        key: "".concat(key, "[0]"),\n        value: value[0],\n        valueSpec: {\n          zoom: {}\n        },\n        style: options.style,\n        styleSpec: options.styleSpec,\n        objectElementValidators: {\n          zoom: validateNumber,\n          value: validateStopDomainValue\n        }\n      }));\n    } else {\n      errors = errors.concat(validateStopDomainValue({\n        key: "".concat(key, "[0]"),\n        value: value[0],\n        valueSpec: {},\n        style: options.style,\n        styleSpec: options.styleSpec\n      }, value));\n    }\n\n    if (isExpression(deepUnbundle(value[1]))) {\n      return errors.concat([new ValidationError("".concat(key, "[1]"), value[1], \'expressions are not allowed in function stops.\')]);\n    }\n\n    return errors.concat(validate({\n      key: "".concat(key, "[1]"),\n      value: value[1],\n      valueSpec: functionValueSpec,\n      style: options.style,\n      styleSpec: options.styleSpec\n    }));\n  }\n\n  function validateStopDomainValue(options, stop) {\n    var type = getType(options.value);\n    var value = unbundle(options.value);\n    var reportValue = options.value !== null ? options.value : stop;\n\n    if (!stopKeyType) {\n      stopKeyType = type;\n    } else if (type !== stopKeyType) {\n      return [new ValidationError(options.key, reportValue, "".concat(type, " stop domain type must match previous stop domain type ").concat(stopKeyType))];\n    }\n\n    if (type !== \'number\' && type !== \'string\' && type !== \'boolean\') {\n      return [new ValidationError(options.key, reportValue, \'stop domain value must be a number, string, or boolean\')];\n    }\n\n    if (type !== \'number\' && functionType !== \'categorical\') {\n      var message = "number expected, ".concat(type, " found");\n\n      if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {\n        message += \'\\nIf you intended to use a categorical function, specify `"type": "categorical"`.\';\n      }\n\n      return [new ValidationError(options.key, reportValue, message)];\n    }\n\n    if (functionType === \'categorical\' && type === \'number\' && (!isFinite(value) || Math.floor(value) !== value)) {\n      return [new ValidationError(options.key, reportValue, "integer expected, found ".concat(value))];\n    }\n\n    if (functionType !== \'categorical\' && type === \'number\' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {\n      return [new ValidationError(options.key, reportValue, \'stop domain values must appear in ascending order\')];\n    } else {\n      previousStopDomainValue = value;\n    }\n\n    if (functionType === \'categorical\' && value in stopDomainValues) {\n      return [new ValidationError(options.key, reportValue, \'stop domain values must be unique\')];\n    } else {\n      stopDomainValues[value] = true;\n    }\n\n    return [];\n  }\n\n  function validateFunctionDefault(options) {\n    return validate({\n      key: options.key,\n      value: options.value,\n      valueSpec: functionValueSpec,\n      style: options.style,\n      styleSpec: options.styleSpec\n    });\n  }\n}\n\nfunction validateExpression(options) {\n  var expression = (options.expressionContext === \'property\' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);\n\n  if (expression.result === \'error\') {\n    return expression.value.map(function (error) {\n      return new ValidationError("".concat(options.key).concat(error.key), options.value, error.message);\n    });\n  }\n\n  var expressionObj = expression.value.expression || expression.value._styleExpression.expression;\n\n  if (options.expressionContext === \'property\' && options.propertyKey === \'text-font\' && !expressionObj.outputDefined()) {\n    return [new ValidationError(options.key, options.value, "Invalid data expression for \\"".concat(options.propertyKey, "\\". Output values must be contained as literals within the expression."))];\n  }\n\n  if (options.expressionContext === \'property\' && options.propertyType === \'layout\' && !isStateConstant(expressionObj)) {\n    return [new ValidationError(options.key, options.value, \'"feature-state" data expressions are not supported with layout properties.\')];\n  }\n\n  if (options.expressionContext === \'filter\' && !isStateConstant(expressionObj)) {\n    return [new ValidationError(options.key, options.value, \'"feature-state" data expressions are not supported with filters.\')];\n  }\n\n  if (options.expressionContext && options.expressionContext.indexOf(\'cluster\') === 0) {\n    if (!isGlobalPropertyConstant(expressionObj, [\'zoom\', \'feature-state\'])) {\n      return [new ValidationError(options.key, options.value, \'"zoom" and "feature-state" expressions are not supported with cluster properties.\')];\n    }\n\n    if (options.expressionContext === \'cluster-initial\' && !isFeatureConstant(expressionObj)) {\n      return [new ValidationError(options.key, options.value, \'Feature data expressions are not supported with initial expression part of cluster properties.\')];\n    }\n  }\n\n  return [];\n}\n\nfunction validateBoolean(options) {\n  var value = options.value;\n  var key = options.key;\n  var type = getType(value);\n\n  if (type !== \'boolean\') {\n    return [new ValidationError(key, value, "boolean expected, ".concat(type, " found"))];\n  }\n\n  return [];\n}\n\nfunction validateColor(options) {\n  var key = options.key;\n  var value = options.value;\n  var type = getType(value);\n\n  if (type !== \'string\') {\n    return [new ValidationError(key, value, "color expected, ".concat(type, " found"))];\n  }\n\n  if (csscolorparser.parseCSSColor(value) === null) {\n    return [new ValidationError(key, value, "color expected, \\"".concat(value, "\\" found"))];\n  }\n\n  return [];\n}\n\nfunction validateEnum(options) {\n  var key = options.key;\n  var value = options.value;\n  var valueSpec = options.valueSpec;\n  var errors = [];\n\n  if (Array.isArray(valueSpec.values)) {\n    if (valueSpec.values.indexOf(unbundle(value)) === -1) {\n      errors.push(new ValidationError(key, value, "expected one of [".concat(valueSpec.values.join(\', \'), "], ").concat(JSON.stringify(value), " found")));\n    }\n  } else {\n    if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {\n      errors.push(new ValidationError(key, value, "expected one of [".concat(Object.keys(valueSpec.values).join(\', \'), "], ").concat(JSON.stringify(value), " found")));\n    }\n  }\n\n  return errors;\n}\n\nfunction validateFilter(options) {\n  if (isExpressionFilter(deepUnbundle(options.value))) {\n    return validateExpression(extend({}, options, {\n      expressionContext: \'filter\',\n      valueSpec: {\n        value: \'boolean\'\n      }\n    }));\n  } else {\n    return validateNonExpressionFilter(options);\n  }\n}\n\nfunction validateNonExpressionFilter(options) {\n  var value = options.value;\n  var key = options.key;\n\n  if (getType(value) !== \'array\') {\n    return [new ValidationError(key, value, "array expected, ".concat(getType(value), " found"))];\n  }\n\n  var styleSpec = options.styleSpec;\n  var type;\n  var errors = [];\n\n  if (value.length < 1) {\n    return [new ValidationError(key, value, \'filter array must have at least 1 element\')];\n  }\n\n  errors = errors.concat(validateEnum({\n    key: "".concat(key, "[0]"),\n    value: value[0],\n    valueSpec: styleSpec.filter_operator,\n    style: options.style,\n    styleSpec: options.styleSpec\n  }));\n\n  switch (unbundle(value[0])) {\n    case \'<\':\n    case \'<=\':\n    case \'>\':\n    case \'>=\':\n      if (value.length >= 2 && unbundle(value[1]) === \'$type\') {\n        errors.push(new ValidationError(key, value, "\\"$type\\" cannot be use with operator \\"".concat(value[0], "\\"")));\n      }\n\n    case \'==\':\n    case \'!=\':\n      if (value.length !== 3) {\n        errors.push(new ValidationError(key, value, "filter array for operator \\"".concat(value[0], "\\" must have 3 elements")));\n      }\n\n    case \'in\':\n    case \'!in\':\n      if (value.length >= 2) {\n        type = getType(value[1]);\n\n        if (type !== \'string\') {\n          errors.push(new ValidationError("".concat(key, "[1]"), value[1], "string expected, ".concat(type, " found")));\n        }\n      }\n\n      for (var i = 2; i < value.length; i++) {\n        type = getType(value[i]);\n\n        if (unbundle(value[1]) === \'$type\') {\n          errors = errors.concat(validateEnum({\n            key: "".concat(key, "[").concat(i, "]"),\n            value: value[i],\n            valueSpec: styleSpec.geometry_type,\n            style: options.style,\n            styleSpec: options.styleSpec\n          }));\n        } else if (type !== \'string\' && type !== \'number\' && type !== \'boolean\') {\n          errors.push(new ValidationError("".concat(key, "[").concat(i, "]"), value[i], "string, number, or boolean expected, ".concat(type, " found")));\n        }\n      }\n\n      break;\n\n    case \'any\':\n    case \'all\':\n    case \'none\':\n      for (var _i10 = 1; _i10 < value.length; _i10++) {\n        errors = errors.concat(validateNonExpressionFilter({\n          key: "".concat(key, "[").concat(_i10, "]"),\n          value: value[_i10],\n          style: options.style,\n          styleSpec: options.styleSpec\n        }));\n      }\n\n      break;\n\n    case \'has\':\n    case \'!has\':\n      type = getType(value[1]);\n\n      if (value.length !== 2) {\n        errors.push(new ValidationError(key, value, "filter array for \\"".concat(value[0], "\\" operator must have 2 elements")));\n      } else if (type !== \'string\') {\n        errors.push(new ValidationError("".concat(key, "[1]"), value[1], "string expected, ".concat(type, " found")));\n      }\n\n      break;\n\n    case \'within\':\n      type = getType(value[1]);\n\n      if (value.length !== 2) {\n        errors.push(new ValidationError(key, value, "filter array for \\"".concat(value[0], "\\" operator must have 2 elements")));\n      } else if (type !== \'object\') {\n        errors.push(new ValidationError("".concat(key, "[1]"), value[1], "object expected, ".concat(type, " found")));\n      }\n\n      break;\n  }\n\n  return errors;\n}\n\nfunction validateProperty(options, propertyType) {\n  var key = options.key;\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n  var value = options.value;\n  var propertyKey = options.objectKey;\n  var layerSpec = styleSpec["".concat(propertyType, "_").concat(options.layerType)];\n  if (!layerSpec) return [];\n  var transitionMatch = propertyKey.match(/^(.*)-transition$/);\n\n  if (propertyType === \'paint\' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {\n    return validate({\n      key: key,\n      value: value,\n      valueSpec: styleSpec.transition,\n      style: style,\n      styleSpec: styleSpec\n    });\n  }\n\n  var valueSpec = options.valueSpec || layerSpec[propertyKey];\n\n  if (!valueSpec) {\n    return [new ValidationError(key, value, "unknown property \\"".concat(propertyKey, "\\""))];\n  }\n\n  var tokenMatch;\n\n  if (getType(value) === \'string\' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {\n    return [new ValidationError(key, value, "\\"".concat(propertyKey, "\\" does not support interpolation syntax\\n") + "Use an identity property function instead: `{ \\"type\\": \\"identity\\", \\"property\\": ".concat(JSON.stringify(tokenMatch[1]), " }`."))];\n  }\n\n  var errors = [];\n\n  if (options.layerType === \'symbol\') {\n    if (propertyKey === \'text-field\' && style && !style.glyphs) {\n      errors.push(new ValidationError(key, value, \'use of "text-field" requires a style "glyphs" property\'));\n    }\n\n    if (propertyKey === \'text-font\' && isFunction$1(deepUnbundle(value)) && unbundle(value.type) === \'identity\') {\n      errors.push(new ValidationError(key, value, \'"text-font" does not support identity functions\'));\n    }\n  }\n\n  return errors.concat(validate({\n    key: options.key,\n    value: value,\n    valueSpec: valueSpec,\n    style: style,\n    styleSpec: styleSpec,\n    expressionContext: \'property\',\n    propertyType: propertyType,\n    propertyKey: propertyKey\n  }));\n}\n\nfunction validatePaintProperty(options) {\n  return validateProperty(options, \'paint\');\n}\n\nfunction validateLayoutProperty(options) {\n  return validateProperty(options, \'layout\');\n}\n\nfunction validateLayer(options) {\n  var errors = [];\n  var layer = options.value;\n  var key = options.key;\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n\n  if (!layer.type && !layer.ref) {\n    errors.push(new ValidationError(key, layer, \'either "type" or "ref" is required\'));\n  }\n\n  var type = unbundle(layer.type);\n  var ref = unbundle(layer.ref);\n\n  if (layer.id) {\n    var layerId = unbundle(layer.id);\n\n    for (var i = 0; i < options.arrayIndex; i++) {\n      var otherLayer = style.layers[i];\n\n      if (unbundle(otherLayer.id) === layerId) {\n        errors.push(new ValidationError(key, layer.id, "duplicate layer id \\"".concat(layer.id, "\\", previously used at line ").concat(otherLayer.id.__line__)));\n      }\n    }\n  }\n\n  if (\'ref\' in layer) {\n    [\'type\', \'source\', \'source-layer\', \'filter\', \'layout\'].forEach(function (p) {\n      if (p in layer) {\n        errors.push(new ValidationError(key, layer[p], "\\"".concat(p, "\\" is prohibited for ref layers")));\n      }\n    });\n    var parent;\n    style.layers.forEach(function (layer) {\n      if (unbundle(layer.id) === ref) parent = layer;\n    });\n\n    if (!parent) {\n      errors.push(new ValidationError(key, layer.ref, "ref layer \\"".concat(ref, "\\" not found")));\n    } else if (parent.ref) {\n      errors.push(new ValidationError(key, layer.ref, \'ref cannot reference another ref layer\'));\n    } else {\n      type = unbundle(parent.type);\n    }\n  } else if (!(type === \'background\' || type === \'sky\')) {\n    if (!layer.source) {\n      errors.push(new ValidationError(key, layer, \'missing required property "source"\'));\n    } else {\n      var _source2 = style.sources && style.sources[layer.source];\n\n      var sourceType = _source2 && unbundle(_source2.type);\n\n      if (!_source2) {\n        errors.push(new ValidationError(key, layer.source, "source \\"".concat(layer.source, "\\" not found")));\n      } else if (sourceType === \'vector\' && type === \'raster\') {\n        errors.push(new ValidationError(key, layer.source, "layer \\"".concat(layer.id, "\\" requires a raster source")));\n      } else if (sourceType === \'raster\' && type !== \'raster\') {\n        errors.push(new ValidationError(key, layer.source, "layer \\"".concat(layer.id, "\\" requires a vector source")));\n      } else if (sourceType === \'vector\' && !layer[\'source-layer\']) {\n        errors.push(new ValidationError(key, layer, "layer \\"".concat(layer.id, "\\" must specify a \\"source-layer\\"")));\n      } else if (sourceType === \'raster-dem\' && type !== \'hillshade\') {\n        errors.push(new ValidationError(key, layer.source, \'raster-dem source can only be used with layer type \\\'hillshade\\\'.\'));\n      } else if (type === \'line\' && layer.paint && layer.paint[\'line-gradient\'] && (sourceType !== \'geojson\' || !_source2.lineMetrics)) {\n        errors.push(new ValidationError(key, layer, "layer \\"".concat(layer.id, "\\" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.")));\n      }\n    }\n  }\n\n  errors = errors.concat(validateObject({\n    key: key,\n    value: layer,\n    valueSpec: styleSpec.layer,\n    style: options.style,\n    styleSpec: options.styleSpec,\n    objectElementValidators: {\n      \'*\': function _() {\n        return [];\n      },\n      type: function type() {\n        return validate({\n          key: "".concat(key, ".type"),\n          value: layer.type,\n          valueSpec: styleSpec.layer.type,\n          style: options.style,\n          styleSpec: options.styleSpec,\n          object: layer,\n          objectKey: \'type\'\n        });\n      },\n      filter: validateFilter,\n      layout: function layout(options) {\n        return validateObject({\n          layer: layer,\n          key: options.key,\n          value: options.value,\n          style: options.style,\n          styleSpec: options.styleSpec,\n          objectElementValidators: {\n            \'*\': function _(options) {\n              return validateLayoutProperty(extend({\n                layerType: type\n              }, options));\n            }\n          }\n        });\n      },\n      paint: function paint(options) {\n        return validateObject({\n          layer: layer,\n          key: options.key,\n          value: options.value,\n          style: options.style,\n          styleSpec: options.styleSpec,\n          objectElementValidators: {\n            \'*\': function _(options) {\n              return validatePaintProperty(extend({\n                layerType: type\n              }, options));\n            }\n          }\n        });\n      }\n    }\n  }));\n  return errors;\n}\n\nfunction validateString(options) {\n  var value = options.value;\n  var key = options.key;\n  var type = getType(value);\n\n  if (type !== \'string\') {\n    return [new ValidationError(key, value, "string expected, ".concat(type, " found"))];\n  }\n\n  return [];\n}\n\nvar objectElementValidators = {\n  promoteId: validatePromoteId\n};\n\nfunction validateSource(options) {\n  var value = options.value;\n  var key = options.key;\n  var styleSpec = options.styleSpec;\n  var style = options.style;\n\n  if (!value.type) {\n    return [new ValidationError(key, value, \'"type" is required\')];\n  }\n\n  var type = unbundle(value.type);\n  var errors;\n\n  switch (type) {\n    case \'vector\':\n    case \'raster\':\n    case \'raster-dem\':\n      errors = validateObject({\n        key: key,\n        value: value,\n        valueSpec: styleSpec["source_".concat(type.replace(\'-\', \'_\'))],\n        style: options.style,\n        styleSpec: styleSpec,\n        objectElementValidators: objectElementValidators\n      });\n      return errors;\n\n    case \'geojson\':\n      errors = validateObject({\n        key: key,\n        value: value,\n        valueSpec: styleSpec.source_geojson,\n        style: style,\n        styleSpec: styleSpec,\n        objectElementValidators: objectElementValidators\n      });\n\n      if (value.cluster) {\n        for (var prop in value.clusterProperties) {\n          var _errors, _errors2;\n\n          var _value$clusterPropert = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(value.clusterProperties[prop], 2),\n              operator = _value$clusterPropert[0],\n              mapExpr = _value$clusterPropert[1];\n\n          var reduceExpr = typeof operator === \'string\' ? [operator, [\'accumulated\'], [\'get\', prop]] : operator;\n\n          (_errors = errors).push.apply(_errors, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(validateExpression({\n            key: "".concat(key, ".").concat(prop, ".map"),\n            value: mapExpr,\n            expressionContext: \'cluster-map\'\n          })));\n\n          (_errors2 = errors).push.apply(_errors2, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(validateExpression({\n            key: "".concat(key, ".").concat(prop, ".reduce"),\n            value: reduceExpr,\n            expressionContext: \'cluster-reduce\'\n          })));\n        }\n      }\n\n      return errors;\n\n    case \'video\':\n      return validateObject({\n        key: key,\n        value: value,\n        valueSpec: styleSpec.source_video,\n        style: style,\n        styleSpec: styleSpec\n      });\n\n    case \'image\':\n      return validateObject({\n        key: key,\n        value: value,\n        valueSpec: styleSpec.source_image,\n        style: style,\n        styleSpec: styleSpec\n      });\n\n    case \'canvas\':\n      return [new ValidationError(key, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", \'source.canvas\')];\n\n    default:\n      return validateEnum({\n        key: "".concat(key, ".type"),\n        value: value.type,\n        valueSpec: {\n          values: [\'vector\', \'raster\', \'raster-dem\', \'geojson\', \'video\', \'image\']\n        },\n        style: style,\n        styleSpec: styleSpec\n      });\n  }\n}\n\nfunction validatePromoteId(_ref113) {\n  var key = _ref113.key,\n      value = _ref113.value;\n\n  if (getType(value) === \'string\') {\n    return validateString({\n      key: key,\n      value: value\n    });\n  } else {\n    var errors = [];\n\n    for (var prop in value) {\n      errors.push.apply(errors, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(validateString({\n        key: "".concat(key, ".").concat(prop),\n        value: value[prop]\n      })));\n    }\n\n    return errors;\n  }\n}\n\nfunction validateLight(options) {\n  var light = options.value;\n  var styleSpec = options.styleSpec;\n  var lightSpec = styleSpec.light;\n  var style = options.style;\n  var errors = [];\n  var rootType = getType(light);\n\n  if (light === undefined) {\n    return errors;\n  } else if (rootType !== \'object\') {\n    errors = errors.concat([new ValidationError(\'light\', light, "object expected, ".concat(rootType, " found"))]);\n    return errors;\n  }\n\n  for (var key in light) {\n    var transitionMatch = key.match(/^(.*)-transition$/);\n\n    if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {\n      errors = errors.concat(validate({\n        key: key,\n        value: light[key],\n        valueSpec: styleSpec.transition,\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else if (lightSpec[key]) {\n      errors = errors.concat(validate({\n        key: key,\n        value: light[key],\n        valueSpec: lightSpec[key],\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else {\n      errors = errors.concat([new ValidationError(key, light[key], "unknown property \\"".concat(key, "\\""))]);\n    }\n  }\n\n  return errors;\n}\n\nfunction validateTerrain(options) {\n  var terrain = options.value;\n  var key = options.key;\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n  var terrainSpec = styleSpec.terrain;\n  var errors = [];\n  var rootType = getType(terrain);\n\n  if (terrain === undefined) {\n    return errors;\n  } else if (rootType !== \'object\') {\n    errors = errors.concat([new ValidationError(\'terrain\', terrain, "object expected, ".concat(rootType, " found"))]);\n    return errors;\n  }\n\n  for (var _key6 in terrain) {\n    var transitionMatch = _key6.match(/^(.*)-transition$/);\n\n    if (transitionMatch && terrainSpec[transitionMatch[1]] && terrainSpec[transitionMatch[1]].transition) {\n      errors = errors.concat(validate({\n        key: _key6,\n        value: terrain[_key6],\n        valueSpec: styleSpec.transition,\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else if (terrainSpec[_key6]) {\n      errors = errors.concat(validate({\n        key: _key6,\n        value: terrain[_key6],\n        valueSpec: terrainSpec[_key6],\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else {\n      errors = errors.concat([new ValidationError(_key6, terrain[_key6], "unknown property \\"".concat(_key6, "\\""))]);\n    }\n  }\n\n  if (!terrain.source) {\n    errors.push(new ValidationError(key, terrain, "terrain is missing required property \\"source\\""));\n  } else {\n    var _source3 = style.sources && style.sources[terrain.source];\n\n    var sourceType = _source3 && unbundle(_source3.type);\n\n    if (!_source3) {\n      errors.push(new ValidationError(key, terrain.source, "source \\"".concat(terrain.source, "\\" not found")));\n    } else if (sourceType !== \'raster-dem\') {\n      errors.push(new ValidationError(key, terrain.source, "terrain cannot be used with a source of type ".concat(sourceType, ", it only be used with a \\"raster-dem\\" source type")));\n    }\n  }\n\n  return errors;\n}\n\nfunction validateFog(options) {\n  var fog = options.value;\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n  var fogSpec = styleSpec.fog;\n  var errors = [];\n  var rootType = getType(fog);\n\n  if (fog === undefined) {\n    return errors;\n  } else if (rootType !== \'object\') {\n    errors = errors.concat([new ValidationError(\'fog\', fog, "object expected, ".concat(rootType, " found"))]);\n    return errors;\n  }\n\n  for (var key in fog) {\n    var transitionMatch = key.match(/^(.*)-transition$/);\n\n    if (transitionMatch && fogSpec[transitionMatch[1]] && fogSpec[transitionMatch[1]].transition) {\n      errors = errors.concat(validate({\n        key: key,\n        value: fog[key],\n        valueSpec: styleSpec.transition,\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else if (fogSpec[key]) {\n      errors = errors.concat(validate({\n        key: key,\n        value: fog[key],\n        valueSpec: fogSpec[key],\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else {\n      errors = errors.concat([new ValidationError(key, fog[key], "unknown property \\"".concat(key, "\\""))]);\n    }\n  }\n\n  return errors;\n}\n\nfunction validateFormatted(options) {\n  if (validateString(options).length === 0) {\n    return [];\n  }\n\n  return validateExpression(options);\n}\n\nfunction validateImage(options) {\n  if (validateString(options).length === 0) {\n    return [];\n  }\n\n  return validateExpression(options);\n}\n\nvar VALIDATORS = {\n  \'*\': function _() {\n    return [];\n  },\n  \'array\': validateArray,\n  \'boolean\': validateBoolean,\n  \'number\': validateNumber,\n  \'color\': validateColor,\n  \'constants\': validateConstants,\n  \'enum\': validateEnum,\n  \'filter\': validateFilter,\n  \'function\': validateFunction,\n  \'layer\': validateLayer,\n  \'object\': validateObject,\n  \'source\': validateSource,\n  \'light\': validateLight,\n  \'terrain\': validateTerrain,\n  \'fog\': validateFog,\n  \'string\': validateString,\n  \'formatted\': validateFormatted,\n  \'resolvedImage\': validateImage\n};\n\nfunction validate(options) {\n  var value = options.value;\n  var valueSpec = options.valueSpec;\n  var styleSpec = options.styleSpec;\n\n  if (valueSpec.expression && isFunction$1(unbundle(value))) {\n    return validateFunction(options);\n  } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {\n    return validateExpression(options);\n  } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {\n    return VALIDATORS[valueSpec.type](options);\n  } else {\n    var valid = validateObject(extend({}, options, {\n      valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec\n    }));\n    return valid;\n  }\n}\n\nfunction validateGlyphsURL(options) {\n  var value = options.value;\n  var key = options.key;\n  var errors = validateString(options);\n  if (errors.length) return errors;\n\n  if (value.indexOf(\'{fontstack}\') === -1) {\n    errors.push(new ValidationError(key, value, \'"glyphs" url must include a "{fontstack}" token\'));\n  }\n\n  if (value.indexOf(\'{range}\') === -1) {\n    errors.push(new ValidationError(key, value, \'"glyphs" url must include a "{range}" token\'));\n  }\n\n  return errors;\n}\n\nfunction validateStyleMin(style) {\n  var styleSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v8;\n  var errors = [];\n  errors = errors.concat(validate({\n    key: \'\',\n    value: style,\n    valueSpec: styleSpec.$root,\n    styleSpec: styleSpec,\n    style: style,\n    objectElementValidators: {\n      glyphs: validateGlyphsURL,\n      \'*\': function _() {\n        return [];\n      }\n    }\n  }));\n\n  if (style.constants) {\n    errors = errors.concat(validateConstants({\n      key: \'constants\',\n      value: style.constants,\n      style: style,\n      styleSpec: styleSpec\n    }));\n  }\n\n  return sortErrors(errors);\n}\n\nvalidateStyleMin.source = wrapCleanErrors(validateSource);\nvalidateStyleMin.light = wrapCleanErrors(validateLight);\nvalidateStyleMin.terrain = wrapCleanErrors(validateTerrain);\nvalidateStyleMin.fog = wrapCleanErrors(validateFog);\nvalidateStyleMin.layer = wrapCleanErrors(validateLayer);\nvalidateStyleMin.filter = wrapCleanErrors(validateFilter);\nvalidateStyleMin.paintProperty = wrapCleanErrors(validatePaintProperty);\nvalidateStyleMin.layoutProperty = wrapCleanErrors(validateLayoutProperty);\n\nfunction sortErrors(errors) {\n  return [].concat(errors).sort(function (a, b) {\n    return a.line - b.line;\n  });\n}\n\nfunction wrapCleanErrors(inner) {\n  return function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key7 = 0; _key7 < _len4; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    return sortErrors(inner.apply(this, args));\n  };\n}\n/* parser generated by jison 0.4.15 */\n\n\nvar jsonlint = createCommonjsModule(function (module, exports) {\n  /*\n    Returns a Parser object of the following structure:\n  \n    Parser: {\n      yy: {}\n    }\n  \n    Parser.prototype: {\n      yy: {},\n      trace: function(),\n      symbols_: {associative list: name ==> number},\n      terminals_: {associative list: number ==> name},\n      productions_: [...],\n      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n      table: [...],\n      defaultActions: {...},\n      parseError: function(str, hash),\n      parse: function(input),\n  \n      lexer: {\n          EOF: 1,\n          parseError: function(str, hash),\n          setInput: function(input),\n          input: function(),\n          unput: function(str),\n          more: function(),\n          less: function(n),\n          pastInput: function(),\n          upcomingInput: function(),\n          showPosition: function(),\n          test_match: function(regex_match_array, rule_index),\n          next: function(),\n          lex: function(),\n          begin: function(condition),\n          popState: function(),\n          _currentRules: function(),\n          topState: function(),\n          pushState: function(condition),\n  \n          options: {\n              ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n          },\n  \n          performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n          rules: [...],\n          conditions: {associative list: name ==> set},\n      }\n    }\n  \n  \n    token location info (@$, _$, etc.): {\n      first_line: n,\n      last_line: n,\n      first_column: n,\n      last_column: n,\n      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n    }\n  \n  \n    the parseError function receives a \'hash\' object with these members for lexer and parser errors: {\n      text:        (matched text)\n      token:       (the produced terminal token, if any)\n      line:        (yylineno)\n    }\n    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n      loc:         (yylloc)\n      expected:    (string describing the set of expected tokens)\n      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n    }\n  */\n  var parser = function () {\n    var o = function o(k, v, _o, l) {\n      for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {\n        ;\n      }\n\n      return _o;\n    },\n        $V0 = [1, 12],\n        $V1 = [1, 13],\n        $V2 = [1, 9],\n        $V3 = [1, 10],\n        $V4 = [1, 11],\n        $V5 = [1, 14],\n        $V6 = [1, 15],\n        $V7 = [14, 18, 22, 24],\n        $V8 = [18, 22],\n        $V9 = [22, 24];\n\n    var parser = {\n      trace: function trace() {},\n      yy: {},\n      symbols_: {\n        "error": 2,\n        "JSONString": 3,\n        "STRING": 4,\n        "JSONNumber": 5,\n        "NUMBER": 6,\n        "JSONNullLiteral": 7,\n        "NULL": 8,\n        "JSONBooleanLiteral": 9,\n        "TRUE": 10,\n        "FALSE": 11,\n        "JSONText": 12,\n        "JSONValue": 13,\n        "EOF": 14,\n        "JSONObject": 15,\n        "JSONArray": 16,\n        "{": 17,\n        "}": 18,\n        "JSONMemberList": 19,\n        "JSONMember": 20,\n        ":": 21,\n        ",": 22,\n        "[": 23,\n        "]": 24,\n        "JSONElementList": 25,\n        "$accept": 0,\n        "$end": 1\n      },\n      terminals_: {\n        2: "error",\n        4: "STRING",\n        6: "NUMBER",\n        8: "NULL",\n        10: "TRUE",\n        11: "FALSE",\n        14: "EOF",\n        17: "{",\n        18: "}",\n        21: ":",\n        22: ",",\n        23: "[",\n        24: "]"\n      },\n      productions_: [0, [3, 1], [5, 1], [7, 1], [9, 1], [9, 1], [12, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [15, 2], [15, 3], [20, 3], [19, 1], [19, 3], [16, 2], [16, 3], [25, 1], [25, 3]],\n      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate\n      /* action[1] */\n      , $$\n      /* vstack */\n      , _$\n      /* lstack */\n      ) {\n        /* this == yyval */\n        var $0 = $$.length - 1;\n\n        switch (yystate) {\n          case 1:\n            // replace escaped characters with actual character\n            this.$ = new String(yytext.replace(/\\\\(\\\\|")/g, "$" + "1").replace(/\\\\n/g, \'\\n\').replace(/\\\\r/g, \'\\r\').replace(/\\\\t/g, \'\\t\').replace(/\\\\v/g, \'\\v\').replace(/\\\\f/g, \'\\f\').replace(/\\\\b/g, \'\\b\'));\n            this.$.__line__ = this._$.first_line;\n            break;\n\n          case 2:\n            this.$ = new Number(yytext);\n            this.$.__line__ = this._$.first_line;\n            break;\n\n          case 3:\n            this.$ = null;\n            break;\n\n          case 4:\n            this.$ = new Boolean(true);\n            this.$.__line__ = this._$.first_line;\n            break;\n\n          case 5:\n            this.$ = new Boolean(false);\n            this.$.__line__ = this._$.first_line;\n            break;\n\n          case 6:\n            return this.$ = $$[$0 - 1];\n\n          case 13:\n            this.$ = {};\n            Object.defineProperty(this.$, \'__line__\', {\n              value: this._$.first_line,\n              enumerable: false\n            });\n            break;\n\n          case 14:\n          case 19:\n            this.$ = $$[$0 - 1];\n            Object.defineProperty(this.$, \'__line__\', {\n              value: this._$.first_line,\n              enumerable: false\n            });\n            break;\n\n          case 15:\n            this.$ = [$$[$0 - 2], $$[$0]];\n            break;\n\n          case 16:\n            this.$ = {};\n            this.$[$$[$0][0]] = $$[$0][1];\n            break;\n\n          case 17:\n            this.$ = $$[$0 - 2];\n            $$[$0 - 2][$$[$0][0]] = $$[$0][1];\n            break;\n\n          case 18:\n            this.$ = [];\n            Object.defineProperty(this.$, \'__line__\', {\n              value: this._$.first_line,\n              enumerable: false\n            });\n            break;\n\n          case 20:\n            this.$ = [$$[$0]];\n            break;\n\n          case 21:\n            this.$ = $$[$0 - 2];\n            $$[$0 - 2].push($$[$0]);\n            break;\n        }\n      },\n      table: [{\n        3: 5,\n        4: $V0,\n        5: 6,\n        6: $V1,\n        7: 3,\n        8: $V2,\n        9: 4,\n        10: $V3,\n        11: $V4,\n        12: 1,\n        13: 2,\n        15: 7,\n        16: 8,\n        17: $V5,\n        23: $V6\n      }, {\n        1: [3]\n      }, {\n        14: [1, 16]\n      }, o($V7, [2, 7]), o($V7, [2, 8]), o($V7, [2, 9]), o($V7, [2, 10]), o($V7, [2, 11]), o($V7, [2, 12]), o($V7, [2, 3]), o($V7, [2, 4]), o($V7, [2, 5]), o([14, 18, 21, 22, 24], [2, 1]), o($V7, [2, 2]), {\n        3: 20,\n        4: $V0,\n        18: [1, 17],\n        19: 18,\n        20: 19\n      }, {\n        3: 5,\n        4: $V0,\n        5: 6,\n        6: $V1,\n        7: 3,\n        8: $V2,\n        9: 4,\n        10: $V3,\n        11: $V4,\n        13: 23,\n        15: 7,\n        16: 8,\n        17: $V5,\n        23: $V6,\n        24: [1, 21],\n        25: 22\n      }, {\n        1: [2, 6]\n      }, o($V7, [2, 13]), {\n        18: [1, 24],\n        22: [1, 25]\n      }, o($V8, [2, 16]), {\n        21: [1, 26]\n      }, o($V7, [2, 18]), {\n        22: [1, 28],\n        24: [1, 27]\n      }, o($V9, [2, 20]), o($V7, [2, 14]), {\n        3: 20,\n        4: $V0,\n        20: 29\n      }, {\n        3: 5,\n        4: $V0,\n        5: 6,\n        6: $V1,\n        7: 3,\n        8: $V2,\n        9: 4,\n        10: $V3,\n        11: $V4,\n        13: 30,\n        15: 7,\n        16: 8,\n        17: $V5,\n        23: $V6\n      }, o($V7, [2, 19]), {\n        3: 5,\n        4: $V0,\n        5: 6,\n        6: $V1,\n        7: 3,\n        8: $V2,\n        9: 4,\n        10: $V3,\n        11: $V4,\n        13: 31,\n        15: 7,\n        16: 8,\n        17: $V5,\n        23: $V6\n      }, o($V8, [2, 17]), o($V8, [2, 15]), o($V9, [2, 21])],\n      defaultActions: {\n        16: [2, 6]\n      },\n      parseError: function parseError(str, hash) {\n        if (hash.recoverable) {\n          this.trace(str);\n        } else {\n          throw new Error(str);\n        }\n      },\n      parse: function parse(input) {\n        var self = this,\n            stack = [0],\n            vstack = [null],\n            lstack = [],\n            table = this.table,\n            yytext = \'\',\n            yylineno = 0,\n            yyleng = 0,\n            TERROR = 2,\n            EOF = 1;\n        var args = lstack.slice.call(arguments, 1);\n        var lexer = Object.create(this.lexer);\n        var sharedState = {\n          yy: {}\n        };\n\n        for (var k in this.yy) {\n          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n          }\n        }\n\n        lexer.setInput(input, sharedState.yy);\n        sharedState.yy.lexer = lexer;\n        sharedState.yy.parser = this;\n\n        if (typeof lexer.yylloc == \'undefined\') {\n          lexer.yylloc = {};\n        }\n\n        var yyloc = lexer.yylloc;\n        lstack.push(yyloc);\n        var ranges = lexer.options && lexer.options.ranges;\n\n        if (typeof sharedState.yy.parseError === \'function\') {\n          this.parseError = sharedState.yy.parseError;\n        } else {\n          this.parseError = Object.getPrototypeOf(this).parseError;\n        }\n\n        function lex() {\n          var token;\n          token = lexer.lex() || EOF;\n\n          if (typeof token !== \'number\') {\n            token = self.symbols_[token] || token;\n          }\n\n          return token;\n        }\n\n        var symbol,\n            state,\n            action,\n            r,\n            yyval = {},\n            p,\n            len,\n            newState,\n            expected;\n\n        while (true) {\n          state = stack[stack.length - 1];\n\n          if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n          } else {\n            if (symbol === null || typeof symbol == \'undefined\') {\n              symbol = lex();\n            }\n\n            action = table[state] && table[state][symbol];\n          }\n\n          if (typeof action === \'undefined\' || !action.length || !action[0]) {\n            var errStr = \'\';\n            expected = [];\n\n            for (p in table[state]) {\n              if (this.terminals_[p] && p > TERROR) {\n                expected.push(\'\\\'\' + this.terminals_[p] + \'\\\'\');\n              }\n            }\n\n            if (lexer.showPosition) {\n              errStr = \'Parse error on line \' + (yylineno + 1) + \':\\n\' + lexer.showPosition() + \'\\nExpecting \' + expected.join(\', \') + \', got \\\'\' + (this.terminals_[symbol] || symbol) + \'\\\'\';\n            } else {\n              errStr = \'Parse error on line \' + (yylineno + 1) + \': Unexpected \' + (symbol == EOF ? \'end of input\' : \'\\\'\' + (this.terminals_[symbol] || symbol) + \'\\\'\');\n            }\n\n            this.parseError(errStr, {\n              text: lexer.match,\n              token: this.terminals_[symbol] || symbol,\n              line: lexer.yylineno,\n              loc: yyloc,\n              expected: expected\n            });\n          }\n\n          if (action[0] instanceof Array && action.length > 1) {\n            throw new Error(\'Parse Error: multiple actions possible at state: \' + state + \', token: \' + symbol);\n          }\n\n          switch (action[0]) {\n            case 1:\n              stack.push(symbol);\n              vstack.push(lexer.yytext);\n              lstack.push(lexer.yylloc);\n              stack.push(action[1]);\n              symbol = null;\n              {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n              }\n              break;\n\n            case 2:\n              len = this.productions_[action[1]][1];\n              yyval.$ = vstack[vstack.length - len];\n              yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n              };\n\n              if (ranges) {\n                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\n              }\n\n              r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\n\n              if (typeof r !== \'undefined\') {\n                return r;\n              }\n\n              if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n              }\n\n              stack.push(this.productions_[action[1]][0]);\n              vstack.push(yyval.$);\n              lstack.push(yyval._$);\n              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n              stack.push(newState);\n              break;\n\n            case 3:\n              return true;\n          }\n        }\n\n        return true;\n      }\n    };\n    /* generated by jison-lex 0.3.4 */\n\n    var lexer = function () {\n      var lexer = {\n        EOF: 1,\n        parseError: function parseError(str, hash) {\n          if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n          } else {\n            throw new Error(str);\n          }\n        },\n        // resets the lexer, sets new input\n        setInput: function setInput(input, yy) {\n          this.yy = yy || this.yy || {};\n          this._input = input;\n          this._more = this._backtrack = this.done = false;\n          this.yylineno = this.yyleng = 0;\n          this.yytext = this.matched = this.match = \'\';\n          this.conditionStack = [\'INITIAL\'];\n          this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n          };\n\n          if (this.options.ranges) {\n            this.yylloc.range = [0, 0];\n          }\n\n          this.offset = 0;\n          return this;\n        },\n        // consumes and returns one char from the input\n        input: function input() {\n          var ch = this._input[0];\n          this.yytext += ch;\n          this.yyleng++;\n          this.offset++;\n          this.match += ch;\n          this.matched += ch;\n          var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n\n          if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n          } else {\n            this.yylloc.last_column++;\n          }\n\n          if (this.options.ranges) {\n            this.yylloc.range[1]++;\n          }\n\n          this._input = this._input.slice(1);\n          return ch;\n        },\n        // unshifts one char (or a string) into the input\n        unput: function unput(ch) {\n          var len = ch.length;\n          var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n          this._input = ch + this._input;\n          this.yytext = this.yytext.substr(0, this.yytext.length - len); //this.yyleng -= len;\n\n          this.offset -= len;\n          var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n          this.match = this.match.substr(0, this.match.length - 1);\n          this.matched = this.matched.substr(0, this.matched.length - 1);\n\n          if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n          }\n\n          var r = this.yylloc.range;\n          this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n          };\n\n          if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n          }\n\n          this.yyleng = this.yytext.length;\n          return this;\n        },\n        // When called from action, caches matched text and appends it on next action\n        more: function more() {\n          this._more = true;\n          return this;\n        },\n        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n        reject: function reject() {\n          if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n          } else {\n            return this.parseError(\'Lexical error on line \' + (this.yylineno + 1) + \'. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\' + this.showPosition(), {\n              text: "",\n              token: null,\n              line: this.yylineno\n            });\n          }\n\n          return this;\n        },\n        // retain first n characters of the match\n        less: function less(n) {\n          this.unput(this.match.slice(n));\n        },\n        // displays already matched input, i.e. for error messages\n        pastInput: function pastInput() {\n          var past = this.matched.substr(0, this.matched.length - this.match.length);\n          return (past.length > 20 ? \'...\' : \'\') + past.substr(-20).replace(/\\n/g, "");\n        },\n        // displays upcoming input, i.e. for error messages\n        upcomingInput: function upcomingInput() {\n          var next = this.match;\n\n          if (next.length < 20) {\n            next += this._input.substr(0, 20 - next.length);\n          }\n\n          return (next.substr(0, 20) + (next.length > 20 ? \'...\' : \'\')).replace(/\\n/g, "");\n        },\n        // displays the character position where the lexing error occurred, i.e. for error messages\n        showPosition: function showPosition() {\n          var pre = this.pastInput();\n          var c = new Array(pre.length + 1).join("-");\n          return pre + this.upcomingInput() + "\\n" + c + "^";\n        },\n        // test the lexed token: return FALSE when not a match, otherwise return token\n        test_match: function test_match(match, indexed_rule) {\n          var token, lines, backup;\n\n          if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n              yylineno: this.yylineno,\n              yylloc: {\n                first_line: this.yylloc.first_line,\n                last_line: this.last_line,\n                first_column: this.yylloc.first_column,\n                last_column: this.yylloc.last_column\n              },\n              yytext: this.yytext,\n              match: this.match,\n              matches: this.matches,\n              matched: this.matched,\n              yyleng: this.yyleng,\n              offset: this.offset,\n              _more: this._more,\n              _input: this._input,\n              yy: this.yy,\n              conditionStack: this.conditionStack.slice(0),\n              done: this.done\n            };\n\n            if (this.options.ranges) {\n              backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n          }\n\n          lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n\n          if (lines) {\n            this.yylineno += lines.length;\n          }\n\n          this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n          };\n          this.yytext += match[0];\n          this.match += match[0];\n          this.matches = match;\n          this.yyleng = this.yytext.length;\n\n          if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n          }\n\n          this._more = false;\n          this._backtrack = false;\n          this._input = this._input.slice(match[0].length);\n          this.matched += match[0];\n          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n\n          if (this.done && this._input) {\n            this.done = false;\n          }\n\n          if (token) {\n            return token;\n          } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n              this[k] = backup[k];\n            }\n\n            return false; // rule action called reject() implying the next rule should be tested instead.\n          }\n\n          return false;\n        },\n        // return next match in input\n        next: function next() {\n          if (this.done) {\n            return this.EOF;\n          }\n\n          if (!this._input) {\n            this.done = true;\n          }\n\n          var token, match, tempMatch, index;\n\n          if (!this._more) {\n            this.yytext = \'\';\n            this.match = \'\';\n          }\n\n          var rules = this._currentRules();\n\n          for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n              match = tempMatch;\n              index = i;\n\n              if (this.options.backtrack_lexer) {\n                token = this.test_match(tempMatch, rules[i]);\n\n                if (token !== false) {\n                  return token;\n                } else if (this._backtrack) {\n                  match = false;\n                  continue; // rule action called reject() implying a rule MISmatch.\n                } else {\n                  // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                  return false;\n                }\n              } else if (!this.options.flex) {\n                break;\n              }\n            }\n          }\n\n          if (match) {\n            token = this.test_match(match, rules[index]);\n\n            if (token !== false) {\n              return token;\n            } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n\n\n            return false;\n          }\n\n          if (this._input === "") {\n            return this.EOF;\n          } else {\n            return this.parseError(\'Lexical error on line \' + (this.yylineno + 1) + \'. Unrecognized text.\\n\' + this.showPosition(), {\n              text: "",\n              token: null,\n              line: this.yylineno\n            });\n          }\n        },\n        // return next match that has a token\n        lex: function lex() {\n          var r = this.next();\n\n          if (r) {\n            return r;\n          } else {\n            return this.lex();\n          }\n        },\n        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n        begin: function begin(condition) {\n          this.conditionStack.push(condition);\n        },\n        // pop the previously active lexer condition state off the condition stack\n        popState: function popState() {\n          var n = this.conditionStack.length - 1;\n\n          if (n > 0) {\n            return this.conditionStack.pop();\n          } else {\n            return this.conditionStack[0];\n          }\n        },\n        // produce the lexer rule set which is active for the currently active lexer condition state\n        _currentRules: function _currentRules() {\n          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n          } else {\n            return this.conditions["INITIAL"].rules;\n          }\n        },\n        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n        topState: function topState(n) {\n          n = this.conditionStack.length - 1 - Math.abs(n || 0);\n\n          if (n >= 0) {\n            return this.conditionStack[n];\n          } else {\n            return "INITIAL";\n          }\n        },\n        // alias for begin(condition)\n        pushState: function pushState(condition) {\n          this.begin(condition);\n        },\n        // return the number of states currently on the stack\n        stateStackSize: function stateStackSize() {\n          return this.conditionStack.length;\n        },\n        options: {},\n        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n          switch ($avoiding_name_collisions) {\n            case 0:\n              /* skip whitespace */\n              break;\n\n            case 1:\n              return 6;\n\n            case 2:\n              yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);\n              return 4;\n\n            case 3:\n              return 17;\n\n            case 4:\n              return 18;\n\n            case 5:\n              return 23;\n\n            case 6:\n              return 24;\n\n            case 7:\n              return 22;\n\n            case 8:\n              return 21;\n\n            case 9:\n              return 10;\n\n            case 10:\n              return 11;\n\n            case 11:\n              return 8;\n\n            case 12:\n              return 14;\n\n            case 13:\n              return \'INVALID\';\n          }\n        },\n        rules: [/^(?:\\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\\.[0-9]+)?([eE][-+]?[0-9]+)?\\b)/, /^(?:"(?:\\\\[\\\\"bfnrt/]|\\\\u[a-fA-F0-9]{4}|[^\\\\\\0-\\x09\\x0a-\\x1f"])*")/, /^(?:\\{)/, /^(?:\\})/, /^(?:\\[)/, /^(?:\\])/, /^(?:,)/, /^(?::)/, /^(?:true\\b)/, /^(?:false\\b)/, /^(?:null\\b)/, /^(?:$)/, /^(?:.)/],\n        conditions: {\n          "INITIAL": {\n            "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],\n            "inclusive": true\n          }\n        }\n      };\n      return lexer;\n    }();\n\n    parser.lexer = lexer;\n\n    function Parser() {\n      this.yy = {};\n    }\n\n    Parser.prototype = parser;\n    parser.Parser = Parser;\n    return new Parser();\n  }();\n\n  if (typeof commonjsRequire !== \'undefined\' && \'object\' !== \'undefined\') {\n    exports.parser = parser;\n    exports.Parser = parser.Parser;\n\n    exports.parse = function () {\n      return parser.parse.apply(parser, arguments);\n    };\n  }\n});\n\nfunction readStyle(style) {\n  if (style instanceof String || typeof style === \'string\' || style instanceof Buffer) {\n    try {\n      return jsonlint.parse(style.toString());\n    } catch (e) {\n      throw new ParsingError$1(e);\n    }\n  }\n\n  return style;\n}\n\nfunction validateStyle(style) {\n  var styleSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v8;\n  var s = style;\n\n  try {\n    s = readStyle(s);\n  } catch (e) {\n    return [e];\n  }\n\n  return validateStyleMin(s, styleSpec);\n}\n\nvar SUPPORTED_SPEC_VERSION = 8;\nvar MAX_SOURCES_IN_STYLE = 15;\n\nfunction isValid(value, regex) {\n  if (!value || getType(value) !== \'string\') return true;\n  return !!value.match(regex);\n}\n\nfunction getSourceCount(source) {\n  if (source.url) {\n    return source.url.split(\',\').length;\n  } else {\n    return 0;\n  }\n}\n\nfunction getAllowedKeyErrors(obj, keys, path) {\n  var allowed = new Set(keys);\n  var errors = [];\n  Object.keys(obj).forEach(function (k) {\n    if (!allowed.has(k)) {\n      var prop = path ? "".concat(path, ".").concat(k) : null;\n      errors.push(new ValidationError(prop, obj[k], "Unsupported property \\"".concat(k, "\\"")));\n    }\n  });\n  return errors;\n}\n\nvar acceptedSourceTypes = new Set([\'vector\', \'raster\', \'raster-dem\']);\n\nfunction getSourceErrors(source, i) {\n  var errors = [];\n  var sourceKeys = [\'type\', \'url\', \'tileSize\'];\n  errors.push.apply(errors, _toConsumableArray(getAllowedKeyErrors(source, sourceKeys, \'source\')));\n\n  if (!acceptedSourceTypes.has(String(source.type))) {\n    errors.push(new ValidationError("sources[".concat(i, "].type"), source.type, "Expected one of [".concat(Array.from(acceptedSourceTypes).join(\', \'), "]")));\n  }\n\n  var sourceUrlPattern = /^mapbox:\\/\\/([^/]*)$/;\n\n  if (!source.url || !isValid(source.url, sourceUrlPattern)) {\n    errors.push(new ValidationError("sources[".concat(i, "].url"), source.url, \'Expected a valid Mapbox tileset url\'));\n  }\n\n  return errors;\n}\n\nfunction getSourcesErrors(sources) {\n  var errors = [];\n  var count = 0;\n  Object.keys(sources).forEach(function (s, i) {\n    var sourceErrors = getSourceErrors(sources[s], i);\n\n    if (!sourceErrors.length) {\n      count = count + getSourceCount(sources[s]);\n    }\n\n    errors.push.apply(errors, _toConsumableArray(sourceErrors));\n  });\n\n  if (count > MAX_SOURCES_IN_STYLE) {\n    errors.push(new ValidationError(\'sources\', null, "Styles must contain ".concat(MAX_SOURCES_IN_STYLE, " or fewer sources")));\n  }\n\n  return errors;\n}\n\nfunction getRootErrors(style, specKeys) {\n  var errors = [];\n  var optionalRootProperties = [\'owner\', \'id\', \'cacheControl\', \'draft\', \'created\', \'modified\', \'visibility\'];\n  var allowedKeyErrors = getAllowedKeyErrors(style, [].concat(_toConsumableArray(specKeys), optionalRootProperties));\n  errors.push.apply(errors, _toConsumableArray(allowedKeyErrors));\n\n  if (style.version > SUPPORTED_SPEC_VERSION || style.version < SUPPORTED_SPEC_VERSION) {\n    errors.push(new ValidationError(\'version\', style.version, "Style version must be ".concat(SUPPORTED_SPEC_VERSION)));\n  }\n\n  var glyphUrlPattern = /^mapbox:\\/\\/fonts\\/([^/]*)\\/{fontstack}\\/{range}.pbf$/;\n\n  if (!isValid(style.glyphs, glyphUrlPattern)) {\n    errors.push(new ValidationError(\'glyphs\', style.glyphs, \'Styles must reference glyphs hosted by Mapbox\'));\n  }\n\n  var spriteUrlPattern = /^mapbox:\\/\\/sprites\\/([^/]*)\\/([^/]*)\\/?([^/]*)?$/;\n\n  if (!isValid(style.sprite, spriteUrlPattern)) {\n    errors.push(new ValidationError(\'sprite\', style.sprite, \'Styles must reference sprites hosted by Mapbox\'));\n  }\n\n  var visibilityPattern = /^(public|private)$/;\n\n  if (!isValid(style.visibility, visibilityPattern)) {\n    errors.push(new ValidationError(\'visibility\', style.visibility, \'Style visibility must be public or private\'));\n  }\n\n  return errors;\n}\n\nfunction validateMapboxApiSupported(style) {\n  var s = style;\n\n  try {\n    s = readStyle(s);\n  } catch (e) {\n    return [e];\n  }\n\n  var errors = validateStyleMin(s, v8).concat(getRootErrors(s, Object.keys(v8.$root)));\n\n  if (s.sources) {\n    errors = errors.concat(getSourcesErrors(s.sources));\n  }\n\n  return errors;\n}\n\nvar expression$1 = {\n  StyleExpression: StyleExpression,\n  isExpression: isExpression,\n  isExpressionFilter: isExpressionFilter,\n  createExpression: createExpression,\n  createPropertyExpression: createPropertyExpression,\n  normalizePropertyExpression: normalizePropertyExpression,\n  ZoomConstantExpression: ZoomConstantExpression,\n  ZoomDependentExpression: ZoomDependentExpression,\n  StylePropertyFunction: StylePropertyFunction\n};\nvar styleFunction = {\n  convertFunction: convertFunction,\n  createFunction: createFunction,\n  isFunction: isFunction$1\n};\nvar visit = {\n  eachSource: eachSource,\n  eachLayer: eachLayer,\n  eachProperty: eachProperty\n};\nvalidateStyle.parsed = validateStyle;\nvalidateStyle.latest = validateStyle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWFwYm94L21hcGJveC1nbC1zdHlsZS1zcGVjL2Rpc3QvaW5kZXguZXMuanM/MjMwYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEg7QUFDb0I7QUFDUjtBQUNKO0FBQ007QUFDWjtBQUNrQztBQUN0QjtBQUNFOztBQUU5SSxnQ0FBZ0MsNkRBQTZELHlDQUF5QyxhQUFhLDhKQUFlLGtCQUFrQixpQ0FBaUMsaUJBQWlCLDhKQUFlLG1CQUFtQix5REFBeUQsRUFBRSxPQUFPLHVDQUF1QyxFQUFFLFFBQVEseUtBQTBCLGVBQWUsR0FBRzs7QUFFdmEsc0NBQXNDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNkVBQTZFLEdBQUcsYUFBYSxFQUFFLFlBQVksY0FBYyxFQUFFOztBQUV2VSx3REFBd0QsaUZBQWlGLFdBQVcsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLDhCQUE4QixFQUFFLHFCQUFxQixVQUFVLEVBQUUsU0FBUyxFQUFFLDhKQUE4SixFQUFFLGtEQUFrRCxTQUFTLGtCQUFrQixpQkFBaUIsRUFBRSxtQkFBbUIsc0JBQXNCLDhCQUE4QixhQUFhLEVBQUUsc0JBQXNCLGVBQWUsV0FBVyxFQUFFLG1CQUFtQixNQUFNLHlEQUF5RCxFQUFFLFVBQVUsdUJBQXVCLEVBQUUsRUFBRSxHQUFHOztBQUVwK0IsaURBQWlELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Qsa0hBQWtIOztBQUU5WixzQ0FBc0MsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sa0JBQWtCLEVBQUUsYUFBYTs7QUFFckw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRHQUE0RyxVQUFVLFFBQVEsTUFBTTtBQUNwSSxxQ0FBcUMsVUFBVSxFQUFFLE1BQU07QUFDdkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0hBQW9ILDhCQUE4QjtBQUNsSixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0SkFBNEosOENBQThDLG9MQUFvTCxzRUFBc0UsMkNBQTJDLGdLQUFnSyxvRkFBb0Y7QUFDbnVCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0hBQW9ILDhCQUE4QjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUxBQXlMO0FBQ3pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5RUFBeUUsWUFBWTtBQUNyRixLQUFLO0FBQ0w7QUFDQSwwRUFBMEUsWUFBWTtBQUN0RixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1UkFBdVI7QUFDdlI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBJQUEwSTtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyS0FBMks7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3S0FBd0s7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4S0FBOEs7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyS0FBMks7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwUUFBMFE7QUFDMVE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUNBQXFDLFVBQVUsRUFBRSxNQUFNO0FBQ3ZELEtBQUs7QUFDTCxnRUFBZ0UsVUFBVSxFQUFFLE1BQU07QUFDbEYsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJGQUEyRixjQUFjO0FBQ3pHO0FBQ0E7O0FBRUEscUNBQXFDLHNCQUFzQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSx3SkFBUzs7QUFFWDs7QUFFQTtBQUNBOztBQUVBLElBQUksOEpBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLGVBQWUsK0pBQWdCOztBQUVoQztBQUNBO0FBQ0E7O0FBRUEsSUFBSSw4SkFBZTs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRCwyQkFBMkIsNkpBQWM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDJKQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLElBQUksOEpBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RCw0QkFBNEIsNkpBQWM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEVBQUUsMkpBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FB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Q0EsaUJBQWlCLDZKQUFjO0FBQy9COztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLDZKQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLDZKQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLDZKQUFjO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQiw2SkFBYztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQiw2SkFBYztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLDZKQUFjO0FBQy9COztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQiw2SkFBYztBQUMvQjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0gsbUVBQW1FO0FBQ25FLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixtQ0FBbUM7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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Q0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDhKQUFlOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSw4SkFBZTs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCLGtCQUFrQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7O0FBR2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVCw2REFBNkQ7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpSUFBaUksRUFBRSxxQ0FBcUMsV0FBVztBQUNuTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNELFVBQVUsR0FBRyxNQUFNOztBQUV6RTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzAyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfdG9BcnJheSBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvanVzdGljZTQwLXRvb2wvanVzdGljZTQwLXRvb2wvY2xpZW50L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0FycmF5XCI7XG5pbXBvcnQgX3RvQ29uc3VtYWJsZUFycmF5IGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5XCI7XG5pbXBvcnQgX3NsaWNlZFRvQXJyYXkgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheVwiO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvanVzdGljZTQwLXRvb2wvanVzdGljZTQwLXRvb2wvY2xpZW50L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvanVzdGljZTQwLXRvb2wvanVzdGljZTQwLXRvb2wvY2xpZW50L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvanVzdGljZTQwLXRvb2wvanVzdGljZTQwLXRvb2wvY2xpZW50L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2ZcIjtcbmltcG9ydCBfd3JhcE5hdGl2ZVN1cGVyIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3dyYXBOYXRpdmVTdXBlclwiO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG52YXIgJHZlcnNpb24gPSA4O1xudmFyICRyb290ID0ge1xuICB2ZXJzaW9uOiB7XG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiBbOF0sXG4gICAgZG9jOiBcIlN0eWxlIHNwZWNpZmljYXRpb24gdmVyc2lvbiBudW1iZXIuIE11c3QgYmUgOC5cIixcbiAgICBleGFtcGxlOiA4XG4gIH0sXG4gIG5hbWU6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJBIGh1bWFuLXJlYWRhYmxlIG5hbWUgZm9yIHRoZSBzdHlsZS5cIixcbiAgICBleGFtcGxlOiBcIkJyaWdodFwiXG4gIH0sXG4gIG1ldGFkYXRhOiB7XG4gICAgdHlwZTogXCIqXCIsXG4gICAgZG9jOiBcIkFyYml0cmFyeSBwcm9wZXJ0aWVzIHVzZWZ1bCB0byB0cmFjayB3aXRoIHRoZSBzdHlsZXNoZWV0LCBidXQgZG8gbm90IGluZmx1ZW5jZSByZW5kZXJpbmcuIFByb3BlcnRpZXMgc2hvdWxkIGJlIHByZWZpeGVkIHRvIGF2b2lkIGNvbGxpc2lvbnMsIGxpa2UgJ21hcGJveDonLlwiXG4gIH0sXG4gIGNlbnRlcjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiRGVmYXVsdCBtYXAgY2VudGVyIGluIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUuICBUaGUgc3R5bGUgY2VudGVyIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG4gICAgZXhhbXBsZTogWy03My45NzQ5LCA0MC43NzM2XVxuICB9LFxuICB6b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiRGVmYXVsdCB6b29tIGxldmVsLiAgVGhlIHN0eWxlIHpvb20gd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcbiAgICBleGFtcGxlOiAxMi41XG4gIH0sXG4gIGJlYXJpbmc6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIHBlcmlvZDogMzYwLFxuICAgIHVuaXRzOiBcImRlZ3JlZXNcIixcbiAgICBkb2M6IFwiRGVmYXVsdCBiZWFyaW5nLCBpbiBkZWdyZWVzLiBUaGUgYmVhcmluZyBpcyB0aGUgY29tcGFzcyBkaXJlY3Rpb24gdGhhdCBpcyBcXFwidXBcXFwiOyBmb3IgZXhhbXBsZSwgYSBiZWFyaW5nIG9mIDkwwrAgb3JpZW50cyB0aGUgbWFwIHNvIHRoYXQgZWFzdCBpcyB1cC4gVGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuICAgIGV4YW1wbGU6IDI5XG4gIH0sXG4gIHBpdGNoOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgZG9jOiBcIkRlZmF1bHQgcGl0Y2gsIGluIGRlZ3JlZXMuIFplcm8gaXMgcGVycGVuZGljdWxhciB0byB0aGUgc3VyZmFjZSwgZm9yIGEgbG9vayBzdHJhaWdodCBkb3duIGF0IHRoZSBtYXAsIHdoaWxlIGEgZ3JlYXRlciB2YWx1ZSBsaWtlIDYwIGxvb2tzIGFoZWFkIHRvd2FyZHMgdGhlIGhvcml6b24uIFRoZSBzdHlsZSBwaXRjaCB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuICAgIGV4YW1wbGU6IDUwXG4gIH0sXG4gIGxpZ2h0OiB7XG4gICAgdHlwZTogXCJsaWdodFwiLFxuICAgIGRvYzogXCJUaGUgZ2xvYmFsIGxpZ2h0IHNvdXJjZS5cIixcbiAgICBleGFtcGxlOiB7XG4gICAgICBhbmNob3I6IFwidmlld3BvcnRcIixcbiAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgICBpbnRlbnNpdHk6IDAuNFxuICAgIH1cbiAgfSxcbiAgdGVycmFpbjoge1xuICAgIHR5cGU6IFwidGVycmFpblwiLFxuICAgIGRvYzogXCJBIGdsb2JhbCBtb2RpZmllciB0aGF0IGVsZXZhdGVzIGxheWVycyBhbmQgbWFya2VycyBiYXNlZCBvbiBhIERFTSBkYXRhIHNvdXJjZS5cIlxuICB9LFxuICBmb2c6IHtcbiAgICB0eXBlOiBcImZvZ1wiLFxuICAgIGRvYzogXCJBIGdsb2JhbCBlZmZlY3QgdGhhdCBmYWRlcyBsYXllcnMgYW5kIG1hcmtlcnMgYmFzZWQgb24gdGhlaXIgZGlzdGFuY2UgdG8gdGhlIGNhbWVyYS4gVGhlIGZvZyBjYW4gYmUgdXNlZCB0byBhcHByb3hpbWF0ZSB0aGUgZWZmZWN0IG9mIGF0bW9zcGhlcmUgb24gZGlzdGFudCBvYmplY3RzIGFuZCBlbmhhbmNlIHRoZSBkZXB0aCBwZXJjZXB0aW9uIG9mIHRoZSBtYXAgd2hlbiB1c2VkIHdpdGggdGVycmFpbiBvciAzRCBmZWF0dXJlcy5cIlxuICB9LFxuICBzb3VyY2VzOiB7XG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgdHlwZTogXCJzb3VyY2VzXCIsXG4gICAgZG9jOiBcIkRhdGEgc291cmNlIHNwZWNpZmljYXRpb25zLlwiLFxuICAgIGV4YW1wbGU6IHtcbiAgICAgIFwibWFwYm94LXN0cmVldHNcIjoge1xuICAgICAgICB0eXBlOiBcInZlY3RvclwiLFxuICAgICAgICB1cmw6IFwibWFwYm94Oi8vbWFwYm94Lm1hcGJveC1zdHJlZXRzLXY2XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNwcml0ZToge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkEgYmFzZSBVUkwgZm9yIHJldHJpZXZpbmcgdGhlIHNwcml0ZSBpbWFnZSBhbmQgbWV0YWRhdGEuIFRoZSBleHRlbnNpb25zIGAucG5nYCwgYC5qc29uYCBhbmQgc2NhbGUgZmFjdG9yIGBAMngucG5nYCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYXBwZW5kZWQuIFRoaXMgcHJvcGVydHkgaXMgcmVxdWlyZWQgaWYgYW55IGxheWVyIHVzZXMgdGhlIGBiYWNrZ3JvdW5kLXBhdHRlcm5gLCBgZmlsbC1wYXR0ZXJuYCwgYGxpbmUtcGF0dGVybmAsIGBmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuYCwgb3IgYGljb24taW1hZ2VgIHByb3BlcnRpZXMuIFRoZSBVUkwgbXVzdCBiZSBhYnNvbHV0ZSwgY29udGFpbmluZyB0aGUgW3NjaGVtZSwgYXV0aG9yaXR5IGFuZCBwYXRoIGNvbXBvbmVudHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VSTCNTeW50YXgpLlwiLFxuICAgIGV4YW1wbGU6IFwibWFwYm94Oi8vc3ByaXRlcy9tYXBib3gvYnJpZ2h0LXY4XCJcbiAgfSxcbiAgZ2x5cGhzOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkb2M6IFwiQSBVUkwgdGVtcGxhdGUgZm9yIGxvYWRpbmcgc2lnbmVkLWRpc3RhbmNlLWZpZWxkIGdseXBoIHNldHMgaW4gUEJGIGZvcm1hdC4gVGhlIFVSTCBtdXN0IGluY2x1ZGUgYHtmb250c3RhY2t9YCBhbmQgYHtyYW5nZX1gIHRva2Vucy4gVGhpcyBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpZiBhbnkgbGF5ZXIgdXNlcyB0aGUgYHRleHQtZmllbGRgIGxheW91dCBwcm9wZXJ0eS4gVGhlIFVSTCBtdXN0IGJlIGFic29sdXRlLCBjb250YWluaW5nIHRoZSBbc2NoZW1lLCBhdXRob3JpdHkgYW5kIHBhdGggY29tcG9uZW50c10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVJMI1N5bnRheCkuXCIsXG4gICAgZXhhbXBsZTogXCJtYXBib3g6Ly9mb250cy9tYXBib3gve2ZvbnRzdGFja30ve3JhbmdlfS5wYmZcIlxuICB9LFxuICB0cmFuc2l0aW9uOiB7XG4gICAgdHlwZTogXCJ0cmFuc2l0aW9uXCIsXG4gICAgZG9jOiBcIkEgZ2xvYmFsIHRyYW5zaXRpb24gZGVmaW5pdGlvbiB0byB1c2UgYXMgYSBkZWZhdWx0IGFjcm9zcyBwcm9wZXJ0aWVzLCB0byBiZSB1c2VkIGZvciB0aW1pbmcgdHJhbnNpdGlvbnMgYmV0d2VlbiBvbmUgdmFsdWUgYW5kIHRoZSBuZXh0IHdoZW4gbm8gcHJvcGVydHktc3BlY2lmaWMgdHJhbnNpdGlvbiBpcyBzZXQuIENvbGxpc2lvbi1iYXNlZCBzeW1ib2wgZmFkaW5nIGlzIGNvbnRyb2xsZWQgaW5kZXBlbmRlbnRseSBvZiB0aGUgc3R5bGUncyBgdHJhbnNpdGlvbmAgcHJvcGVydHkuXCIsXG4gICAgZXhhbXBsZToge1xuICAgICAgZHVyYXRpb246IDMwMCxcbiAgICAgIGRlbGF5OiAwXG4gICAgfVxuICB9LFxuICBsYXllcnM6IHtcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibGF5ZXJcIixcbiAgICBkb2M6IFwiTGF5ZXJzIHdpbGwgYmUgZHJhd24gaW4gdGhlIG9yZGVyIG9mIHRoaXMgYXJyYXkuXCIsXG4gICAgZXhhbXBsZTogW3tcbiAgICAgIGlkOiBcIndhdGVyXCIsXG4gICAgICBzb3VyY2U6IFwibWFwYm94LXN0cmVldHNcIixcbiAgICAgIFwic291cmNlLWxheWVyXCI6IFwid2F0ZXJcIixcbiAgICAgIHR5cGU6IFwiZmlsbFwiLFxuICAgICAgcGFpbnQ6IHtcbiAgICAgICAgXCJmaWxsLWNvbG9yXCI6IFwiIzAwZmZmZlwiXG4gICAgICB9XG4gICAgfV1cbiAgfVxufTtcbnZhciBzb3VyY2VzID0ge1xuICBcIipcIjoge1xuICAgIHR5cGU6IFwic291cmNlXCIsXG4gICAgZG9jOiBcIlNwZWNpZmljYXRpb24gb2YgYSBkYXRhIHNvdXJjZS4gRm9yIHZlY3RvciBhbmQgcmFzdGVyIHNvdXJjZXMsIGVpdGhlciBUaWxlSlNPTiBvciBhIFVSTCB0byBhIFRpbGVKU09OIG11c3QgYmUgcHJvdmlkZWQuIEZvciBpbWFnZSBhbmQgdmlkZW8gc291cmNlcywgYSBVUkwgbXVzdCBiZSBwcm92aWRlZC4gRm9yIEdlb0pTT04gc291cmNlcywgYSBVUkwgb3IgaW5saW5lIEdlb0pTT04gbXVzdCBiZSBwcm92aWRlZC5cIlxuICB9XG59O1xudmFyIHNvdXJjZSA9IFtcInNvdXJjZV92ZWN0b3JcIiwgXCJzb3VyY2VfcmFzdGVyXCIsIFwic291cmNlX3Jhc3Rlcl9kZW1cIiwgXCJzb3VyY2VfZ2VvanNvblwiLCBcInNvdXJjZV92aWRlb1wiLCBcInNvdXJjZV9pbWFnZVwiXTtcbnZhciBzb3VyY2VfdmVjdG9yID0ge1xuICB0eXBlOiB7XG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2ZWN0b3I6IHtcbiAgICAgICAgZG9jOiBcIkEgdmVjdG9yIHRpbGUgc291cmNlLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBkb2M6IFwiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuICB9LFxuICB1cmw6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88VGlsZXNldCBJRD5gLlwiXG4gIH0sXG4gIHRpbGVzOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuICB9LFxuICBib3VuZHM6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiA0LFxuICAgIFwiZGVmYXVsdFwiOiBbLTE4MCwgLTg1LjA1MTEyOSwgMTgwLCA4NS4wNTExMjldLFxuICAgIGRvYzogXCJBbiBhcnJheSBjb250YWluaW5nIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIG9mIHRoZSBzb3V0aHdlc3QgYW5kIG5vcnRoZWFzdCBjb3JuZXJzIG9mIHRoZSBzb3VyY2UncyBib3VuZGluZyBib3ggaW4gdGhlIGZvbGxvd2luZyBvcmRlcjogYFtzdy5sbmcsIHN3LmxhdCwgbmUubG5nLCBuZS5sYXRdYC4gV2hlbiB0aGlzIHByb3BlcnR5IGlzIGluY2x1ZGVkIGluIGEgc291cmNlLCBubyB0aWxlcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBib3VuZHMgYXJlIHJlcXVlc3RlZCBieSBNYXBib3ggR0wuXCJcbiAgfSxcbiAgc2NoZW1lOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB4eXo6IHtcbiAgICAgICAgZG9jOiBcIlNsaXBweSBtYXAgdGlsZW5hbWVzIHNjaGVtZS5cIlxuICAgICAgfSxcbiAgICAgIHRtczoge1xuICAgICAgICBkb2M6IFwiT1NHZW8gc3BlYyBzY2hlbWUuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcInh5elwiLFxuICAgIGRvYzogXCJJbmZsdWVuY2VzIHRoZSB5IGRpcmVjdGlvbiBvZiB0aGUgdGlsZSBjb29yZGluYXRlcy4gVGhlIGdsb2JhbC1tZXJjYXRvciAoYWthIFNwaGVyaWNhbCBNZXJjYXRvcikgcHJvZmlsZSBpcyBhc3N1bWVkLlwiXG4gIH0sXG4gIG1pbnpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIGRvYzogXCJNaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG4gIH0sXG4gIG1heHpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAyMixcbiAgICBkb2M6IFwiTWF4aW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy4gRGF0YSBmcm9tIHRpbGVzIGF0IHRoZSBtYXh6b29tIGFyZSB1c2VkIHdoZW4gZGlzcGxheWluZyB0aGUgbWFwIGF0IGhpZ2hlciB6b29tIGxldmVscy5cIlxuICB9LFxuICBhdHRyaWJ1dGlvbjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLlwiXG4gIH0sXG4gIHByb21vdGVJZDoge1xuICAgIHR5cGU6IFwicHJvbW90ZUlkXCIsXG4gICAgZG9jOiBcIkEgcHJvcGVydHkgdG8gdXNlIGFzIGEgZmVhdHVyZSBpZCAoZm9yIGZlYXR1cmUgc3RhdGUpLiBFaXRoZXIgYSBwcm9wZXJ0eSBuYW1lLCBvciBhbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHs8c291cmNlTGF5ZXI+OiA8cHJvcGVydHlOYW1lPn1gLiBJZiBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgZm9yIGEgdmVjdG9yIHRpbGUgc291cmNlLCB0aGUgc2FtZSBwcm9wZXJ0eSBpcyB1c2VkIGFjcm9zcyBhbGwgaXRzIHNvdXJjZSBsYXllcnMuXCJcbiAgfSxcbiAgdm9sYXRpbGU6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgZG9jOiBcIkEgc2V0dGluZyB0byBkZXRlcm1pbmUgd2hldGhlciBhIHNvdXJjZSdzIHRpbGVzIGFyZSBjYWNoZWQgbG9jYWxseS5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGFuZHJvaWQ6IFwiOS4zLjBcIixcbiAgICAgICAgaW9zOiBcIjUuMTAuMFwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcIipcIjoge1xuICAgIHR5cGU6IFwiKlwiLFxuICAgIGRvYzogXCJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuXCJcbiAgfVxufTtcbnZhciBzb3VyY2VfcmFzdGVyID0ge1xuICB0eXBlOiB7XG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICByYXN0ZXI6IHtcbiAgICAgICAgZG9jOiBcIkEgcmFzdGVyIHRpbGUgc291cmNlLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBkb2M6IFwiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuICB9LFxuICB1cmw6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88VGlsZXNldCBJRD5gLlwiXG4gIH0sXG4gIHRpbGVzOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuICB9LFxuICBib3VuZHM6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiA0LFxuICAgIFwiZGVmYXVsdFwiOiBbLTE4MCwgLTg1LjA1MTEyOSwgMTgwLCA4NS4wNTExMjldLFxuICAgIGRvYzogXCJBbiBhcnJheSBjb250YWluaW5nIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIG9mIHRoZSBzb3V0aHdlc3QgYW5kIG5vcnRoZWFzdCBjb3JuZXJzIG9mIHRoZSBzb3VyY2UncyBib3VuZGluZyBib3ggaW4gdGhlIGZvbGxvd2luZyBvcmRlcjogYFtzdy5sbmcsIHN3LmxhdCwgbmUubG5nLCBuZS5sYXRdYC4gV2hlbiB0aGlzIHByb3BlcnR5IGlzIGluY2x1ZGVkIGluIGEgc291cmNlLCBubyB0aWxlcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBib3VuZHMgYXJlIHJlcXVlc3RlZCBieSBNYXBib3ggR0wuXCJcbiAgfSxcbiAgbWluem9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgZG9jOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcbiAgfSxcbiAgbWF4em9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDIyLFxuICAgIGRvYzogXCJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLlwiXG4gIH0sXG4gIHRpbGVTaXplOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogNTEyLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSB0byBkaXNwbGF5IHRpbGVzIGZvciB0aGlzIGxheWVyLiBPbmx5IGNvbmZpZ3VyYWJsZSBmb3IgcmFzdGVyIGxheWVycy5cIlxuICB9LFxuICBzY2hlbWU6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHh5ejoge1xuICAgICAgICBkb2M6IFwiU2xpcHB5IG1hcCB0aWxlbmFtZXMgc2NoZW1lLlwiXG4gICAgICB9LFxuICAgICAgdG1zOiB7XG4gICAgICAgIGRvYzogXCJPU0dlbyBzcGVjIHNjaGVtZS5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwieHl6XCIsXG4gICAgZG9jOiBcIkluZmx1ZW5jZXMgdGhlIHkgZGlyZWN0aW9uIG9mIHRoZSB0aWxlIGNvb3JkaW5hdGVzLiBUaGUgZ2xvYmFsLW1lcmNhdG9yIChha2EgU3BoZXJpY2FsIE1lcmNhdG9yKSBwcm9maWxlIGlzIGFzc3VtZWQuXCJcbiAgfSxcbiAgYXR0cmlidXRpb246IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJDb250YWlucyBhbiBhdHRyaWJ1dGlvbiB0byBiZSBkaXNwbGF5ZWQgd2hlbiB0aGUgbWFwIGlzIHNob3duIHRvIGEgdXNlci5cIlxuICB9LFxuICB2b2xhdGlsZToge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICBkb2M6IFwiQSBzZXR0aW5nIHRvIGRldGVybWluZSB3aGV0aGVyIGEgc291cmNlJ3MgdGlsZXMgYXJlIGNhY2hlZCBsb2NhbGx5LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgYW5kcm9pZDogXCI5LjMuMFwiLFxuICAgICAgICBpb3M6IFwiNS4xMC4wXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiKlwiOiB7XG4gICAgdHlwZTogXCIqXCIsXG4gICAgZG9jOiBcIk90aGVyIGtleXMgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZS5cIlxuICB9XG59O1xudmFyIHNvdXJjZV9yYXN0ZXJfZGVtID0ge1xuICB0eXBlOiB7XG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBcInJhc3Rlci1kZW1cIjoge1xuICAgICAgICBkb2M6IFwiQSBSR0ItZW5jb2RlZCByYXN0ZXIgREVNIHNvdXJjZVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBkb2M6IFwiVGhlIHR5cGUgb2YgdGhlIHNvdXJjZS5cIlxuICB9LFxuICB1cmw6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJBIFVSTCB0byBhIFRpbGVKU09OIHJlc291cmNlLiBTdXBwb3J0ZWQgcHJvdG9jb2xzIGFyZSBgaHR0cDpgLCBgaHR0cHM6YCwgYW5kIGBtYXBib3g6Ly88VGlsZXNldCBJRD5gLlwiXG4gIH0sXG4gIHRpbGVzOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJBbiBhcnJheSBvZiBvbmUgb3IgbW9yZSB0aWxlIHNvdXJjZSBVUkxzLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuICB9LFxuICBib3VuZHM6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiA0LFxuICAgIFwiZGVmYXVsdFwiOiBbLTE4MCwgLTg1LjA1MTEyOSwgMTgwLCA4NS4wNTExMjldLFxuICAgIGRvYzogXCJBbiBhcnJheSBjb250YWluaW5nIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIG9mIHRoZSBzb3V0aHdlc3QgYW5kIG5vcnRoZWFzdCBjb3JuZXJzIG9mIHRoZSBzb3VyY2UncyBib3VuZGluZyBib3ggaW4gdGhlIGZvbGxvd2luZyBvcmRlcjogYFtzdy5sbmcsIHN3LmxhdCwgbmUubG5nLCBuZS5sYXRdYC4gV2hlbiB0aGlzIHByb3BlcnR5IGlzIGluY2x1ZGVkIGluIGEgc291cmNlLCBubyB0aWxlcyBvdXRzaWRlIG9mIHRoZSBnaXZlbiBib3VuZHMgYXJlIHJlcXVlc3RlZCBieSBNYXBib3ggR0wuXCJcbiAgfSxcbiAgbWluem9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgZG9jOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcbiAgfSxcbiAgbWF4em9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDIyLFxuICAgIGRvYzogXCJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLlwiXG4gIH0sXG4gIHRpbGVTaXplOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogNTEyLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJUaGUgbWluaW11bSB2aXN1YWwgc2l6ZSB0byBkaXNwbGF5IHRpbGVzIGZvciB0aGlzIGxheWVyLiBPbmx5IGNvbmZpZ3VyYWJsZSBmb3IgcmFzdGVyIGxheWVycy5cIlxuICB9LFxuICBhdHRyaWJ1dGlvbjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLlwiXG4gIH0sXG4gIGVuY29kaW5nOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB0ZXJyYXJpdW06IHtcbiAgICAgICAgZG9jOiBcIlRlcnJhcml1bSBmb3JtYXQgUE5HIHRpbGVzLiBTZWUgaHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9lcy9wdWJsaWMtZGF0YXNldHMvdGVycmFpbi8gZm9yIG1vcmUgaW5mby5cIlxuICAgICAgfSxcbiAgICAgIG1hcGJveDoge1xuICAgICAgICBkb2M6IFwiTWFwYm94IFRlcnJhaW4gUkdCIHRpbGVzLiBTZWUgaHR0cHM6Ly93d3cubWFwYm94LmNvbS9oZWxwL2FjY2Vzcy1lbGV2YXRpb24tZGF0YS8jbWFwYm94LXRlcnJhaW4tcmdiIGZvciBtb3JlIGluZm8uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcIm1hcGJveFwiLFxuICAgIGRvYzogXCJUaGUgZW5jb2RpbmcgdXNlZCBieSB0aGlzIHNvdXJjZS4gTWFwYm94IFRlcnJhaW4gUkdCIGlzIHVzZWQgYnkgZGVmYXVsdFwiXG4gIH0sXG4gIHZvbGF0aWxlOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgIGRvYzogXCJBIHNldHRpbmcgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBzb3VyY2UncyB0aWxlcyBhcmUgY2FjaGVkIGxvY2FsbHkuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBhbmRyb2lkOiBcIjkuMy4wXCIsXG4gICAgICAgIGlvczogXCI1LjEwLjBcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCIqXCI6IHtcbiAgICB0eXBlOiBcIipcIixcbiAgICBkb2M6IFwiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLlwiXG4gIH1cbn07XG52YXIgc291cmNlX2dlb2pzb24gPSB7XG4gIHR5cGU6IHtcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGdlb2pzb246IHtcbiAgICAgICAgZG9jOiBcIkEgR2VvSlNPTiBkYXRhIHNvdXJjZS5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgZG9jOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIEdlb0pTT04gc291cmNlLlwiXG4gIH0sXG4gIGRhdGE6IHtcbiAgICB0eXBlOiBcIipcIixcbiAgICBkb2M6IFwiQSBVUkwgdG8gYSBHZW9KU09OIGZpbGUsIG9yIGlubGluZSBHZW9KU09OLlwiXG4gIH0sXG4gIG1heHpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAxOCxcbiAgICBkb2M6IFwiTWF4aW11bSB6b29tIGxldmVsIGF0IHdoaWNoIHRvIGNyZWF0ZSB2ZWN0b3IgdGlsZXMgKGhpZ2hlciBtZWFucyBncmVhdGVyIGRldGFpbCBhdCBoaWdoIHpvb20gbGV2ZWxzKS5cIlxuICB9LFxuICBhdHRyaWJ1dGlvbjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLlwiXG4gIH0sXG4gIGJ1ZmZlcjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEyOCxcbiAgICBtYXhpbXVtOiA1MTIsXG4gICAgbWluaW11bTogMCxcbiAgICBkb2M6IFwiU2l6ZSBvZiB0aGUgdGlsZSBidWZmZXIgb24gZWFjaCBzaWRlLiBBIHZhbHVlIG9mIDAgcHJvZHVjZXMgbm8gYnVmZmVyLiBBIHZhbHVlIG9mIDUxMiBwcm9kdWNlcyBhIGJ1ZmZlciBhcyB3aWRlIGFzIHRoZSB0aWxlIGl0c2VsZi4gTGFyZ2VyIHZhbHVlcyBwcm9kdWNlIGZld2VyIHJlbmRlcmluZyBhcnRpZmFjdHMgbmVhciB0aWxlIGVkZ2VzIGFuZCBzbG93ZXIgcGVyZm9ybWFuY2UuXCJcbiAgfSxcbiAgZmlsdGVyOiB7XG4gICAgdHlwZTogXCIqXCIsXG4gICAgZG9jOiBcIkFuIGV4cHJlc3Npb24gZm9yIGZpbHRlcmluZyBmZWF0dXJlcyBwcmlvciB0byBwcm9jZXNzaW5nIHRoZW0gZm9yIHJlbmRlcmluZy5cIlxuICB9LFxuICB0b2xlcmFuY2U6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLjM3NSxcbiAgICBkb2M6IFwiRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uIHRvbGVyYW5jZSAoaGlnaGVyIG1lYW5zIHNpbXBsZXIgZ2VvbWV0cmllcyBhbmQgZmFzdGVyIHBlcmZvcm1hbmNlKS5cIlxuICB9LFxuICBjbHVzdGVyOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgIGRvYzogXCJJZiB0aGUgZGF0YSBpcyBhIGNvbGxlY3Rpb24gb2YgcG9pbnQgZmVhdHVyZXMsIHNldHRpbmcgdGhpcyB0byB0cnVlIGNsdXN0ZXJzIHRoZSBwb2ludHMgYnkgcmFkaXVzIGludG8gZ3JvdXBzLiBDbHVzdGVyIGdyb3VwcyBiZWNvbWUgbmV3IGBQb2ludGAgZmVhdHVyZXMgaW4gdGhlIHNvdXJjZSB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllczpcXG4gKiBgY2x1c3RlcmAgSXMgYHRydWVgIGlmIHRoZSBwb2ludCBpcyBhIGNsdXN0ZXIgXFxuICogYGNsdXN0ZXJfaWRgIEEgdW5xaXVlIGlkIGZvciB0aGUgY2x1c3RlciB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIFtjbHVzdGVyIGluc3BlY3Rpb24gbWV0aG9kc10oaHR0cHM6Ly93d3cubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvYXBpLyNnZW9qc29uc291cmNlI2dldGNsdXN0ZXJleHBhbnNpb256b29tKVxcbiAqIGBwb2ludF9jb3VudGAgTnVtYmVyIG9mIG9yaWdpbmFsIHBvaW50cyBncm91cGVkIGludG8gdGhpcyBjbHVzdGVyXFxuICogYHBvaW50X2NvdW50X2FiYnJldmlhdGVkYCBBbiBhYmJyZXZpYXRlZCBwb2ludCBjb3VudFwiXG4gIH0sXG4gIGNsdXN0ZXJSYWRpdXM6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiA1MCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIGRvYzogXCJSYWRpdXMgb2YgZWFjaCBjbHVzdGVyIGlmIGNsdXN0ZXJpbmcgaXMgZW5hYmxlZC4gQSB2YWx1ZSBvZiA1MTIgaW5kaWNhdGVzIGEgcmFkaXVzIGVxdWFsIHRvIHRoZSB3aWR0aCBvZiBhIHRpbGUuXCJcbiAgfSxcbiAgY2x1c3Rlck1heFpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJNYXggem9vbSBvbiB3aGljaCB0byBjbHVzdGVyIHBvaW50cyBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQuIERlZmF1bHRzIHRvIG9uZSB6b29tIGxlc3MgdGhhbiBtYXh6b29tIChzbyB0aGF0IGxhc3Qgem9vbSBmZWF0dXJlcyBhcmUgbm90IGNsdXN0ZXJlZCkuIENsdXN0ZXJzIGFyZSByZS1ldmFsdWF0ZWQgYXQgaW50ZWdlciB6b29tIGxldmVscyBzbyBzZXR0aW5nIGNsdXN0ZXJNYXhab29tIHRvIDE0IG1lYW5zIHRoZSBjbHVzdGVycyB3aWxsIGJlIGRpc3BsYXllZCB1bnRpbCB6MTUuXCJcbiAgfSxcbiAgY2x1c3Rlck1pblBvaW50czoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZG9jOiBcIk1pbmltdW0gbnVtYmVyIG9mIHBvaW50cyBuZWNlc3NhcnkgdG8gZm9ybSBhIGNsdXN0ZXIgaWYgY2x1c3RlcmluZyBpcyBlbmFibGVkLiBEZWZhdWx0cyB0byBgMmAuXCJcbiAgfSxcbiAgY2x1c3RlclByb3BlcnRpZXM6IHtcbiAgICB0eXBlOiBcIipcIixcbiAgICBkb2M6IFwiQW4gb2JqZWN0IGRlZmluaW5nIGN1c3RvbSBwcm9wZXJ0aWVzIG9uIHRoZSBnZW5lcmF0ZWQgY2x1c3RlcnMgaWYgY2x1c3RlcmluZyBpcyBlbmFibGVkLCBhZ2dyZWdhdGluZyB2YWx1ZXMgZnJvbSBjbHVzdGVyZWQgcG9pbnRzLiBIYXMgdGhlIGZvcm0gYHtcXFwicHJvcGVydHlfbmFtZVxcXCI6IFtvcGVyYXRvciwgbWFwX2V4cHJlc3Npb25dfWAuIGBvcGVyYXRvcmAgaXMgYW55IGV4cHJlc3Npb24gZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGF0IGxlYXN0IDIgb3BlcmFuZHMgKGUuZy4gYFxcXCIrXFxcImAgb3IgYFxcXCJtYXhcXFwiYCkg4oCUIGl0IGFjY3VtdWxhdGVzIHRoZSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIGNsdXN0ZXJzL3BvaW50cyB0aGUgY2x1c3RlciBjb250YWluczsgYG1hcF9leHByZXNzaW9uYCBwcm9kdWNlcyB0aGUgdmFsdWUgb2YgYSBzaW5nbGUgcG9pbnQuXFxuXFxuRXhhbXBsZTogYHtcXFwic3VtXFxcIjogW1xcXCIrXFxcIiwgW1xcXCJnZXRcXFwiLCBcXFwic2NhbGVyYW5rXFxcIl1dfWAuXFxuXFxuRm9yIG1vcmUgYWR2YW5jZWQgdXNlIGNhc2VzLCBpbiBwbGFjZSBvZiBgb3BlcmF0b3JgLCB5b3UgY2FuIHVzZSBhIGN1c3RvbSByZWR1Y2UgZXhwcmVzc2lvbiB0aGF0IHJlZmVyZW5jZXMgYSBzcGVjaWFsIGBbXFxcImFjY3VtdWxhdGVkXFxcIl1gIHZhbHVlLCBlLmcuOlxcbmB7XFxcInN1bVxcXCI6IFtbXFxcIitcXFwiLCBbXFxcImFjY3VtdWxhdGVkXFxcIl0sIFtcXFwiZ2V0XFxcIiwgXFxcInN1bVxcXCJdXSwgW1xcXCJnZXRcXFwiLCBcXFwic2NhbGVyYW5rXFxcIl1dfWBcIlxuICB9LFxuICBsaW5lTWV0cmljczoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICBkb2M6IFwiV2hldGhlciB0byBjYWxjdWxhdGUgbGluZSBkaXN0YW5jZSBtZXRyaWNzLiBUaGlzIGlzIHJlcXVpcmVkIGZvciBsaW5lIGxheWVycyB0aGF0IHNwZWNpZnkgYGxpbmUtZ3JhZGllbnRgIHZhbHVlcy5cIlxuICB9LFxuICBnZW5lcmF0ZUlkOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgIGRvYzogXCJXaGV0aGVyIHRvIGdlbmVyYXRlIGlkcyBmb3IgdGhlIGdlb2pzb24gZmVhdHVyZXMuIFdoZW4gZW5hYmxlZCwgdGhlIGBmZWF0dXJlLmlkYCBwcm9wZXJ0eSB3aWxsIGJlIGF1dG8gYXNzaWduZWQgYmFzZWQgb24gaXRzIGluZGV4IGluIHRoZSBgZmVhdHVyZXNgIGFycmF5LCBvdmVyLXdyaXRpbmcgYW55IHByZXZpb3VzIHZhbHVlcy5cIlxuICB9LFxuICBwcm9tb3RlSWQ6IHtcbiAgICB0eXBlOiBcInByb21vdGVJZFwiLFxuICAgIGRvYzogXCJBIHByb3BlcnR5IHRvIHVzZSBhcyBhIGZlYXR1cmUgaWQgKGZvciBmZWF0dXJlIHN0YXRlKS4gRWl0aGVyIGEgcHJvcGVydHkgbmFtZSwgb3IgYW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7PHNvdXJjZUxheWVyPjogPHByb3BlcnR5TmFtZT59YC5cIlxuICB9XG59O1xudmFyIHNvdXJjZV92aWRlbyA9IHtcbiAgdHlwZToge1xuICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmlkZW86IHtcbiAgICAgICAgZG9jOiBcIkEgdmlkZW8gZGF0YSBzb3VyY2UuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvYzogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSB2aWRlbyBzb3VyY2UuXCJcbiAgfSxcbiAgdXJsczoge1xuICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJzdHJpbmdcIixcbiAgICBkb2M6IFwiVVJMcyB0byB2aWRlbyBjb250ZW50IGluIG9yZGVyIG9mIHByZWZlcnJlZCBmb3JtYXQuXCJcbiAgfSxcbiAgY29vcmRpbmF0ZXM6IHtcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICBkb2M6IFwiQ29ybmVycyBvZiB2aWRlbyBzcGVjaWZpZWQgaW4gbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlycy5cIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbGVuZ3RoOiA0LFxuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBsZW5ndGg6IDIsXG4gICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgIGRvYzogXCJBIHNpbmdsZSBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXIuXCJcbiAgICB9XG4gIH1cbn07XG52YXIgc291cmNlX2ltYWdlID0ge1xuICB0eXBlOiB7XG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBpbWFnZToge1xuICAgICAgICBkb2M6IFwiQW4gaW1hZ2UgZGF0YSBzb3VyY2UuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvYzogXCJUaGUgZGF0YSB0eXBlIG9mIHRoZSBpbWFnZSBzb3VyY2UuXCJcbiAgfSxcbiAgdXJsOiB7XG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkb2M6IFwiVVJMIHRoYXQgcG9pbnRzIHRvIGFuIGltYWdlLlwiXG4gIH0sXG4gIGNvb3JkaW5hdGVzOiB7XG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgZG9jOiBcIkNvcm5lcnMgb2YgaW1hZ2Ugc3BlY2lmaWVkIGluIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpcnMuXCIsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIGxlbmd0aDogNCxcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgbGVuZ3RoOiAyLFxuICAgICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgICBkb2M6IFwiQSBzaW5nbGUgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlyLlwiXG4gICAgfVxuICB9XG59O1xudmFyIGxheWVyID0ge1xuICBpZDoge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIlVuaXF1ZSBsYXllciBuYW1lLlwiLFxuICAgIHJlcXVpcmVkOiB0cnVlXG4gIH0sXG4gIHR5cGU6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGZpbGw6IHtcbiAgICAgICAgZG9jOiBcIkEgZmlsbGVkIHBvbHlnb24gd2l0aCBhbiBvcHRpb25hbCBzdHJva2VkIGJvcmRlci5cIixcbiAgICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbGluZToge1xuICAgICAgICBkb2M6IFwiQSBzdHJva2VkIGxpbmUuXCIsXG4gICAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN5bWJvbDoge1xuICAgICAgICBkb2M6IFwiQW4gaWNvbiBvciBhIHRleHQgbGFiZWwuXCIsXG4gICAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNpcmNsZToge1xuICAgICAgICBkb2M6IFwiQSBmaWxsZWQgY2lyY2xlLlwiLFxuICAgICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoZWF0bWFwOiB7XG4gICAgICAgIGRvYzogXCJBIGhlYXRtYXAuXCIsXG4gICAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZmlsbC1leHRydXNpb25cIjoge1xuICAgICAgICBkb2M6IFwiQW4gZXh0cnVkZWQgKDNEKSBwb2x5Z29uLlwiLFxuICAgICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgICAganM6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByYXN0ZXI6IHtcbiAgICAgICAgZG9jOiBcIlJhc3RlciBtYXAgdGV4dHVyZXMgc3VjaCBhcyBzYXRlbGxpdGUgaW1hZ2VyeS5cIixcbiAgICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGlsbHNoYWRlOiB7XG4gICAgICAgIGRvYzogXCJDbGllbnQtc2lkZSBoaWxsc2hhZGluZyB2aXN1YWxpemF0aW9uIGJhc2VkIG9uIERFTSBkYXRhLiBDdXJyZW50bHksIHRoZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIE1hcGJveCBUZXJyYWluIFJHQiBhbmQgTWFwemVuIFRlcnJhcml1bSB0aWxlcy5cIixcbiAgICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICAgIGpzOiBcIjAuNDMuMFwiLFxuICAgICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICBkb2M6IFwiVGhlIGJhY2tncm91bmQgY29sb3Igb3IgcGF0dGVybiBvZiB0aGUgbWFwLlwiLFxuICAgICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBza3k6IHtcbiAgICAgICAgZG9jOiBcIkEgc3BoZXJpY2FsIGRvbWUgYXJvdW5kIHRoZSBtYXAgdGhhdCBpcyBhbHdheXMgcmVuZGVyZWQgYmVoaW5kIGFsbCBvdGhlciBsYXllcnMuXCIsXG4gICAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICBqczogXCIyLjAuMFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkb2M6IFwiUmVuZGVyaW5nIHR5cGUgb2YgdGhpcyBsYXllci5cIixcbiAgICByZXF1aXJlZDogdHJ1ZVxuICB9LFxuICBtZXRhZGF0YToge1xuICAgIHR5cGU6IFwiKlwiLFxuICAgIGRvYzogXCJBcmJpdHJhcnkgcHJvcGVydGllcyB1c2VmdWwgdG8gdHJhY2sgd2l0aCB0aGUgbGF5ZXIsIGJ1dCBkbyBub3QgaW5mbHVlbmNlIHJlbmRlcmluZy4gUHJvcGVydGllcyBzaG91bGQgYmUgcHJlZml4ZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSAnbWFwYm94OicuXCJcbiAgfSxcbiAgc291cmNlOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkb2M6IFwiTmFtZSBvZiBhIHNvdXJjZSBkZXNjcmlwdGlvbiB0byBiZSB1c2VkIGZvciB0aGlzIGxheWVyLiBSZXF1aXJlZCBmb3IgYWxsIGxheWVyIHR5cGVzIGV4Y2VwdCBgYmFja2dyb3VuZGAuXCJcbiAgfSxcbiAgXCJzb3VyY2UtbGF5ZXJcIjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkxheWVyIHRvIHVzZSBmcm9tIGEgdmVjdG9yIHRpbGUgc291cmNlLiBSZXF1aXJlZCBmb3IgdmVjdG9yIHRpbGUgc291cmNlczsgcHJvaGliaXRlZCBmb3IgYWxsIG90aGVyIHNvdXJjZSB0eXBlcywgaW5jbHVkaW5nIEdlb0pTT04gc291cmNlcy5cIlxuICB9LFxuICBtaW56b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDI0LFxuICAgIGRvYzogXCJUaGUgbWluaW11bSB6b29tIGxldmVsIGZvciB0aGUgbGF5ZXIuIEF0IHpvb20gbGV2ZWxzIGxlc3MgdGhhbiB0aGUgbWluem9vbSwgdGhlIGxheWVyIHdpbGwgYmUgaGlkZGVuLlwiXG4gIH0sXG4gIG1heHpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMjQsXG4gICAgZG9jOiBcIlRoZSBtYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBsYXllci4gQXQgem9vbSBsZXZlbHMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIHRoZSBtYXh6b29tLCB0aGUgbGF5ZXIgd2lsbCBiZSBoaWRkZW4uXCJcbiAgfSxcbiAgZmlsdGVyOiB7XG4gICAgdHlwZTogXCJmaWx0ZXJcIixcbiAgICBkb2M6IFwiQSBleHByZXNzaW9uIHNwZWNpZnlpbmcgY29uZGl0aW9ucyBvbiBzb3VyY2UgZmVhdHVyZXMuIE9ubHkgZmVhdHVyZXMgdGhhdCBtYXRjaCB0aGUgZmlsdGVyIGFyZSBkaXNwbGF5ZWQuIFpvb20gZXhwcmVzc2lvbnMgaW4gZmlsdGVycyBhcmUgb25seSBldmFsdWF0ZWQgYXQgaW50ZWdlciB6b29tIGxldmVscy4gVGhlIGBmZWF0dXJlLXN0YXRlYCBleHByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZmlsdGVyIGV4cHJlc3Npb25zLlwiXG4gIH0sXG4gIGxheW91dDoge1xuICAgIHR5cGU6IFwibGF5b3V0XCIsXG4gICAgZG9jOiBcIkxheW91dCBwcm9wZXJ0aWVzIGZvciB0aGUgbGF5ZXIuXCJcbiAgfSxcbiAgcGFpbnQ6IHtcbiAgICB0eXBlOiBcInBhaW50XCIsXG4gICAgZG9jOiBcIkRlZmF1bHQgcGFpbnQgcHJvcGVydGllcyBmb3IgdGhpcyBsYXllci5cIlxuICB9XG59O1xudmFyIGxheW91dCA9IFtcImxheW91dF9maWxsXCIsIFwibGF5b3V0X2xpbmVcIiwgXCJsYXlvdXRfY2lyY2xlXCIsIFwibGF5b3V0X2hlYXRtYXBcIiwgXCJsYXlvdXRfZmlsbC1leHRydXNpb25cIiwgXCJsYXlvdXRfc3ltYm9sXCIsIFwibGF5b3V0X3Jhc3RlclwiLCBcImxheW91dF9oaWxsc2hhZGVcIiwgXCJsYXlvdXRfYmFja2dyb3VuZFwiLCBcImxheW91dF9za3lcIl07XG52YXIgbGF5b3V0X2JhY2tncm91bmQgPSB7XG4gIHZpc2liaWxpdHk6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuICAgICAgfSxcbiAgICAgIG5vbmU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICBkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn07XG52YXIgbGF5b3V0X3NreSA9IHtcbiAgdmlzaWJpbGl0eToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmlzaWJsZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICB9LFxuICAgICAgbm9uZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgIGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4wLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICB9XG59O1xudmFyIGxheW91dF9maWxsID0ge1xuICBcImZpbGwtc29ydC1rZXlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZG9jOiBcIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgYXBwZWFyIGFib3ZlIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjEuMi4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiOS4xLjBcIixcbiAgICAgICAgaW9zOiBcIjUuOC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTUuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMS4yLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI5LjEuMFwiLFxuICAgICAgICBpb3M6IFwiNS44LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xNS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcbiAgICAgIH0sXG4gICAgICBub25lOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICB9XG59O1xudmFyIGxheW91dF9jaXJjbGUgPSB7XG4gIFwiY2lyY2xlLXNvcnQta2V5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJTb3J0cyBmZWF0dXJlcyBpbiBhc2NlbmRpbmcgb3JkZXIgYmFzZWQgb24gdGhpcyB2YWx1ZS4gRmVhdHVyZXMgd2l0aCBhIGhpZ2hlciBzb3J0IGtleSB3aWxsIGFwcGVhciBhYm92ZSBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIxLjIuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjkuMi4wXCIsXG4gICAgICAgIGlvczogXCI1LjkuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjE2LjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjEuMi4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiOS4yLjBcIixcbiAgICAgICAgaW9zOiBcIjUuOS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTYuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgdmlzaWJpbGl0eToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmlzaWJsZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICB9LFxuICAgICAgbm9uZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgIGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgfVxufTtcbnZhciBsYXlvdXRfaGVhdG1hcCA9IHtcbiAgdmlzaWJpbGl0eToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmlzaWJsZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICB9LFxuICAgICAgbm9uZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgIGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgfVxufTtcbnZhciBsYXlvdXRfbGluZSA9IHtcbiAgXCJsaW5lLWNhcFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBidXR0OiB7XG4gICAgICAgIGRvYzogXCJBIGNhcCB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIHRvIHRoZSBleGFjdCBlbmRwb2ludCBvZiB0aGUgbGluZS5cIlxuICAgICAgfSxcbiAgICAgIHJvdW5kOiB7XG4gICAgICAgIGRvYzogXCJBIGNhcCB3aXRoIGEgcm91bmRlZCBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIHJhZGl1cyBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoIGFuZCBjZW50ZXJlZCBvbiB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUuXCJcbiAgICAgIH0sXG4gICAgICBzcXVhcmU6IHtcbiAgICAgICAgZG9jOiBcIkEgY2FwIHdpdGggYSBzcXVhcmVkLW9mZiBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIGRpc3RhbmNlIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGguXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcImJ1dHRcIixcbiAgICBkb2M6IFwiVGhlIGRpc3BsYXkgb2YgbGluZSBlbmRpbmdzLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIyLjMuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLWpvaW5cIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgYmV2ZWw6IHtcbiAgICAgICAgZG9jOiBcIkEgam9pbiB3aXRoIGEgc3F1YXJlZC1vZmYgZW5kIHdoaWNoIGlzIGRyYXduIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUgYXQgYSBkaXN0YW5jZSBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoLlwiXG4gICAgICB9LFxuICAgICAgcm91bmQ6IHtcbiAgICAgICAgZG9jOiBcIkEgam9pbiB3aXRoIGEgcm91bmRlZCBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIHJhZGl1cyBvZiBvbmUtaGFsZiBvZiB0aGUgbGluZSdzIHdpZHRoIGFuZCBjZW50ZXJlZCBvbiB0aGUgZW5kcG9pbnQgb2YgdGhlIGxpbmUuXCJcbiAgICAgIH0sXG4gICAgICBtaXRlcjoge1xuICAgICAgICBkb2M6IFwiQSBqb2luIHdpdGggYSBzaGFycCwgYW5nbGVkIGNvcm5lciB3aGljaCBpcyBkcmF3biB3aXRoIHRoZSBvdXRlciBzaWRlcyBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBwYXRoIHVudGlsIHRoZXkgbWVldC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwibWl0ZXJcIixcbiAgICBkb2M6IFwiVGhlIGRpc3BsYXkgb2YgbGluZXMgd2hlbiBqb2luaW5nLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjQwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjIuMFwiLFxuICAgICAgICBpb3M6IFwiMy43LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC42LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwibGluZS1taXRlci1saW1pdFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMixcbiAgICBkb2M6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgbWl0ZXIgam9pbnMgdG8gYmV2ZWwgam9pbnMgZm9yIHNoYXJwIGFuZ2xlcy5cIixcbiAgICByZXF1aXJlczogW3tcbiAgICAgIFwibGluZS1qb2luXCI6IFwibWl0ZXJcIlxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImxpbmUtcm91bmQtbGltaXRcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEuMDUsXG4gICAgZG9jOiBcIlVzZWQgdG8gYXV0b21hdGljYWxseSBjb252ZXJ0IHJvdW5kIGpvaW5zIHRvIG1pdGVyIGpvaW5zIGZvciBzaGFsbG93IGFuZ2xlcy5cIixcbiAgICByZXF1aXJlczogW3tcbiAgICAgIFwibGluZS1qb2luXCI6IFwicm91bmRcIlxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImxpbmUtc29ydC1rZXlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZG9jOiBcIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgYXBwZWFyIGFib3ZlIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjEuMi4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiOS4xLjBcIixcbiAgICAgICAgaW9zOiBcIjUuOC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTUuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMS4yLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI5LjEuMFwiLFxuICAgICAgICBpb3M6IFwiNS44LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xNS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcbiAgICAgIH0sXG4gICAgICBub25lOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICB9XG59O1xudmFyIGxheW91dF9zeW1ib2wgPSB7XG4gIFwic3ltYm9sLXBsYWNlbWVudFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBwb2ludDoge1xuICAgICAgICBkb2M6IFwiVGhlIGxhYmVsIGlzIHBsYWNlZCBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIGdlb21ldHJ5IGlzIGxvY2F0ZWQuXCJcbiAgICAgIH0sXG4gICAgICBsaW5lOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGFiZWwgaXMgcGxhY2VkIGFsb25nIHRoZSBsaW5lIG9mIHRoZSBnZW9tZXRyeS4gQ2FuIG9ubHkgYmUgdXNlZCBvbiBgTGluZVN0cmluZ2AgYW5kIGBQb2x5Z29uYCBnZW9tZXRyaWVzLlwiXG4gICAgICB9LFxuICAgICAgXCJsaW5lLWNlbnRlclwiOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGFiZWwgaXMgcGxhY2VkIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGxpbmUgb2YgdGhlIGdlb21ldHJ5LiBDYW4gb25seSBiZSB1c2VkIG9uIGBMaW5lU3RyaW5nYCBhbmQgYFBvbHlnb25gIGdlb21ldHJpZXMuIE5vdGUgdGhhdCBhIHNpbmdsZSBmZWF0dXJlIGluIGEgdmVjdG9yIHRpbGUgbWF5IGNvbnRhaW4gbXVsdGlwbGUgbGluZSBnZW9tZXRyaWVzLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJwb2ludFwiLFxuICAgIGRvYzogXCJMYWJlbCBwbGFjZW1lbnQgcmVsYXRpdmUgdG8gaXRzIGdlb21ldHJ5LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImBsaW5lLWNlbnRlcmAgdmFsdWVcIjoge1xuICAgICAgICBqczogXCIwLjQ3LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjQuMFwiLFxuICAgICAgICBpb3M6IFwiNC4zLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xMC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJzeW1ib2wtc3BhY2luZ1wiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMjUwLFxuICAgIG1pbmltdW06IDEsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIkRpc3RhbmNlIGJldHdlZW4gdHdvIHN5bWJvbCBhbmNob3JzLlwiLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFwibGluZVwiXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwic3ltYm9sLWF2b2lkLWVkZ2VzXCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgZG9jOiBcIklmIHRydWUsIHRoZSBzeW1ib2xzIHdpbGwgbm90IGNyb3NzIHRpbGUgZWRnZXMgdG8gYXZvaWQgbXV0dWFsIGNvbGxpc2lvbnMuIFJlY29tbWVuZGVkIGluIGxheWVycyB0aGF0IGRvbid0IGhhdmUgZW5vdWdoIHBhZGRpbmcgaW4gdGhlIHZlY3RvciB0aWxlIHRvIHByZXZlbnQgY29sbGlzaW9ucywgb3IgaWYgaXQgaXMgYSBwb2ludCBzeW1ib2wgbGF5ZXIgcGxhY2VkIGFmdGVyIGEgbGluZSBzeW1ib2wgbGF5ZXIuIFdoZW4gdXNpbmcgYSBjbGllbnQgdGhhdCBzdXBwb3J0cyBnbG9iYWwgY29sbGlzaW9uIGRldGVjdGlvbiwgbGlrZSBNYXBib3ggR0wgSlMgdmVyc2lvbiAwLjQyLjAgb3IgZ3JlYXRlciwgZW5hYmxpbmcgdGhpcyBwcm9wZXJ0eSBpcyBub3QgbmVlZGVkIHRvIHByZXZlbnQgY2xpcHBlZCBsYWJlbHMgYXQgdGlsZSBib3VuZGFyaWVzLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJzeW1ib2wtc29ydC1rZXlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZG9jOiBcIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGxvd2VyIHNvcnQga2V5cyBhcmUgZHJhd24gYW5kIHBsYWNlZCBmaXJzdC4gIFdoZW4gYGljb24tYWxsb3ctb3ZlcmxhcGAgb3IgYHRleHQtYWxsb3ctb3ZlcmxhcGAgaXMgYGZhbHNlYCwgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5IHdpbGwgaGF2ZSBwcmlvcml0eSBkdXJpbmcgcGxhY2VtZW50LiBXaGVuIGBpY29uLWFsbG93LW92ZXJsYXBgIG9yIGB0ZXh0LWFsbG93LW92ZXJsYXBgIGlzIHNldCB0byBgdHJ1ZWAsIGZlYXR1cmVzIHdpdGggYSBoaWdoZXIgc29ydCBrZXkgd2lsbCBvdmVybGFwIG92ZXIgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC41My4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNy40LjBcIixcbiAgICAgICAgaW9zOiBcIjQuMTEuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjE0LjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuNTMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjcuNC4wXCIsXG4gICAgICAgIGlvczogXCI0LjExLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInN5bWJvbC16LW9yZGVyXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGF1dG86IHtcbiAgICAgICAgZG9jOiBcIlNvcnRzIHN5bWJvbHMgYnkgYHN5bWJvbC1zb3J0LWtleWAgaWYgc2V0LiBPdGhlcndpc2UsIHNvcnRzIHN5bWJvbHMgYnkgdGhlaXIgeS1wb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgaWYgYGljb24tYWxsb3ctb3ZlcmxhcGAgb3IgYHRleHQtYWxsb3ctb3ZlcmxhcGAgaXMgc2V0IHRvIGB0cnVlYCBvciBgaWNvbi1pZ25vcmUtcGxhY2VtZW50YCBvciBgdGV4dC1pZ25vcmUtcGxhY2VtZW50YCBpcyBgZmFsc2VgLlwiXG4gICAgICB9LFxuICAgICAgXCJ2aWV3cG9ydC15XCI6IHtcbiAgICAgICAgZG9jOiBcIlNvcnRzIHN5bWJvbHMgYnkgdGhlaXIgeS1wb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgaWYgYGljb24tYWxsb3ctb3ZlcmxhcGAgb3IgYHRleHQtYWxsb3ctb3ZlcmxhcGAgaXMgc2V0IHRvIGB0cnVlYCBvciBgaWNvbi1pZ25vcmUtcGxhY2VtZW50YCBvciBgdGV4dC1pZ25vcmUtcGxhY2VtZW50YCBpcyBgZmFsc2VgLlwiXG4gICAgICB9LFxuICAgICAgc291cmNlOiB7XG4gICAgICAgIGRvYzogXCJTb3J0cyBzeW1ib2xzIGJ5IGBzeW1ib2wtc29ydC1rZXlgIGlmIHNldC4gT3RoZXJ3aXNlLCBubyBzb3J0aW5nIGlzIGFwcGxpZWQ7IHN5bWJvbHMgYXJlIHJlbmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBzb3VyY2UgZGF0YS5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwiYXV0b1wiLFxuICAgIGRvYzogXCJEZXRlcm1pbmVzIHdoZXRoZXIgb3ZlcmxhcHBpbmcgc3ltYm9scyBpbiB0aGUgc2FtZSBsYXllciBhcmUgcmVuZGVyZWQgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcHBlYXIgaW4gdGhlIGRhdGEgc291cmNlIG9yIGJ5IHRoZWlyIHktcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LiBUbyBjb250cm9sIHRoZSBvcmRlciBhbmQgcHJpb3JpdGl6YXRpb24gb2Ygc3ltYm9scyBvdGhlcndpc2UsIHVzZSBgc3ltYm9sLXNvcnQta2V5YC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuNi4wXCIsXG4gICAgICAgIGlvczogXCI0LjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEyLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24tYWxsb3ctb3ZlcmxhcFwiOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgIGRvYzogXCJJZiB0cnVlLCB0aGUgaWNvbiB3aWxsIGJlIHZpc2libGUgZXZlbiBpZiBpdCBjb2xsaWRlcyB3aXRoIG90aGVyIHByZXZpb3VzbHkgZHJhd24gc3ltYm9scy5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi1pZ25vcmUtcGxhY2VtZW50XCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgZG9jOiBcIklmIHRydWUsIG90aGVyIHN5bWJvbHMgY2FuIGJlIHZpc2libGUgZXZlbiBpZiB0aGV5IGNvbGxpZGUgd2l0aCB0aGUgaWNvbi5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi1vcHRpb25hbFwiOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgIGRvYzogXCJJZiB0cnVlLCB0ZXh0IHdpbGwgZGlzcGxheSB3aXRob3V0IHRoZWlyIGNvcnJlc3BvbmRpbmcgaWNvbnMgd2hlbiB0aGUgaWNvbiBjb2xsaWRlcyB3aXRoIG90aGVyIHN5bWJvbHMgYW5kIHRoZSB0ZXh0IGRvZXMgbm90LlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCIsIFwidGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7XG4gICAgICAgIGRvYzogXCJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgYWxpZ25zIGljb25zIGVhc3Qtd2VzdC4gV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBsaW5lYCBvciBgbGluZS1jZW50ZXJgLCBhbGlnbnMgaWNvbiB4LWF4ZXMgd2l0aCB0aGUgbGluZS5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJQcm9kdWNlcyBpY29ucyB3aG9zZSB4LWF4ZXMgYXJlIGFsaWduZWQgd2l0aCB0aGUgeC1heGlzIG9mIHRoZSB2aWV3cG9ydCwgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYHN5bWJvbC1wbGFjZW1lbnRgLlwiXG4gICAgICB9LFxuICAgICAgYXV0bzoge1xuICAgICAgICBkb2M6IFwiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgdmlld3BvcnRgLiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgbWFwYC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwiYXV0b1wiLFxuICAgIGRvYzogXCJJbiBjb21iaW5hdGlvbiB3aXRoIGBzeW1ib2wtcGxhY2VtZW50YCwgZGV0ZXJtaW5lcyB0aGUgcm90YXRpb24gYmVoYXZpb3Igb2YgaWNvbnMuXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiYGF1dG9gIHZhbHVlXCI6IHtcbiAgICAgICAganM6IFwiMC4yNS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNC4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLXNpemVcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJmYWN0b3Igb2YgdGhlIG9yaWdpbmFsIGljb24gc2l6ZVwiLFxuICAgIGRvYzogXCJTY2FsZXMgdGhlIG9yaWdpbmFsIHNpemUgb2YgdGhlIGljb24gYnkgdGhlIHByb3ZpZGVkIGZhY3Rvci4gVGhlIG5ldyBwaXhlbCBzaXplIG9mIHRoZSBpbWFnZSB3aWxsIGJlIHRoZSBvcmlnaW5hbCBwaXhlbCBzaXplIG11bHRpcGxpZWQgYnkgYGljb24tc2l6ZWAuIDEgaXMgdGhlIG9yaWdpbmFsIHNpemU7IDMgdHJpcGxlcyB0aGUgc2l6ZSBvZiB0aGUgaW1hZ2UuXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMzUuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImljb24tdGV4dC1maXRcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbm9uZToge1xuICAgICAgICBkb2M6IFwiVGhlIGljb24gaXMgZGlzcGxheWVkIGF0IGl0cyBpbnRyaW5zaWMgYXNwZWN0IHJhdGlvLlwiXG4gICAgICB9LFxuICAgICAgd2lkdGg6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBpY29uIGlzIHNjYWxlZCBpbiB0aGUgeC1kaW1lbnNpb24gdG8gZml0IHRoZSB3aWR0aCBvZiB0aGUgdGV4dC5cIlxuICAgICAgfSxcbiAgICAgIGhlaWdodDoge1xuICAgICAgICBkb2M6IFwiVGhlIGljb24gaXMgc2NhbGVkIGluIHRoZSB5LWRpbWVuc2lvbiB0byBmaXQgdGhlIGhlaWdodCBvZiB0aGUgdGV4dC5cIlxuICAgICAgfSxcbiAgICAgIGJvdGg6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBpY29uIGlzIHNjYWxlZCBpbiBib3RoIHgtIGFuZCB5LWRpbWVuc2lvbnMuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcIm5vbmVcIixcbiAgICBkb2M6IFwiU2NhbGVzIHRoZSBpY29uIHRvIGZpdCBhcm91bmQgdGhlIGFzc29jaWF0ZWQgdGV4dC5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiLCBcInRleHQtZmllbGRcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjIxLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI0LjIuMFwiLFxuICAgICAgICBpb3M6IFwiMy40LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4yLjFcIlxuICAgICAgfSxcbiAgICAgIFwic3RyZXRjaGFibGUgaWNvbnNcIjoge1xuICAgICAgICBqczogXCIxLjYuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjkuMi4wXCIsXG4gICAgICAgIGlvczogXCI1LjguMFwiLFxuICAgICAgICBtYWNvczogXCIwLjE1LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24tdGV4dC1maXQtcGFkZGluZ1wiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGxlbmd0aDogNCxcbiAgICBcImRlZmF1bHRcIjogWzAsIDAsIDAsIDBdLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYWRkZWQgdG8gZGltZW5zaW9ucyBkZXRlcm1pbmVkIGJ5IGBpY29uLXRleHQtZml0YCwgaW4gY2xvY2t3aXNlIG9yZGVyOiB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQuXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIiwgXCJ0ZXh0LWZpZWxkXCIsIHtcbiAgICAgIFwiaWNvbi10ZXh0LWZpdFwiOiBbXCJib3RoXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl1cbiAgICB9XSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMjEuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjQuMi4wXCIsXG4gICAgICAgIGlvczogXCIzLjQuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjIuMVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLWltYWdlXCI6IHtcbiAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICBkb2M6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGFuIGltYWdlIGJhY2tncm91bmQuXCIsXG4gICAgdG9rZW5zOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjM1LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi1yb3RhdGVcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgcGVyaW9kOiAzNjAsXG4gICAgdW5pdHM6IFwiZGVncmVlc1wiLFxuICAgIGRvYzogXCJSb3RhdGVzIHRoZSBpY29uIGNsb2Nrd2lzZS5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4yMS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi1wYWRkaW5nXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgIG1pbmltdW06IDAsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIlNpemUgb2YgdGhlIGFkZGl0aW9uYWwgYXJlYSBhcm91bmQgdGhlIGljb24gYm91bmRpbmcgYm94IHVzZWQgZm9yIGRldGVjdGluZyBzeW1ib2wgY29sbGlzaW9ucy5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLWtlZXAtdXByaWdodFwiOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgIGRvYzogXCJJZiB0cnVlLCB0aGUgaWNvbiBtYXkgYmUgZmxpcHBlZCB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIiwge1xuICAgICAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgfSwge1xuICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcImxpbmVcIiwgXCJsaW5lLWNlbnRlclwiXVxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLW9mZnNldFwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGxlbmd0aDogMixcbiAgICBcImRlZmF1bHRcIjogWzAsIDBdLFxuICAgIGRvYzogXCJPZmZzZXQgZGlzdGFuY2Ugb2YgaWNvbiBmcm9tIGl0cyBhbmNob3IuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLiBFYWNoIGNvbXBvbmVudCBpcyBtdWx0aXBsaWVkIGJ5IHRoZSB2YWx1ZSBvZiBgaWNvbi1zaXplYCB0byBvYnRhaW4gdGhlIGZpbmFsIG9mZnNldCBpbiBwaXhlbHMuIFdoZW4gY29tYmluZWQgd2l0aCBgaWNvbi1yb3RhdGVgIHRoZSBvZmZzZXQgd2lsbCBiZSBhcyBpZiB0aGUgcm90YXRlZCBkaXJlY3Rpb24gd2FzIHVwLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjI5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBjZW50ZXI6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBjZW50ZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIGxlZnQ6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsZWZ0IHNpZGUgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgcmlnaHQgc2lkZSBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgdG9wOiB7XG4gICAgICAgIGRvYzogXCJUaGUgdG9wIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICBib3R0b206IHtcbiAgICAgICAgZG9jOiBcIlRoZSBib3R0b20gb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIFwidG9wLWxlZnRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgXCJ0b3AtcmlnaHRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIFwiYm90dG9tLWxlZnRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgXCJib3R0b20tcmlnaHRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG4gICAgZG9jOiBcIlBhcnQgb2YgdGhlIGljb24gcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMi4wXCIsXG4gICAgICAgIGlvczogXCIzLjcuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjYuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC40MC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNy4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNi4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImljb24tcGl0Y2gtYWxpZ25tZW50XCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge1xuICAgICAgICBkb2M6IFwiVGhlIGljb24gaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIG1hcC5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgaWNvbiBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgdmlld3BvcnQuXCJcbiAgICAgIH0sXG4gICAgICBhdXRvOiB7XG4gICAgICAgIGRvYzogXCJBdXRvbWF0aWNhbGx5IG1hdGNoZXMgdGhlIHZhbHVlIG9mIGBpY29uLXJvdGF0aW9uLWFsaWdubWVudGAuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcImF1dG9cIixcbiAgICBkb2M6IFwiT3JpZW50YXRpb24gb2YgaWNvbiB3aGVuIG1hcCBpcyBwaXRjaGVkLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4zOS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNy4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNi4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LXBpdGNoLWFsaWdubWVudFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHtcbiAgICAgICAgZG9jOiBcIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSBtYXAuXCJcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBkb2M6IFwiVGhlIHRleHQgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIHZpZXdwb3J0LlwiXG4gICAgICB9LFxuICAgICAgYXV0bzoge1xuICAgICAgICBkb2M6IFwiQXV0b21hdGljYWxseSBtYXRjaGVzIHRoZSB2YWx1ZSBvZiBgdGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRgLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJhdXRvXCIsXG4gICAgZG9jOiBcIk9yaWVudGF0aW9uIG9mIHRleHQgd2hlbiBtYXAgaXMgcGl0Y2hlZC5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMjEuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjQuMi4wXCIsXG4gICAgICAgIGlvczogXCIzLjQuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjIuMVwiXG4gICAgICB9LFxuICAgICAgXCJgYXV0b2AgdmFsdWVcIjoge1xuICAgICAgICBqczogXCIwLjI1LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI0LjIuMFwiLFxuICAgICAgICBpb3M6IFwiMy40LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4zLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge1xuICAgICAgICBkb2M6IFwiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIGFsaWducyB0ZXh0IGVhc3Qtd2VzdC4gV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBsaW5lYCBvciBgbGluZS1jZW50ZXJgLCBhbGlnbnMgdGV4dCB4LWF4ZXMgd2l0aCB0aGUgbGluZS5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJQcm9kdWNlcyBnbHlwaHMgd2hvc2UgeC1heGVzIGFyZSBhbGlnbmVkIHdpdGggdGhlIHgtYXhpcyBvZiB0aGUgdmlld3BvcnQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGBzeW1ib2wtcGxhY2VtZW50YC5cIlxuICAgICAgfSxcbiAgICAgIGF1dG86IHtcbiAgICAgICAgZG9jOiBcIldoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgcG9pbnRgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYHZpZXdwb3J0YC4gV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBsaW5lYCBvciBgbGluZS1jZW50ZXJgLCB0aGlzIGlzIGVxdWl2YWxlbnQgdG8gYG1hcGAuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcImF1dG9cIixcbiAgICBkb2M6IFwiSW4gY29tYmluYXRpb24gd2l0aCBgc3ltYm9sLXBsYWNlbWVudGAsIGRldGVybWluZXMgdGhlIHJvdGF0aW9uIGJlaGF2aW9yIG9mIHRoZSBpbmRpdmlkdWFsIGdseXBocyBmb3JtaW5nIHRoZSB0ZXh0LlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImBhdXRvYCB2YWx1ZVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMjUuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjQuMi4wXCIsXG4gICAgICAgIGlvczogXCIzLjQuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjMuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC1maWVsZFwiOiB7XG4gICAgdHlwZTogXCJmb3JtYXR0ZWRcIixcbiAgICBcImRlZmF1bHRcIjogXCJcIixcbiAgICB0b2tlbnM6IHRydWUsXG4gICAgZG9jOiBcIlZhbHVlIHRvIHVzZSBmb3IgYSB0ZXh0IGxhYmVsLiBJZiBhIHBsYWluIGBzdHJpbmdgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBgZm9ybWF0dGVkYCB3aXRoIGRlZmF1bHQvaW5oZXJpdGVkIGZvcm1hdHRpbmcgb3B0aW9ucy5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zMy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtZm9udFwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcInN0cmluZ1wiLFxuICAgIFwiZGVmYXVsdFwiOiBbXCJPcGVuIFNhbnMgUmVndWxhclwiLCBcIkFyaWFsIFVuaWNvZGUgTVMgUmVndWxhclwiXSxcbiAgICBkb2M6IFwiRm9udCBzdGFjayB0byB1c2UgZm9yIGRpc3BsYXlpbmcgdGV4dC5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC40My4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtc2l6ZVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMTYsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiRm9udCBzaXplLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjM1LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LW1heC13aWR0aFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMTAsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJlbXNcIixcbiAgICBkb2M6IFwiVGhlIG1heGltdW0gbGluZSB3aWR0aCBmb3IgdGV4dCB3cmFwcGluZy5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC40MC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNy4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNi4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1saW5lLWhlaWdodFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMS4yLFxuICAgIHVuaXRzOiBcImVtc1wiLFxuICAgIGRvYzogXCJUZXh0IGxlYWRpbmcgdmFsdWUgZm9yIG11bHRpLWxpbmUgdGV4dC5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMi4zLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LWxldHRlci1zcGFjaW5nXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIHVuaXRzOiBcImVtc1wiLFxuICAgIGRvYzogXCJUZXh0IHRyYWNraW5nIGFtb3VudC5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC40MC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNy4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNi4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1qdXN0aWZ5XCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGF1dG86IHtcbiAgICAgICAgZG9jOiBcIlRoZSB0ZXh0IGlzIGFsaWduZWQgdG93YXJkcyB0aGUgYW5jaG9yIHBvc2l0aW9uLlwiXG4gICAgICB9LFxuICAgICAgbGVmdDoge1xuICAgICAgICBkb2M6IFwiVGhlIHRleHQgaXMgYWxpZ25lZCB0byB0aGUgbGVmdC5cIlxuICAgICAgfSxcbiAgICAgIGNlbnRlcjoge1xuICAgICAgICBkb2M6IFwiVGhlIHRleHQgaXMgY2VudGVyZWQuXCJcbiAgICAgIH0sXG4gICAgICByaWdodDoge1xuICAgICAgICBkb2M6IFwiVGhlIHRleHQgaXMgYWxpZ25lZCB0byB0aGUgcmlnaHQuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuICAgIGRvYzogXCJUZXh0IGp1c3RpZmljYXRpb24gb3B0aW9ucy5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zOS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNy4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNi4wXCJcbiAgICAgIH0sXG4gICAgICBhdXRvOiB7XG4gICAgICAgIGpzOiBcIjAuNTQuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjcuNC4wXCIsXG4gICAgICAgIGlvczogXCI0LjEwLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtcmFkaWFsLW9mZnNldFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICB1bml0czogXCJlbXNcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBkb2M6IFwiUmFkaWFsIG9mZnNldCBvZiB0ZXh0LCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzeW1ib2wncyBhbmNob3IuIFVzZWZ1bCBpbiBjb21iaW5hdGlvbiB3aXRoIGB0ZXh0LXZhcmlhYmxlLWFuY2hvcmAsIHdoaWNoIGRlZmF1bHRzIHRvIHVzaW5nIHRoZSB0d28tZGltZW5zaW9uYWwgYHRleHQtb2Zmc2V0YCBpZiBwcmVzZW50LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC41NC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNy40LjBcIixcbiAgICAgICAgaW9zOiBcIjQuMTAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjE0LjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuNTQuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjcuNC4wXCIsXG4gICAgICAgIGlvczogXCI0LjEwLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCIsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9XG4gIH0sXG4gIFwidGV4dC12YXJpYWJsZS1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBjZW50ZXI6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBjZW50ZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIGxlZnQ6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsZWZ0IHNpZGUgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgcmlnaHQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgdG9wOiB7XG4gICAgICAgIGRvYzogXCJUaGUgdG9wIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICBib3R0b206IHtcbiAgICAgICAgZG9jOiBcIlRoZSBib3R0b20gb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIFwidG9wLWxlZnRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgXCJ0b3AtcmlnaHRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIFwiYm90dG9tLWxlZnRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgXCJib3R0b20tcmlnaHRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcInBvaW50XCJdXG4gICAgfV0sXG4gICAgZG9jOiBcIlRvIGluY3JlYXNlIHRoZSBjaGFuY2Ugb2YgcGxhY2luZyBoaWdoLXByaW9yaXR5IGxhYmVscyBvbiB0aGUgbWFwLCB5b3UgY2FuIHByb3ZpZGUgYW4gYXJyYXkgb2YgYHRleHQtYW5jaG9yYCBsb2NhdGlvbnM6IHRoZSByZW5kZXJlciB3aWxsIGF0dGVtcHQgdG8gcGxhY2UgdGhlIGxhYmVsIGF0IGVhY2ggbG9jYXRpb24sIGluIG9yZGVyLCBiZWZvcmUgbW92aW5nIG9udG8gdGhlIG5leHQgbGFiZWwuIFVzZSBgdGV4dC1qdXN0aWZ5OiBhdXRvYCB0byBjaG9vc2UganVzdGlmaWNhdGlvbiBiYXNlZCBvbiBhbmNob3IgcG9zaXRpb24uIFRvIGFwcGx5IGFuIG9mZnNldCwgdXNlIHRoZSBgdGV4dC1yYWRpYWwtb2Zmc2V0YCBvciB0aGUgdHdvLWRpbWVuc2lvbmFsIGB0ZXh0LW9mZnNldGAuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjU0LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI3LjQuMFwiLFxuICAgICAgICBpb3M6IFwiNC4xMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgY2VudGVyOiB7XG4gICAgICAgIGRvYzogXCJUaGUgY2VudGVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICBsZWZ0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGVmdCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICByaWdodDoge1xuICAgICAgICBkb2M6IFwiVGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIHRvcDoge1xuICAgICAgICBkb2M6IFwiVGhlIHRvcCBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgYm90dG9tOiB7XG4gICAgICAgIGRvYzogXCJUaGUgYm90dG9tIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICBcInRvcC1sZWZ0XCI6IHtcbiAgICAgICAgZG9jOiBcIlRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIFwidG9wLXJpZ2h0XCI6IHtcbiAgICAgICAgZG9jOiBcIlRoZSB0b3AgcmlnaHQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICBcImJvdHRvbS1sZWZ0XCI6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBib3R0b20gbGVmdCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIFwiYm90dG9tLXJpZ2h0XCI6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBib3R0b20gcmlnaHQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcImNlbnRlclwiLFxuICAgIGRvYzogXCJQYXJ0IG9mIHRoZSB0ZXh0IHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgXCIhXCI6IFwidGV4dC12YXJpYWJsZS1hbmNob3JcIlxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjM5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjIuMFwiLFxuICAgICAgICBpb3M6IFwiMy43LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC42LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1tYXgtYW5nbGVcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDQ1LFxuICAgIHVuaXRzOiBcImRlZ3JlZXNcIixcbiAgICBkb2M6IFwiTWF4aW11bSBhbmdsZSBjaGFuZ2UgYmV0d2VlbiBhZGphY2VudCBjaGFyYWN0ZXJzLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCIsIHtcbiAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXCJsaW5lXCIsIFwibGluZS1jZW50ZXJcIl1cbiAgICB9XSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LXdyaXRpbmctbW9kZVwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGhvcml6b250YWw6IHtcbiAgICAgICAgZG9jOiBcIklmIGEgdGV4dCdzIGxhbmd1YWdlIHN1cHBvcnRzIGhvcml6b250YWwgd3JpdGluZyBtb2RlLCBzeW1ib2xzIHdpdGggcG9pbnQgcGxhY2VtZW50IHdvdWxkIGJlIGxhaWQgb3V0IGhvcml6b250YWxseS5cIlxuICAgICAgfSxcbiAgICAgIHZlcnRpY2FsOiB7XG4gICAgICAgIGRvYzogXCJJZiBhIHRleHQncyBsYW5ndWFnZSBzdXBwb3J0cyB2ZXJ0aWNhbCB3cml0aW5nIG1vZGUsIHN5bWJvbHMgd2l0aCBwb2ludCBwbGFjZW1lbnQgd291bGQgYmUgbGFpZCBvdXQgdmVydGljYWxseS5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgZG9jOiBcIlRoZSBwcm9wZXJ0eSBhbGxvd3MgY29udHJvbCBvdmVyIGEgc3ltYm9sJ3Mgb3JpZW50YXRpb24uIE5vdGUgdGhhdCB0aGUgcHJvcGVydHkgdmFsdWVzIGFjdCBhcyBhIGhpbnQsIHNvIHRoYXQgYSBzeW1ib2wgd2hvc2UgbGFuZ3VhZ2UgZG9lc27igJl0IHN1cHBvcnQgdGhlIHByb3ZpZGVkIG9yaWVudGF0aW9uIHdpbGwgYmUgbGFpZCBvdXQgaW4gaXRzIG5hdHVyYWwgb3JpZW50YXRpb24uIEV4YW1wbGU6IEVuZ2xpc2ggcG9pbnQgc3ltYm9sIHdpbGwgYmUgcmVuZGVyZWQgaG9yaXpvbnRhbGx5IGV2ZW4gaWYgYXJyYXkgdmFsdWUgY29udGFpbnMgc2luZ2xlICd2ZXJ0aWNhbCcgZW51bSB2YWx1ZS4gVGhlIG9yZGVyIG9mIGVsZW1lbnRzIGluIGFuIGFycmF5IGRlZmluZSBwcmlvcml0eSBvcmRlciBmb3IgdGhlIHBsYWNlbWVudCBvZiBhbiBvcmllbnRhdGlvbiB2YXJpYW50LlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCIsIHtcbiAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBbXCJwb2ludFwiXVxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMS4zLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI4LjMuMFwiLFxuICAgICAgICBpb3M6IFwiNS4zLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xNS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LXJvdGF0ZVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBwZXJpb2Q6IDM2MCxcbiAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgZG9jOiBcIlJvdGF0ZXMgdGhlIHRleHQgY2xvY2t3aXNlLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjM1LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LXBhZGRpbmdcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDIsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiU2l6ZSBvZiB0aGUgYWRkaXRpb25hbCBhcmVhIGFyb3VuZCB0aGUgdGV4dCBib3VuZGluZyBib3ggdXNlZCBmb3IgZGV0ZWN0aW5nIHN5bWJvbCBjb2xsaXNpb25zLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQta2VlcC11cHJpZ2h0XCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICBkb2M6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgbWF5IGJlIGZsaXBwZWQgdmVydGljYWxseSB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcmVuZGVyZWQgdXBzaWRlLWRvd24uXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgXCJ0ZXh0LXJvdGF0aW9uLWFsaWdubWVudFwiOiBcIm1hcFwiXG4gICAgfSwge1xuICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcImxpbmVcIiwgXCJsaW5lLWNlbnRlclwiXVxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LXRyYW5zZm9ybVwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBub25lOiB7XG4gICAgICAgIGRvYzogXCJUaGUgdGV4dCBpcyBub3QgYWx0ZXJlZC5cIlxuICAgICAgfSxcbiAgICAgIHVwcGVyY2FzZToge1xuICAgICAgICBkb2M6IFwiRm9yY2VzIGFsbCBsZXR0ZXJzIHRvIGJlIGRpc3BsYXllZCBpbiB1cHBlcmNhc2UuXCJcbiAgICAgIH0sXG4gICAgICBsb3dlcmNhc2U6IHtcbiAgICAgICAgZG9jOiBcIkZvcmNlcyBhbGwgbGV0dGVycyB0byBiZSBkaXNwbGF5ZWQgaW4gbG93ZXJjYXNlLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJub25lXCIsXG4gICAgZG9jOiBcIlNwZWNpZmllcyBob3cgdG8gY2FwaXRhbGl6ZSB0ZXh0LCBzaW1pbGFyIHRvIHRoZSBDU1MgYHRleHQtdHJhbnNmb3JtYCBwcm9wZXJ0eS5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zMy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtb2Zmc2V0XCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgZG9jOiBcIk9mZnNldCBkaXN0YW5jZSBvZiB0ZXh0IGZyb20gaXRzIGFuY2hvci4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuIElmIHVzZWQgd2l0aCB0ZXh0LXZhcmlhYmxlLWFuY2hvciwgaW5wdXQgdmFsdWVzIHdpbGwgYmUgdGFrZW4gYXMgYWJzb2x1dGUgdmFsdWVzLiBPZmZzZXRzIGFsb25nIHRoZSB4LSBhbmQgeS1heGlzIHdpbGwgYmUgYXBwbGllZCBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoZSBhbmNob3IgcG9zaXRpb24uXCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgbGVuZ3RoOiAyLFxuICAgIFwiZGVmYXVsdFwiOiBbMCwgMF0sXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgXCIhXCI6IFwidGV4dC1yYWRpYWwtb2Zmc2V0XCJcbiAgICB9XSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zNS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4xLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgZG9jOiBcIklmIHRydWUsIHRoZSB0ZXh0IHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgcHJldmlvdXNseSBkcmF3biBzeW1ib2xzLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICBkb2M6IFwiSWYgdHJ1ZSwgb3RoZXIgc3ltYm9scyBjYW4gYmUgdmlzaWJsZSBldmVuIGlmIHRoZXkgY29sbGlkZSB3aXRoIHRoZSB0ZXh0LlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LW9wdGlvbmFsXCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgZG9jOiBcIklmIHRydWUsIGljb25zIHdpbGwgZGlzcGxheSB3aXRob3V0IHRoZWlyIGNvcnJlc3BvbmRpbmcgdGV4dCB3aGVuIHRoZSB0ZXh0IGNvbGxpZGVzIHdpdGggb3RoZXIgc3ltYm9scyBhbmQgdGhlIGljb24gZG9lcyBub3QuXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwgXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgdmlzaWJpbGl0eToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmlzaWJsZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICB9LFxuICAgICAgbm9uZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgIGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgfVxufTtcbnZhciBsYXlvdXRfcmFzdGVyID0ge1xuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcbiAgICAgIH0sXG4gICAgICBub25lOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICB9XG59O1xudmFyIGxheW91dF9oaWxsc2hhZGUgPSB7XG4gIHZpc2liaWxpdHk6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuICAgICAgfSxcbiAgICAgIG5vbmU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICBkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn07XG52YXIgZmlsdGVyID0ge1xuICB0eXBlOiBcImFycmF5XCIsXG4gIHZhbHVlOiBcIipcIixcbiAgZG9jOiBcIkEgZmlsdGVyIHNlbGVjdHMgc3BlY2lmaWMgZmVhdHVyZXMgZnJvbSBhIGxheWVyLlwiXG59O1xudmFyIGZpbHRlcl9vcGVyYXRvciA9IHtcbiAgdHlwZTogXCJlbnVtXCIsXG4gIHZhbHVlczoge1xuICAgIFwiPT1cIjoge1xuICAgICAgZG9jOiBcImBbXFxcIj09XFxcIiwga2V5LCB2YWx1ZV1gIGVxdWFsaXR5OiBgZmVhdHVyZVtrZXldID0gdmFsdWVgXCJcbiAgICB9LFxuICAgIFwiIT1cIjoge1xuICAgICAgZG9jOiBcImBbXFxcIiE9XFxcIiwga2V5LCB2YWx1ZV1gIGluZXF1YWxpdHk6IGBmZWF0dXJlW2tleV0g4omgIHZhbHVlYFwiXG4gICAgfSxcbiAgICBcIj5cIjoge1xuICAgICAgZG9jOiBcImBbXFxcIj5cXFwiLCBrZXksIHZhbHVlXWAgZ3JlYXRlciB0aGFuOiBgZmVhdHVyZVtrZXldID4gdmFsdWVgXCJcbiAgICB9LFxuICAgIFwiPj1cIjoge1xuICAgICAgZG9jOiBcImBbXFxcIj49XFxcIiwga2V5LCB2YWx1ZV1gIGdyZWF0ZXIgdGhhbiBvciBlcXVhbDogYGZlYXR1cmVba2V5XSDiiaUgdmFsdWVgXCJcbiAgICB9LFxuICAgIFwiPFwiOiB7XG4gICAgICBkb2M6IFwiYFtcXFwiPFxcXCIsIGtleSwgdmFsdWVdYCBsZXNzIHRoYW46IGBmZWF0dXJlW2tleV0gPCB2YWx1ZWBcIlxuICAgIH0sXG4gICAgXCI8PVwiOiB7XG4gICAgICBkb2M6IFwiYFtcXFwiPD1cXFwiLCBrZXksIHZhbHVlXWAgbGVzcyB0aGFuIG9yIGVxdWFsOiBgZmVhdHVyZVtrZXldIOKJpCB2YWx1ZWBcIlxuICAgIH0sXG4gICAgXCJpblwiOiB7XG4gICAgICBkb2M6IFwiYFtcXFwiaW5cXFwiLCBrZXksIHYwLCAuLi4sIHZuXWAgc2V0IGluY2x1c2lvbjogYGZlYXR1cmVba2V5XSDiiIgge3YwLCAuLi4sIHZufWBcIlxuICAgIH0sXG4gICAgXCIhaW5cIjoge1xuICAgICAgZG9jOiBcImBbXFxcIiFpblxcXCIsIGtleSwgdjAsIC4uLiwgdm5dYCBzZXQgZXhjbHVzaW9uOiBgZmVhdHVyZVtrZXldIOKIiSB7djAsIC4uLiwgdm59YFwiXG4gICAgfSxcbiAgICBhbGw6IHtcbiAgICAgIGRvYzogXCJgW1xcXCJhbGxcXFwiLCBmMCwgLi4uLCBmbl1gIGxvZ2ljYWwgYEFORGA6IGBmMCDiiKcgLi4uIOKIpyBmbmBcIlxuICAgIH0sXG4gICAgYW55OiB7XG4gICAgICBkb2M6IFwiYFtcXFwiYW55XFxcIiwgZjAsIC4uLiwgZm5dYCBsb2dpY2FsIGBPUmA6IGBmMCDiiKggLi4uIOKIqCBmbmBcIlxuICAgIH0sXG4gICAgbm9uZToge1xuICAgICAgZG9jOiBcImBbXFxcIm5vbmVcXFwiLCBmMCwgLi4uLCBmbl1gIGxvZ2ljYWwgYE5PUmA6IGDCrGYwIOKIpyAuLi4g4oinIMKsZm5gXCJcbiAgICB9LFxuICAgIGhhczoge1xuICAgICAgZG9jOiBcImBbXFxcImhhc1xcXCIsIGtleV1gIGBmZWF0dXJlW2tleV1gIGV4aXN0c1wiXG4gICAgfSxcbiAgICBcIiFoYXNcIjoge1xuICAgICAgZG9jOiBcImBbXFxcIiFoYXNcXFwiLCBrZXldYCBgZmVhdHVyZVtrZXldYCBkb2VzIG5vdCBleGlzdFwiXG4gICAgfSxcbiAgICB3aXRoaW46IHtcbiAgICAgIGRvYzogXCJgW1xcXCJ3aXRoaW5cXFwiLCBvYmplY3RdYCBmZWF0dXJlIGdlb21ldHJ5IGlzIHdpdGhpbiBvYmplY3QgZ2VvbWV0cnlcIlxuICAgIH1cbiAgfSxcbiAgZG9jOiBcIlRoZSBmaWx0ZXIgb3BlcmF0b3IuXCJcbn07XG52YXIgZ2VvbWV0cnlfdHlwZSA9IHtcbiAgdHlwZTogXCJlbnVtXCIsXG4gIHZhbHVlczoge1xuICAgIFBvaW50OiB7XG4gICAgICBkb2M6IFwiRmlsdGVyIHRvIHBvaW50IGdlb21ldHJpZXMuXCJcbiAgICB9LFxuICAgIExpbmVTdHJpbmc6IHtcbiAgICAgIGRvYzogXCJGaWx0ZXIgdG8gbGluZSBnZW9tZXRyaWVzLlwiXG4gICAgfSxcbiAgICBQb2x5Z29uOiB7XG4gICAgICBkb2M6IFwiRmlsdGVyIHRvIHBvbHlnb24gZ2VvbWV0cmllcy5cIlxuICAgIH1cbiAgfSxcbiAgZG9jOiBcIlRoZSBnZW9tZXRyeSB0eXBlIGZvciB0aGUgZmlsdGVyIHRvIHNlbGVjdC5cIlxufTtcbnZhciBmdW5jdGlvbl9zdG9wID0ge1xuICB0eXBlOiBcImFycmF5XCIsXG4gIG1pbmltdW06IDAsXG4gIG1heGltdW06IDI0LFxuICB2YWx1ZTogW1wibnVtYmVyXCIsIFwiY29sb3JcIl0sXG4gIGxlbmd0aDogMixcbiAgZG9jOiBcIlpvb20gbGV2ZWwgYW5kIHZhbHVlIHBhaXIuXCJcbn07XG52YXIgZXhwcmVzc2lvbiA9IHtcbiAgdHlwZTogXCJhcnJheVwiLFxuICB2YWx1ZTogXCIqXCIsXG4gIG1pbmltdW06IDEsXG4gIGRvYzogXCJBbiBleHByZXNzaW9uIGRlZmluZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIGZvciBkYXRhLWRyaXZlbiBzdHlsZSBwcm9wZXJ0aWVzIG9yIGZlYXR1cmUgZmlsdGVycy5cIlxufTtcbnZhciBleHByZXNzaW9uX25hbWUgPSB7XG4gIGRvYzogXCJcIixcbiAgdHlwZTogXCJlbnVtXCIsXG4gIHZhbHVlczoge1xuICAgIFwibGV0XCI6IHtcbiAgICAgIGRvYzogXCJCaW5kcyBleHByZXNzaW9ucyB0byBuYW1lZCB2YXJpYWJsZXMsIHdoaWNoIGNhbiB0aGVuIGJlIHJlZmVyZW5jZWQgaW4gdGhlIHJlc3VsdCBleHByZXNzaW9uIHVzaW5nIFtcXFwidmFyXFxcIiwgXFxcInZhcmlhYmxlX25hbWVcXFwiXS5cIixcbiAgICAgIGdyb3VwOiBcIlZhcmlhYmxlIGJpbmRpbmdcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidmFyXCI6IHtcbiAgICAgIGRvYzogXCJSZWZlcmVuY2VzIHZhcmlhYmxlIGJvdW5kIHVzaW5nIFxcXCJsZXRcXFwiLlwiLFxuICAgICAgZ3JvdXA6IFwiVmFyaWFibGUgYmluZGluZ1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbGl0ZXJhbDoge1xuICAgICAgZG9jOiBcIlByb3ZpZGVzIGEgbGl0ZXJhbCBhcnJheSBvciBvYmplY3QgdmFsdWUuXCIsXG4gICAgICBncm91cDogXCJUeXBlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYXJyYXk6IHtcbiAgICAgIGRvYzogXCJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IGlzIGFuIGFycmF5IChvcHRpb25hbGx5IHdpdGggYSBzcGVjaWZpYyBpdGVtIHR5cGUgYW5kIGxlbmd0aCkuICBJZiwgd2hlbiB0aGUgaW5wdXQgZXhwcmVzc2lvbiBpcyBldmFsdWF0ZWQsIGl0IGlzIG5vdCBvZiB0aGUgYXNzZXJ0ZWQgdHlwZSwgdGhlbiB0aGlzIGFzc2VydGlvbiB3aWxsIGNhdXNlIHRoZSB3aG9sZSBleHByZXNzaW9uIHRvIGJlIGFib3J0ZWQuXCIsXG4gICAgICBncm91cDogXCJUeXBlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYXQ6IHtcbiAgICAgIGRvYzogXCJSZXRyaWV2ZXMgYW4gaXRlbSBmcm9tIGFuIGFycmF5LlwiLFxuICAgICAgZ3JvdXA6IFwiTG9va3VwXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImluXCI6IHtcbiAgICAgIGRvYzogXCJEZXRlcm1pbmVzIHdoZXRoZXIgYW4gaXRlbSBleGlzdHMgaW4gYW4gYXJyYXkgb3IgYSBzdWJzdHJpbmcgZXhpc3RzIGluIGEgc3RyaW5nLlwiLFxuICAgICAgZ3JvdXA6IFwiTG9va3VwXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIxLjYuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiOS4xLjBcIixcbiAgICAgICAgICBpb3M6IFwiNS44LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjE1LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImluZGV4LW9mXCI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBmaXJzdCBwb3NpdGlvbiBhdCB3aGljaCBhbiBpdGVtIGNhbiBiZSBmb3VuZCBpbiBhbiBhcnJheSBvciBhIHN1YnN0cmluZyBjYW4gYmUgZm91bmQgaW4gYSBzdHJpbmcsIG9yIGAtMWAgaWYgdGhlIGlucHV0IGNhbm5vdCBiZSBmb3VuZC4gQWNjZXB0cyBhbiBvcHRpb25hbCBpbmRleCBmcm9tIHdoZXJlIHRvIGJlZ2luIHRoZSBzZWFyY2guXCIsXG4gICAgICBncm91cDogXCJMb29rdXBcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjEuMTAuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNsaWNlOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBhbiBpdGVtIGZyb20gYW4gYXJyYXkgb3IgYSBzdWJzdHJpbmcgZnJvbSBhIHN0cmluZyBmcm9tIGEgc3BlY2lmaWVkIHN0YXJ0IGluZGV4LCBvciBiZXR3ZWVuIGEgc3RhcnQgaW5kZXggYW5kIGFuIGVuZCBpbmRleCBpZiBzZXQuIFRoZSByZXR1cm4gdmFsdWUgaXMgaW5jbHVzaXZlIG9mIHRoZSBzdGFydCBpbmRleCBidXQgbm90IG9mIHRoZSBlbmQgaW5kZXguXCIsXG4gICAgICBncm91cDogXCJMb29rdXBcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjEuMTAuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2FzZVwiOiB7XG4gICAgICBkb2M6IFwiU2VsZWN0cyB0aGUgZmlyc3Qgb3V0cHV0IHdob3NlIGNvcnJlc3BvbmRpbmcgdGVzdCBjb25kaXRpb24gZXZhbHVhdGVzIHRvIHRydWUsIG9yIHRoZSBmYWxsYmFjayB2YWx1ZSBvdGhlcndpc2UuXCIsXG4gICAgICBncm91cDogXCJEZWNpc2lvblwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbWF0Y2g6IHtcbiAgICAgIGRvYzogXCJTZWxlY3RzIHRoZSBvdXRwdXQgZm9yIHdoaWNoIHRoZSBsYWJlbCB2YWx1ZSBtYXRjaGVzIHRoZSBpbnB1dCB2YWx1ZSwgb3IgdGhlIGZhbGxiYWNrIHZhbHVlIGlmIG5vIG1hdGNoIGlzIGZvdW5kLiBUaGUgaW5wdXQgY2FuIGJlIGFueSBleHByZXNzaW9uIChmb3IgZXhhbXBsZSwgYFtcXFwiZ2V0XFxcIiwgXFxcImJ1aWxkaW5nX3R5cGVcXFwiXWApLiBFYWNoIGxhYmVsIG11c3QgYmUgdW5pcXVlLCBhbmQgbXVzdCBiZSBlaXRoZXI6XFxuIC0gYSBzaW5nbGUgbGl0ZXJhbCB2YWx1ZTsgb3JcXG4gLSBhbiBhcnJheSBvZiBsaXRlcmFsIHZhbHVlcywgdGhlIHZhbHVlcyBvZiB3aGljaCBtdXN0IGJlIGFsbCBzdHJpbmdzIG9yIGFsbCBudW1iZXJzIChmb3IgZXhhbXBsZSBgWzEwMCwgMTAxXWAgb3IgYFtcXFwiY1xcXCIsIFxcXCJiXFxcIl1gKS5cXG5cXG5UaGUgaW5wdXQgbWF0Y2hlcyBpZiBhbnkgb2YgdGhlIHZhbHVlcyBpbiB0aGUgYXJyYXkgbWF0Y2hlcyB1c2luZyBzdHJpY3QgZXF1YWxpdHksIHNpbWlsYXIgdG8gdGhlIGBcXFwiaW5cXFwiYCBvcGVyYXRvci5cXG5JZiB0aGUgaW5wdXQgdHlwZSBkb2VzIG5vdCBtYXRjaCB0aGUgdHlwZSBvZiB0aGUgbGFiZWxzLCB0aGUgcmVzdWx0IHdpbGwgYmUgdGhlIGZhbGxiYWNrIHZhbHVlLlwiLFxuICAgICAgZ3JvdXA6IFwiRGVjaXNpb25cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvYWxlc2NlOiB7XG4gICAgICBkb2M6IFwiRXZhbHVhdGVzIGVhY2ggZXhwcmVzc2lvbiBpbiB0dXJuIHVudGlsIHRoZSBmaXJzdCBub24tbnVsbCB2YWx1ZSBpcyBvYnRhaW5lZCwgYW5kIHJldHVybnMgdGhhdCB2YWx1ZS5cIixcbiAgICAgIGdyb3VwOiBcIkRlY2lzaW9uXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzdGVwOiB7XG4gICAgICBkb2M6IFwiUHJvZHVjZXMgZGlzY3JldGUsIHN0ZXBwZWQgcmVzdWx0cyBieSBldmFsdWF0aW5nIGEgcGllY2V3aXNlLWNvbnN0YW50IGZ1bmN0aW9uIGRlZmluZWQgYnkgcGFpcnMgb2YgaW5wdXQgYW5kIG91dHB1dCB2YWx1ZXMgKFxcXCJzdG9wc1xcXCIpLiBUaGUgYGlucHV0YCBtYXkgYmUgYW55IG51bWVyaWMgZXhwcmVzc2lvbiAoZS5nLiwgYFtcXFwiZ2V0XFxcIiwgXFxcInBvcHVsYXRpb25cXFwiXWApLiBTdG9wIGlucHV0cyBtdXN0IGJlIG51bWVyaWMgbGl0ZXJhbHMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLiBSZXR1cm5zIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhlIHN0b3AganVzdCBsZXNzIHRoYW4gdGhlIGlucHV0LCBvciB0aGUgZmlyc3Qgb3V0cHV0IGlmIHRoZSBpbnB1dCBpcyBsZXNzIHRoYW4gdGhlIGZpcnN0IHN0b3AuXCIsXG4gICAgICBncm91cDogXCJSYW1wcywgc2NhbGVzLCBjdXJ2ZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDIuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGludGVycG9sYXRlOiB7XG4gICAgICBkb2M6IFwiUHJvZHVjZXMgY29udGludW91cywgc21vb3RoIHJlc3VsdHMgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHBhaXJzIG9mIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzIChcXFwic3RvcHNcXFwiKS4gVGhlIGBpbnB1dGAgbWF5IGJlIGFueSBudW1lcmljIGV4cHJlc3Npb24gKGUuZy4sIGBbXFxcImdldFxcXCIsIFxcXCJwb3B1bGF0aW9uXFxcIl1gKS4gU3RvcCBpbnB1dHMgbXVzdCBiZSBudW1lcmljIGxpdGVyYWxzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4gVGhlIG91dHB1dCB0eXBlIG11c3QgYmUgYG51bWJlcmAsIGBhcnJheTxudW1iZXI+YCwgb3IgYGNvbG9yYC5cXG5cXG5JbnRlcnBvbGF0aW9uIHR5cGVzOlxcbi0gYFtcXFwibGluZWFyXFxcIl1gOiBJbnRlcnBvbGF0ZXMgbGluZWFybHkgYmV0d2VlbiB0aGUgcGFpciBvZiBzdG9wcyBqdXN0IGxlc3MgdGhhbiBhbmQganVzdCBncmVhdGVyIHRoYW4gdGhlIGlucHV0Llxcbi0gYFtcXFwiZXhwb25lbnRpYWxcXFwiLCBiYXNlXWA6IEludGVycG9sYXRlcyBleHBvbmVudGlhbGx5IGJldHdlZW4gdGhlIHN0b3BzIGp1c3QgbGVzcyB0aGFuIGFuZCBqdXN0IGdyZWF0ZXIgdGhhbiB0aGUgaW5wdXQuIGBiYXNlYCBjb250cm9scyB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgb3V0cHV0IGluY3JlYXNlczogaGlnaGVyIHZhbHVlcyBtYWtlIHRoZSBvdXRwdXQgaW5jcmVhc2UgbW9yZSB0b3dhcmRzIHRoZSBoaWdoIGVuZCBvZiB0aGUgcmFuZ2UuIFdpdGggdmFsdWVzIGNsb3NlIHRvIDEgdGhlIG91dHB1dCBpbmNyZWFzZXMgbGluZWFybHkuXFxuLSBgW1xcXCJjdWJpYy1iZXppZXJcXFwiLCB4MSwgeTEsIHgyLCB5Ml1gOiBJbnRlcnBvbGF0ZXMgdXNpbmcgdGhlIGN1YmljIGJlemllciBjdXJ2ZSBkZWZpbmVkIGJ5IHRoZSBnaXZlbiBjb250cm9sIHBvaW50cy5cIixcbiAgICAgIGdyb3VwOiBcIlJhbXBzLCBzY2FsZXMsIGN1cnZlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40Mi4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJpbnRlcnBvbGF0ZS1oY2xcIjoge1xuICAgICAgZG9jOiBcIlByb2R1Y2VzIGNvbnRpbnVvdXMsIHNtb290aCByZXN1bHRzIGJ5IGludGVycG9sYXRpbmcgYmV0d2VlbiBwYWlycyBvZiBpbnB1dCBhbmQgb3V0cHV0IHZhbHVlcyAoXFxcInN0b3BzXFxcIikuIFdvcmtzIGxpa2UgYGludGVycG9sYXRlYCwgYnV0IHRoZSBvdXRwdXQgdHlwZSBtdXN0IGJlIGBjb2xvcmAsIGFuZCB0aGUgaW50ZXJwb2xhdGlvbiBpcyBwZXJmb3JtZWQgaW4gdGhlIEh1ZS1DaHJvbWEtTHVtaW5hbmNlIGNvbG9yIHNwYWNlLlwiLFxuICAgICAgZ3JvdXA6IFwiUmFtcHMsIHNjYWxlcywgY3VydmVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ5LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImludGVycG9sYXRlLWxhYlwiOiB7XG4gICAgICBkb2M6IFwiUHJvZHVjZXMgY29udGludW91cywgc21vb3RoIHJlc3VsdHMgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHBhaXJzIG9mIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzIChcXFwic3RvcHNcXFwiKS4gV29ya3MgbGlrZSBgaW50ZXJwb2xhdGVgLCBidXQgdGhlIG91dHB1dCB0eXBlIG11c3QgYmUgYGNvbG9yYCwgYW5kIHRoZSBpbnRlcnBvbGF0aW9uIGlzIHBlcmZvcm1lZCBpbiB0aGUgQ0lFTEFCIGNvbG9yIHNwYWNlLlwiLFxuICAgICAgZ3JvdXA6IFwiUmFtcHMsIHNjYWxlcywgY3VydmVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ5LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsbjI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIG1hdGhlbWF0aWNhbCBjb25zdGFudCBsbigyKS5cIixcbiAgICAgIGdyb3VwOiBcIk1hdGhcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHBpOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgbWF0aGVtYXRpY2FsIGNvbnN0YW50IHBpLlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZToge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIG1hdGhlbWF0aWNhbCBjb25zdGFudCBlLlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ0eXBlb2ZcIjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgYSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgdHlwZSBvZiB0aGUgZ2l2ZW4gdmFsdWUuXCIsXG4gICAgICBncm91cDogXCJUeXBlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3RyaW5nOiB7XG4gICAgICBkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIHN0cmluZy4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGEgc3RyaW5nIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIHN0cmluZ3MsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuICAgICAgZ3JvdXA6IFwiVHlwZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG51bWJlcjoge1xuICAgICAgZG9jOiBcIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYSBudW1iZXIuIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhIG51bWJlciBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGFyZSBudW1iZXJzLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcbiAgICAgIGdyb3VwOiBcIlR5cGVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBib29sZWFuOiB7XG4gICAgICBkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIGJvb2xlYW4uIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhIGJvb2xlYW4gaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgYm9vbGVhbnMsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuICAgICAgZ3JvdXA6IFwiVHlwZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9iamVjdDoge1xuICAgICAgZG9jOiBcIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgdmFsdWUgaXMgYW4gb2JqZWN0LiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgYW4gb2JqZWN0IGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIG9iamVjdHMsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuICAgICAgZ3JvdXA6IFwiVHlwZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbGxhdG9yOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBhIGBjb2xsYXRvcmAgZm9yIHVzZSBpbiBsb2NhbGUtZGVwZW5kZW50IGNvbXBhcmlzb24gb3BlcmF0aW9ucy4gVGhlIGBjYXNlLXNlbnNpdGl2ZWAgYW5kIGBkaWFjcml0aWMtc2Vuc2l0aXZlYCBvcHRpb25zIGRlZmF1bHQgdG8gYGZhbHNlYC4gVGhlIGBsb2NhbGVgIGFyZ3VtZW50IHNwZWNpZmllcyB0aGUgSUVURiBsYW5ndWFnZSB0YWcgb2YgdGhlIGxvY2FsZSB0byB1c2UuIElmIG5vbmUgaXMgcHJvdmlkZWQsIHRoZSBkZWZhdWx0IGxvY2FsZSBpcyB1c2VkLiBJZiB0aGUgcmVxdWVzdGVkIGxvY2FsZSBpcyBub3QgYXZhaWxhYmxlLCB0aGUgYGNvbGxhdG9yYCB3aWxsIHVzZSBhIHN5c3RlbS1kZWZpbmVkIGZhbGxiYWNrIGxvY2FsZS4gVXNlIGByZXNvbHZlZC1sb2NhbGVgIHRvIHRlc3QgdGhlIHJlc3VsdHMgb2YgbG9jYWxlIGZhbGxiYWNrIGJlaGF2aW9yLlwiLFxuICAgICAgZ3JvdXA6IFwiVHlwZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDUuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi41LjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4yLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjkuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZvcm1hdDoge1xuICAgICAgZG9jOiBcIlJldHVybnMgYSBgZm9ybWF0dGVkYCBzdHJpbmcgZm9yIGRpc3BsYXlpbmcgbWl4ZWQtZm9ybWF0IHRleHQgaW4gdGhlIGB0ZXh0LWZpZWxkYCBwcm9wZXJ0eS4gVGhlIGlucHV0IG1heSBjb250YWluIGEgc3RyaW5nIGxpdGVyYWwgb3IgZXhwcmVzc2lvbiwgaW5jbHVkaW5nIGFuIFtgJ2ltYWdlJ2BdKCN0eXBlcy1pbWFnZSkgZXhwcmVzc2lvbi4gU3RyaW5ncyBtYXkgYmUgZm9sbG93ZWQgYnkgYSBzdHlsZSBvdmVycmlkZSBvYmplY3QgdGhhdCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XFxuLSBgXFxcInRleHQtZm9udFxcXCJgOiBPdmVycmlkZXMgdGhlIGZvbnQgc3RhY2sgc3BlY2lmaWVkIGJ5IHRoZSByb290IGxheW91dCBwcm9wZXJ0eS5cXG4tIGBcXFwidGV4dC1jb2xvclxcXCJgOiBPdmVycmlkZXMgdGhlIGNvbG9yIHNwZWNpZmllZCBieSB0aGUgcm9vdCBwYWludCBwcm9wZXJ0eS5cXG4tIGBcXFwiZm9udC1zY2FsZVxcXCJgOiBBcHBsaWVzIGEgc2NhbGluZyBmYWN0b3Igb24gYHRleHQtc2l6ZWAgYXMgc3BlY2lmaWVkIGJ5IHRoZSByb290IGxheW91dCBwcm9wZXJ0eS5cIixcbiAgICAgIGdyb3VwOiBcIlR5cGVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ4LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuNy4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuNi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC4xMi4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0ZXh0LWZvbnRcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDguMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi43LjBcIixcbiAgICAgICAgICBpb3M6IFwiNC42LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjEyLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImZvbnQtc2NhbGVcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDguMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi43LjBcIixcbiAgICAgICAgICBpb3M6IFwiNC42LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjEyLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtY29sb3JcIjoge1xuICAgICAgICAgIGpzOiBcIjEuMy4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI3LjMuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjEwLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjE0LjBcIlxuICAgICAgICB9LFxuICAgICAgICBpbWFnZToge1xuICAgICAgICAgIGpzOiBcIjEuNi4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI4LjYuMFwiLFxuICAgICAgICAgIGlvczogXCI1LjcuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuMTUuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGltYWdlOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBhbiBgaW1hZ2VgIHR5cGUgZm9yIHVzZSBpbiBgaWNvbi1pbWFnZWAsIGAqLXBhdHRlcm5gIGVudHJpZXMgYW5kIGFzIGEgc2VjdGlvbiBpbiB0aGUgYGZvcm1hdGAgZXhwcmVzc2lvbi4gSWYgc2V0LCB0aGUgYGltYWdlYCBhcmd1bWVudCB3aWxsIGNoZWNrIHRoYXQgdGhlIHJlcXVlc3RlZCBpbWFnZSBleGlzdHMgaW4gdGhlIHN0eWxlIGFuZCB3aWxsIHJldHVybiBlaXRoZXIgdGhlIHJlc29sdmVkIGltYWdlIG5hbWUgb3IgYG51bGxgLCBkZXBlbmRpbmcgb24gd2hldGhlciBvciBub3QgdGhlIGltYWdlIGlzIGN1cnJlbnRseSBpbiB0aGUgc3R5bGUuIFRoaXMgdmFsaWRhdGlvbiBwcm9jZXNzIGlzIHN5bmNocm9ub3VzIGFuZCByZXF1aXJlcyB0aGUgaW1hZ2UgdG8gaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBzdHlsZSBiZWZvcmUgcmVxdWVzdGluZyBpdCBpbiB0aGUgYGltYWdlYCBhcmd1bWVudC5cIixcbiAgICAgIGdyb3VwOiBcIlR5cGVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIxLjQuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiOC42LjBcIixcbiAgICAgICAgICBpb3M6IFwiNS43LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjE1LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIm51bWJlci1mb3JtYXRcIjoge1xuICAgICAgZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCBudW1iZXIgaW50byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiB1c2luZyB0aGUgcHJvdmlkaW5nIGZvcm1hdHRpbmcgcnVsZXMuIElmIHNldCwgdGhlIGBsb2NhbGVgIGFyZ3VtZW50IHNwZWNpZmllcyB0aGUgbG9jYWxlIHRvIHVzZSwgYXMgYSBCQ1AgNDcgbGFuZ3VhZ2UgdGFnLiBJZiBzZXQsIHRoZSBgY3VycmVuY3lgIGFyZ3VtZW50IHNwZWNpZmllcyBhbiBJU08gNDIxNyBjb2RlIHRvIHVzZSBmb3IgY3VycmVuY3ktc3R5bGUgZm9ybWF0dGluZy4gSWYgc2V0LCB0aGUgYG1pbi1mcmFjdGlvbi1kaWdpdHNgIGFuZCBgbWF4LWZyYWN0aW9uLWRpZ2l0c2AgYXJndW1lbnRzIHNwZWNpZnkgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbnVtYmVyIG9mIGZyYWN0aW9uYWwgZGlnaXRzIHRvIGluY2x1ZGUuXCIsXG4gICAgICBncm91cDogXCJUeXBlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC41NC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ0by1zdHJpbmdcIjoge1xuICAgICAgZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIHN0cmluZy4gSWYgdGhlIGlucHV0IGlzIGBudWxsYCwgdGhlIHJlc3VsdCBpcyBgXFxcIlxcXCJgLiBJZiB0aGUgaW5wdXQgaXMgYSBib29sZWFuLCB0aGUgcmVzdWx0IGlzIGBcXFwidHJ1ZVxcXCJgIG9yIGBcXFwiZmFsc2VcXFwiYC4gSWYgdGhlIGlucHV0IGlzIGEgbnVtYmVyLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgYXMgc3BlY2lmaWVkIGJ5IHRoZSBbXFxcIk51bWJlclRvU3RyaW5nXFxcIiBhbGdvcml0aG1dKGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvc3RyaW5nLWFwcGxpZWQtdG8tdGhlLW51bWJlci10eXBlKSBvZiB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uLiBJZiB0aGUgaW5wdXQgaXMgYSBjb2xvciwgaXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIG9mIHRoZSBmb3JtIGBcXFwicmdiYShyLGcsYixhKVxcXCJgLCB3aGVyZSBgcmAsIGBnYCwgYW5kIGBiYCBhcmUgbnVtZXJhbHMgcmFuZ2luZyBmcm9tIDAgdG8gMjU1LCBhbmQgYGFgIHJhbmdlcyBmcm9tIDAgdG8gMS4gT3RoZXJ3aXNlLCB0aGUgaW5wdXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGluIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGJ5IHRoZSBbYEpTT04uc3RyaW5naWZ5YF0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtanNvbi5zdHJpbmdpZnkpIGZ1bmN0aW9uIG9mIHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb24uXCIsXG4gICAgICBncm91cDogXCJUeXBlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ0by1udW1iZXJcIjoge1xuICAgICAgZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciwgaWYgcG9zc2libGUuIElmIHRoZSBpbnB1dCBpcyBgbnVsbGAgb3IgYGZhbHNlYCwgdGhlIHJlc3VsdCBpcyAwLiBJZiB0aGUgaW5wdXQgaXMgYHRydWVgLCB0aGUgcmVzdWx0IGlzIDEuIElmIHRoZSBpbnB1dCBpcyBhIHN0cmluZywgaXQgaXMgY29udmVydGVkIHRvIGEgbnVtYmVyIGFzIHNwZWNpZmllZCBieSB0aGUgW1xcXCJUb051bWJlciBBcHBsaWVkIHRvIHRoZSBTdHJpbmcgVHlwZVxcXCIgYWxnb3JpdGhtXShodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b251bWJlci1hcHBsaWVkLXRvLXRoZS1zdHJpbmctdHlwZSkgb2YgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgU3BlY2lmaWNhdGlvbi4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIHRoZSBmaXJzdCBzdWNjZXNzZnVsIGNvbnZlcnNpb24gaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBjYW4gYmUgY29udmVydGVkLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcbiAgICAgIGdyb3VwOiBcIlR5cGVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRvLWJvb2xlYW5cIjoge1xuICAgICAgZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIGJvb2xlYW4uIFRoZSByZXN1bHQgaXMgYGZhbHNlYCB3aGVuIHRoZW4gaW5wdXQgaXMgYW4gZW1wdHkgc3RyaW5nLCAwLCBgZmFsc2VgLCBgbnVsbGAsIG9yIGBOYU5gOyBvdGhlcndpc2UgaXQgaXMgYHRydWVgLlwiLFxuICAgICAgZ3JvdXA6IFwiVHlwZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidG8tcmdiYVwiOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBhIGZvdXItZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSBpbnB1dCBjb2xvcidzIHJlZCwgZ3JlZW4sIGJsdWUsIGFuZCBhbHBoYSBjb21wb25lbnRzLCBpbiB0aGF0IG9yZGVyLlwiLFxuICAgICAgZ3JvdXA6IFwiQ29sb3JcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidG8tY29sb3JcIjoge1xuICAgICAgZG9jOiBcIkNvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSB0byBhIGNvbG9yLiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgdGhlIGZpcnN0IHN1Y2Nlc3NmdWwgY29udmVyc2lvbiBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGNhbiBiZSBjb252ZXJ0ZWQsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuICAgICAgZ3JvdXA6IFwiVHlwZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJnYjoge1xuICAgICAgZG9jOiBcIkNyZWF0ZXMgYSBjb2xvciB2YWx1ZSBmcm9tIHJlZCwgZ3JlZW4sIGFuZCBibHVlIGNvbXBvbmVudHMsIHdoaWNoIG11c3QgcmFuZ2UgYmV0d2VlbiAwIGFuZCAyNTUsIGFuZCBhbiBhbHBoYSBjb21wb25lbnQgb2YgMS4gSWYgYW55IGNvbXBvbmVudCBpcyBvdXQgb2YgcmFuZ2UsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuICAgICAgZ3JvdXA6IFwiQ29sb3JcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHJnYmE6IHtcbiAgICAgIGRvYzogXCJDcmVhdGVzIGEgY29sb3IgdmFsdWUgZnJvbSByZWQsIGdyZWVuLCBibHVlIGNvbXBvbmVudHMsIHdoaWNoIG11c3QgcmFuZ2UgYmV0d2VlbiAwIGFuZCAyNTUsIGFuZCBhbiBhbHBoYSBjb21wb25lbnQgd2hpY2ggbXVzdCByYW5nZSBiZXR3ZWVuIDAgYW5kIDEuIElmIGFueSBjb21wb25lbnQgaXMgb3V0IG9mIHJhbmdlLCB0aGUgZXhwcmVzc2lvbiBpcyBhbiBlcnJvci5cIixcbiAgICAgIGdyb3VwOiBcIkNvbG9yXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IHtcbiAgICAgIGRvYzogXCJSZXRyaWV2ZXMgYSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IGZlYXR1cmUncyBwcm9wZXJ0aWVzLCBvciBmcm9tIGFub3RoZXIgb2JqZWN0IGlmIGEgc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkLiBSZXR1cm5zIG51bGwgaWYgdGhlIHJlcXVlc3RlZCBwcm9wZXJ0eSBpcyBtaXNzaW5nLlwiLFxuICAgICAgZ3JvdXA6IFwiTG9va3VwXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoYXM6IHtcbiAgICAgIGRvYzogXCJUZXN0cyBmb3IgdGhlIHByZXNlbmNlIG9mIGFuIHByb3BlcnR5IHZhbHVlIGluIHRoZSBjdXJyZW50IGZlYXR1cmUncyBwcm9wZXJ0aWVzLCBvciBmcm9tIGFub3RoZXIgb2JqZWN0IGlmIGEgc2Vjb25kIGFyZ3VtZW50IGlzIHByb3ZpZGVkLlwiLFxuICAgICAgZ3JvdXA6IFwiTG9va3VwXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsZW5ndGg6IHtcbiAgICAgIGRvYzogXCJHZXRzIHRoZSBsZW5ndGggb2YgYW4gYXJyYXkgb3Igc3RyaW5nLlwiLFxuICAgICAgZ3JvdXA6IFwiTG9va3VwXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBkb2M6IFwiR2V0cyB0aGUgZmVhdHVyZSBwcm9wZXJ0aWVzIG9iamVjdC4gIE5vdGUgdGhhdCBpbiBzb21lIGNhc2VzLCBpdCBtYXkgYmUgbW9yZSBlZmZpY2llbnQgdG8gdXNlIFtcXFwiZ2V0XFxcIiwgXFxcInByb3BlcnR5X25hbWVcXFwiXSBkaXJlY3RseS5cIixcbiAgICAgIGdyb3VwOiBcIkZlYXR1cmUgZGF0YVwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJmZWF0dXJlLXN0YXRlXCI6IHtcbiAgICAgIGRvYzogXCJSZXRyaWV2ZXMgYSBwcm9wZXJ0eSB2YWx1ZSBmcm9tIHRoZSBjdXJyZW50IGZlYXR1cmUncyBzdGF0ZS4gUmV0dXJucyBudWxsIGlmIHRoZSByZXF1ZXN0ZWQgcHJvcGVydHkgaXMgbm90IHByZXNlbnQgb24gdGhlIGZlYXR1cmUncyBzdGF0ZS4gQSBmZWF0dXJlJ3Mgc3RhdGUgaXMgbm90IHBhcnQgb2YgdGhlIEdlb0pTT04gb3IgdmVjdG9yIHRpbGUgZGF0YSwgYW5kIG11c3QgYmUgc2V0IHByb2dyYW1tYXRpY2FsbHkgb24gZWFjaCBmZWF0dXJlLiBGZWF0dXJlcyBhcmUgaWRlbnRpZmllZCBieSB0aGVpciBgaWRgIGF0dHJpYnV0ZSwgd2hpY2ggbXVzdCBiZSBhbiBpbnRlZ2VyIG9yIGEgc3RyaW5nIHRoYXQgY2FuIGJlIGNhc3QgdG8gYW4gaW50ZWdlci4gTm90ZSB0aGF0IFtcXFwiZmVhdHVyZS1zdGF0ZVxcXCJdIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBwYWludCBwcm9wZXJ0aWVzIHRoYXQgc3VwcG9ydCBkYXRhLWRyaXZlbiBzdHlsaW5nLlwiLFxuICAgICAgZ3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ2LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImdlb21ldHJ5LXR5cGVcIjoge1xuICAgICAgZG9jOiBcIkdldHMgdGhlIGZlYXR1cmUncyBnZW9tZXRyeSB0eXBlOiBgUG9pbnRgLCBgTXVsdGlQb2ludGAsIGBMaW5lU3RyaW5nYCwgYE11bHRpTGluZVN0cmluZ2AsIGBQb2x5Z29uYCwgYE11bHRpUG9seWdvbmAuXCIsXG4gICAgICBncm91cDogXCJGZWF0dXJlIGRhdGFcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGlkOiB7XG4gICAgICBkb2M6IFwiR2V0cyB0aGUgZmVhdHVyZSdzIGlkLCBpZiBpdCBoYXMgb25lLlwiLFxuICAgICAgZ3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB6b29tOiB7XG4gICAgICBkb2M6IFwiR2V0cyB0aGUgY3VycmVudCB6b29tIGxldmVsLiAgTm90ZSB0aGF0IGluIHN0eWxlIGxheW91dCBhbmQgcGFpbnQgcHJvcGVydGllcywgW1xcXCJ6b29tXFxcIl0gbWF5IG9ubHkgYXBwZWFyIGFzIHRoZSBpbnB1dCB0byBhIHRvcC1sZXZlbCBcXFwic3RlcFxcXCIgb3IgXFxcImludGVycG9sYXRlXFxcIiBleHByZXNzaW9uLlwiLFxuICAgICAgZ3JvdXA6IFwiWm9vbVwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJoZWF0bWFwLWRlbnNpdHlcIjoge1xuICAgICAgZG9jOiBcIkdldHMgdGhlIGtlcm5lbCBkZW5zaXR5IGVzdGltYXRpb24gb2YgYSBwaXhlbCBpbiBhIGhlYXRtYXAgbGF5ZXIsIHdoaWNoIGlzIGEgcmVsYXRpdmUgbWVhc3VyZSBvZiBob3cgbWFueSBkYXRhIHBvaW50cyBhcmUgY3Jvd2RlZCBhcm91bmQgYSBwYXJ0aWN1bGFyIHBpeGVsLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgaGVhdG1hcC1jb2xvcmAgcHJvcGVydHkuXCIsXG4gICAgICBncm91cDogXCJIZWF0bWFwXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImxpbmUtcHJvZ3Jlc3NcIjoge1xuICAgICAgZG9jOiBcIkdldHMgdGhlIHByb2dyZXNzIGFsb25nIGEgZ3JhZGllbnQgbGluZS4gQ2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgYGxpbmUtZ3JhZGllbnRgIHByb3BlcnR5LlwiLFxuICAgICAgZ3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuNS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuNi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC4xMi4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJza3ktcmFkaWFsLXByb2dyZXNzXCI6IHtcbiAgICAgIGRvYzogXCJHZXRzIHRoZSBkaXN0YW5jZSBvZiBhIHBvaW50IG9uIHRoZSBza3kgZnJvbSB0aGUgc3VuIHBvc2l0aW9uLiBSZXR1cm5zIDAgYXQgc3VuIHBvc2l0aW9uIGFuZCAxIHdoZW4gdGhlIGRpc3RhbmNlIHJlYWNoZXMgYHNreS1ncmFkaWVudC1yYWRpdXNgLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgc2t5LWdyYWRpZW50YCBwcm9wZXJ0eS5cIixcbiAgICAgIGdyb3VwOiBcInNreVwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMi4wLjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhY2N1bXVsYXRlZDoge1xuICAgICAgZG9jOiBcIkdldHMgdGhlIHZhbHVlIG9mIGEgY2x1c3RlciBwcm9wZXJ0eSBhY2N1bXVsYXRlZCBzbyBmYXIuIENhbiBvbmx5IGJlIHVzZWQgaW4gdGhlIGBjbHVzdGVyUHJvcGVydGllc2Agb3B0aW9uIG9mIGEgY2x1c3RlcmVkIEdlb0pTT04gc291cmNlLlwiLFxuICAgICAgZ3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjUzLjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIitcIjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIHN1bSBvZiB0aGUgaW5wdXRzLlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCIqXCI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoZSBpbnB1dHMuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIi1cIjoge1xuICAgICAgZG9jOiBcIkZvciB0d28gaW5wdXRzLCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3RpbmcgdGhlIHNlY29uZCBpbnB1dCBmcm9tIHRoZSBmaXJzdC4gRm9yIGEgc2luZ2xlIGlucHV0LCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygc3VidHJhY3RpbmcgaXQgZnJvbSAwLlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCIvXCI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSByZXN1bHQgb2YgZmxvYXRpbmcgcG9pbnQgZGl2aXNpb24gb2YgdGhlIGZpcnN0IGlucHV0IGJ5IHRoZSBzZWNvbmQuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIiVcIjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIHJlbWFpbmRlciBhZnRlciBpbnRlZ2VyIGRpdmlzaW9uIG9mIHRoZSBmaXJzdCBpbnB1dCBieSB0aGUgc2Vjb25kLlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJeXCI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSByZXN1bHQgb2YgcmFpc2luZyB0aGUgZmlyc3QgaW5wdXQgdG8gdGhlIHBvd2VyIHNwZWNpZmllZCBieSB0aGUgc2Vjb25kLlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3FydDoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIHNxdWFyZSByb290IG9mIHRoZSBpbnB1dC5cIixcbiAgICAgIGdyb3VwOiBcIk1hdGhcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDIuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxvZzEwOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgYmFzZS10ZW4gbG9nYXJpdGhtIG9mIHRoZSBpbnB1dC5cIixcbiAgICAgIGdyb3VwOiBcIk1hdGhcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxuOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgdGhlIGlucHV0LlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbG9nMjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIGJhc2UtdHdvIGxvZ2FyaXRobSBvZiB0aGUgaW5wdXQuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzaW46IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBzaW5lIG9mIHRoZSBpbnB1dC5cIixcbiAgICAgIGdyb3VwOiBcIk1hdGhcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvczoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIGNvc2luZSBvZiB0aGUgaW5wdXQuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB0YW46IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSB0YW5nZW50IG9mIHRoZSBpbnB1dC5cIixcbiAgICAgIGdyb3VwOiBcIk1hdGhcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFzaW46IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBhcmNzaW5lIG9mIHRoZSBpbnB1dC5cIixcbiAgICAgIGdyb3VwOiBcIk1hdGhcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFjb3M6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBhcmNjb3NpbmUgb2YgdGhlIGlucHV0LlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYXRhbjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIGFyY3RhbmdlbnQgb2YgdGhlIGlucHV0LlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbWluOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZSBvZiB0aGUgaW5wdXRzLlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbWF4OiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBvZiB0aGUgaW5wdXRzLlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcm91bmQ6IHtcbiAgICAgIGRvYzogXCJSb3VuZHMgdGhlIGlucHV0IHRvIHRoZSBuZWFyZXN0IGludGVnZXIuIEhhbGZ3YXkgdmFsdWVzIGFyZSByb3VuZGVkIGF3YXkgZnJvbSB6ZXJvLiBGb3IgZXhhbXBsZSwgYFtcXFwicm91bmRcXFwiLCAtMS41XWAgZXZhbHVhdGVzIHRvIC0yLlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWJzOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhlIGlucHV0LlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2VpbDoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIHNtYWxsZXN0IGludGVnZXIgdGhhdCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGlucHV0LlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZmxvb3I6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBsYXJnZXN0IGludGVnZXIgdGhhdCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGlucHV0LlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlzdGFuY2U6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSBpbiBtZXRlcnMgYmV0d2VlbiB0aGUgZXZhbHVhdGVkIGZlYXR1cmUgYW5kIHRoZSBpbnB1dCBnZW9tZXRyeS4gVGhlIGlucHV0IHZhbHVlIGNhbiBiZSBhIHZhbGlkIEdlb0pTT04gb2YgdHlwZSBgUG9pbnRgLCBgTXVsdGlQb2ludGAsIGBMaW5lU3RyaW5nYCwgYE11bHRpTGluZVN0cmluZ2AsIGBQb2x5Z29uYCwgYE11bHRpUG9seWdvbmAsIGBGZWF0dXJlYCwgb3IgYEZlYXR1cmVDb2xsZWN0aW9uYC4gRGlzdGFuY2UgdmFsdWVzIHJldHVybmVkIG1heSB2YXJ5IGluIHByZWNpc2lvbiBkdWUgdG8gbG9zcyBpbiBwcmVjaXNpb24gZnJvbSBlbmNvZGluZyBnZW9tZXRyaWVzLCBwYXJ0aWN1bGFybHkgYmVsb3cgem9vbSBsZXZlbCAxMy5cIixcbiAgICAgIGdyb3VwOiBcIk1hdGhcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGFuZHJvaWQ6IFwiOS4yLjBcIixcbiAgICAgICAgICBpb3M6IFwiNS45LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjE2LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIj09XCI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBjb21wYXJpc29uIGlzIHN0cmljdGx5IHR5cGVkOiB2YWx1ZXMgb2YgZGlmZmVyZW50IHJ1bnRpbWUgdHlwZXMgYXJlIGFsd2F5cyBjb25zaWRlcmVkIHVuZXF1YWwuIENhc2VzIHdoZXJlIHRoZSB0eXBlcyBhcmUga25vd24gdG8gYmUgZGlmZmVyZW50IGF0IHBhcnNlIHRpbWUgYXJlIGNvbnNpZGVyZWQgaW52YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuICAgICAgZ3JvdXA6IFwiRGVjaXNpb25cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxhdG9yOiB7XG4gICAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjUuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjIuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuOS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCIhPVwiOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IHZhbHVlcyBhcmUgbm90IGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGNvbXBhcmlzb24gaXMgc3RyaWN0bHkgdHlwZWQ6IHZhbHVlcyBvZiBkaWZmZXJlbnQgcnVudGltZSB0eXBlcyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQgdW5lcXVhbC4gQ2FzZXMgd2hlcmUgdGhlIHR5cGVzIGFyZSBrbm93biB0byBiZSBkaWZmZXJlbnQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbnZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG4gICAgICBncm91cDogXCJEZWNpc2lvblwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgY29sbGF0b3I6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuNS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC45LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIj5cIjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBpbnB1dCBpcyBzdHJpY3RseSBncmVhdGVyIHRoYW4gdGhlIHNlY29uZCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBhcmd1bWVudHMgYXJlIHJlcXVpcmVkIHRvIGJlIGVpdGhlciBib3RoIHN0cmluZ3Mgb3IgYm90aCBudW1iZXJzOyBpZiBkdXJpbmcgZXZhbHVhdGlvbiB0aGV5IGFyZSBub3QsIGV4cHJlc3Npb24gZXZhbHVhdGlvbiBwcm9kdWNlcyBhbiBlcnJvci4gQ2FzZXMgd2hlcmUgdGhpcyBjb25zdHJhaW50IGlzIGtub3duIG5vdCB0byBob2xkIGF0IHBhcnNlIHRpbWUgYXJlIGNvbnNpZGVyZWQgaW4gdmFsaWQgYW5kIHdpbGwgcHJvZHVjZSBhIHBhcnNlIGVycm9yLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGBjb2xsYXRvcmAgYXJndW1lbnQgdG8gY29udHJvbCBsb2NhbGUtZGVwZW5kZW50IHN0cmluZyBjb21wYXJpc29ucy5cIixcbiAgICAgIGdyb3VwOiBcIkRlY2lzaW9uXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9LFxuICAgICAgICBjb2xsYXRvcjoge1xuICAgICAgICAgIGpzOiBcIjAuNDUuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi41LjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4yLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjkuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiPFwiOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIHN0cmljdGx5IGxlc3MgdGhhbiB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuICAgICAgZ3JvdXA6IFwiRGVjaXNpb25cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxhdG9yOiB7XG4gICAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjUuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjIuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuOS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCI+PVwiOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuICAgICAgZ3JvdXA6IFwiRGVjaXNpb25cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxhdG9yOiB7XG4gICAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjUuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjIuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuOS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCI8PVwiOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuICAgICAgZ3JvdXA6IFwiRGVjaXNpb25cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxhdG9yOiB7XG4gICAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjUuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjIuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuOS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWxsOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIHRoZSBpbnB1dHMgYXJlIGB0cnVlYCwgYGZhbHNlYCBvdGhlcndpc2UuIFRoZSBpbnB1dHMgYXJlIGV2YWx1YXRlZCBpbiBvcmRlciwgYW5kIGV2YWx1YXRpb24gaXMgc2hvcnQtY2lyY3VpdGluZzogb25jZSBhbiBpbnB1dCBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBgZmFsc2VgLCB0aGUgcmVzdWx0IGlzIGBmYWxzZWAgYW5kIG5vIGZ1cnRoZXIgaW5wdXQgZXhwcmVzc2lvbnMgYXJlIGV2YWx1YXRlZC5cIixcbiAgICAgIGdyb3VwOiBcIkRlY2lzaW9uXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhbnk6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiBhbnkgb2YgdGhlIGlucHV0cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGlucHV0cyBhcmUgZXZhbHVhdGVkIGluIG9yZGVyLCBhbmQgZXZhbHVhdGlvbiBpcyBzaG9ydC1jaXJjdWl0aW5nOiBvbmNlIGFuIGlucHV0IGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGB0cnVlYCwgdGhlIHJlc3VsdCBpcyBgdHJ1ZWAgYW5kIG5vIGZ1cnRoZXIgaW5wdXQgZXhwcmVzc2lvbnMgYXJlIGV2YWx1YXRlZC5cIixcbiAgICAgIGdyb3VwOiBcIkRlY2lzaW9uXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIiFcIjoge1xuICAgICAgZG9jOiBcIkxvZ2ljYWwgbmVnYXRpb24uIFJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCBpcyBgZmFsc2VgLCBhbmQgYGZhbHNlYCBpZiB0aGUgaW5wdXQgaXMgYHRydWVgLlwiLFxuICAgICAgZ3JvdXA6IFwiRGVjaXNpb25cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHdpdGhpbjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIHRoZSBldmFsdWF0ZWQgZmVhdHVyZSBpcyBmdWxseSBjb250YWluZWQgaW5zaWRlIGEgYm91bmRhcnkgb2YgdGhlIGlucHV0IGdlb21ldHJ5LCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGlucHV0IHZhbHVlIGNhbiBiZSBhIHZhbGlkIEdlb0pTT04gb2YgdHlwZSBgUG9seWdvbmAsIGBNdWx0aVBvbHlnb25gLCBgRmVhdHVyZWAsIG9yIGBGZWF0dXJlQ29sbGVjdGlvbmAuIFN1cHBvcnRlZCBmZWF0dXJlcyBmb3IgZXZhbHVhdGlvbjpcXG4tIGBQb2ludGA6IFJldHVybnMgYGZhbHNlYCBpZiBhIHBvaW50IGlzIG9uIHRoZSBib3VuZGFyeSBvciBmYWxscyBvdXRzaWRlIHRoZSBib3VuZGFyeS5cXG4tIGBMaW5lU3RyaW5nYDogUmV0dXJucyBgZmFsc2VgIGlmIGFueSBwYXJ0IG9mIGEgbGluZSBmYWxscyBvdXRzaWRlIHRoZSBib3VuZGFyeSwgdGhlIGxpbmUgaW50ZXJzZWN0cyB0aGUgYm91bmRhcnksIG9yIGEgbGluZSdzIGVuZHBvaW50IGlzIG9uIHRoZSBib3VuZGFyeS5cIixcbiAgICAgIGdyb3VwOiBcIkRlY2lzaW9uXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIxLjkuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiOS4xLjBcIixcbiAgICAgICAgICBpb3M6IFwiNS44LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjE1LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImlzLXN1cHBvcnRlZC1zY3JpcHRcIjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gcmVuZGVyIGxlZ2libHkuIFJldHVybnMgYGZhbHNlYCBpZiB0aGUgaW5wdXQgc3RyaW5nIGNvbnRhaW5zIHNlY3Rpb25zIHRoYXQgY2Fubm90IGJlIHJlbmRlcmVkIHdpdGhvdXQgcG90ZW50aWFsIGxvc3Mgb2YgbWVhbmluZyAoZS5nLiBJbmRpYyBzY3JpcHRzIHRoYXQgcmVxdWlyZSBjb21wbGV4IHRleHQgc2hhcGluZywgb3IgcmlnaHQtdG8tbGVmdCBzY3JpcHRzIGlmIHRoZSB0aGUgYG1hcGJveC1nbC1ydGwtdGV4dGAgcGx1Z2luIGlzIG5vdCBpbiB1c2UgaW4gTWFwYm94IEdMIEpTKS5cIixcbiAgICAgIGdyb3VwOiBcIlN0cmluZ1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjYuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHVwY2FzZToge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIGlucHV0IHN0cmluZyBjb252ZXJ0ZWQgdG8gdXBwZXJjYXNlLiBGb2xsb3dzIHRoZSBVbmljb2RlIERlZmF1bHQgQ2FzZSBDb252ZXJzaW9uIGFsZ29yaXRobSBhbmQgdGhlIGxvY2FsZS1pbnNlbnNpdGl2ZSBjYXNlIG1hcHBpbmdzIGluIHRoZSBVbmljb2RlIENoYXJhY3RlciBEYXRhYmFzZS5cIixcbiAgICAgIGdyb3VwOiBcIlN0cmluZ1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZG93bmNhc2U6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBpbnB1dCBzdHJpbmcgY29udmVydGVkIHRvIGxvd2VyY2FzZS4gRm9sbG93cyB0aGUgVW5pY29kZSBEZWZhdWx0IENhc2UgQ29udmVyc2lvbiBhbGdvcml0aG0gYW5kIHRoZSBsb2NhbGUtaW5zZW5zaXRpdmUgY2FzZSBtYXBwaW5ncyBpbiB0aGUgVW5pY29kZSBDaGFyYWN0ZXIgRGF0YWJhc2UuXCIsXG4gICAgICBncm91cDogXCJTdHJpbmdcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbmNhdDoge1xuICAgICAgZG9jOiBcIlJldHVybnMgYSBgc3RyaW5nYCBjb25zaXN0aW5nIG9mIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZSBpbnB1dHMuIEVhY2ggaW5wdXQgaXMgY29udmVydGVkIHRvIGEgc3RyaW5nIGFzIGlmIGJ5IGB0by1zdHJpbmdgLlwiLFxuICAgICAgZ3JvdXA6IFwiU3RyaW5nXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlc29sdmVkLWxvY2FsZVwiOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgSUVURiBsYW5ndWFnZSB0YWcgb2YgdGhlIGxvY2FsZSBiZWluZyB1c2VkIGJ5IHRoZSBwcm92aWRlZCBgY29sbGF0b3JgLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgZGVmYXVsdCBzeXN0ZW0gbG9jYWxlLCBvciB0byBkZXRlcm1pbmUgaWYgYSByZXF1ZXN0ZWQgbG9jYWxlIHdhcyBzdWNjZXNzZnVsbHkgbG9hZGVkLlwiLFxuICAgICAgZ3JvdXA6IFwiU3RyaW5nXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuNS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC45LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGZvZyA9IHtcbiAgcmFuZ2U6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgXCJkZWZhdWx0XCI6IFswLjUsIDEwXSxcbiAgICBtaW5pbXVtOiAtMjAsXG4gICAgbWF4aW11bTogMjAsXG4gICAgbGVuZ3RoOiAyLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIGRvYzogXCJUaGUgc3RhcnQgYW5kIGVuZCBkaXN0YW5jZSByYW5nZSBpbiB3aGljaCBmb2cgZmFkZXMgZnJvbSBmdWxseSB0cmFuc3BhcmVudCB0byBmdWxseSBvcGFxdWUuIFRoZSBkaXN0YW5jZSB0byB0aGUgcG9pbnQgYXQgdGhlIGNlbnRlciBvZiB0aGUgbWFwIGlzIGRlZmluZWQgYXMgemVybywgc28gdGhhdCBuZWdhdGl2ZSByYW5nZSB2YWx1ZXMgYXJlIGNsb3NlciB0byB0aGUgY2FtZXJhLCBhbmQgcG9zaXRpdmUgdmFsdWVzIGFyZSBmYXJ0aGVyIGF3YXkuXCIsXG4gICAgZXhhbXBsZTogWzAuNSwgMTBdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4zLjBcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29sb3I6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIiNmZmZmZmZcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIGRvYzogXCJUaGUgY29sb3Igb2YgdGhlIGZvZy4gVXNpbmcgb3BhY2l0eSBpcyByZWNvbW1lbmRlZCBvbmx5IGZvciBzbW9vdGhseSB0cmFuc2l0aW9uaW5nIGZvZyBvbi9vZmYgYXMgYW55dGhpbmcgbGVzcyB0aGFuIDEwMCUgb3BhY2l0eSByZXN1bHRzIGluIG1vcmUgdGlsZXMgbG9hZGVkIGFuZCBkcmF3bi5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjIuMy4wXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiaG9yaXpvbi1ibGVuZFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgXCJkZWZhdWx0XCI6IDAuMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBkb2M6IFwiSG9yaXpvbiBibGVuZCBhcHBsaWVzIGEgc21vb3RoIGZhZGUgZnJvbSB0aGUgY29sb3Igb2YgdGhlIGZvZyB0byB0aGUgY29sb3Igb2YgdGhlIHNreS4gQSB2YWx1ZSBvZiB6ZXJvIGxlYXZlcyBhIHNoYXJwIHRyYW5zaXRpb24gZnJvbSBmb2cgdG8gc2t5LiBJbmNyZWFzaW5nIHRoZSB2YWx1ZSBibGVuZHMgdGhlIGNvbG9yIG9mIGZvZyBpbnRvIGluY3JlYXNpbmdseSBoaWdoIGFuZ2xlcyBvZiB0aGUgc2t5LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4zLjBcIlxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBsaWdodCA9IHtcbiAgYW5jaG9yOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge1xuICAgICAgICBkb2M6IFwiVGhlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UgaXMgYWxpZ25lZCB0byB0aGUgcm90YXRpb24gb2YgdGhlIG1hcC5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSBpcyBhbGlnbmVkIHRvIHRoZSByb3RhdGlvbiBvZiB0aGUgdmlld3BvcnQuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgZG9jOiBcIldoZXRoZXIgZXh0cnVkZWQgZ2VvbWV0cmllcyBhcmUgbGl0IHJlbGF0aXZlIHRvIHRoZSBtYXAgb3Igdmlld3BvcnQuXCIsXG4gICAgZXhhbXBsZTogXCJtYXBcIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMjcuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb3NpdGlvbjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBcImRlZmF1bHRcIjogWzEuMTUsIDIxMCwgMzBdLFxuICAgIGxlbmd0aDogMyxcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBkb2M6IFwiUG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSByZWxhdGl2ZSB0byBsaXQgKGV4dHJ1ZGVkKSBnZW9tZXRyaWVzLCBpbiBbciByYWRpYWwgY29vcmRpbmF0ZSwgYSBhemltdXRoYWwgYW5nbGUsIHAgcG9sYXIgYW5nbGVdIHdoZXJlIHIgaW5kaWNhdGVzIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBjZW50ZXIgb2YgdGhlIGJhc2Ugb2YgYW4gb2JqZWN0IHRvIGl0cyBsaWdodCwgYSBpbmRpY2F0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsaWdodCByZWxhdGl2ZSB0byAwwrAgKDDCsCB3aGVuIGBsaWdodC5hbmNob3JgIGlzIHNldCB0byBgdmlld3BvcnRgIGNvcnJlc3BvbmRzIHRvIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0LCBvciAwwrAgd2hlbiBgbGlnaHQuYW5jaG9yYCBpcyBzZXQgdG8gYG1hcGAgY29ycmVzcG9uZHMgdG8gZHVlIG5vcnRoLCBhbmQgZGVncmVlcyBwcm9jZWVkIGNsb2Nrd2lzZSksIGFuZCBwIGluZGljYXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBsaWdodCAoZnJvbSAwwrAsIGRpcmVjdGx5IGFib3ZlLCB0byAxODDCsCwgZGlyZWN0bHkgYmVsb3cpLlwiLFxuICAgIGV4YW1wbGU6IFsxLjUsIDkwLCA4MF0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29sb3I6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIiNmZmZmZmZcIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIGRvYzogXCJDb2xvciB0aW50IGZvciBsaWdodGluZyBleHRydWRlZCBnZW9tZXRyaWVzLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4yNy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4xLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGludGVuc2l0eToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLjUsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgZG9jOiBcIkludGVuc2l0eSBvZiBsaWdodGluZyAob24gYSBzY2FsZSBmcm9tIDAgdG8gMSkuIEhpZ2hlciBudW1iZXJzIHdpbGwgcHJlc2VudCBhcyBtb3JlIGV4dHJlbWUgY29udHJhc3QuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciB0ZXJyYWluID0ge1xuICBzb3VyY2U6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJOYW1lIG9mIGEgc291cmNlIG9mIGByYXN0ZXJfZGVtYCB0eXBlIHRvIGJlIHVzZWQgZm9yIHRlcnJhaW4gZWxldmF0aW9uLlwiLFxuICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4wLjBcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZXhhZ2dlcmF0aW9uOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxMDAwLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgZG9jOiBcIkV4YWdnZXJhdGVzIHRoZSBlbGV2YXRpb24gb2YgdGhlIHRlcnJhaW4gYnkgbXVsdGlwbHlpbmcgdGhlIGRhdGEgZnJvbSB0aGUgREVNIHdpdGggdGhpcyB2YWx1ZS5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjIuMC4wXCJcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgcGFpbnQgPSBbXCJwYWludF9maWxsXCIsIFwicGFpbnRfbGluZVwiLCBcInBhaW50X2NpcmNsZVwiLCBcInBhaW50X2hlYXRtYXBcIiwgXCJwYWludF9maWxsLWV4dHJ1c2lvblwiLCBcInBhaW50X3N5bWJvbFwiLCBcInBhaW50X3Jhc3RlclwiLCBcInBhaW50X2hpbGxzaGFkZVwiLCBcInBhaW50X2JhY2tncm91bmRcIiwgXCJwYWludF9za3lcIl07XG52YXIgcGFpbnRfZmlsbCA9IHtcbiAgXCJmaWxsLWFudGlhbGlhc1wiOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgZG9jOiBcIldoZXRoZXIgb3Igbm90IHRoZSBmaWxsIHNob3VsZCBiZSBhbnRpYWxpYXNlZC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiZmlsbC1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICBkb2M6IFwiVGhlIG9wYWNpdHkgb2YgdGhlIGVudGlyZSBmaWxsIGxheWVyLiBJbiBjb250cmFzdCB0byB0aGUgYGZpbGwtY29sb3JgLCB0aGlzIHZhbHVlIHdpbGwgYWxzbyBhZmZlY3QgdGhlIDFweCBzdHJva2UgYXJvdW5kIHRoZSBmaWxsLCBpZiB0aGUgc3Ryb2tlIGlzIHVzZWQuXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4yMS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImZpbGwtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgZG9jOiBcIlRoZSBjb2xvciBvZiB0aGUgZmlsbGVkIHBhcnQgb2YgdGhpcyBsYXllci4gVGhpcyBjb2xvciBjYW4gYmUgc3BlY2lmaWVkIGFzIGByZ2JhYCB3aXRoIGFuIGFscGhhIGNvbXBvbmVudCBhbmQgdGhlIGNvbG9yJ3Mgb3BhY2l0eSB3aWxsIG5vdCBhZmZlY3QgdGhlIG9wYWNpdHkgb2YgdGhlIDFweCBzdHJva2UsIGlmIGl0IGlzIHVzZWQuXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICByZXF1aXJlczogW3tcbiAgICAgIFwiIVwiOiBcImZpbGwtcGF0dGVyblwiXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMTkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJmaWxsLW91dGxpbmUtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBkb2M6IFwiVGhlIG91dGxpbmUgY29sb3Igb2YgdGhlIGZpbGwuIE1hdGNoZXMgdGhlIHZhbHVlIG9mIGBmaWxsLWNvbG9yYCBpZiB1bnNwZWNpZmllZC5cIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCIhXCI6IFwiZmlsbC1wYXR0ZXJuXCJcbiAgICB9LCB7XG4gICAgICBcImZpbGwtYW50aWFsaWFzXCI6IHRydWVcbiAgICB9XSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4xOS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImZpbGwtdHJhbnNsYXRlXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiAyLFxuICAgIFwiZGVmYXVsdFwiOiBbMCwgMF0sXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJmaWxsLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7XG4gICAgICAgIGRvYzogXCJUaGUgZmlsbCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBkb2M6IFwiVGhlIGZpbGwgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgZmlsbC10cmFuc2xhdGVgLlwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgIHJlcXVpcmVzOiBbXCJmaWxsLXRyYW5zbGF0ZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiZmlsbC1wYXR0ZXJuXCI6IHtcbiAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIGRvYzogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgaW1hZ2UgZmlsbHMuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLiBOb3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjQ5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjExLjBcIixcbiAgICAgICAgaW9zOiBcIjQuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIlxuICB9XG59O1xudmFyIHBhaW50X2xpbmUgPSB7XG4gIFwibGluZS1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgbGluZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjI5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwibGluZS1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIGRvYzogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgbGluZSB3aWxsIGJlIGRyYXduLlwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCIhXCI6IFwibGluZS1wYXR0ZXJuXCJcbiAgICB9XSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4yMy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtdHJhbnNsYXRlXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiAyLFxuICAgIFwiZGVmYXVsdFwiOiBbMCwgMF0sXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJsaW5lLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGluZSBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBkb2M6IFwiVGhlIGxpbmUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgbGluZS10cmFuc2xhdGVgLlwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgIHJlcXVpcmVzOiBbXCJsaW5lLXRyYW5zbGF0ZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwibGluZS13aWR0aFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIlN0cm9rZSB0aGlja25lc3MuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMzkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMi4wXCIsXG4gICAgICAgIGlvczogXCIzLjcuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjYuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLWdhcC13aWR0aFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIGRvYzogXCJEcmF3cyBhIGxpbmUgY2FzaW5nIG91dHNpZGUgb2YgYSBsaW5lJ3MgYWN0dWFsIHBhdGguIFZhbHVlIGluZGljYXRlcyB0aGUgd2lkdGggb2YgdGhlIGlubmVyIGdhcC5cIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjI5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwibGluZS1vZmZzZXRcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgZG9jOiBcIlRoZSBsaW5lJ3Mgb2Zmc2V0LiBGb3IgbGluZWFyIGZlYXR1cmVzLCBhIHBvc2l0aXZlIHZhbHVlIG9mZnNldHMgdGhlIGxpbmUgdG8gdGhlIHJpZ2h0LCByZWxhdGl2ZSB0byB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaW5lLCBhbmQgYSBuZWdhdGl2ZSB2YWx1ZSB0byB0aGUgbGVmdC4gRm9yIHBvbHlnb24gZmVhdHVyZXMsIGEgcG9zaXRpdmUgdmFsdWUgcmVzdWx0cyBpbiBhbiBpbnNldCwgYW5kIGEgbmVnYXRpdmUgdmFsdWUgcmVzdWx0cyBpbiBhbiBvdXRzZXQuXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTIuMVwiLFxuICAgICAgICBhbmRyb2lkOiBcIjMuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjEuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4yOS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtYmx1clwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIkJsdXIgYXBwbGllZCB0byB0aGUgbGluZSwgaW4gcGl4ZWxzLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjI5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwibGluZS1kYXNoYXJyYXlcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiU3BlY2lmaWVzIHRoZSBsZW5ndGhzIG9mIHRoZSBhbHRlcm5hdGluZyBkYXNoZXMgYW5kIGdhcHMgdGhhdCBmb3JtIHRoZSBkYXNoIHBhdHRlcm4uIFRoZSBsZW5ndGhzIGFyZSBsYXRlciBzY2FsZWQgYnkgdGhlIGxpbmUgd2lkdGguIFRvIGNvbnZlcnQgYSBkYXNoIGxlbmd0aCB0byBwaXhlbHMsIG11bHRpcGx5IHRoZSBsZW5ndGggYnkgdGhlIGN1cnJlbnQgbGluZSB3aWR0aC4gTm90ZSB0aGF0IEdlb0pTT04gc291cmNlcyB3aXRoIGBsaW5lTWV0cmljczogdHJ1ZWAgc3BlY2lmaWVkIHdvbid0IHJlbmRlciBkYXNoZWQgbGluZXMgdG8gdGhlIGV4cGVjdGVkIHNjYWxlLiBBbHNvIG5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcImxpbmUgd2lkdGhzXCIsXG4gICAgcmVxdWlyZXM6IFt7XG4gICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIyLjMuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLXBhdHRlcm5cIjoge1xuICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBsaW5lcy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLiBOb3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjQ5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjExLjBcIixcbiAgICAgICAgaW9zOiBcIjQuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtZ3JhZGllbnRcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBkb2M6IFwiRGVmaW5lcyBhIGdyYWRpZW50IHdpdGggd2hpY2ggdG8gY29sb3IgYSBsaW5lIGZlYXR1cmUuIENhbiBvbmx5IGJlIHVzZWQgd2l0aCBHZW9KU09OIHNvdXJjZXMgdGhhdCBzcGVjaWZ5IGBcXFwibGluZU1ldHJpY3NcXFwiOiB0cnVlYC5cIixcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICByZXF1aXJlczogW3tcbiAgICAgIFwiIVwiOiBcImxpbmUtZGFzaGFycmF5XCJcbiAgICB9LCB7XG4gICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgIH0sIHtcbiAgICAgIHNvdXJjZTogXCJnZW9qc29uXCIsXG4gICAgICBoYXM6IHtcbiAgICAgICAgbGluZU1ldHJpY3M6IHRydWVcbiAgICAgIH1cbiAgICB9XSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDUuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuNS4wXCIsXG4gICAgICAgIGlvczogXCI0LjQuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjExLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wibGluZS1wcm9ncmVzc1wiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG4gIH1cbn07XG52YXIgcGFpbnRfY2lyY2xlID0ge1xuICBcImNpcmNsZS1yYWRpdXNcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDUsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJDaXJjbGUgcmFkaXVzLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjE4LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiY2lyY2xlLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgIGRvYzogXCJUaGUgZmlsbCBjb2xvciBvZiB0aGUgY2lyY2xlLlwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMTguMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJjaXJjbGUtYmx1clwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBkb2M6IFwiQW1vdW50IHRvIGJsdXIgdGhlIGNpcmNsZS4gMSBibHVycyB0aGUgY2lyY2xlIHN1Y2ggdGhhdCBvbmx5IHRoZSBjZW50ZXJwb2ludCBpcyBmdWxsIG9wYWNpdHkuXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4yMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImNpcmNsZS1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgY2lyY2xlIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMjAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJjaXJjbGUtdHJhbnNsYXRlXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiAyLFxuICAgIFwiZGVmYXVsdFwiOiBbMCwgMF0sXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAsIHJlc3BlY3RpdmVseS5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJjaXJjbGUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBjaXJjbGUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLlwiXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBjaXJjbGUgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgY2lyY2xlLXRyYW5zbGF0ZWAuXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgcmVxdWlyZXM6IFtcImNpcmNsZS10cmFuc2xhdGVcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImNpcmNsZS1waXRjaC1zY2FsZVwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHtcbiAgICAgICAgZG9jOiBcIkNpcmNsZXMgYXJlIHNjYWxlZCBhY2NvcmRpbmcgdG8gdGhlaXIgYXBwYXJlbnQgZGlzdGFuY2UgdG8gdGhlIGNhbWVyYS5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJDaXJjbGVzIGFyZSBub3Qgc2NhbGVkLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJtYXBcIixcbiAgICBkb2M6IFwiQ29udHJvbHMgdGhlIHNjYWxpbmcgYmVoYXZpb3Igb2YgdGhlIGNpcmNsZSB3aGVuIHRoZSBtYXAgaXMgcGl0Y2hlZC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMjEuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjQuMi4wXCIsXG4gICAgICAgIGlvczogXCIzLjQuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjIuMVwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiY2lyY2xlLXBpdGNoLWFsaWdubWVudFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBjaXJjbGUgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIG1hcC5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgY2lyY2xlIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcbiAgICBkb2M6IFwiT3JpZW50YXRpb24gb2YgY2lyY2xlIHdoZW4gbWFwIGlzIHBpdGNoZWQuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjM5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjIuMFwiLFxuICAgICAgICBpb3M6IFwiMy43LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC42LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImNpcmNsZS1zdHJva2Utd2lkdGhcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJUaGUgd2lkdGggb2YgdGhlIGNpcmNsZSdzIHN0cm9rZS4gU3Ryb2tlcyBhcmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGBjaXJjbGUtcmFkaXVzYC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMjkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4yOS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImNpcmNsZS1zdHJva2UtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgZG9jOiBcIlRoZSBzdHJva2UgY29sb3Igb2YgdGhlIGNpcmNsZS5cIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4yOS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjI5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiY2lyY2xlLXN0cm9rZS1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJUaGUgb3BhY2l0eSBvZiB0aGUgY2lyY2xlJ3Mgc3Ryb2tlLlwiLFxuICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4yOS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjI5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH1cbn07XG52YXIgcGFpbnRfaGVhdG1hcCA9IHtcbiAgXCJoZWF0bWFwLXJhZGl1c1wiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMzAsXG4gICAgbWluaW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJSYWRpdXMgb2YgaW5mbHVlbmNlIG9mIG9uZSBoZWF0bWFwIHBvaW50IGluIHBpeGVscy4gSW5jcmVhc2luZyB0aGUgdmFsdWUgbWFrZXMgdGhlIGhlYXRtYXAgc21vb3RoZXIsIGJ1dCBsZXNzIGRldGFpbGVkLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjQzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaGVhdG1hcC13ZWlnaHRcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICBkb2M6IFwiQSBtZWFzdXJlIG9mIGhvdyBtdWNoIGFuIGluZGl2aWR1YWwgcG9pbnQgY29udHJpYnV0ZXMgdG8gdGhlIGhlYXRtYXAuIEEgdmFsdWUgb2YgMTAgd291bGQgYmUgZXF1aXZhbGVudCB0byBoYXZpbmcgMTAgcG9pbnRzIG9mIHdlaWdodCAxIGluIHRoZSBzYW1lIHNwb3QuIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gY29tYmluZWQgd2l0aCBjbHVzdGVyaW5nLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaGVhdG1hcC1pbnRlbnNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIGRvYzogXCJTaW1pbGFyIHRvIGBoZWF0bWFwLXdlaWdodGAgYnV0IGNvbnRyb2xzIHRoZSBpbnRlbnNpdHkgb2YgdGhlIGhlYXRtYXAgZ2xvYmFsbHkuIFByaW1hcmlseSB1c2VkIGZvciBhZGp1c3RpbmcgdGhlIGhlYXRtYXAgYmFzZWQgb24gem9vbSBsZXZlbC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJoZWF0bWFwLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJkZWZhdWx0XCI6IFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wiaGVhdG1hcC1kZW5zaXR5XCJdLCAwLCBcInJnYmEoMCwgMCwgMjU1LCAwKVwiLCAwLjEsIFwicm95YWxibHVlXCIsIDAuMywgXCJjeWFuXCIsIDAuNSwgXCJsaW1lXCIsIDAuNywgXCJ5ZWxsb3dcIiwgMSwgXCJyZWRcIl0sXG4gICAgZG9jOiBcIkRlZmluZXMgdGhlIGNvbG9yIG9mIGVhY2ggcGl4ZWwgYmFzZWQgb24gaXRzIGRlbnNpdHkgdmFsdWUgaW4gYSBoZWF0bWFwLiAgU2hvdWxkIGJlIGFuIGV4cHJlc3Npb24gdGhhdCB1c2VzIGBbXFxcImhlYXRtYXAtZGVuc2l0eVxcXCJdYCBhcyBpbnB1dC5cIixcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJoZWF0bWFwLWRlbnNpdHlcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbG9yLXJhbXBcIlxuICB9LFxuICBcImhlYXRtYXAtb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiVGhlIGdsb2JhbCBvcGFjaXR5IGF0IHdoaWNoIHRoZSBoZWF0bWFwIGxheWVyIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH1cbn07XG52YXIgcGFpbnRfc3ltYm9sID0ge1xuICBcImljb24tb3BhY2l0eVwiOiB7XG4gICAgZG9jOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBpY29uIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zMy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImljb24tY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBkb2M6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uLiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzZGYgaWNvbnMuXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMzMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLWhhbG8tY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcImRlZmF1bHRcIjogXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBkb2M6IFwiVGhlIGNvbG9yIG9mIHRoZSBpY29uJ3MgaGFsby4gSWNvbiBoYWxvcyBjYW4gb25seSBiZSB1c2VkIHdpdGggU0RGIGljb25zLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjMzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi1oYWxvLXdpZHRoXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiRGlzdGFuY2Ugb2YgaGFsbyB0byB0aGUgaWNvbiBvdXRsaW5lLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjMzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi1oYWxvLWJsdXJcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJGYWRlIG91dCB0aGUgaGFsbyB0b3dhcmRzIHRoZSBvdXRzaWRlLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjMzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi10cmFuc2xhdGVcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDIsXG4gICAgXCJkZWZhdWx0XCI6IFswLCAwXSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJEaXN0YW5jZSB0aGF0IHRoZSBpY29uJ3MgYW5jaG9yIGlzIG1vdmVkIGZyb20gaXRzIG9yaWdpbmFsIHBsYWNlbWVudC4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge1xuICAgICAgICBkb2M6IFwiSWNvbnMgYXJlIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJJY29ucyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgaWNvbi10cmFuc2xhdGVgLlwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCIsIFwiaWNvbi10cmFuc2xhdGVcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIHRleHQgd2lsbCBiZSBkcmF3bi5cIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zMy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBkb2M6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIHRleHQgd2lsbCBiZSBkcmF3bi5cIixcbiAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBvdmVycmlkYWJsZTogdHJ1ZSxcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zMy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtaGFsby1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIGRvYzogXCJUaGUgY29sb3Igb2YgdGhlIHRleHQncyBoYWxvLCB3aGljaCBoZWxwcyBpdCBzdGFuZCBvdXQgZnJvbSBiYWNrZ3JvdW5kcy5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zMy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtaGFsby13aWR0aFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIkRpc3RhbmNlIG9mIGhhbG8gdG8gdGhlIGZvbnQgb3V0bGluZS4gTWF4IHRleHQgaGFsbyB3aWR0aCBpcyAxLzQgb2YgdGhlIGZvbnQtc2l6ZS5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zMy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtaGFsby1ibHVyXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiVGhlIGhhbG8ncyBmYWRlb3V0IGRpc3RhbmNlIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMzMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LXRyYW5zbGF0ZVwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGxlbmd0aDogMixcbiAgICBcImRlZmF1bHRcIjogWzAsIDBdLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIkRpc3RhbmNlIHRoYXQgdGhlIHRleHQncyBhbmNob3IgaXMgbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgcGxhY2VtZW50LiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7XG4gICAgICAgIGRvYzogXCJUaGUgdGV4dCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBkb2M6IFwiVGhlIHRleHQgaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgdGV4dC10cmFuc2xhdGVgLlwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCIsIFwidGV4dC10cmFuc2xhdGVcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9XG59O1xudmFyIHBhaW50X3Jhc3RlciA9IHtcbiAgXCJyYXN0ZXItb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGltYWdlIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwicmFzdGVyLWh1ZS1yb3RhdGVcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgcGVyaW9kOiAzNjAsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgZG9jOiBcIlJvdGF0ZXMgaHVlcyBhcm91bmQgdGhlIGNvbG9yIHdoZWVsLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInJhc3Rlci1icmlnaHRuZXNzLW1pblwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBicmlnaHRuZXNzIG9mIHRoZSBpbWFnZS4gVGhlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIGJyaWdodG5lc3MuXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwicmFzdGVyLWJyaWdodG5lc3MtbWF4XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1heGltdW0gYnJpZ2h0bmVzcy5cIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJyYXN0ZXItc2F0dXJhdGlvblwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiSW5jcmVhc2Ugb3IgcmVkdWNlIHRoZSBzYXR1cmF0aW9uIG9mIHRoZSBpbWFnZS5cIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBtaW5pbXVtOiAtMSxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwicmFzdGVyLWNvbnRyYXN0XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGNvbnRyYXN0IG9mIHRoZSBpbWFnZS5cIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBtaW5pbXVtOiAtMSxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwicmFzdGVyLXJlc2FtcGxpbmdcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIGRvYzogXCJUaGUgcmVzYW1wbGluZy9pbnRlcnBvbGF0aW9uIG1ldGhvZCB0byB1c2UgZm9yIG92ZXJzY2FsaW5nLCBhbHNvIGtub3duIGFzIHRleHR1cmUgbWFnbmlmaWNhdGlvbiBmaWx0ZXJcIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGxpbmVhcjoge1xuICAgICAgICBkb2M6IFwiKEJpKWxpbmVhciBmaWx0ZXJpbmcgaW50ZXJwb2xhdGVzIHBpeGVsIHZhbHVlcyB1c2luZyB0aGUgd2VpZ2h0ZWQgYXZlcmFnZSBvZiB0aGUgZm91ciBjbG9zZXN0IG9yaWdpbmFsIHNvdXJjZSBwaXhlbHMgY3JlYXRpbmcgYSBzbW9vdGggYnV0IGJsdXJyeSBsb29rIHdoZW4gb3ZlcnNjYWxlZFwiXG4gICAgICB9LFxuICAgICAgbmVhcmVzdDoge1xuICAgICAgICBkb2M6IFwiTmVhcmVzdCBuZWlnaGJvciBmaWx0ZXJpbmcgaW50ZXJwb2xhdGVzIHBpeGVsIHZhbHVlcyB1c2luZyB0aGUgbmVhcmVzdCBvcmlnaW5hbCBzb3VyY2UgcGl4ZWwgY3JlYXRpbmcgYSBzaGFycCBidXQgcGl4ZWxhdGVkIGxvb2sgd2hlbiBvdmVyc2NhbGVkXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcImxpbmVhclwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40Ny4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4zLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMi4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuOS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJyYXN0ZXItZmFkZS1kdXJhdGlvblwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMzAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogZmFsc2UsXG4gICAgdW5pdHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgZG9jOiBcIkZhZGUgZHVyYXRpb24gd2hlbiBhIG5ldyB0aWxlIGlzIGFkZGVkLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9XG59O1xudmFyIHBhaW50X2hpbGxzaGFkZSA9IHtcbiAgXCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWRpcmVjdGlvblwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMzM1LFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMzU5LFxuICAgIGRvYzogXCJUaGUgZGlyZWN0aW9uIG9mIHRoZSBsaWdodCBzb3VyY2UgdXNlZCB0byBnZW5lcmF0ZSB0aGUgaGlsbHNoYWRpbmcgd2l0aCAwIGFzIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0IGlmIGBoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvcmAgaXMgc2V0IHRvIGB2aWV3cG9ydGAgYW5kIGR1ZSBub3J0aCBpZiBgaGlsbHNoYWRlLWlsbHVtaW5hdGlvbi1hbmNob3JgIGlzIHNldCB0byBgbWFwYC5cIixcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBoaWxsc2hhZGUgaWxsdW1pbmF0aW9uIGlzIHJlbGF0aXZlIHRvIHRoZSBub3J0aCBkaXJlY3Rpb24uXCJcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBkb2M6IFwiVGhlIGhpbGxzaGFkZSBpbGx1bWluYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcInZpZXdwb3J0XCIsXG4gICAgZG9jOiBcIkRpcmVjdGlvbiBvZiBsaWdodCBzb3VyY2Ugd2hlbiBtYXAgaXMgcm90YXRlZC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaGlsbHNoYWRlLWV4YWdnZXJhdGlvblwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiSW50ZW5zaXR5IG9mIHRoZSBoaWxsc2hhZGVcIixcbiAgICBcImRlZmF1bHRcIjogMC41LFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40My4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImhpbGxzaGFkZS1zaGFkb3ctY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgZG9jOiBcIlRoZSBzaGFkaW5nIGNvbG9yIG9mIGFyZWFzIHRoYXQgZmFjZSBhd2F5IGZyb20gdGhlIGxpZ2h0IHNvdXJjZS5cIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40My4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImhpbGxzaGFkZS1oaWdobGlnaHQtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcImRlZmF1bHRcIjogXCIjRkZGRkZGXCIsXG4gICAgZG9jOiBcIlRoZSBzaGFkaW5nIGNvbG9yIG9mIGFyZWFzIHRoYXQgZmFjZXMgdG93YXJkcyB0aGUgbGlnaHQgc291cmNlLlwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjQzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaGlsbHNoYWRlLWFjY2VudC1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICBkb2M6IFwiVGhlIHNoYWRpbmcgY29sb3IgdXNlZCB0byBhY2NlbnR1YXRlIHJ1Z2dlZCB0ZXJyYWluIGxpa2Ugc2hhcnAgY2xpZmZzIGFuZCBnb3JnZXMuXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfVxufTtcbnZhciBwYWludF9iYWNrZ3JvdW5kID0ge1xuICBcImJhY2tncm91bmQtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgZG9jOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICByZXF1aXJlczogW3tcbiAgICAgIFwiIVwiOiBcImJhY2tncm91bmQtcGF0dGVyblwiXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiYmFja2dyb3VuZC1wYXR0ZXJuXCI6IHtcbiAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIGRvYzogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgYW4gaW1hZ2UgYmFja2dyb3VuZC4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuIE5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkXCJcbiAgfSxcbiAgXCJiYWNrZ3JvdW5kLW9wYWNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIGRvYzogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgYmFja2dyb3VuZCB3aWxsIGJlIGRyYXduLlwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH1cbn07XG52YXIgcGFpbnRfc2t5ID0ge1xuICBcInNreS10eXBlXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGdyYWRpZW50OiB7XG4gICAgICAgIGRvYzogXCJSZW5kZXJzIHRoZSBza3kgd2l0aCBhIGdyYWRpZW50IHRoYXQgY2FuIGJlIGNvbmZpZ3VyZWQgd2l0aCBgc2t5LWdyYWRpZW50LXJhZGl1c2AgYW5kIGBza3ktZ3JhZGllbnRgLlwiXG4gICAgICB9LFxuICAgICAgYXRtb3NwaGVyZToge1xuICAgICAgICBkb2M6IFwiUmVuZGVycyB0aGUgc2t5IHdpdGggYSBzaW11bGF0ZWQgYXRtb3NwaGVyaWMgc2NhdHRlcmluZyBhbGdvcml0aG0sIHRoZSBzdW4gZGlyZWN0aW9uIGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgbGlnaHQgcG9zaXRpb24gb3IgZXhwbGljaXRseSBzZXQgdGhyb3VnaCBgc2t5LWF0bW9zcGhlcmUtc3VuYC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwiYXRtb3NwaGVyZVwiLFxuICAgIGRvYzogXCJUaGUgdHlwZSBvZiB0aGUgc2t5XCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIyLjAuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwic2t5LWF0bW9zcGhlcmUtc3VuXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiAyLFxuICAgIHVuaXRzOiBcImRlZ3JlZXNcIixcbiAgICBtaW5pbXVtOiBbMCwgMF0sXG4gICAgbWF4aW11bTogWzM2MCwgMTgwXSxcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICBkb2M6IFwiUG9zaXRpb24gb2YgdGhlIHN1biBjZW50ZXIgW2EgYXppbXV0aGFsIGFuZ2xlLCBwIHBvbGFyIGFuZ2xlXS4gVGhlIGF6aW11dGhhbCBhbmdsZSBpbmRpY2F0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzdW4gcmVsYXRpdmUgdG8gMMKwIG5vcnRoLCB3aGVyZSBkZWdyZWVzIHByb2NlZWQgY2xvY2t3aXNlLiBUaGUgcG9sYXIgYW5nbGUgaW5kaWNhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIHN1biwgd2hlcmUgMMKwIGlzIGRpcmVjdGx5IGFib3ZlLCBhdCB6ZW5pdGgsIGFuZCA5MMKwIGF0IHRoZSBob3Jpem9uLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgb21taXR0ZWQsIHRoZSBzdW4gY2VudGVyIGlzIGRpcmVjdGx5IGluaGVyaXRlZCBmcm9tIHRoZSBsaWdodCBwb3NpdGlvbi5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjIuMC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCJza3ktdHlwZVwiOiBcImF0bW9zcGhlcmVcIlxuICAgIH1dLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJza3ktYXRtb3NwaGVyZS1zdW4taW50ZW5zaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCJza3ktdHlwZVwiOiBcImF0bW9zcGhlcmVcIlxuICAgIH1dLFxuICAgIFwiZGVmYXVsdFwiOiAxMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEwMCxcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICBkb2M6IFwiSW50ZW5zaXR5IG9mIHRoZSBzdW4gYXMgYSBsaWdodCBzb3VyY2UgaW4gdGhlIGF0bW9zcGhlcmUgKG9uIGEgc2NhbGUgZnJvbSAwIHRvIGEgMTAwKS4gU2V0dGluZyBoaWdoZXIgdmFsdWVzIHdpbGwgYnJpZ2h0ZW4gdXAgdGhlIHNreS5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjIuMC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInNreS1ncmFkaWVudC1jZW50ZXJcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICByZXF1aXJlczogW3tcbiAgICAgIFwic2t5LXR5cGVcIjogXCJncmFkaWVudFwiXG4gICAgfV0sXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IFswLCAwXSxcbiAgICBsZW5ndGg6IDIsXG4gICAgdW5pdHM6IFwiZGVncmVlc1wiLFxuICAgIG1pbmltdW06IFswLCAwXSxcbiAgICBtYXhpbXVtOiBbMzYwLCAxODBdLFxuICAgIHRyYW5zaXRpb246IGZhbHNlLFxuICAgIGRvYzogXCJQb3NpdGlvbiBvZiB0aGUgZ3JhZGllbnQgY2VudGVyIFthIGF6aW11dGhhbCBhbmdsZSwgcCBwb2xhciBhbmdsZV0uIFRoZSBhemltdXRoYWwgYW5nbGUgaW5kaWNhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgZ3JhZGllbnQgY2VudGVyIHJlbGF0aXZlIHRvIDDCsCBub3J0aCwgd2hlcmUgZGVncmVlcyBwcm9jZWVkIGNsb2Nrd2lzZS4gVGhlIHBvbGFyIGFuZ2xlIGluZGljYXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBncmFkaWVudCBjZW50ZXIsIHdoZXJlIDDCsCBpcyBkaXJlY3RseSBhYm92ZSwgYXQgemVuaXRoLCBhbmQgOTDCsCBhdCB0aGUgaG9yaXpvbi5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjIuMC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJza3ktZ3JhZGllbnQtcmFkaXVzXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCJza3ktdHlwZVwiOiBcImdyYWRpZW50XCJcbiAgICB9XSxcbiAgICBcImRlZmF1bHRcIjogOTAsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxODAsXG4gICAgdHJhbnNpdGlvbjogZmFsc2UsXG4gICAgZG9jOiBcIlRoZSBhbmd1bGFyIGRpc3RhbmNlIChtZWFzdXJlZCBpbiBkZWdyZWVzKSBmcm9tIGBza3ktZ3JhZGllbnQtY2VudGVyYCB1cCB0byB3aGljaCB0aGUgZ3JhZGllbnQgZXh0ZW5kcy4gQSB2YWx1ZSBvZiAxODAgY2F1c2VzIHRoZSBncmFkaWVudCB0byB3cmFwIGFyb3VuZCB0byB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uIGZyb20gYHNreS1ncmFkaWVudC1jZW50ZXJgLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4wLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInNreS1ncmFkaWVudFwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBbXCJpbnRlcnBvbGF0ZVwiLCBbXCJsaW5lYXJcIl0sIFtcInNreS1yYWRpYWwtcHJvZ3Jlc3NcIl0sIDAuOCwgXCIjODdjZWViXCIsIDEsIFwid2hpdGVcIl0sXG4gICAgZG9jOiBcIkRlZmluZXMgYSByYWRpYWwgY29sb3IgZ3JhZGllbnQgd2l0aCB3aGljaCB0byBjb2xvciB0aGUgc2t5LiBUaGUgY29sb3IgdmFsdWVzIGNhbiBiZSBpbnRlcnBvbGF0ZWQgd2l0aCBhbiBleHByZXNzaW9uIHVzaW5nIGBza3ktcmFkaWFsLXByb2dyZXNzYC4gVGhlIHJhbmdlIFswLCAxXSBmb3IgdGhlIGludGVycG9sYW50IGNvdmVycyBhIHJhZGlhbCBkaXN0YW5jZSAoaW4gZGVncmVlcykgb2YgWzAsIGBza3ktZ3JhZGllbnQtcmFkaXVzYF0gY2VudGVyZWQgYXQgdGhlIHBvc2l0aW9uIHNwZWNpZmllZCBieSBgc2t5LWdyYWRpZW50LWNlbnRlcmAuXCIsXG4gICAgdHJhbnNpdGlvbjogZmFsc2UsXG4gICAgcmVxdWlyZXM6IFt7XG4gICAgICBcInNreS10eXBlXCI6IFwiZ3JhZGllbnRcIlxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4wLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7fVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wic2t5LXJhZGlhbC1wcm9ncmVzc1wiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG4gIH0sXG4gIFwic2t5LWF0bW9zcGhlcmUtaGFsby1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIndoaXRlXCIsXG4gICAgZG9jOiBcIkEgY29sb3IgYXBwbGllZCB0byB0aGUgYXRtb3NwaGVyZSBzdW4gaGFsby4gVGhlIGFscGhhIGNoYW5uZWwgZGVzY3JpYmVzIGhvdyBzdHJvbmdseSB0aGUgc3VuIGhhbG8gaXMgcmVwcmVzZW50ZWQgaW4gYW4gYXRtb3NwaGVyZSBza3kgbGF5ZXIuXCIsXG4gICAgdHJhbnNpdGlvbjogZmFsc2UsXG4gICAgcmVxdWlyZXM6IFt7XG4gICAgICBcInNreS10eXBlXCI6IFwiYXRtb3NwaGVyZVwiXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIyLjAuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJza3ktYXRtb3NwaGVyZS1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIndoaXRlXCIsXG4gICAgZG9jOiBcIkEgY29sb3IgdXNlZCB0byB0d2VhayB0aGUgbWFpbiBhdG1vc3BoZXJpYyBzY2F0dGVyaW5nIGNvZWZmaWNpZW50cy4gVXNpbmcgd2hpdGUgYXBwbGllcyB0aGUgZGVmYXVsdCBjb2VmZmljaWVudHMgZ2l2aW5nIHRoZSBuYXR1cmFsIGJsdWUgY29sb3IgdG8gdGhlIGF0bW9zcGhlcmUuIFRoaXMgY29sb3IgYWZmZWN0cyBob3cgaGVhdmlseSB0aGUgY29ycmVzcG9uZGluZyB3YXZlbGVuZ3RoIGlzIHJlcHJlc2VudGVkIGR1cmluZyBzY2F0dGVyaW5nLiBUaGUgYWxwaGEgY2hhbm5lbCBkZXNjcmliZXMgdGhlIGRlbnNpdHkgb2YgdGhlIGF0bW9zcGhlcmUsIHdpdGggMSBtYXhpbXVtIGRlbnNpdHkgYW5kIDAgbm8gZGVuc2l0eS5cIixcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICByZXF1aXJlczogW3tcbiAgICAgIFwic2t5LXR5cGVcIjogXCJhdG1vc3BoZXJlXCJcbiAgICB9XSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjIuMC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInNreS1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICBkb2M6IFwiVGhlIG9wYWNpdHkgb2YgdGhlIGVudGlyZSBza3kgbGF5ZXIuXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjIuMC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9XG59O1xudmFyIHRyYW5zaXRpb24gPSB7XG4gIGR1cmF0aW9uOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMzAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdW5pdHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgZG9jOiBcIlRpbWUgYWxsb3R0ZWQgZm9yIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlLlwiXG4gIH0sXG4gIGRlbGF5OiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHVuaXRzOiBcIm1pbGxpc2Vjb25kc1wiLFxuICAgIGRvYzogXCJMZW5ndGggb2YgdGltZSBiZWZvcmUgYSB0cmFuc2l0aW9uIGJlZ2lucy5cIlxuICB9XG59O1xudmFyIHByb21vdGVJZCA9IHtcbiAgXCIqXCI6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJBIG5hbWUgb2YgYSBmZWF0dXJlIHByb3BlcnR5IHRvIHVzZSBhcyBJRCBmb3IgZmVhdHVyZSBzdGF0ZS5cIlxuICB9XG59O1xudmFyIHY4ID0ge1xuICAkdmVyc2lvbjogJHZlcnNpb24sXG4gICRyb290OiAkcm9vdCxcbiAgc291cmNlczogc291cmNlcyxcbiAgc291cmNlOiBzb3VyY2UsXG4gIHNvdXJjZV92ZWN0b3I6IHNvdXJjZV92ZWN0b3IsXG4gIHNvdXJjZV9yYXN0ZXI6IHNvdXJjZV9yYXN0ZXIsXG4gIHNvdXJjZV9yYXN0ZXJfZGVtOiBzb3VyY2VfcmFzdGVyX2RlbSxcbiAgc291cmNlX2dlb2pzb246IHNvdXJjZV9nZW9qc29uLFxuICBzb3VyY2VfdmlkZW86IHNvdXJjZV92aWRlbyxcbiAgc291cmNlX2ltYWdlOiBzb3VyY2VfaW1hZ2UsXG4gIGxheWVyOiBsYXllcixcbiAgbGF5b3V0OiBsYXlvdXQsXG4gIGxheW91dF9iYWNrZ3JvdW5kOiBsYXlvdXRfYmFja2dyb3VuZCxcbiAgbGF5b3V0X3NreTogbGF5b3V0X3NreSxcbiAgbGF5b3V0X2ZpbGw6IGxheW91dF9maWxsLFxuICBsYXlvdXRfY2lyY2xlOiBsYXlvdXRfY2lyY2xlLFxuICBsYXlvdXRfaGVhdG1hcDogbGF5b3V0X2hlYXRtYXAsXG4gIFwibGF5b3V0X2ZpbGwtZXh0cnVzaW9uXCI6IHtcbiAgICB2aXNpYmlsaXR5OiB7XG4gICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgIHZhbHVlczoge1xuICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuICAgICAgICB9LFxuICAgICAgICBub25lOiB7XG4gICAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICAgIGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgICB9XG4gIH0sXG4gIGxheW91dF9saW5lOiBsYXlvdXRfbGluZSxcbiAgbGF5b3V0X3N5bWJvbDogbGF5b3V0X3N5bWJvbCxcbiAgbGF5b3V0X3Jhc3RlcjogbGF5b3V0X3Jhc3RlcixcbiAgbGF5b3V0X2hpbGxzaGFkZTogbGF5b3V0X2hpbGxzaGFkZSxcbiAgZmlsdGVyOiBmaWx0ZXIsXG4gIGZpbHRlcl9vcGVyYXRvcjogZmlsdGVyX29wZXJhdG9yLFxuICBnZW9tZXRyeV90eXBlOiBnZW9tZXRyeV90eXBlLFxuICBcImZ1bmN0aW9uXCI6IHtcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICB0eXBlOiBcImV4cHJlc3Npb25cIixcbiAgICAgIGRvYzogXCJBbiBleHByZXNzaW9uLlwiXG4gICAgfSxcbiAgICBzdG9wczoge1xuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgZG9jOiBcIkFuIGFycmF5IG9mIHN0b3BzLlwiLFxuICAgICAgdmFsdWU6IFwiZnVuY3Rpb25fc3RvcFwiXG4gICAgfSxcbiAgICBiYXNlOiB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZG9jOiBcIlRoZSBleHBvbmVudGlhbCBiYXNlIG9mIHRoZSBpbnRlcnBvbGF0aW9uIGN1cnZlLiBJdCBjb250cm9scyB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgcmVzdWx0IGluY3JlYXNlcy4gSGlnaGVyIHZhbHVlcyBtYWtlIHRoZSByZXN1bHQgaW5jcmVhc2UgbW9yZSB0b3dhcmRzIHRoZSBoaWdoIGVuZCBvZiB0aGUgcmFuZ2UuIFdpdGggYDFgIHRoZSBzdG9wcyBhcmUgaW50ZXJwb2xhdGVkIGxpbmVhcmx5LlwiXG4gICAgfSxcbiAgICBwcm9wZXJ0eToge1xuICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgIGRvYzogXCJUaGUgbmFtZSBvZiBhIGZlYXR1cmUgcHJvcGVydHkgdG8gdXNlIGFzIHRoZSBmdW5jdGlvbiBpbnB1dC5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiR6b29tXCJcbiAgICB9LFxuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgdmFsdWVzOiB7XG4gICAgICAgIGlkZW50aXR5OiB7XG4gICAgICAgICAgZG9jOiBcIlJldHVybiB0aGUgaW5wdXQgdmFsdWUgYXMgdGhlIG91dHB1dCB2YWx1ZS5cIlxuICAgICAgICB9LFxuICAgICAgICBleHBvbmVudGlhbDoge1xuICAgICAgICAgIGRvYzogXCJHZW5lcmF0ZSBhbiBvdXRwdXQgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHN0b3BzIGp1c3QgbGVzcyB0aGFuIGFuZCBqdXN0IGdyZWF0ZXIgdGhhbiB0aGUgZnVuY3Rpb24gaW5wdXQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJ2YWw6IHtcbiAgICAgICAgICBkb2M6IFwiUmV0dXJuIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhlIHN0b3AganVzdCBsZXNzIHRoYW4gdGhlIGZ1bmN0aW9uIGlucHV0LlwiXG4gICAgICAgIH0sXG4gICAgICAgIGNhdGVnb3JpY2FsOiB7XG4gICAgICAgICAgZG9jOiBcIlJldHVybiB0aGUgb3V0cHV0IHZhbHVlIG9mIHRoZSBzdG9wIGVxdWFsIHRvIHRoZSBmdW5jdGlvbiBpbnB1dC5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZG9jOiBcIlRoZSBpbnRlcnBvbGF0aW9uIHN0cmF0ZWd5IHRvIHVzZSBpbiBmdW5jdGlvbiBldmFsdWF0aW9uLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiZXhwb25lbnRpYWxcIlxuICAgIH0sXG4gICAgY29sb3JTcGFjZToge1xuICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICB2YWx1ZXM6IHtcbiAgICAgICAgcmdiOiB7XG4gICAgICAgICAgZG9jOiBcIlVzZSB0aGUgUkdCIGNvbG9yIHNwYWNlIHRvIGludGVycG9sYXRlIGNvbG9yIHZhbHVlc1wiXG4gICAgICAgIH0sXG4gICAgICAgIGxhYjoge1xuICAgICAgICAgIGRvYzogXCJVc2UgdGhlIExBQiBjb2xvciBzcGFjZSB0byBpbnRlcnBvbGF0ZSBjb2xvciB2YWx1ZXMuXCJcbiAgICAgICAgfSxcbiAgICAgICAgaGNsOiB7XG4gICAgICAgICAgZG9jOiBcIlVzZSB0aGUgSENMIGNvbG9yIHNwYWNlIHRvIGludGVycG9sYXRlIGNvbG9yIHZhbHVlcywgaW50ZXJwb2xhdGluZyB0aGUgSHVlLCBDaHJvbWEsIGFuZCBMdW1pbmFuY2UgY2hhbm5lbHMgaW5kaXZpZHVhbGx5LlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkb2M6IFwiVGhlIGNvbG9yIHNwYWNlIGluIHdoaWNoIGNvbG9ycyBpbnRlcnBvbGF0ZWQuIEludGVycG9sYXRpbmcgY29sb3JzIGluIHBlcmNlcHR1YWwgY29sb3Igc3BhY2VzIGxpa2UgTEFCIGFuZCBIQ0wgdGVuZCB0byBwcm9kdWNlIGNvbG9yIHJhbXBzIHRoYXQgbG9vayBtb3JlIGNvbnNpc3RlbnQgYW5kIHByb2R1Y2UgY29sb3JzIHRoYXQgY2FuIGJlIGRpZmZlcmVudGlhdGVkIG1vcmUgZWFzaWx5IHRoYW4gdGhvc2UgaW50ZXJwb2xhdGVkIGluIFJHQiBzcGFjZS5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcInJnYlwiXG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjoge1xuICAgICAgdHlwZTogXCIqXCIsXG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBkb2M6IFwiQSB2YWx1ZSB0byBzZXJ2ZSBhcyBhIGZhbGxiYWNrIGZ1bmN0aW9uIHJlc3VsdCB3aGVuIGEgdmFsdWUgaXNuJ3Qgb3RoZXJ3aXNlIGF2YWlsYWJsZS4gSXQgaXMgdXNlZCBpbiB0aGUgZm9sbG93aW5nIGNpcmN1bXN0YW5jZXM6XFxuKiBJbiBjYXRlZ29yaWNhbCBmdW5jdGlvbnMsIHdoZW4gdGhlIGZlYXR1cmUgdmFsdWUgZG9lcyBub3QgbWF0Y2ggYW55IG9mIHRoZSBzdG9wIGRvbWFpbiB2YWx1ZXMuXFxuKiBJbiBwcm9wZXJ0eSBhbmQgem9vbS1hbmQtcHJvcGVydHkgZnVuY3Rpb25zLCB3aGVuIGEgZmVhdHVyZSBkb2VzIG5vdCBjb250YWluIGEgdmFsdWUgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuXFxuKiBJbiBpZGVudGl0eSBmdW5jdGlvbnMsIHdoZW4gdGhlIGZlYXR1cmUgdmFsdWUgaXMgbm90IHZhbGlkIGZvciB0aGUgc3R5bGUgcHJvcGVydHkgKGZvciBleGFtcGxlLCBpZiB0aGUgZnVuY3Rpb24gaXMgYmVpbmcgdXNlZCBmb3IgYSBgY2lyY2xlLWNvbG9yYCBwcm9wZXJ0eSBidXQgdGhlIGZlYXR1cmUgcHJvcGVydHkgdmFsdWUgaXMgbm90IGEgc3RyaW5nIG9yIG5vdCBhIHZhbGlkIGNvbG9yKS5cXG4qIEluIGludGVydmFsIG9yIGV4cG9uZW50aWFsIHByb3BlcnR5IGFuZCB6b29tLWFuZC1wcm9wZXJ0eSBmdW5jdGlvbnMsIHdoZW4gdGhlIGZlYXR1cmUgdmFsdWUgaXMgbm90IG51bWVyaWMuXFxuSWYgbm8gZGVmYXVsdCBpcyBwcm92aWRlZCwgdGhlIHN0eWxlIHByb3BlcnR5J3MgZGVmYXVsdCBpcyB1c2VkIGluIHRoZXNlIGNpcmN1bXN0YW5jZXMuXCJcbiAgICB9XG4gIH0sXG4gIGZ1bmN0aW9uX3N0b3A6IGZ1bmN0aW9uX3N0b3AsXG4gIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gIGV4cHJlc3Npb25fbmFtZTogZXhwcmVzc2lvbl9uYW1lLFxuICBmb2c6IGZvZyxcbiAgbGlnaHQ6IGxpZ2h0LFxuICB0ZXJyYWluOiB0ZXJyYWluLFxuICBwYWludDogcGFpbnQsXG4gIHBhaW50X2ZpbGw6IHBhaW50X2ZpbGwsXG4gIFwicGFpbnRfZmlsbC1leHRydXNpb25cIjoge1xuICAgIFwiZmlsbC1leHRydXNpb24tb3BhY2l0eVwiOiB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMSxcbiAgICAgIGRvYzogXCJUaGUgb3BhY2l0eSBvZiB0aGUgZW50aXJlIGZpbGwgZXh0cnVzaW9uIGxheWVyLiBUaGlzIGlzIHJlbmRlcmVkIG9uIGEgcGVyLWxheWVyLCBub3QgcGVyLWZlYXR1cmUsIGJhc2lzLCBhbmQgZGF0YS1kcml2ZW4gc3R5bGluZyBpcyBub3QgYXZhaWxhYmxlLlwiLFxuICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuMjcuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNS4xLjBcIixcbiAgICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgIH0sXG4gICAgXCJmaWxsLWV4dHJ1c2lvbi1jb2xvclwiOiB7XG4gICAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgICBkb2M6IFwiVGhlIGJhc2UgY29sb3Igb2YgdGhlIGV4dHJ1ZGVkIGZpbGwuIFRoZSBleHRydXNpb24ncyBzdXJmYWNlcyB3aWxsIGJlIHNoYWRlZCBkaWZmZXJlbnRseSBiYXNlZCBvbiB0aGlzIGNvbG9yIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIHJvb3QgYGxpZ2h0YCBzZXR0aW5ncy4gSWYgdGhpcyBjb2xvciBpcyBzcGVjaWZpZWQgYXMgYHJnYmFgIHdpdGggYW4gYWxwaGEgY29tcG9uZW50LCB0aGUgYWxwaGEgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZDsgdXNlIGBmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5YCB0byBzZXQgbGF5ZXIgb3BhY2l0eS5cIixcbiAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICByZXF1aXJlczogW3tcbiAgICAgICAgXCIhXCI6IFwiZmlsbC1leHRydXNpb24tcGF0dGVyblwiXG4gICAgICB9XSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuMjcuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNS4xLjBcIixcbiAgICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAganM6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiOiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgIGxlbmd0aDogMixcbiAgICAgIFwiZGVmYXVsdFwiOiBbMCwgMF0sXG4gICAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgICBkb2M6IFwiVGhlIGdlb21ldHJ5J3Mgb2Zmc2V0LiBWYWx1ZXMgYXJlIFt4LCB5XSB3aGVyZSBuZWdhdGl2ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAgKG9uIHRoZSBmbGF0IHBsYW5lKSwgcmVzcGVjdGl2ZWx5LlwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICB2YWx1ZXM6IHtcbiAgICAgICAgbWFwOiB7XG4gICAgICAgICAgZG9jOiBcIlRoZSBmaWxsIGV4dHJ1c2lvbiBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcbiAgICAgICAgfSxcbiAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICBkb2M6IFwiVGhlIGZpbGwgZXh0cnVzaW9uIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0LlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkb2M6IFwiQ29udHJvbHMgdGhlIGZyYW1lIG9mIHJlZmVyZW5jZSBmb3IgYGZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZWAuXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJtYXBcIixcbiAgICAgIHJlcXVpcmVzOiBbXCJmaWxsLWV4dHJ1c2lvbi10cmFuc2xhdGVcIl0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLXBhdHRlcm5cIjoge1xuICAgICAgdHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG4gICAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgICAgZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZXMgb24gZXh0cnVkZWQgZmlsbHMuIEZvciBzZWFtbGVzcyBwYXR0ZXJucywgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGEgZmFjdG9yIG9mIHR3byAoMiwgNCwgOCwgLi4uLCA1MTIpLiBOb3RlIHRoYXQgem9vbS1kZXBlbmRlbnQgZXhwcmVzc2lvbnMgd2lsbCBiZSBldmFsdWF0ZWQgb25seSBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLlwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ5LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuNS4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC4xMS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuNC4wXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiXG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLWhlaWdodFwiOiB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgdW5pdHM6IFwibWV0ZXJzXCIsXG4gICAgICBkb2M6IFwiVGhlIGhlaWdodCB3aXRoIHdoaWNoIHRvIGV4dHJ1ZGUgdGhpcyBsYXllci5cIixcbiAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIGpzOiBcIjAuMjcuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNS4xLjBcIixcbiAgICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgIH0sXG4gICAgXCJmaWxsLWV4dHJ1c2lvbi1iYXNlXCI6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICB1bml0czogXCJtZXRlcnNcIixcbiAgICAgIGRvYzogXCJUaGUgaGVpZ2h0IHdpdGggd2hpY2ggdG8gZXh0cnVkZSB0aGUgYmFzZSBvZiB0aGlzIGxheWVyLiBNdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgZmlsbC1leHRydXNpb24taGVpZ2h0YC5cIixcbiAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICByZXF1aXJlczogW1wiZmlsbC1leHRydXNpb24taGVpZ2h0XCJdLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tdmVydGljYWwtZ3JhZGllbnRcIjoge1xuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICAgIGRvYzogXCJXaGV0aGVyIHRvIGFwcGx5IGEgdmVydGljYWwgZ3JhZGllbnQgdG8gdGhlIHNpZGVzIG9mIGEgZmlsbC1leHRydXNpb24gbGF5ZXIuIElmIHRydWUsIHNpZGVzIHdpbGwgYmUgc2hhZGVkIHNsaWdodGx5IGRhcmtlciBmYXJ0aGVyIGRvd24uXCIsXG4gICAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNTAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjcuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuMTMuMFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICB9XG4gIH0sXG4gIHBhaW50X2xpbmU6IHBhaW50X2xpbmUsXG4gIHBhaW50X2NpcmNsZTogcGFpbnRfY2lyY2xlLFxuICBwYWludF9oZWF0bWFwOiBwYWludF9oZWF0bWFwLFxuICBwYWludF9zeW1ib2w6IHBhaW50X3N5bWJvbCxcbiAgcGFpbnRfcmFzdGVyOiBwYWludF9yYXN0ZXIsXG4gIHBhaW50X2hpbGxzaGFkZTogcGFpbnRfaGlsbHNoYWRlLFxuICBwYWludF9iYWNrZ3JvdW5kOiBwYWludF9iYWNrZ3JvdW5kLFxuICBwYWludF9za3k6IHBhaW50X3NreSxcbiAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgXCJwcm9wZXJ0eS10eXBlXCI6IHtcbiAgICBcImRhdGEtZHJpdmVuXCI6IHtcbiAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiLFxuICAgICAgZG9jOiBcIlByb3BlcnR5IGlzIGludGVycG9sYWJsZSBhbmQgY2FuIGJlIHJlcHJlc2VudGVkIHVzaW5nIGEgcHJvcGVydHkgZXhwcmVzc2lvbi5cIlxuICAgIH0sXG4gICAgXCJjcm9zcy1mYWRlZFwiOiB7XG4gICAgICB0eXBlOiBcInByb3BlcnR5LXR5cGVcIixcbiAgICAgIGRvYzogXCJQcm9wZXJ0eSBpcyBub24taW50ZXJwb2xhYmxlOyByYXRoZXIsIGl0cyB2YWx1ZXMgd2lsbCBiZSBjcm9zcy1mYWRlZCB0byBzbW9vdGhseSB0cmFuc2l0aW9uIGJldHdlZW4gaW50ZWdlciB6b29tcy5cIlxuICAgIH0sXG4gICAgXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiOiB7XG4gICAgICB0eXBlOiBcInByb3BlcnR5LXR5cGVcIixcbiAgICAgIGRvYzogXCJQcm9wZXJ0eSBpcyBub24taW50ZXJwb2xhYmxlOyByYXRoZXIsIGl0cyB2YWx1ZXMgd2lsbCBiZSBjcm9zcy1mYWRlZCB0byBzbW9vdGhseSB0cmFuc2l0aW9uIGJldHdlZW4gaW50ZWdlciB6b29tcy4gSXQgY2FuIGJlIHJlcHJlc2VudGVkIHVzaW5nIGEgcHJvcGVydHkgZXhwcmVzc2lvbi5cIlxuICAgIH0sXG4gICAgXCJjb2xvci1yYW1wXCI6IHtcbiAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiLFxuICAgICAgZG9jOiBcIlByb3BlcnR5IHNob3VsZCBiZSBzcGVjaWZpZWQgdXNpbmcgYSBjb2xvciByYW1wIGZyb20gd2hpY2ggdGhlIG91dHB1dCBjb2xvciBjYW4gYmUgc2FtcGxlZCBiYXNlZCBvbiBhIHByb3BlcnR5IGNhbGN1bGF0aW9uLlwiXG4gICAgfSxcbiAgICBcImRhdGEtY29uc3RhbnRcIjoge1xuICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG4gICAgICBkb2M6IFwiUHJvcGVydHkgaXMgaW50ZXJwb2xhYmxlIGJ1dCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgdXNpbmcgYSBwcm9wZXJ0eSBleHByZXNzaW9uLlwiXG4gICAgfSxcbiAgICBjb25zdGFudDoge1xuICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG4gICAgICBkb2M6IFwiUHJvcGVydHkgaXMgY29uc3RhbnQgYWNyb3NzIGFsbCB6b29tIGxldmVscyBhbmQgcHJvcGVydHkgdmFsdWVzLlwiXG4gICAgfVxuICB9LFxuICBwcm9tb3RlSWQ6IHByb21vdGVJZFxufTsgLy8gTm90ZTogVGhpcyByZWdleCBtYXRjaGVzIGV2ZW4gaW52YWxpZCBKU09OIHN0cmluZ3MsIGJ1dCBzaW5jZSB3ZeKAmXJlXG4vLyB3b3JraW5nIG9uIHRoZSBvdXRwdXQgb2YgYEpTT04uc3RyaW5naWZ5YCB3ZSBrbm93IHRoYXQgb25seSB2YWxpZCBzdHJpbmdzXG4vLyBhcmUgcHJlc2VudCAodW5sZXNzIHRoZSB1c2VyIHN1cHBsaWVkIGEgd2VpcmQgYG9wdGlvbnMuaW5kZW50YCBidXQgaW5cbi8vIHRoYXQgY2FzZSB3ZSBkb27igJl0IGNhcmUgc2luY2UgdGhlIG91dHB1dCB3b3VsZCBiZSBpbnZhbGlkIGFueXdheSkuXG5cbnZhciBzdHJpbmdPckNoYXIgPSAvKFwiKD86W15cXFxcXCJdfFxcXFwuKSpcIil8WzosXS9nO1xuXG52YXIganNvblN0cmluZ2lmeVByZXR0eUNvbXBhY3QgPSBmdW5jdGlvbiBzdHJpbmdpZnkocGFzc2VkT2JqLCBvcHRpb25zKSB7XG4gIHZhciBpbmRlbnQsIG1heExlbmd0aCwgcmVwbGFjZXI7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpbmRlbnQgPSBKU09OLnN0cmluZ2lmeShbMV0sIHVuZGVmaW5lZCwgb3B0aW9ucy5pbmRlbnQgPT09IHVuZGVmaW5lZCA/IDIgOiBvcHRpb25zLmluZGVudCkuc2xpY2UoMiwgLTMpO1xuICBtYXhMZW5ndGggPSBpbmRlbnQgPT09IFwiXCIgPyBJbmZpbml0eSA6IG9wdGlvbnMubWF4TGVuZ3RoID09PSB1bmRlZmluZWQgPyA4MCA6IG9wdGlvbnMubWF4TGVuZ3RoO1xuICByZXBsYWNlciA9IG9wdGlvbnMucmVwbGFjZXI7XG4gIHJldHVybiBmdW5jdGlvbiBfc3RyaW5naWZ5KG9iaiwgY3VycmVudEluZGVudCwgcmVzZXJ2ZWQpIHtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICB2YXIgZW5kLCBpbmRleCwgaXRlbXMsIGtleSwga2V5UGFydCwga2V5cywgbGVuZ3RoLCBuZXh0SW5kZW50LCBwcmV0dGlmaWVkLCBzdGFydCwgc3RyaW5nLCB2YWx1ZTtcblxuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgIH1cblxuICAgIHN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIpO1xuXG4gICAgaWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cblxuICAgIGxlbmd0aCA9IG1heExlbmd0aCAtIGN1cnJlbnRJbmRlbnQubGVuZ3RoIC0gcmVzZXJ2ZWQ7XG5cbiAgICBpZiAoc3RyaW5nLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgIHByZXR0aWZpZWQgPSBzdHJpbmcucmVwbGFjZShzdHJpbmdPckNoYXIsIGZ1bmN0aW9uIChtYXRjaCwgc3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nTGl0ZXJhbCB8fCBtYXRjaCArIFwiIFwiO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChwcmV0dGlmaWVkLmxlbmd0aCA8PSBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHByZXR0aWZpZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2VyICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IEpTT04ucGFyc2Uoc3RyaW5nKTtcbiAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgbmV4dEluZGVudCA9IGN1cnJlbnRJbmRlbnQgKyBpbmRlbnQ7XG4gICAgICBpdGVtcyA9IFtdO1xuICAgICAgaW5kZXggPSAwO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHN0YXJ0ID0gXCJbXCI7XG4gICAgICAgIGVuZCA9IFwiXVwiO1xuICAgICAgICBsZW5ndGggPSBvYmoubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGl0ZW1zLnB1c2goX3N0cmluZ2lmeShvYmpbaW5kZXhdLCBuZXh0SW5kZW50LCBpbmRleCA9PT0gbGVuZ3RoIC0gMSA/IDAgOiAxKSB8fCBcIm51bGxcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gXCJ7XCI7XG4gICAgICAgIGVuZCA9IFwifVwiO1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgICAga2V5UGFydCA9IEpTT04uc3RyaW5naWZ5KGtleSkgKyBcIjogXCI7XG4gICAgICAgICAgdmFsdWUgPSBfc3RyaW5naWZ5KG9ialtrZXldLCBuZXh0SW5kZW50LCBrZXlQYXJ0Lmxlbmd0aCArIChpbmRleCA9PT0gbGVuZ3RoIC0gMSA/IDAgOiAxKSk7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXRlbXMucHVzaChrZXlQYXJ0ICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gW3N0YXJ0LCBpbmRlbnQgKyBpdGVtcy5qb2luKFwiLFxcblwiICsgbmV4dEluZGVudCksIGVuZF0uam9pbihcIlxcblwiICsgY3VycmVudEluZGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfShwYXNzZWRPYmosIFwiXCIsIDApO1xufTtcblxuZnVuY3Rpb24gc29ydEtleXNCeShvYmosIHJlZmVyZW5jZSkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgZm9yICh2YXIga2V5IGluIHJlZmVyZW5jZSkge1xuICAgIGlmIChvYmpba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9rZXkgaW4gb2JqKSB7XG4gICAgaWYgKHJlc3VsdFtfa2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHRbX2tleV0gPSBvYmpbX2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0KHN0eWxlKSB7XG4gIHZhciBzcGFjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMjtcbiAgc3R5bGUgPSBzb3J0S2V5c0J5KHN0eWxlLCB2OC4kcm9vdCk7XG5cbiAgaWYgKHN0eWxlLmxheWVycykge1xuICAgIHN0eWxlLmxheWVycyA9IHN0eWxlLmxheWVycy5tYXAoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICByZXR1cm4gc29ydEtleXNCeShsYXllciwgdjgubGF5ZXIpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGpzb25TdHJpbmdpZnlQcmV0dHlDb21wYWN0KHN0eWxlLCB7XG4gICAgaW5kZW50OiBzcGFjZVxuICB9KTtcbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuKSB7XG4gIHZhciBtb2R1bGUgPSB7XG4gICAgZXhwb3J0czoge31cbiAgfTtcbiAgcmV0dXJuIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxuZnVuY3Rpb24gY29tbW9uanNSZXF1aXJlKHRhcmdldCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkeW5hbWljYWxseSByZXF1aXJlIFwiJyArIHRhcmdldCArICdcIi4gUGxlYXNlIGNvbmZpZ3VyZSB0aGUgZHluYW1pY1JlcXVpcmVUYXJnZXRzIG9wdGlvbiBvZiBAcm9sbHVwL3BsdWdpbi1jb21tb25qcyBhcHByb3ByaWF0ZWx5IGZvciB0aGlzIHJlcXVpcmUgY2FsbCB0byBiZWhhdmUgcHJvcGVybHkuJyk7XG59XG4vKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuXG5cbnZhciBwdW55Y29kZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgKGZ1bmN0aW9uIChyb290KSB7XG4gICAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuICAgIHZhciBmcmVlRXhwb3J0cyA9IGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcbiAgICB2YXIgZnJlZU1vZHVsZSA9IG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcbiAgICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBjb21tb25qc0dsb2JhbCA9PSAnb2JqZWN0JyAmJiBjb21tb25qc0dsb2JhbDtcblxuICAgIGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWwpIHtcbiAgICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG4gICAgICogQG5hbWUgcHVueWNvZGVcbiAgICAgKiBAdHlwZSBPYmplY3RcbiAgICAgKi9cblxuXG4gICAgdmFyIHB1bnljb2RlLFxuXG4gICAgLyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuICAgIG1heEludCA9IDIxNDc0ODM2NDcsXG4gICAgICAgIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuICAgIC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cbiAgICBiYXNlID0gMzYsXG4gICAgICAgIHRNaW4gPSAxLFxuICAgICAgICB0TWF4ID0gMjYsXG4gICAgICAgIHNrZXcgPSAzOCxcbiAgICAgICAgZGFtcCA9IDcwMCxcbiAgICAgICAgaW5pdGlhbEJpYXMgPSA3MixcbiAgICAgICAgaW5pdGlhbE4gPSAxMjgsXG4gICAgICAgIC8vIDB4ODBcbiAgICBkZWxpbWl0ZXIgPSAnLScsXG4gICAgICAgIC8vICdcXHgyRCdcblxuICAgIC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG4gICAgcmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG4gICAgICAgIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLFxuICAgICAgICAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuICAgIHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csXG4gICAgICAgIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuICAgIC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuICAgIGVycm9ycyA9IHtcbiAgICAgICdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG4gICAgICAnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuICAgICAgJ2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcbiAgICB9LFxuXG4gICAgLyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuICAgIGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcbiAgICAgICAgZmxvb3IgPSBNYXRoLmZsb29yLFxuICAgICAgICBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG4gICAgLyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuICAgIGtleTtcbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG4gICAgICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuICAgICAgdGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG4gICAgICogaXRlbS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcbiAgICAgKiBhZGRyZXNzZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuICAgICAqIGNoYXJhY3Rlci5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuICAgICAqIGZ1bmN0aW9uLlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuICAgICAgdmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG4gICAgICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcbiAgICAgICAgLy8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cbiAgICAgICAgcmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG4gICAgICAgIHN0cmluZyA9IHBhcnRzWzFdO1xuICAgICAgfSAvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cblxuICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcbiAgICAgIHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4gICAgICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICAgICAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG4gICAgICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4gICAgICogbWF0Y2hpbmcgVVRGLTE2LlxuICAgICAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuICAgICAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gICAgICogQG5hbWUgZGVjb2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG4gICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgY291bnRlciA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBleHRyYTtcblxuICAgICAgd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXG4gICAgICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cbiAgICAgICAgICBpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHtcbiAgICAgICAgICAgIC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAgICAgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcbiAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuICAgICAqIEBuYW1lIGVuY29kZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG4gICAgICByZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuXG4gICAgICAgIGlmICh2YWx1ZSA+IDB4RkZGRikge1xuICAgICAgICAgIHZhbHVlIC09IDB4MTAwMDA7XG4gICAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICAgICAgdmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9KS5qb2luKCcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuICAgICAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuICAgICAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcbiAgICAgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuICAgICAgaWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuICAgICAgICByZXR1cm4gY29kZVBvaW50IC0gNjU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA5NztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cbiAgICAgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3JcbiAgICAgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuICAgICAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuICAgICAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG4gICAgICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG4gICAgICAvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuICAgICAgLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG4gICAgICByZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuICAgICAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiAgICAgIHZhciBrID0gMDtcbiAgICAgIGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG4gICAgICBkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cbiAgICAgIGZvciAoO1xuICAgICAgLyogbm8gaW5pdGlhbGl6YXRpb24gKi9cbiAgICAgIGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG4gICAgICAgIGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG4gICAgICogc3ltYm9scy5cbiAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgICAgIC8vIERvbid0IHVzZSBVQ1MtMlxuICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuICAgICAgICAgIG91dCxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBuID0gaW5pdGlhbE4sXG4gICAgICAgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuICAgICAgICAgIGJhc2ljLFxuICAgICAgICAgIGosXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgb2xkaSxcbiAgICAgICAgICB3LFxuICAgICAgICAgIGssXG4gICAgICAgICAgZGlnaXQsXG4gICAgICAgICAgdCxcblxuICAgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG4gICAgICBiYXNlTWludXNUOyAvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcbiAgICAgIC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG4gICAgICAvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuICAgICAgYmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXG4gICAgICBpZiAoYmFzaWMgPCAwKSB7XG4gICAgICAgIGJhc2ljID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcbiAgICAgICAgLy8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcbiAgICAgICAgICBlcnJvcignbm90LWJhc2ljJyk7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcbiAgICAgIH0gLy8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuICAgICAgLy8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXG4gICAgICBmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDspXG4gICAgICAvKiBubyBmaW5hbCBleHByZXNzaW9uICovXG4gICAgICB7XG4gICAgICAgIC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cbiAgICAgICAgLy8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuICAgICAgICAvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuICAgICAgICAvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuICAgICAgICAvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuICAgICAgICBmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7O1xuICAgICAgICAvKiBubyBjb25kaXRpb24gKi9cbiAgICAgICAgayArPSBiYXNlKSB7XG4gICAgICAgICAgaWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgICAgICBlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG4gICAgICAgICAgaWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuICAgICAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSBkaWdpdCAqIHc7XG4gICAgICAgICAgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXG4gICAgICAgICAgaWYgKGRpZ2l0IDwgdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXG4gICAgICAgICAgaWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuICAgICAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdyAqPSBiYXNlTWludXNUO1xuICAgICAgICB9XG5cbiAgICAgICAgb3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG4gICAgICAgIGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApOyAvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuICAgICAgICAvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXG4gICAgICAgIGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcbiAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG4gKz0gZmxvb3IoaSAvIG91dCk7XG4gICAgICAgIGkgJT0gb3V0OyAvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cbiAgICAgICAgb3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICAgICAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG4gICAgICogQG1lbWJlck9mIHB1bnljb2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgICB2YXIgbixcbiAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICBoYW5kbGVkQ1BDb3VudCxcbiAgICAgICAgICBiYXNpY0xlbmd0aCxcbiAgICAgICAgICBiaWFzLFxuICAgICAgICAgIGosXG4gICAgICAgICAgbSxcbiAgICAgICAgICBxLFxuICAgICAgICAgIGssXG4gICAgICAgICAgdCxcbiAgICAgICAgICBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgb3V0cHV0ID0gW10sXG5cbiAgICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG4gICAgICBpbnB1dExlbmd0aCxcblxuICAgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG4gICAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG4gICAgICAgICAgYmFzZU1pbnVzVCxcbiAgICAgICAgICBxTWludXNUOyAvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cbiAgICAgIGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7IC8vIENhY2hlIHRoZSBsZW5ndGhcblxuICAgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7IC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cbiAgICAgIG4gPSBpbml0aWFsTjtcbiAgICAgIGRlbHRhID0gMDtcbiAgICAgIGJpYXMgPSBpbml0aWFsQmlhczsgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuICAgICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDsgLy8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG4gICAgICAvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG4gICAgICAvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblxuICAgICAgaWYgKGJhc2ljTGVuZ3RoKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG4gICAgICB9IC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblxuXG4gICAgICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICAgICAgICAvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG4gICAgICAgIC8vIGxhcmdlciBvbmU6XG4gICAgICAgIGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cbiAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuICAgICAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuICAgICAgICAvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXG5cbiAgICAgICAgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXG4gICAgICAgIGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG4gICAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuICAgICAgICBuID0gbTtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuICAgICAgICAgICAgZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG4gICAgICAgICAgICAvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuICAgICAgICAgICAgZm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOztcbiAgICAgICAgICAgIC8qIG5vIGNvbmRpdGlvbiAqL1xuICAgICAgICAgICAgayArPSBiYXNlKSB7XG4gICAgICAgICAgICAgIHQgPSBrIDw9IGJpYXMgPyB0TWluIDogayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcztcblxuICAgICAgICAgICAgICBpZiAocSA8IHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHFNaW51c1QgPSBxIC0gdDtcbiAgICAgICAgICAgICAgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpKTtcbiAgICAgICAgICAgICAgcSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuICAgICAgICAgICAgYmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcbiAgICAgICAgICAgIGRlbHRhID0gMDtcbiAgICAgICAgICAgICsraGFuZGxlZENQQ291bnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgKytkZWx0YTtcbiAgICAgICAgKytuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG4gICAgICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuICAgICAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuICAgICAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cbiAgICAgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG4gICAgICogc3RyaW5nLlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcbiAgICAgIHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpID8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKSA6IHN0cmluZztcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cbiAgICAgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcbiAgICAgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cbiAgICAgKiBBU0NJSS5cbiAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuICAgICAqIFVuaWNvZGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3JcbiAgICAgKiBlbWFpbCBhZGRyZXNzLlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG4gICAgICByZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKSA/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpIDogc3RyaW5nO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXG5cbiAgICBwdW55Y29kZSA9IHtcbiAgICAgIC8qKlxuICAgICAgICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuICAgICAgICogQG1lbWJlck9mIHB1bnljb2RlXG4gICAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgICAqL1xuICAgICAgJ3ZlcnNpb24nOiAnMS4zLjInLFxuXG4gICAgICAvKipcbiAgICAgICAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG4gICAgICAgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuICAgICAgICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gICAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICAndWNzMic6IHtcbiAgICAgICAgJ2RlY29kZSc6IHVjczJkZWNvZGUsXG4gICAgICAgICdlbmNvZGUnOiB1Y3MyZW5jb2RlXG4gICAgICB9LFxuICAgICAgJ2RlY29kZSc6IGRlY29kZSxcbiAgICAgICdlbmNvZGUnOiBlbmNvZGUsXG4gICAgICAndG9BU0NJSSc6IHRvQVNDSUksXG4gICAgICAndG9Vbmljb2RlJzogdG9Vbmljb2RlXG4gICAgfTtcbiAgICAvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cbiAgICAvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcbiAgICAvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cbiAgICBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuICAgICAgaWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG4gICAgICAgIC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG4gICAgICAgIGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cbiAgICAgICAgZm9yIChrZXkgaW4gcHVueWNvZGUpIHtcbiAgICAgICAgICBwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuICAgICAgcm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuICAgIH1cbiAgfSkoY29tbW9uanNHbG9iYWwpO1xufSk7XG52YXIgdXRpbCA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07IC8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gZGVjb2RlKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7IC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuXG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsXG4gICAgICAgIHZzdHIsXG4gICAgICAgIGssXG4gICAgICAgIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTsgLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG5cblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uIHN0cmluZ2lmeVByaW1pdGl2ZSh2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcblxuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBxdWVyeXN0cmluZyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gZGVjb2RlO1xuICBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gZW5jb2RlO1xufSk7XG52YXIgcGFyc2UgPSB1cmxQYXJzZTtcbnZhciByZXNvbHZlID0gdXJsUmVzb2x2ZTtcbnZhciByZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbnZhciBmb3JtYXQkMSA9IHVybEZvcm1hdDtcbnZhciBVcmxfMSA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufSAvLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cblxuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4vLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbnVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG5hdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4vLyB0aGVtLlxubm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG51bnNhZmVQcm90b2NvbCA9IHtcbiAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAnamF2YXNjcmlwdDonOiB0cnVlXG59LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbmhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxufSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbnNsYXNoZWRQcm90b2NvbCA9IHtcbiAgJ2h0dHAnOiB0cnVlLFxuICAnaHR0cHMnOiB0cnVlLFxuICAnZnRwJzogdHJ1ZSxcbiAgJ2dvcGhlcic6IHRydWUsXG4gICdmaWxlJzogdHJ1ZSxcbiAgJ2h0dHA6JzogdHJ1ZSxcbiAgJ2h0dHBzOic6IHRydWUsXG4gICdmdHA6JzogdHJ1ZSxcbiAgJ2dvcGhlcjonOiB0cnVlLFxuICAnZmlsZTonOiB0cnVlXG59O1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcbiAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9IC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcblxuXG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID0gcXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcbiAgdmFyIHJlc3QgPSB1cmw7IC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcblxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcblxuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuXG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG5cbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcblxuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfSAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG5cblxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuXG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJiAoc2xhc2hlcyB8fCBwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpIHtcbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSBob3N0RW5kID0gaGVjO1xuICAgIH0gLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG5cblxuICAgIHZhciBhdXRoLCBhdFNpZ247XG5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfSAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuXG5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH0gLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuXG5cbiAgICBob3N0RW5kID0gLTE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSBob3N0RW5kID0gaGVjO1xuICAgIH0gLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuXG5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpOyAvLyBwdWxsIG91dCBwb3J0LlxuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTsgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7IC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nOyAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcblxuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuXG5cbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuXG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0OyAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcblxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuXG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuXG5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG5cbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9IC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG5cblxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuXG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuXG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuXG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcblxuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuXG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG5cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuXG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiYgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH0gLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuXG5cbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfSAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cblxuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuXG5cbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG5cbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID8gdGhpcy5ob3N0bmFtZSA6ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuXG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiYgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJiBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCBxdWVyeSAmJiAnPycgKyBxdWVyeSB8fCAnJztcbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonOyAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cblxuICBpZiAodGhpcy5zbGFzaGVzIHx8ICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uIChyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG5cbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH0gLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuXG5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoOyAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cblxuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG5cbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKSByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9IC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG5cblxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJiByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG5cbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG5cbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcblxuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpIHtcbiAgICAgICAgO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cblxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDsgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcblxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cblxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyxcbiAgICAgIGlzUmVsQWJzID0gcmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyxcbiAgICAgIG11c3RFbmRBYnMgPSBpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fCByZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTsgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcblxuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7ZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cblxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG5cbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuXG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O2Vsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuXG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycgPyByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnID8gcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDsgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7IC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcblxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID8gcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuXG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTsgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuXG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICsgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDsgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuXG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuXG5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJyc7IC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcblxuICB2YXIgdXAgPSAwO1xuXG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcblxuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH0gLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuXG5cbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiYgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJzsgLy8gcHV0IHRoZSBob3N0IGJhY2tcblxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOiBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnOyAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcblxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/IHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcblxuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfSAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG5cblxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICsgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG5cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG5cbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcblxuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cbnZhciB1cmwgPSB7XG4gIHBhcnNlOiBwYXJzZSxcbiAgcmVzb2x2ZTogcmVzb2x2ZSxcbiAgcmVzb2x2ZU9iamVjdDogcmVzb2x2ZU9iamVjdCxcbiAgZm9ybWF0OiBmb3JtYXQkMSxcbiAgVXJsOiBVcmxfMVxufTtcblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlSZWZlcmVuY2UocHJvcGVydHlOYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdjgubGF5b3V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHY4W3Y4LmxheW91dFtpXV0pIHtcbiAgICAgIGlmIChrZXkgPT09IHByb3BlcnR5TmFtZSkgcmV0dXJuIHY4W3Y4LmxheW91dFtpXV1ba2V5XTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdjgucGFpbnQubGVuZ3RoOyBfaSsrKSB7XG4gICAgZm9yICh2YXIgX2tleTIgaW4gdjhbdjgucGFpbnRbX2ldXSkge1xuICAgICAgaWYgKF9rZXkyID09PSBwcm9wZXJ0eU5hbWUpIHJldHVybiB2OFt2OC5wYWludFtfaV1dW19rZXkyXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZWFjaFNvdXJjZShzdHlsZSwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgayBpbiBzdHlsZS5zb3VyY2VzKSB7XG4gICAgY2FsbGJhY2soc3R5bGUuc291cmNlc1trXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZWFjaExheWVyKHN0eWxlLCBjYWxsYmFjaykge1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3R5bGUubGF5ZXJzKSxcbiAgICAgIF9zdGVwO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfbGF5ZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgIGNhbGxiYWNrKF9sYXllcik7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZWFjaFByb3BlcnR5KHN0eWxlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBpbm5lcihsYXllciwgcHJvcGVydHlUeXBlKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBsYXllcltwcm9wZXJ0eVR5cGVdO1xuICAgIGlmICghcHJvcGVydGllcykgcmV0dXJuO1xuICAgIE9iamVjdC5rZXlzKHByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgY2FsbGJhY2soe1xuICAgICAgICBwYXRoOiBbbGF5ZXIuaWQsIHByb3BlcnR5VHlwZSwga2V5XSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiBwcm9wZXJ0aWVzW2tleV0sXG4gICAgICAgIHJlZmVyZW5jZTogZ2V0UHJvcGVydHlSZWZlcmVuY2Uoa2V5KSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoeCkge1xuICAgICAgICAgIHByb3BlcnRpZXNba2V5XSA9IHg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZWFjaExheWVyKHN0eWxlLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICBpZiAob3B0aW9ucy5wYWludCkge1xuICAgICAgaW5uZXIobGF5ZXIsICdwYWludCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxheW91dCkge1xuICAgICAgaW5uZXIobGF5ZXIsICdsYXlvdXQnKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlYWNoTGF5b3V0KGxheWVyLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBrIGluIGxheWVyKSB7XG4gICAgaWYgKGsuaW5kZXhPZignbGF5b3V0JykgPT09IDApIHtcbiAgICAgIGNhbGxiYWNrKGxheWVyW2tdLCBrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZWFjaFBhaW50KGxheWVyLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBrIGluIGxheWVyKSB7XG4gICAgaWYgKGsuaW5kZXhPZigncGFpbnQnKSA9PT0gMCkge1xuICAgICAgY2FsbGJhY2sobGF5ZXJba10sIGspO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnQCcpIHtcbiAgICByZXR1cm4gcmVzb2x2ZUNvbnN0YW50KHN0eWxlLCBzdHlsZS5jb25zdGFudHNbdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZS5zdG9wcyk7XG59XG5cbmZ1bmN0aW9uIHJlbmFtZVByb3BlcnR5KG9iaiwgZnJvbSwgdG8pIHtcbiAgb2JqW3RvXSA9IG9ialtmcm9tXTtcbiAgZGVsZXRlIG9ialtmcm9tXTtcbn1cblxuZnVuY3Rpb24gbWlncmF0ZVRvVjgoc3R5bGUpIHtcbiAgc3R5bGUudmVyc2lvbiA9IDg7XG4gIGVhY2hTb3VyY2Uoc3R5bGUsIGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLnR5cGUgPT09ICd2aWRlbycgJiYgc291cmNlLnVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZW5hbWVQcm9wZXJ0eShzb3VyY2UsICd1cmwnLCAndXJscycpO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2UudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgc291cmNlLmNvb3JkaW5hdGVzLmZvckVhY2goZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgIHJldHVybiBjb29yZC5yZXZlcnNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBlYWNoTGF5ZXIoc3R5bGUsIGZ1bmN0aW9uIChsYXllcikge1xuICAgIGVhY2hMYXlvdXQobGF5ZXIsIGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgICAgIGlmIChsYXlvdXRbJ3N5bWJvbC1taW4tZGlzdGFuY2UnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbmFtZVByb3BlcnR5KGxheW91dCwgJ3N5bWJvbC1taW4tZGlzdGFuY2UnLCAnc3ltYm9sLXNwYWNpbmcnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlYWNoUGFpbnQobGF5ZXIsIGZ1bmN0aW9uIChwYWludCkge1xuICAgICAgaWYgKHBhaW50WydiYWNrZ3JvdW5kLWltYWdlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW5hbWVQcm9wZXJ0eShwYWludCwgJ2JhY2tncm91bmQtaW1hZ2UnLCAnYmFja2dyb3VuZC1wYXR0ZXJuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWludFsnbGluZS1pbWFnZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVuYW1lUHJvcGVydHkocGFpbnQsICdsaW5lLWltYWdlJywgJ2xpbmUtcGF0dGVybicpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFpbnRbJ2ZpbGwtaW1hZ2UnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbmFtZVByb3BlcnR5KHBhaW50LCAnZmlsbC1pbWFnZScsICdmaWxsLXBhdHRlcm4nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIGVhY2hQcm9wZXJ0eShzdHlsZSwge1xuICAgIHBhaW50OiB0cnVlLFxuICAgIGxheW91dDogdHJ1ZVxuICB9LCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICB2YXIgdmFsdWUgPSByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHByb3BlcnR5LnZhbHVlKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUuc3RvcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICBzdG9wWzFdID0gcmVzb2x2ZUNvbnN0YW50KHN0eWxlLCBzdG9wWzFdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHByb3BlcnR5LnNldCh2YWx1ZSk7XG4gIH0pO1xuICBkZWxldGUgc3R5bGUuY29uc3RhbnRzO1xuICBlYWNoTGF5ZXIoc3R5bGUsIGZ1bmN0aW9uIChsYXllcikge1xuICAgIGVhY2hMYXlvdXQobGF5ZXIsIGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgICAgIGRlbGV0ZSBsYXlvdXRbJ3RleHQtbWF4LXNpemUnXTtcbiAgICAgIGRlbGV0ZSBsYXlvdXRbJ2ljb24tbWF4LXNpemUnXTtcbiAgICB9KTtcbiAgICBlYWNoUGFpbnQobGF5ZXIsIGZ1bmN0aW9uIChwYWludCkge1xuICAgICAgaWYgKHBhaW50Wyd0ZXh0LXNpemUnXSkge1xuICAgICAgICBpZiAoIWxheWVyLmxheW91dCkgbGF5ZXIubGF5b3V0ID0ge307XG4gICAgICAgIGxheWVyLmxheW91dFsndGV4dC1zaXplJ10gPSBwYWludFsndGV4dC1zaXplJ107XG4gICAgICAgIGRlbGV0ZSBwYWludFsndGV4dC1zaXplJ107XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWludFsnaWNvbi1zaXplJ10pIHtcbiAgICAgICAgaWYgKCFsYXllci5sYXlvdXQpIGxheWVyLmxheW91dCA9IHt9O1xuICAgICAgICBsYXllci5sYXlvdXRbJ2ljb24tc2l6ZSddID0gcGFpbnRbJ2ljb24tc2l6ZSddO1xuICAgICAgICBkZWxldGUgcGFpbnRbJ2ljb24tc2l6ZSddO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBmdW5jdGlvbiBtaWdyYXRlRm9udHN0YWNrVVJMKGlucHV0KSB7XG4gICAgdmFyIGlucHV0UGFyc2VkID0gdXJsLnBhcnNlKGlucHV0KTtcbiAgICB2YXIgaW5wdXRQYXRobmFtZVBhcnRzID0gaW5wdXRQYXJzZWQucGF0aG5hbWUuc3BsaXQoJy8nKTtcblxuICAgIGlmIChpbnB1dFBhcnNlZC5wcm90b2NvbCAhPT0gJ21hcGJveDonKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfSBlbHNlIGlmIChpbnB1dFBhcnNlZC5ob3N0bmFtZSA9PT0gJ2ZvbnRzdGFjaycpIHtcbiAgICAgIHJldHVybiAnbWFwYm94Oi8vZm9udHMvbWFwYm94L3tmb250c3RhY2t9L3tyYW5nZX0ucGJmJztcbiAgICB9IGVsc2UgaWYgKGlucHV0UGFyc2VkLmhvc3RuYW1lID09PSAnZm9udHMnKSB7XG4gICAgICByZXR1cm4gXCJtYXBib3g6Ly9mb250cy9cIi5jb25jYXQoaW5wdXRQYXRobmFtZVBhcnRzWzJdLCBcIi97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZlwiKTtcbiAgICB9IGVsc2UgO1xuICB9XG5cbiAgaWYgKHN0eWxlLmdseXBocykge1xuICAgIHN0eWxlLmdseXBocyA9IG1pZ3JhdGVGb250c3RhY2tVUkwoc3R5bGUuZ2x5cGhzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1pZ3JhdGVGb250U3RhY2soZm9udCkge1xuICAgIGZ1bmN0aW9uIHNwbGl0QW5kVHJpbShzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHMudHJpbSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm9udCkpIHtcbiAgICAgIHJldHVybiBmb250O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gc3BsaXRBbmRUcmltKGZvbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGZvbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICBmb250LnN0b3BzLmZvckVhY2goZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgc3RvcFsxXSA9IHNwbGl0QW5kVHJpbShzdG9wWzFdKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBmb250IHZhbHVlJyk7XG4gICAgfVxuICB9XG5cbiAgZWFjaExheWVyKHN0eWxlLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICBlYWNoTGF5b3V0KGxheWVyLCBmdW5jdGlvbiAobGF5b3V0KSB7XG4gICAgICBpZiAobGF5b3V0Wyd0ZXh0LWZvbnQnXSkge1xuICAgICAgICBsYXlvdXRbJ3RleHQtZm9udCddID0gbWlncmF0ZUZvbnRTdGFjayhsYXlvdXRbJ3RleHQtZm9udCddKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHZhciBmaXJzdFN5bWJvbExheWVyID0gMDtcblxuICBmb3IgKHZhciBpID0gc3R5bGUubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIF9sYXllcjIgPSBzdHlsZS5sYXllcnNbaV07XG5cbiAgICBpZiAoX2xheWVyMi50eXBlICE9PSAnc3ltYm9sJykge1xuICAgICAgZmlyc3RTeW1ib2xMYXllciA9IGkgKyAxO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN5bWJvbExheWVycyA9IHN0eWxlLmxheWVycy5zcGxpY2UoZmlyc3RTeW1ib2xMYXllcik7XG4gIHN5bWJvbExheWVycy5yZXZlcnNlKCk7XG4gIHN0eWxlLmxheWVycyA9IHN0eWxlLmxheWVycy5jb25jYXQoc3ltYm9sTGF5ZXJzKTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBleHRlbmQob3V0cHV0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBpbnB1dHMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5MyA9IDE7IF9rZXkzIDwgX2xlbjsgX2tleTMrKykge1xuICAgIGlucHV0c1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuXG4gIGZvciAodmFyIF9pMiA9IDAsIF9pbnB1dHMgPSBpbnB1dHM7IF9pMiA8IF9pbnB1dHMubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBpbnB1dCA9IF9pbnB1dHNbX2kyXTtcblxuICAgIGZvciAodmFyIGsgaW4gaW5wdXQpIHtcbiAgICAgIG91dHB1dFtrXSA9IGlucHV0W2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbnZhciBQYXJzaW5nRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoUGFyc2luZ0Vycm9yLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUGFyc2luZ0Vycm9yKTtcblxuICBmdW5jdGlvbiBQYXJzaW5nRXJyb3Ioa2V5LCBtZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnNpbmdFcnJvcik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIF90aGlzLmtleSA9IGtleTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gUGFyc2luZ0Vycm9yO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcblxudmFyIFNjb3BlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2NvcGUocGFyZW50KSB7XG4gICAgdmFyIGJpbmRpbmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY29wZSk7XG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmJpbmRpbmdzID0ge307XG5cbiAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGJpbmRpbmdzKSxcbiAgICAgICAgX3N0ZXAyO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDIkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDIudmFsdWUsIDIpLFxuICAgICAgICAgICAgbmFtZSA9IF9zdGVwMiR2YWx1ZVswXSxcbiAgICAgICAgICAgIF9leHByZXNzaW9uID0gX3N0ZXAyJHZhbHVlWzFdO1xuXG4gICAgICAgIHRoaXMuYmluZGluZ3NbbmFtZV0gPSBfZXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2NvcGUsIFt7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQoYmluZGluZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgU2NvcGUodGhpcywgYmluZGluZ3MpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLmJpbmRpbmdzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldChuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KG5hbWUsIFwiIG5vdCBmb3VuZCBpbiBzY29wZS5cIikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmICh0aGlzLmJpbmRpbmdzW25hbWVdKSByZXR1cm4gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmhhcyhuYW1lKSA6IGZhbHNlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY29wZTtcbn0oKTtcblxudmFyIE51bGxUeXBlID0ge1xuICBraW5kOiAnbnVsbCdcbn07XG52YXIgTnVtYmVyVHlwZSA9IHtcbiAga2luZDogJ251bWJlcidcbn07XG52YXIgU3RyaW5nVHlwZSA9IHtcbiAga2luZDogJ3N0cmluZydcbn07XG52YXIgQm9vbGVhblR5cGUgPSB7XG4gIGtpbmQ6ICdib29sZWFuJ1xufTtcbnZhciBDb2xvclR5cGUgPSB7XG4gIGtpbmQ6ICdjb2xvcidcbn07XG52YXIgT2JqZWN0VHlwZSA9IHtcbiAga2luZDogJ29iamVjdCdcbn07XG52YXIgVmFsdWVUeXBlID0ge1xuICBraW5kOiAndmFsdWUnXG59O1xudmFyIEVycm9yVHlwZSA9IHtcbiAga2luZDogJ2Vycm9yJ1xufTtcbnZhciBDb2xsYXRvclR5cGUgPSB7XG4gIGtpbmQ6ICdjb2xsYXRvcidcbn07XG52YXIgRm9ybWF0dGVkVHlwZSA9IHtcbiAga2luZDogJ2Zvcm1hdHRlZCdcbn07XG52YXIgUmVzb2x2ZWRJbWFnZVR5cGUgPSB7XG4gIGtpbmQ6ICdyZXNvbHZlZEltYWdlJ1xufTtcblxuZnVuY3Rpb24gYXJyYXkoaXRlbVR5cGUsIE4pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnYXJyYXknLFxuICAgIGl0ZW1UeXBlOiBpdGVtVHlwZSxcbiAgICBOOiBOXG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nKHR5cGUpIHtcbiAgaWYgKHR5cGUua2luZCA9PT0gJ2FycmF5Jykge1xuICAgIHZhciBpdGVtVHlwZSA9IHRvU3RyaW5nKHR5cGUuaXRlbVR5cGUpO1xuICAgIHJldHVybiB0eXBlb2YgdHlwZS5OID09PSAnbnVtYmVyJyA/IFwiYXJyYXk8XCIuY29uY2F0KGl0ZW1UeXBlLCBcIiwgXCIpLmNvbmNhdCh0eXBlLk4sIFwiPlwiKSA6IHR5cGUuaXRlbVR5cGUua2luZCA9PT0gJ3ZhbHVlJyA/ICdhcnJheScgOiBcImFycmF5PFwiLmNvbmNhdChpdGVtVHlwZSwgXCI+XCIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0eXBlLmtpbmQ7XG4gIH1cbn1cblxudmFyIHZhbHVlTWVtYmVyVHlwZXMgPSBbTnVsbFR5cGUsIE51bWJlclR5cGUsIFN0cmluZ1R5cGUsIEJvb2xlYW5UeXBlLCBDb2xvclR5cGUsIEZvcm1hdHRlZFR5cGUsIE9iamVjdFR5cGUsIGFycmF5KFZhbHVlVHlwZSksIFJlc29sdmVkSW1hZ2VUeXBlXTtcblxuZnVuY3Rpb24gX2NoZWNrU3VidHlwZShleHBlY3RlZCwgdCkge1xuICBpZiAodC5raW5kID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQua2luZCA9PT0gJ2FycmF5Jykge1xuICAgIGlmICh0LmtpbmQgPT09ICdhcnJheScgJiYgKHQuTiA9PT0gMCAmJiB0Lml0ZW1UeXBlLmtpbmQgPT09ICd2YWx1ZScgfHwgIV9jaGVja1N1YnR5cGUoZXhwZWN0ZWQuaXRlbVR5cGUsIHQuaXRlbVR5cGUpKSAmJiAodHlwZW9mIGV4cGVjdGVkLk4gIT09ICdudW1iZXInIHx8IGV4cGVjdGVkLk4gPT09IHQuTikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZC5raW5kID09PSB0LmtpbmQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5raW5kID09PSAndmFsdWUnKSB7XG4gICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih2YWx1ZU1lbWJlclR5cGVzKSxcbiAgICAgICAgX3N0ZXAzO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBtZW1iZXJUeXBlID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgIGlmICghX2NoZWNrU3VidHlwZShtZW1iZXJUeXBlLCB0KSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIuY29uY2F0KHRvU3RyaW5nKGV4cGVjdGVkKSwgXCIgYnV0IGZvdW5kIFwiKS5jb25jYXQodG9TdHJpbmcodCksIFwiIGluc3RlYWQuXCIpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkVHlwZShwcm92aWRlZCwgYWxsb3dlZFR5cGVzKSB7XG4gIHJldHVybiBhbGxvd2VkVHlwZXMuc29tZShmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LmtpbmQgPT09IHByb3ZpZGVkLmtpbmQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkTmF0aXZlVHlwZShwcm92aWRlZCwgYWxsb3dlZFR5cGVzKSB7XG4gIHJldHVybiBhbGxvd2VkVHlwZXMuc29tZShmdW5jdGlvbiAodCkge1xuICAgIGlmICh0ID09PSAnbnVsbCcpIHtcbiAgICAgIHJldHVybiBwcm92aWRlZCA9PT0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHQgPT09ICdhcnJheScpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHByb3ZpZGVkKTtcbiAgICB9IGVsc2UgaWYgKHQgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcHJvdmlkZWQgJiYgIUFycmF5LmlzQXJyYXkocHJvdmlkZWQpICYmIHR5cGVvZiBwcm92aWRlZCA9PT0gJ29iamVjdCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0ID09PSB0eXBlb2YgcHJvdmlkZWQ7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGNzc2NvbG9ycGFyc2VyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTIuXG4gIC8vXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9jc3MtY29sb3ItcGFyc2VyLWpzXG4gIC8vXG4gIC8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG9cbiAgLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbiAgLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4gIC8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gIC8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gIC8vXG4gIC8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gIC8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAvL1xuICAvLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gIC8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAvLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAvLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICAvLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4gIC8vIElOIFRIRSBTT0ZUV0FSRS5cbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1jb2xvci9cbiAgdmFyIGtDU1NDb2xvclRhYmxlID0ge1xuICAgIFwidHJhbnNwYXJlbnRcIjogWzAsIDAsIDAsIDBdLFxuICAgIFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1LCAxXSxcbiAgICBcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNSwgMV0sXG4gICAgXCJhcXVhXCI6IFswLCAyNTUsIDI1NSwgMV0sXG4gICAgXCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyLCAxXSxcbiAgICBcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1LCAxXSxcbiAgICBcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwLCAxXSxcbiAgICBcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5NiwgMV0sXG4gICAgXCJibGFja1wiOiBbMCwgMCwgMCwgMV0sXG4gICAgXCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNSwgMV0sXG4gICAgXCJibHVlXCI6IFswLCAwLCAyNTUsIDFdLFxuICAgIFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2LCAxXSxcbiAgICBcImJyb3duXCI6IFsxNjUsIDQyLCA0MiwgMV0sXG4gICAgXCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzUsIDFdLFxuICAgIFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjAsIDFdLFxuICAgIFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDAsIDFdLFxuICAgIFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzAsIDFdLFxuICAgIFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MCwgMV0sXG4gICAgXCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzNywgMV0sXG4gICAgXCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMCwgMV0sXG4gICAgXCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MCwgMV0sXG4gICAgXCJjeWFuXCI6IFswLCAyNTUsIDI1NSwgMV0sXG4gICAgXCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5LCAxXSxcbiAgICBcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOSwgMV0sXG4gICAgXCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTEsIDFdLFxuICAgIFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAgIFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDAsIDFdLFxuICAgIFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAgIFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3LCAxXSxcbiAgICBcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOSwgMV0sXG4gICAgXCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDcsIDFdLFxuICAgIFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDAsIDFdLFxuICAgIFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0LCAxXSxcbiAgICBcImRhcmtyZWRcIjogWzEzOSwgMCwgMCwgMV0sXG4gICAgXCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyLCAxXSxcbiAgICBcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0MywgMV0sXG4gICAgXCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOSwgMV0sXG4gICAgXCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5LCAxXSxcbiAgICBcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzksIDFdLFxuICAgIFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDksIDFdLFxuICAgIFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTEsIDFdLFxuICAgIFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0NywgMV0sXG4gICAgXCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTUsIDFdLFxuICAgIFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICAgXCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1LCAxXSxcbiAgICBcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NSwgMV0sXG4gICAgXCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0LCAxXSxcbiAgICBcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwLCAxXSxcbiAgICBcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNCwgMV0sXG4gICAgXCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICAgXCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjAsIDFdLFxuICAgIFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NSwgMV0sXG4gICAgXCJnb2xkXCI6IFsyNTUsIDIxNSwgMCwgMV0sXG4gICAgXCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMiwgMV0sXG4gICAgXCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgICBcImdyZWVuXCI6IFswLCAxMjgsIDAsIDFdLFxuICAgIFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0NywgMV0sXG4gICAgXCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4LCAxXSxcbiAgICBcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwLCAxXSxcbiAgICBcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODAsIDFdLFxuICAgIFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5MiwgMV0sXG4gICAgXCJpbmRpZ29cIjogWzc1LCAwLCAxMzAsIDFdLFxuICAgIFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDAsIDFdLFxuICAgIFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDAsIDFdLFxuICAgIFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTAsIDFdLFxuICAgIFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NSwgMV0sXG4gICAgXCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwLCAxXSxcbiAgICBcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNSwgMV0sXG4gICAgXCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzAsIDFdLFxuICAgIFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOCwgMV0sXG4gICAgXCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTUsIDFdLFxuICAgIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTAsIDFdLFxuICAgIFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExLCAxXSxcbiAgICBcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDQsIDFdLFxuICAgIFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExLCAxXSxcbiAgICBcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5MywgMV0sXG4gICAgXCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMiwgMV0sXG4gICAgXCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzAsIDFdLFxuICAgIFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwLCAxXSxcbiAgICBcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgICBcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgICBcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyLCAxXSxcbiAgICBcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0LCAxXSxcbiAgICBcImxpbWVcIjogWzAsIDI1NSwgMCwgMV0sXG4gICAgXCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwLCAxXSxcbiAgICBcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwLCAxXSxcbiAgICBcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1LCAxXSxcbiAgICBcIm1hcm9vblwiOiBbMTI4LCAwLCAwLCAxXSxcbiAgICBcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzAsIDFdLFxuICAgIFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1LCAxXSxcbiAgICBcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExLCAxXSxcbiAgICBcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOSwgMV0sXG4gICAgXCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzLCAxXSxcbiAgICBcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOCwgMV0sXG4gICAgXCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTQsIDFdLFxuICAgIFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDQsIDFdLFxuICAgIFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzMsIDFdLFxuICAgIFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMiwgMV0sXG4gICAgXCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTAsIDFdLFxuICAgIFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1LCAxXSxcbiAgICBcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxLCAxXSxcbiAgICBcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczLCAxXSxcbiAgICBcIm5hdnlcIjogWzAsIDAsIDEyOCwgMV0sXG4gICAgXCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwLCAxXSxcbiAgICBcIm9saXZlXCI6IFsxMjgsIDEyOCwgMCwgMV0sXG4gICAgXCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNSwgMV0sXG4gICAgXCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwLCAxXSxcbiAgICBcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMCwgMV0sXG4gICAgXCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTQsIDFdLFxuICAgIFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MCwgMV0sXG4gICAgXCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTIsIDFdLFxuICAgIFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOCwgMV0sXG4gICAgXCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3LCAxXSxcbiAgICBcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTMsIDFdLFxuICAgIFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1LCAxXSxcbiAgICBcInBlcnVcIjogWzIwNSwgMTMzLCA2MywgMV0sXG4gICAgXCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzLCAxXSxcbiAgICBcInBsdW1cIjogWzIyMSwgMTYwLCAyMjEsIDFdLFxuICAgIFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMCwgMV0sXG4gICAgXCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4LCAxXSxcbiAgICBcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1MywgMV0sXG4gICAgXCJyZWRcIjogWzI1NSwgMCwgMCwgMV0sXG4gICAgXCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDMsIDFdLFxuICAgIFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjUsIDFdLFxuICAgIFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5LCAxXSxcbiAgICBcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNCwgMV0sXG4gICAgXCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTYsIDFdLFxuICAgIFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3LCAxXSxcbiAgICBcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4LCAxXSxcbiAgICBcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDUsIDFdLFxuICAgIFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyLCAxXSxcbiAgICBcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzUsIDFdLFxuICAgIFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDUsIDFdLFxuICAgIFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgICBcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NCwgMV0sXG4gICAgXCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwLCAxXSxcbiAgICBcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyNywgMV0sXG4gICAgXCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MCwgMV0sXG4gICAgXCJ0YW5cIjogWzIxMCwgMTgwLCAxNDAsIDFdLFxuICAgIFwidGVhbFwiOiBbMCwgMTI4LCAxMjgsIDFdLFxuICAgIFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNiwgMV0sXG4gICAgXCJ0b21hdG9cIjogWzI1NSwgOTksIDcxLCAxXSxcbiAgICBcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4LCAxXSxcbiAgICBcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOCwgMV0sXG4gICAgXCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OSwgMV0sXG4gICAgXCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NSwgMV0sXG4gICAgXCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1LCAxXSxcbiAgICBcInllbGxvd1wiOiBbMjU1LCAyNTUsIDAsIDFdLFxuICAgIFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MCwgMV1cbiAgfTtcblxuICBmdW5jdGlvbiBjbGFtcF9jc3NfYnl0ZShpKSB7XG4gICAgLy8gQ2xhbXAgdG8gaW50ZWdlciAwIC4uIDI1NS5cbiAgICBpID0gTWF0aC5yb3VuZChpKTsgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG5cbiAgICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGFtcF9jc3NfZmxvYXQoZikge1xuICAgIC8vIENsYW1wIHRvIGZsb2F0IDAuMCAuLiAxLjAuXG4gICAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZV9jc3NfaW50KHN0cikge1xuICAgIC8vIGludCBvciBwZXJjZW50YWdlLlxuICAgIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUZsb2F0KHN0cikgLyAxMDAgKiAyNTUpO1xuICAgIHJldHVybiBjbGFtcF9jc3NfYnl0ZShwYXJzZUludChzdHIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlX2Nzc19mbG9hdChzdHIpIHtcbiAgICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICAgIGlmIChzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnJScpIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgICByZXR1cm4gY2xhbXBfY3NzX2Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG4gIH1cblxuICBmdW5jdGlvbiBjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGgpIHtcbiAgICBpZiAoaCA8IDApIGggKz0gMTtlbHNlIGlmIChoID4gMSkgaCAtPSAxO1xuICAgIGlmIChoICogNiA8IDEpIHJldHVybiBtMSArIChtMiAtIG0xKSAqIGggKiA2O1xuICAgIGlmIChoICogMiA8IDEpIHJldHVybiBtMjtcbiAgICBpZiAoaCAqIDMgPCAyKSByZXR1cm4gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDY7XG4gICAgcmV0dXJuIG0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDU1NDb2xvcihjc3Nfc3RyKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCB3aGl0ZXNwYWNlLCBub3QgY29tcGxpYW50LCBidXQgc2hvdWxkIGp1c3QgYmUgbW9yZSBhY2NlcHRpbmcuXG4gICAgdmFyIHN0ciA9IGNzc19zdHIucmVwbGFjZSgvIC9nLCAnJykudG9Mb3dlckNhc2UoKTsgLy8gQ29sb3Iga2V5d29yZHMgKGFuZCB0cmFuc3BhcmVudCkgbG9va3VwLlxuXG4gICAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkgcmV0dXJuIGtDU1NDb2xvclRhYmxlW3N0cl0uc2xpY2UoKTsgLy8gZHVwLlxuICAgIC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuXG4gICAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7IC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuXG4gICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmYpKSByZXR1cm4gbnVsbDsgLy8gQ292ZXJzIE5hTi5cblxuICAgICAgICByZXR1cm4gWyhpdiAmIDB4ZjAwKSA+PiA0IHwgKGl2ICYgMHhmMDApID4+IDgsIGl2ICYgMHhmMCB8IChpdiAmIDB4ZjApID4+IDQsIGl2ICYgMHhmIHwgKGl2ICYgMHhmKSA8PCA0LCAxXTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7IC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuXG4gICAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSByZXR1cm4gbnVsbDsgLy8gQ292ZXJzIE5hTi5cblxuICAgICAgICByZXR1cm4gWyhpdiAmIDB4ZmYwMDAwKSA+PiAxNiwgKGl2ICYgMHhmZjAwKSA+PiA4LCBpdiAmIDB4ZmYsIDFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgb3AgPSBzdHIuaW5kZXhPZignKCcpLFxuICAgICAgICBlcCA9IHN0ci5pbmRleE9mKCcpJyk7XG5cbiAgICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgdmFyIGZuYW1lID0gc3RyLnN1YnN0cigwLCBvcCk7XG4gICAgICB2YXIgcGFyYW1zID0gc3RyLnN1YnN0cihvcCArIDEsIGVwIC0gKG9wICsgMSkpLnNwbGl0KCcsJyk7XG4gICAgICB2YXIgYWxwaGEgPSAxOyAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuXG4gICAgICBzd2l0Y2ggKGZuYW1lKSB7XG4gICAgICAgIGNhc2UgJ3JnYmEnOlxuICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBhbHBoYSA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXMucG9wKCkpO1xuICAgICAgICAvLyBGYWxsIHRocm91Z2guXG5cbiAgICAgICAgY2FzZSAncmdiJzpcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcmV0dXJuIFtwYXJzZV9jc3NfaW50KHBhcmFtc1swXSksIHBhcnNlX2Nzc19pbnQocGFyYW1zWzFdKSwgcGFyc2VfY3NzX2ludChwYXJhbXNbMl0pLCBhbHBoYV07XG5cbiAgICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cblxuICAgICAgICBjYXNlICdoc2wnOlxuICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIgaCA9IChwYXJzZUZsb2F0KHBhcmFtc1swXSkgJSAzNjAgKyAzNjApICUgMzYwIC8gMzYwOyAvLyAwIC4uIDFcbiAgICAgICAgICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgICAgICAgICAvLyBwZXJjZW50YWdlcywgYnV0IHdlIGRvbid0IGJvdGhlciBhbmQgbGV0IGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG5cbiAgICAgICAgICB2YXIgcyA9IHBhcnNlX2Nzc19mbG9hdChwYXJhbXNbMV0pO1xuICAgICAgICAgIHZhciBsID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1syXSk7XG4gICAgICAgICAgdmFyIG0yID0gbCA8PSAwLjUgPyBsICogKHMgKyAxKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgICAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgICAgICAgICByZXR1cm4gW2NsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkgKiAyNTUpLCBjbGFtcF9jc3NfYnl0ZShjc3NfaHVlX3RvX3JnYihtMSwgbTIsIGggLSAxIC8gMykgKiAyNTUpLCBhbHBoYV07XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgZXhwb3J0cy5wYXJzZUNTU0NvbG9yID0gcGFyc2VDU1NDb2xvcjtcbiAgfSBjYXRjaCAoZSkge31cbn0pO1xuXG52YXIgQ29sb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2xvcihyLCBnLCBiKSB7XG4gICAgdmFyIGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDE7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sb3IpO1xuXG4gICAgdGhpcy5yID0gcjtcbiAgICB0aGlzLmcgPSBnO1xuICAgIHRoaXMuYiA9IGI7XG4gICAgdGhpcy5hID0gYTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2xvciwgW3tcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgX3RoaXMkdG9BcnJheSA9IHRoaXMudG9BcnJheSgpLFxuICAgICAgICAgIF90aGlzJHRvQXJyYXkyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkdG9BcnJheSwgNCksXG4gICAgICAgICAgciA9IF90aGlzJHRvQXJyYXkyWzBdLFxuICAgICAgICAgIGcgPSBfdGhpcyR0b0FycmF5MlsxXSxcbiAgICAgICAgICBiID0gX3RoaXMkdG9BcnJheTJbMl0sXG4gICAgICAgICAgYSA9IF90aGlzJHRvQXJyYXkyWzNdO1xuXG4gICAgICByZXR1cm4gXCJyZ2JhKFwiLmNvbmNhdChNYXRoLnJvdW5kKHIpLCBcIixcIikuY29uY2F0KE1hdGgucm91bmQoZyksIFwiLFwiKS5jb25jYXQoTWF0aC5yb3VuZChiKSwgXCIsXCIpLmNvbmNhdChhLCBcIilcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvQXJyYXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgIHZhciByID0gdGhpcy5yLFxuICAgICAgICAgIGcgPSB0aGlzLmcsXG4gICAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgICBhID0gdGhpcy5hO1xuICAgICAgcmV0dXJuIGEgPT09IDAgPyBbMCwgMCwgMCwgMF0gOiBbciAqIDI1NSAvIGEsIGcgKiAyNTUgLyBhLCBiICogMjU1IC8gYSwgYV07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmdiYSA9IGNzc2NvbG9ycGFyc2VyLnBhcnNlQ1NTQ29sb3IoaW5wdXQpO1xuXG4gICAgICBpZiAoIXJnYmEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb2xvcihyZ2JhWzBdIC8gMjU1ICogcmdiYVszXSwgcmdiYVsxXSAvIDI1NSAqIHJnYmFbM10sIHJnYmFbMl0gLyAyNTUgKiByZ2JhWzNdLCByZ2JhWzNdKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29sb3I7XG59KCk7XG5cbkNvbG9yLmJsYWNrID0gbmV3IENvbG9yKDAsIDAsIDAsIDEpO1xuQ29sb3Iud2hpdGUgPSBuZXcgQ29sb3IoMSwgMSwgMSwgMSk7XG5Db2xvci50cmFuc3BhcmVudCA9IG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcbkNvbG9yLnJlZCA9IG5ldyBDb2xvcigxLCAwLCAwLCAxKTtcbkNvbG9yLmJsdWUgPSBuZXcgQ29sb3IoMCwgMCwgMSwgMSk7XG5cbnZhciBDb2xsYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbGxhdG9yKGNhc2VTZW5zaXRpdmUsIGRpYWNyaXRpY1NlbnNpdGl2ZSwgbG9jYWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbGxhdG9yKTtcblxuICAgIGlmIChjYXNlU2Vuc2l0aXZlKSB0aGlzLnNlbnNpdGl2aXR5ID0gZGlhY3JpdGljU2Vuc2l0aXZlID8gJ3ZhcmlhbnQnIDogJ2Nhc2UnO2Vsc2UgdGhpcy5zZW5zaXRpdml0eSA9IGRpYWNyaXRpY1NlbnNpdGl2ZSA/ICdhY2NlbnQnIDogJ2Jhc2UnO1xuICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMuY29sbGF0b3IgPSBuZXcgSW50bC5Db2xsYXRvcih0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlIDogW10sIHtcbiAgICAgIHNlbnNpdGl2aXR5OiB0aGlzLnNlbnNpdGl2aXR5LFxuICAgICAgdXNhZ2U6ICdzZWFyY2gnXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29sbGF0b3IsIFt7XG4gICAga2V5OiBcImNvbXBhcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZShsaHMsIHJocykge1xuICAgICAgcmV0dXJuIHRoaXMuY29sbGF0b3IuY29tcGFyZShsaHMsIHJocyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVkTG9jYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVkTG9jYWxlKCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnRsLkNvbGxhdG9yKHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUgOiBbXSkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2xsYXRvcjtcbn0oKTtcblxudmFyIEZvcm1hdHRlZFNlY3Rpb24gPSBmdW5jdGlvbiBGb3JtYXR0ZWRTZWN0aW9uKHRleHQsIGltYWdlLCBzY2FsZSwgZm9udFN0YWNrLCB0ZXh0Q29sb3IpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1hdHRlZFNlY3Rpb24pO1xuXG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuaW1hZ2UgPSBpbWFnZTtcbiAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICB0aGlzLmZvbnRTdGFjayA9IGZvbnRTdGFjaztcbiAgdGhpcy50ZXh0Q29sb3IgPSB0ZXh0Q29sb3I7XG59O1xuXG52YXIgRm9ybWF0dGVkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9ybWF0dGVkKHNlY3Rpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1hdHRlZCk7XG5cbiAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRm9ybWF0dGVkLCBbe1xuICAgIGtleTogXCJpc0VtcHR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgICBpZiAodGhpcy5zZWN0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuICF0aGlzLnNlY3Rpb25zLnNvbWUoZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24udGV4dC5sZW5ndGggIT09IDAgfHwgc2VjdGlvbi5pbWFnZSAmJiBzZWN0aW9uLmltYWdlLm5hbWUubGVuZ3RoICE9PSAwO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgaWYgKHRoaXMuc2VjdGlvbnMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gdGhpcy5zZWN0aW9ucy5tYXAoZnVuY3Rpb24gKHNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHNlY3Rpb24udGV4dDtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2Zvcm1hdCddO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuc2VjdGlvbnMpLFxuICAgICAgICAgIF9zdGVwNDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgc2VjdGlvbiA9IF9zdGVwNC52YWx1ZTtcblxuICAgICAgICAgIGlmIChzZWN0aW9uLmltYWdlKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goWydpbWFnZScsIHNlY3Rpb24uaW1hZ2UubmFtZV0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VyaWFsaXplZC5wdXNoKHNlY3Rpb24udGV4dCk7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgICAgICAgIGlmIChzZWN0aW9uLmZvbnRTdGFjaykge1xuICAgICAgICAgICAgb3B0aW9uc1sndGV4dC1mb250J10gPSBbJ2xpdGVyYWwnLCBzZWN0aW9uLmZvbnRTdGFjay5zcGxpdCgnLCcpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdGlvbi5zY2FsZSkge1xuICAgICAgICAgICAgb3B0aW9uc1snZm9udC1zY2FsZSddID0gc2VjdGlvbi5zY2FsZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdGlvbi50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ3RleHQtY29sb3InXSA9IFsncmdiYSddLmNvbmNhdChzZWN0aW9uLnRleHRDb2xvci50b0FycmF5KCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImZyb21TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbVN0cmluZyh1bmZvcm1hdHRlZCkge1xuICAgICAgcmV0dXJuIG5ldyBGb3JtYXR0ZWQoW25ldyBGb3JtYXR0ZWRTZWN0aW9uKHVuZm9ybWF0dGVkLCBudWxsLCBudWxsLCBudWxsLCBudWxsKV0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmYWN0b3J5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhY3RvcnkodGV4dCkge1xuICAgICAgaWYgKHRleHQgaW5zdGFuY2VvZiBGb3JtYXR0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVkLmZyb21TdHJpbmcodGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvcm1hdHRlZDtcbn0oKTtcblxudmFyIFJlc29sdmVkSW1hZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXNvbHZlZEltYWdlKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzb2x2ZWRJbWFnZSk7XG5cbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5hdmFpbGFibGUgPSBvcHRpb25zLmF2YWlsYWJsZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXNvbHZlZEltYWdlLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICByZXR1cm4gWydpbWFnZScsIHRoaXMubmFtZV07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nKG5hbWUpIHtcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbmV3IFJlc29sdmVkSW1hZ2Uoe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBhdmFpbGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVzb2x2ZWRJbWFnZTtcbn0oKTtcblxuZnVuY3Rpb24gdmFsaWRhdGVSR0JBKHIsIGcsIGIsIGEpIHtcbiAgaWYgKCEodHlwZW9mIHIgPT09ICdudW1iZXInICYmIHIgPj0gMCAmJiByIDw9IDI1NSAmJiB0eXBlb2YgZyA9PT0gJ251bWJlcicgJiYgZyA+PSAwICYmIGcgPD0gMjU1ICYmIHR5cGVvZiBiID09PSAnbnVtYmVyJyAmJiBiID49IDAgJiYgYiA8PSAyNTUpKSB7XG4gICAgdmFyIHZhbHVlID0gdHlwZW9mIGEgPT09ICdudW1iZXInID8gW3IsIGcsIGIsIGFdIDogW3IsIGcsIGJdO1xuICAgIHJldHVybiBcIkludmFsaWQgcmdiYSB2YWx1ZSBbXCIuY29uY2F0KHZhbHVlLmpvaW4oJywgJyksIFwiXTogJ3InLCAnZycsIGFuZCAnYicgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDI1NS5cIik7XG4gIH1cblxuICBpZiAoISh0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGEgPT09ICdudW1iZXInICYmIGEgPj0gMCAmJiBhIDw9IDEpKSB7XG4gICAgcmV0dXJuIFwiSW52YWxpZCByZ2JhIHZhbHVlIFtcIi5jb25jYXQoW3IsIGcsIGIsIGFdLmpvaW4oJywgJyksIFwiXTogJ2EnIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLlwiKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1ZhbHVlKG1peGVkKSB7XG4gIGlmIChtaXhlZCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWl4ZWQgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAobWl4ZWQgaW5zdGFuY2VvZiBDb2xsYXRvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAobWl4ZWQgaW5zdGFuY2VvZiBSZXNvbHZlZEltYWdlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtaXhlZCkpIHtcbiAgICB2YXIgX2l0ZXJhdG9yNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG1peGVkKSxcbiAgICAgICAgX3N0ZXA1O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBpdGVtID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgIGlmICghaXNWYWx1ZShpdGVtKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbWl4ZWQpIHtcbiAgICAgIGlmICghaXNWYWx1ZShtaXhlZFtrZXldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHR5cGVPZih2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gTnVsbFR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBTdHJpbmdUeXBlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIEJvb2xlYW5UeXBlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gTnVtYmVyVHlwZTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgcmV0dXJuIENvbG9yVHlwZTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbGxhdG9yKSB7XG4gICAgcmV0dXJuIENvbGxhdG9yVHlwZTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZvcm1hdHRlZCkge1xuICAgIHJldHVybiBGb3JtYXR0ZWRUeXBlO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSkge1xuICAgIHJldHVybiBSZXNvbHZlZEltYWdlVHlwZTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgdmFyIGl0ZW1UeXBlO1xuXG4gICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih2YWx1ZSksXG4gICAgICAgIF9zdGVwNjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICB2YXIgaXRlbSA9IF9zdGVwNi52YWx1ZTtcbiAgICAgICAgdmFyIHQgPSB0eXBlT2YoaXRlbSk7XG5cbiAgICAgICAgaWYgKCFpdGVtVHlwZSkge1xuICAgICAgICAgIGl0ZW1UeXBlID0gdDtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtVHlwZSA9PT0gdCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1UeXBlID0gVmFsdWVUeXBlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5KGl0ZW1UeXBlIHx8IFZhbHVlVHlwZSwgbGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gT2JqZWN0VHlwZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1N0cmluZyQxKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIENvbG9yIHx8IHZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gIH1cbn1cblxudmFyIExpdGVyYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaXRlcmFsKHR5cGUsIHZhbHVlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpdGVyYWwpO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGl0ZXJhbCwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2hDaGlsZCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdhcnJheScgfHwgdGhpcy50eXBlLmtpbmQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBbJ2xpdGVyYWwnLCB0aGlzLnZhbHVlXTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy52YWx1ZSBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICAgIHJldHVybiBbJ3JnYmEnXS5jb25jYXQodGhpcy52YWx1ZS50b0FycmF5KCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlLnNlcmlhbGl6ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSByZXR1cm4gY29udGV4dC5lcnJvcihcIidsaXRlcmFsJyBleHByZXNzaW9uIHJlcXVpcmVzIGV4YWN0bHkgb25lIGFyZ3VtZW50LCBidXQgZm91bmQgXCIuY29uY2F0KGFyZ3MubGVuZ3RoIC0gMSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgaWYgKCFpc1ZhbHVlKGFyZ3NbMV0pKSByZXR1cm4gY29udGV4dC5lcnJvcihcImludmFsaWQgdmFsdWVcIik7XG4gICAgICB2YXIgdmFsdWUgPSBhcmdzWzFdO1xuICAgICAgdmFyIHR5cGUgPSB0eXBlT2YodmFsdWUpO1xuICAgICAgdmFyIGV4cGVjdGVkID0gY29udGV4dC5leHBlY3RlZFR5cGU7XG5cbiAgICAgIGlmICh0eXBlLmtpbmQgPT09ICdhcnJheScgJiYgdHlwZS5OID09PSAwICYmIGV4cGVjdGVkICYmIGV4cGVjdGVkLmtpbmQgPT09ICdhcnJheScgJiYgKHR5cGVvZiBleHBlY3RlZC5OICE9PSAnbnVtYmVyJyB8fCBleHBlY3RlZC5OID09PSAwKSkge1xuICAgICAgICB0eXBlID0gZXhwZWN0ZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbCh0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpdGVyYWw7XG59KCk7XG5cbnZhciBSdW50aW1lRXJyb3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSdW50aW1lRXJyb3IobWVzc2FnZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSdW50aW1lRXJyb3IpO1xuXG4gICAgdGhpcy5uYW1lID0gJ0V4cHJlc3Npb25FdmFsdWF0aW9uRXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUnVudGltZUVycm9yLCBbe1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUnVudGltZUVycm9yO1xufSgpO1xuXG52YXIgdHlwZXMgPSB7XG4gIHN0cmluZzogU3RyaW5nVHlwZSxcbiAgbnVtYmVyOiBOdW1iZXJUeXBlLFxuICBib29sZWFuOiBCb29sZWFuVHlwZSxcbiAgb2JqZWN0OiBPYmplY3RUeXBlXG59O1xuXG52YXIgQXNzZXJ0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXNzZXJ0aW9uKHR5cGUsIGFyZ3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXNzZXJ0aW9uKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBc3NlcnRpb24sIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5hcmdzW2ldLmV2YWx1YXRlKGN0eCk7XG5cbiAgICAgICAgdmFyIF9lcnJvciA9IF9jaGVja1N1YnR5cGUodGhpcy50eXBlLCB0eXBlT2YodmFsdWUpKTtcblxuICAgICAgICBpZiAoIV9lcnJvcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSB0aGlzLmFyZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlIFwiLmNvbmNhdCh0b1N0cmluZyh0aGlzLnR5cGUpLCBcIiwgYnV0IGZvdW5kIFwiKS5jb25jYXQodG9TdHJpbmcodHlwZU9mKHZhbHVlKSksIFwiIGluc3RlYWQuXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgICAgdGhpcy5hcmdzLmZvckVhY2goZm4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbdHlwZS5raW5kXTtcblxuICAgICAgaWYgKHR5cGUua2luZCA9PT0gJ2FycmF5Jykge1xuICAgICAgICB2YXIgaXRlbVR5cGUgPSB0eXBlLml0ZW1UeXBlO1xuXG4gICAgICAgIGlmIChpdGVtVHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCBpdGVtVHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCBpdGVtVHlwZS5raW5kID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBzZXJpYWxpemVkLnB1c2goaXRlbVR5cGUua2luZCk7XG4gICAgICAgICAgdmFyIE4gPSB0eXBlLk47XG5cbiAgICAgICAgICBpZiAodHlwZW9mIE4gPT09ICdudW1iZXInIHx8IHRoaXMuYXJncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLnB1c2goTik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXJpYWxpemVkLmNvbmNhdCh0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5zZXJpYWxpemUoKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5cIik7XG4gICAgICB2YXIgaSA9IDE7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIHZhciBuYW1lID0gYXJnc1swXTtcblxuICAgICAgaWYgKG5hbWUgPT09ICdhcnJheScpIHtcbiAgICAgICAgdmFyIGl0ZW1UeXBlO1xuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICB2YXIgX3R5cGUgPSBhcmdzWzFdO1xuICAgICAgICAgIGlmICh0eXBlb2YgX3R5cGUgIT09ICdzdHJpbmcnIHx8ICEoX3R5cGUgaW4gdHlwZXMpIHx8IF90eXBlID09PSAnb2JqZWN0JykgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1RoZSBpdGVtIHR5cGUgYXJndW1lbnQgb2YgXCJhcnJheVwiIG11c3QgYmUgb25lIG9mIHN0cmluZywgbnVtYmVyLCBib29sZWFuJywgMSk7XG4gICAgICAgICAgaXRlbVR5cGUgPSB0eXBlc1tfdHlwZV07XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1UeXBlID0gVmFsdWVUeXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIE47XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMykge1xuICAgICAgICAgIGlmIChhcmdzWzJdICE9PSBudWxsICYmICh0eXBlb2YgYXJnc1syXSAhPT0gJ251bWJlcicgfHwgYXJnc1syXSA8IDAgfHwgYXJnc1syXSAhPT0gTWF0aC5mbG9vcihhcmdzWzJdKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdUaGUgbGVuZ3RoIGFyZ3VtZW50IHRvIFwiYXJyYXlcIiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBsaXRlcmFsJywgMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgTiA9IGFyZ3NbMl07XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdHlwZSA9IGFycmF5KGl0ZW1UeXBlLCBOKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPSB0eXBlc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnNlZCA9IFtdO1xuXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCBpLCBWYWx1ZVR5cGUpO1xuICAgICAgICBpZiAoIWlucHV0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgcGFyc2VkLnB1c2goaW5wdXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEFzc2VydGlvbih0eXBlLCBwYXJzZWQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBc3NlcnRpb247XG59KCk7XG5cbnZhciBGb3JtYXRFeHByZXNzaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9ybWF0RXhwcmVzc2lvbihzZWN0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtYXRFeHByZXNzaW9uKTtcblxuICAgIHRoaXMudHlwZSA9IEZvcm1hdHRlZFR5cGU7XG4gICAgdGhpcy5zZWN0aW9ucyA9IHNlY3Rpb25zO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZvcm1hdEV4cHJlc3Npb24sIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgdmFyIGV2YWx1YXRlU2VjdGlvbiA9IGZ1bmN0aW9uIGV2YWx1YXRlU2VjdGlvbihzZWN0aW9uKSB7XG4gICAgICAgIHZhciBldmFsdWF0ZWRDb250ZW50ID0gc2VjdGlvbi5jb250ZW50LmV2YWx1YXRlKGN0eCk7XG5cbiAgICAgICAgaWYgKHR5cGVPZihldmFsdWF0ZWRDb250ZW50KSA9PT0gUmVzb2x2ZWRJbWFnZVR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZvcm1hdHRlZFNlY3Rpb24oJycsIGV2YWx1YXRlZENvbnRlbnQsIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXR0ZWRTZWN0aW9uKHRvU3RyaW5nJDEoZXZhbHVhdGVkQ29udGVudCksIG51bGwsIHNlY3Rpb24uc2NhbGUgPyBzZWN0aW9uLnNjYWxlLmV2YWx1YXRlKGN0eCkgOiBudWxsLCBzZWN0aW9uLmZvbnQgPyBzZWN0aW9uLmZvbnQuZXZhbHVhdGUoY3R4KS5qb2luKCcsJykgOiBudWxsLCBzZWN0aW9uLnRleHRDb2xvciA/IHNlY3Rpb24udGV4dENvbG9yLmV2YWx1YXRlKGN0eCkgOiBudWxsKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBuZXcgRm9ybWF0dGVkKHRoaXMuc2VjdGlvbnMubWFwKGV2YWx1YXRlU2VjdGlvbikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuc2VjdGlvbnMpLFxuICAgICAgICAgIF9zdGVwNztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgc2VjdGlvbiA9IF9zdGVwNy52YWx1ZTtcbiAgICAgICAgICBmbihzZWN0aW9uLmNvbnRlbnQpO1xuXG4gICAgICAgICAgaWYgKHNlY3Rpb24uc2NhbGUpIHtcbiAgICAgICAgICAgIGZuKHNlY3Rpb24uc2NhbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN0aW9uLmZvbnQpIHtcbiAgICAgICAgICAgIGZuKHNlY3Rpb24uZm9udCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3Rpb24udGV4dENvbG9yKSB7XG4gICAgICAgICAgICBmbihzZWN0aW9uLnRleHRDb2xvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2Zvcm1hdCddO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuc2VjdGlvbnMpLFxuICAgICAgICAgIF9zdGVwODtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I4LnMoKTsgIShfc3RlcDggPSBfaXRlcmF0b3I4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgc2VjdGlvbiA9IF9zdGVwOC52YWx1ZTtcbiAgICAgICAgICBzZXJpYWxpemVkLnB1c2goc2VjdGlvbi5jb250ZW50LnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgaWYgKHNlY3Rpb24uc2NhbGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ2ZvbnQtc2NhbGUnXSA9IHNlY3Rpb24uc2NhbGUuc2VyaWFsaXplKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3Rpb24uZm9udCkge1xuICAgICAgICAgICAgb3B0aW9uc1sndGV4dC1mb250J10gPSBzZWN0aW9uLmZvbnQuc2VyaWFsaXplKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3Rpb24udGV4dENvbG9yKSB7XG4gICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWNvbG9yJ10gPSBzZWN0aW9uLnRleHRDb2xvci5zZXJpYWxpemUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXJpYWxpemVkLnB1c2gob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I4LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjguZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0QXJnID0gYXJnc1sxXTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZpcnN0QXJnKSAmJiB0eXBlb2YgZmlyc3RBcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBpbWFnZSBvciB0ZXh0IHNlY3Rpb24uXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICAgIHZhciBuZXh0VG9rZW5NYXlCZU9iamVjdCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBhcmdzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICB2YXIgYXJnID0gYXJnc1tpXTtcblxuICAgICAgICBpZiAobmV4dFRva2VuTWF5QmVPYmplY3QgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgIG5leHRUb2tlbk1heUJlT2JqZWN0ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIHNjYWxlID0gbnVsbDtcblxuICAgICAgICAgIGlmIChhcmdbJ2ZvbnQtc2NhbGUnXSkge1xuICAgICAgICAgICAgc2NhbGUgPSBjb250ZXh0LnBhcnNlKGFyZ1snZm9udC1zY2FsZSddLCAxLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgICAgIGlmICghc2NhbGUpIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBmb250ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChhcmdbJ3RleHQtZm9udCddKSB7XG4gICAgICAgICAgICBmb250ID0gY29udGV4dC5wYXJzZShhcmdbJ3RleHQtZm9udCddLCAxLCBhcnJheShTdHJpbmdUeXBlKSk7XG4gICAgICAgICAgICBpZiAoIWZvbnQpIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0ZXh0Q29sb3IgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGFyZ1sndGV4dC1jb2xvciddKSB7XG4gICAgICAgICAgICB0ZXh0Q29sb3IgPSBjb250ZXh0LnBhcnNlKGFyZ1sndGV4dC1jb2xvciddLCAxLCBDb2xvclR5cGUpO1xuICAgICAgICAgICAgaWYgKCF0ZXh0Q29sb3IpIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBsYXN0RXhwcmVzc2lvbiA9IHNlY3Rpb25zW3NlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGxhc3RFeHByZXNzaW9uLnNjYWxlID0gc2NhbGU7XG4gICAgICAgICAgbGFzdEV4cHJlc3Npb24uZm9udCA9IGZvbnQ7XG4gICAgICAgICAgbGFzdEV4cHJlc3Npb24udGV4dENvbG9yID0gdGV4dENvbG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb250ZW50ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCAxLCBWYWx1ZVR5cGUpO1xuICAgICAgICAgIGlmICghY29udGVudCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdmFyIGtpbmQgPSBjb250ZW50LnR5cGUua2luZDtcbiAgICAgICAgICBpZiAoa2luZCAhPT0gJ3N0cmluZycgJiYga2luZCAhPT0gJ3ZhbHVlJyAmJiBraW5kICE9PSAnbnVsbCcgJiYga2luZCAhPT0gJ3Jlc29sdmVkSW1hZ2UnKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkZvcm1hdHRlZCB0ZXh0IHR5cGUgbXVzdCBiZSAnc3RyaW5nJywgJ3ZhbHVlJywgJ2ltYWdlJyBvciAnbnVsbCcuXCIpO1xuICAgICAgICAgIG5leHRUb2tlbk1heUJlT2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICBzY2FsZTogbnVsbCxcbiAgICAgICAgICAgIGZvbnQ6IG51bGwsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEZvcm1hdEV4cHJlc3Npb24oc2VjdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb3JtYXRFeHByZXNzaW9uO1xufSgpO1xuXG52YXIgSW1hZ2VFeHByZXNzaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW1hZ2VFeHByZXNzaW9uKGlucHV0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEltYWdlRXhwcmVzc2lvbik7XG5cbiAgICB0aGlzLnR5cGUgPSBSZXNvbHZlZEltYWdlVHlwZTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW1hZ2VFeHByZXNzaW9uLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHZhciBldmFsdWF0ZWRJbWFnZU5hbWUgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7XG4gICAgICB2YXIgdmFsdWUgPSBSZXNvbHZlZEltYWdlLmZyb21TdHJpbmcoZXZhbHVhdGVkSW1hZ2VOYW1lKTtcbiAgICAgIGlmICh2YWx1ZSAmJiBjdHguYXZhaWxhYmxlSW1hZ2VzKSB2YWx1ZS5hdmFpbGFibGUgPSBjdHguYXZhaWxhYmxlSW1hZ2VzLmluZGV4T2YoZXZhbHVhdGVkSW1hZ2VOYW1lKSA+IC0xO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICBmbih0aGlzLmlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIFsnaW1hZ2UnLCB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCB0d28gYXJndW1lbnRzLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFN0cmluZ1R5cGUpO1xuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gY29udGV4dC5lcnJvcihcIk5vIGltYWdlIG5hbWUgcHJvdmlkZWQuXCIpO1xuICAgICAgcmV0dXJuIG5ldyBJbWFnZUV4cHJlc3Npb24obmFtZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEltYWdlRXhwcmVzc2lvbjtcbn0oKTtcblxudmFyIHR5cGVzJDEgPSB7XG4gICd0by1ib29sZWFuJzogQm9vbGVhblR5cGUsXG4gICd0by1jb2xvcic6IENvbG9yVHlwZSxcbiAgJ3RvLW51bWJlcic6IE51bWJlclR5cGUsXG4gICd0by1zdHJpbmcnOiBTdHJpbmdUeXBlXG59O1xuXG52YXIgQ29lcmNpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2VyY2lvbih0eXBlLCBhcmdzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvZXJjaW9uKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2VyY2lvbiwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5raW5kID09PSAnY29sb3InKSB7XG4gICAgICAgIHZhciBpbnB1dDtcblxuICAgICAgICB2YXIgX2Vycm9yMjtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuYXJncyksXG4gICAgICAgICAgICBfc3RlcDk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjkucygpOyAhKF9zdGVwOSA9IF9pdGVyYXRvcjkubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGFyZyA9IF9zdGVwOS52YWx1ZTtcbiAgICAgICAgICAgIGlucHV0ID0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBfZXJyb3IyID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciBjID0gY3R4LnBhcnNlQ29sb3IoaW5wdXQpO1xuICAgICAgICAgICAgICBpZiAoYykgcmV0dXJuIGM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPCAzIHx8IGlucHV0Lmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgICAgICBfZXJyb3IyID0gXCJJbnZhbGlkIHJiZ2EgdmFsdWUgXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KGlucHV0KSwgXCI6IGV4cGVjdGVkIGFuIGFycmF5IGNvbnRhaW5pbmcgZWl0aGVyIHRocmVlIG9yIGZvdXIgbnVtZXJpYyB2YWx1ZXMuXCIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9lcnJvcjIgPSB2YWxpZGF0ZVJHQkEoaW5wdXRbMF0sIGlucHV0WzFdLCBpbnB1dFsyXSwgaW5wdXRbM10pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFfZXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihpbnB1dFswXSAvIDI1NSwgaW5wdXRbMV0gLyAyNTUsIGlucHV0WzJdIC8gMjU1LCBpbnB1dFszXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjkuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjkuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihfZXJyb3IyIHx8IFwiQ291bGQgbm90IHBhcnNlIGNvbG9yIGZyb20gdmFsdWUgJ1wiLmNvbmNhdCh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gaW5wdXQgOiBTdHJpbmcoSlNPTi5zdHJpbmdpZnkoaW5wdXQpKSwgXCInXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjEwID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5hcmdzKSxcbiAgICAgICAgICAgIF9zdGVwMTA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjEwLnMoKTsgIShfc3RlcDEwID0gX2l0ZXJhdG9yMTAubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9hcmcgPSBfc3RlcDEwLnZhbHVlO1xuICAgICAgICAgICAgdmFsdWUgPSBfYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiAwO1xuICAgICAgICAgICAgdmFyIG51bSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNOYU4obnVtKSkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMTAuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjEwLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJDb3VsZCBub3QgY29udmVydCBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBcIiB0byBudW1iZXIuXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdmb3JtYXR0ZWQnKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZWQuZnJvbVN0cmluZyh0b1N0cmluZyQxKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZS5raW5kID09PSAncmVzb2x2ZWRJbWFnZScpIHtcbiAgICAgICAgcmV0dXJuIFJlc29sdmVkSW1hZ2UuZnJvbVN0cmluZyh0b1N0cmluZyQxKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmckMSh0aGlzLmFyZ3NbMF0uZXZhbHVhdGUoY3R4KSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIHRoaXMuYXJncy5mb3JFYWNoKGZuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeShmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBhcmcub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdmb3JtYXR0ZWQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgRm9ybWF0RXhwcmVzc2lvbihbe1xuICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuYXJnc1swXSxcbiAgICAgICAgICBzY2FsZTogbnVsbCxcbiAgICAgICAgICBmb250OiBudWxsLFxuICAgICAgICAgIHRleHRDb2xvcjogbnVsbFxuICAgICAgICB9XSkuc2VyaWFsaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ3Jlc29sdmVkSW1hZ2UnKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW1hZ2VFeHByZXNzaW9uKHRoaXMuYXJnc1swXSkuc2VyaWFsaXplKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXJpYWxpemVkID0gW1widG8tXCIuY29uY2F0KHRoaXMudHlwZS5raW5kKV07XG4gICAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuXCIpO1xuICAgICAgdmFyIG5hbWUgPSBhcmdzWzBdO1xuICAgICAgaWYgKChuYW1lID09PSAndG8tYm9vbGVhbicgfHwgbmFtZSA9PT0gJ3RvLXN0cmluZycpICYmIGFyZ3MubGVuZ3RoICE9PSAyKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIG9uZSBhcmd1bWVudC5cIik7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVzJDFbbmFtZV07XG4gICAgICB2YXIgcGFyc2VkID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIGksIFZhbHVlVHlwZSk7XG4gICAgICAgIGlmICghaW5wdXQpIHJldHVybiBudWxsO1xuICAgICAgICBwYXJzZWQucHVzaChpbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQ29lcmNpb24odHlwZSwgcGFyc2VkKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29lcmNpb247XG59KCk7XG5cbnZhciBnZW9tZXRyeVR5cGVzID0gWydVbmtub3duJywgJ1BvaW50JywgJ0xpbmVTdHJpbmcnLCAnUG9seWdvbiddO1xuXG52YXIgRXZhbHVhdGlvbkNvbnRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmFsdWF0aW9uQ29udGV4dCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZhbHVhdGlvbkNvbnRleHQpO1xuXG4gICAgdGhpcy5nbG9iYWxzID0gbnVsbDtcbiAgICB0aGlzLmZlYXR1cmUgPSBudWxsO1xuICAgIHRoaXMuZmVhdHVyZVN0YXRlID0gbnVsbDtcbiAgICB0aGlzLmZvcm1hdHRlZFNlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuX3BhcnNlQ29sb3JDYWNoZSA9IHt9O1xuICAgIHRoaXMuYXZhaWxhYmxlSW1hZ2VzID0gbnVsbDtcbiAgICB0aGlzLmNhbm9uaWNhbCA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXZhbHVhdGlvbkNvbnRleHQsIFt7XG4gICAga2V5OiBcImlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiAnaWQnIGluIHRoaXMuZmVhdHVyZSA/IHRoaXMuZmVhdHVyZS5pZCA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlb21ldHJ5VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW9tZXRyeVR5cGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZWF0dXJlID8gdHlwZW9mIHRoaXMuZmVhdHVyZS50eXBlID09PSAnbnVtYmVyJyA/IGdlb21ldHJ5VHlwZXNbdGhpcy5mZWF0dXJlLnR5cGVdIDogdGhpcy5mZWF0dXJlLnR5cGUgOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZW9tZXRyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW9tZXRyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgJiYgJ2dlb21ldHJ5JyBpbiB0aGlzLmZlYXR1cmUgPyB0aGlzLmZlYXR1cmUuZ2VvbWV0cnkgOiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5vbmljYWxJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5vbmljYWxJRCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbm9uaWNhbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvcGVydGllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiB0aGlzLmZlYXR1cmUucHJvcGVydGllcyB8fCB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUNvbG9yKGlucHV0KSB7XG4gICAgICB2YXIgY2FjaGVkID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW2lucHV0XTtcblxuICAgICAgaWYgKCFjYWNoZWQpIHtcbiAgICAgICAgY2FjaGVkID0gdGhpcy5fcGFyc2VDb2xvckNhY2hlW2lucHV0XSA9IENvbG9yLnBhcnNlKGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXZhbHVhdGlvbkNvbnRleHQ7XG59KCk7XG5cbnZhciBDb21wb3VuZEV4cHJlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21wb3VuZEV4cHJlc3Npb24obmFtZSwgdHlwZSwgZXZhbHVhdGUsIGFyZ3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcG91bmRFeHByZXNzaW9uKTtcblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLl9ldmFsdWF0ZSA9IGV2YWx1YXRlO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29tcG91bmRFeHByZXNzaW9uLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ldmFsdWF0ZShjdHgsIHRoaXMuYXJncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIHRoaXMuYXJncy5mb3JFYWNoKGZuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLm5hbWVdLmNvbmNhdCh0aGlzLmFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5zZXJpYWxpemUoKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICB2YXIgb3AgPSBhcmdzWzBdO1xuICAgICAgdmFyIGRlZmluaXRpb24gPSBDb21wb3VuZEV4cHJlc3Npb24uZGVmaW5pdGlvbnNbb3BdO1xuXG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJVbmtub3duIGV4cHJlc3Npb24gXFxcIlwiLmNvbmNhdChvcCwgXCJcXFwiLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcXFwibGl0ZXJhbFxcXCIsIFsuLi5dXS5cIiksIDApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZSA9IEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikgPyBkZWZpbml0aW9uWzBdIDogZGVmaW5pdGlvbi50eXBlO1xuICAgICAgdmFyIGF2YWlsYWJsZU92ZXJsb2FkcyA9IEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikgPyBbW2RlZmluaXRpb25bMV0sIGRlZmluaXRpb25bMl1dXSA6IGRlZmluaXRpb24ub3ZlcmxvYWRzO1xuICAgICAgdmFyIG92ZXJsb2FkcyA9IGF2YWlsYWJsZU92ZXJsb2Fkcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMSksXG4gICAgICAgICAgICBzaWduYXR1cmUgPSBfcmVmMlswXTtcblxuICAgICAgICByZXR1cm4gIUFycmF5LmlzQXJyYXkoc2lnbmF0dXJlKSB8fCBzaWduYXR1cmUubGVuZ3RoID09PSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgICB9KTtcbiAgICAgIHZhciBzaWduYXR1cmVDb250ZXh0ID0gbnVsbDtcblxuICAgICAgdmFyIF9pdGVyYXRvcjExID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob3ZlcmxvYWRzKSxcbiAgICAgICAgICBfc3RlcDExO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjExLnMoKTsgIShfc3RlcDExID0gX2l0ZXJhdG9yMTEubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDExJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAxMS52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIHBhcmFtcyA9IF9zdGVwMTEkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIGV2YWx1YXRlID0gX3N0ZXAxMSR2YWx1ZVsxXTtcblxuICAgICAgICAgIHNpZ25hdHVyZUNvbnRleHQgPSBuZXcgUGFyc2luZ0NvbnRleHQoY29udGV4dC5yZWdpc3RyeSwgY29udGV4dC5wYXRoLCBudWxsLCBjb250ZXh0LnNjb3BlKTtcbiAgICAgICAgICB2YXIgcGFyc2VkQXJncyA9IFtdO1xuICAgICAgICAgIHZhciBhcmdQYXJzZUZhaWxlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMTsgX2kzIDwgYXJncy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gYXJnc1tfaTNdO1xuICAgICAgICAgICAgdmFyIGV4cGVjdGVkVHlwZSA9IEFycmF5LmlzQXJyYXkocGFyYW1zKSA/IHBhcmFtc1tfaTMgLSAxXSA6IHBhcmFtcy50eXBlO1xuXG4gICAgICAgICAgICB2YXIgX3BhcnNlZCA9IHNpZ25hdHVyZUNvbnRleHQucGFyc2UoYXJnLCAxICsgcGFyc2VkQXJncy5sZW5ndGgsIGV4cGVjdGVkVHlwZSk7XG5cbiAgICAgICAgICAgIGlmICghX3BhcnNlZCkge1xuICAgICAgICAgICAgICBhcmdQYXJzZUZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJzZWRBcmdzLnB1c2goX3BhcnNlZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFyZ1BhcnNlRmFpbGVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gcGFyc2VkQXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc2lnbmF0dXJlQ29udGV4dC5lcnJvcihcIkV4cGVjdGVkIFwiLmNvbmNhdChwYXJhbXMubGVuZ3RoLCBcIiBhcmd1bWVudHMsIGJ1dCBmb3VuZCBcIikuY29uY2F0KHBhcnNlZEFyZ3MubGVuZ3RoLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IHBhcnNlZEFyZ3MubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgdmFyIF9leHBlY3RlZCA9IEFycmF5LmlzQXJyYXkocGFyYW1zKSA/IHBhcmFtc1tfaTRdIDogcGFyYW1zLnR5cGU7XG5cbiAgICAgICAgICAgIHZhciBfYXJnMiA9IHBhcnNlZEFyZ3NbX2k0XTtcbiAgICAgICAgICAgIHNpZ25hdHVyZUNvbnRleHQuY29uY2F0KF9pNCArIDEpLmNoZWNrU3VidHlwZShfZXhwZWN0ZWQsIF9hcmcyLnR5cGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzaWduYXR1cmVDb250ZXh0LmVycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcG91bmRFeHByZXNzaW9uKG9wLCB0eXBlLCBldmFsdWF0ZSwgcGFyc2VkQXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTEuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTEuZigpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3ZlcmxvYWRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIgX2NvbnRleHQkZXJyb3JzO1xuXG4gICAgICAgIChfY29udGV4dCRlcnJvcnMgPSBjb250ZXh0LmVycm9ycykucHVzaC5hcHBseShfY29udGV4dCRlcnJvcnMsIF90b0NvbnN1bWFibGVBcnJheShzaWduYXR1cmVDb250ZXh0LmVycm9ycykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkID0gb3ZlcmxvYWRzLmxlbmd0aCA/IG92ZXJsb2FkcyA6IGF2YWlsYWJsZU92ZXJsb2FkcztcbiAgICAgICAgdmFyIHNpZ25hdHVyZXMgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgICAgdmFyIF9yZWY0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMsIDEpLFxuICAgICAgICAgICAgICBwYXJhbXMgPSBfcmVmNFswXTtcblxuICAgICAgICAgIHJldHVybiBzdHJpbmdpZnlTaWduYXR1cmUocGFyYW1zKTtcbiAgICAgICAgfSkuam9pbignIHwgJyk7XG4gICAgICAgIHZhciBhY3R1YWxUeXBlcyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIDEgKyBhY3R1YWxUeXBlcy5sZW5ndGgpO1xuICAgICAgICAgIGlmICghcGFyc2VkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICBhY3R1YWxUeXBlcy5wdXNoKHRvU3RyaW5nKHBhcnNlZC50eXBlKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgYXJndW1lbnRzIG9mIHR5cGUgXCIuY29uY2F0KHNpZ25hdHVyZXMsIFwiLCBidXQgZm91bmQgKFwiKS5jb25jYXQoYWN0dWFsVHlwZXMuam9pbignLCAnKSwgXCIpIGluc3RlYWQuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKHJlZ2lzdHJ5LCBkZWZpbml0aW9ucykge1xuICAgICAgQ29tcG91bmRFeHByZXNzaW9uLmRlZmluaXRpb25zID0gZGVmaW5pdGlvbnM7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgcmVnaXN0cnlbbmFtZV0gPSBDb21wb3VuZEV4cHJlc3Npb247XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbXBvdW5kRXhwcmVzc2lvbjtcbn0oKTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzaWduYXR1cmUpKSB7XG4gICAgcmV0dXJuIFwiKFwiLmNvbmNhdChzaWduYXR1cmUubWFwKHRvU3RyaW5nKS5qb2luKCcsICcpLCBcIilcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiKFwiLmNvbmNhdCh0b1N0cmluZyhzaWduYXR1cmUudHlwZSksIFwiLi4uKVwiKTtcbiAgfVxufVxuXG52YXIgQ29sbGF0b3JFeHByZXNzaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29sbGF0b3JFeHByZXNzaW9uKGNhc2VTZW5zaXRpdmUsIGRpYWNyaXRpY1NlbnNpdGl2ZSwgbG9jYWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbGxhdG9yRXhwcmVzc2lvbik7XG5cbiAgICB0aGlzLnR5cGUgPSBDb2xsYXRvclR5cGU7XG4gICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5jYXNlU2Vuc2l0aXZlID0gY2FzZVNlbnNpdGl2ZTtcbiAgICB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSA9IGRpYWNyaXRpY1NlbnNpdGl2ZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2xsYXRvckV4cHJlc3Npb24sIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgcmV0dXJuIG5ldyBDb2xsYXRvcih0aGlzLmNhc2VTZW5zaXRpdmUuZXZhbHVhdGUoY3R4KSwgdGhpcy5kaWFjcml0aWNTZW5zaXRpdmUuZXZhbHVhdGUoY3R4KSwgdGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZS5ldmFsdWF0ZShjdHgpIDogbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIGZuKHRoaXMuY2FzZVNlbnNpdGl2ZSk7XG4gICAgICBmbih0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZSk7XG5cbiAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICBmbih0aGlzLmxvY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm91dHB1dERlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICBvcHRpb25zWydjYXNlLXNlbnNpdGl2ZSddID0gdGhpcy5jYXNlU2Vuc2l0aXZlLnNlcmlhbGl6ZSgpO1xuICAgICAgb3B0aW9uc1snZGlhY3JpdGljLXNlbnNpdGl2ZSddID0gdGhpcy5kaWFjcml0aWNTZW5zaXRpdmUuc2VyaWFsaXplKCk7XG5cbiAgICAgIGlmICh0aGlzLmxvY2FsZSkge1xuICAgICAgICBvcHRpb25zWydsb2NhbGUnXSA9IHRoaXMubG9jYWxlLnNlcmlhbGl6ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gWydjb2xsYXRvcicsIG9wdGlvbnNdO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBvbmUgYXJndW1lbnQuXCIpO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzWzFdO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkNvbGxhdG9yIG9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgdmFyIGNhc2VTZW5zaXRpdmUgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2Nhc2Utc2Vuc2l0aXZlJ10gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9uc1snY2FzZS1zZW5zaXRpdmUnXSwgMSwgQm9vbGVhblR5cGUpO1xuICAgICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBkaWFjcml0aWNTZW5zaXRpdmUgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2RpYWNyaXRpYy1zZW5zaXRpdmUnXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zWydkaWFjcml0aWMtc2Vuc2l0aXZlJ10sIDEsIEJvb2xlYW5UeXBlKTtcbiAgICAgIGlmICghZGlhY3JpdGljU2Vuc2l0aXZlKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBsb2NhbGUgPSBudWxsO1xuXG4gICAgICBpZiAob3B0aW9uc1snbG9jYWxlJ10pIHtcbiAgICAgICAgbG9jYWxlID0gY29udGV4dC5wYXJzZShvcHRpb25zWydsb2NhbGUnXSwgMSwgU3RyaW5nVHlwZSk7XG4gICAgICAgIGlmICghbG9jYWxlKSByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb2xsYXRvckV4cHJlc3Npb24oY2FzZVNlbnNpdGl2ZSwgZGlhY3JpdGljU2Vuc2l0aXZlLCBsb2NhbGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2xsYXRvckV4cHJlc3Npb247XG59KCk7XG5cbnZhciBFWFRFTlQgPSA4MTkyO1xuXG5mdW5jdGlvbiB1cGRhdGVCQm94KGJib3gsIGNvb3JkKSB7XG4gIGJib3hbMF0gPSBNYXRoLm1pbihiYm94WzBdLCBjb29yZFswXSk7XG4gIGJib3hbMV0gPSBNYXRoLm1pbihiYm94WzFdLCBjb29yZFsxXSk7XG4gIGJib3hbMl0gPSBNYXRoLm1heChiYm94WzJdLCBjb29yZFswXSk7XG4gIGJib3hbM10gPSBNYXRoLm1heChiYm94WzNdLCBjb29yZFsxXSk7XG59XG5cbmZ1bmN0aW9uIG1lcmNhdG9yWGZyb21MbmcobG5nKSB7XG4gIHJldHVybiAoMTgwICsgbG5nKSAvIDM2MDtcbn1cblxuZnVuY3Rpb24gbWVyY2F0b3JZZnJvbUxhdChsYXQpIHtcbiAgcmV0dXJuICgxODAgLSAxODAgLyBNYXRoLlBJICogTWF0aC5sb2coTWF0aC50YW4oTWF0aC5QSSAvIDQgKyBsYXQgKiBNYXRoLlBJIC8gMzYwKSkpIC8gMzYwO1xufVxuXG5mdW5jdGlvbiBib3hXaXRoaW5Cb3goYmJveDEsIGJib3gyKSB7XG4gIGlmIChiYm94MVswXSA8PSBiYm94MlswXSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYmJveDFbMl0gPj0gYmJveDJbMl0pIHJldHVybiBmYWxzZTtcbiAgaWYgKGJib3gxWzFdIDw9IGJib3gyWzFdKSByZXR1cm4gZmFsc2U7XG4gIGlmIChiYm94MVszXSA+PSBiYm94MlszXSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VGlsZUNvb3JkaW5hdGVzKHAsIGNhbm9uaWNhbCkge1xuICB2YXIgeCA9IG1lcmNhdG9yWGZyb21MbmcocFswXSk7XG4gIHZhciB5ID0gbWVyY2F0b3JZZnJvbUxhdChwWzFdKTtcbiAgdmFyIHRpbGVzQXRab29tID0gTWF0aC5wb3coMiwgY2Fub25pY2FsLnopO1xuICByZXR1cm4gW01hdGgucm91bmQoeCAqIHRpbGVzQXRab29tICogRVhURU5UKSwgTWF0aC5yb3VuZCh5ICogdGlsZXNBdFpvb20gKiBFWFRFTlQpXTtcbn1cblxuZnVuY3Rpb24gb25Cb3VuZGFyeShwLCBwMSwgcDIpIHtcbiAgdmFyIHgxID0gcFswXSAtIHAxWzBdO1xuICB2YXIgeTEgPSBwWzFdIC0gcDFbMV07XG4gIHZhciB4MiA9IHBbMF0gLSBwMlswXTtcbiAgdmFyIHkyID0gcFsxXSAtIHAyWzFdO1xuICByZXR1cm4geDEgKiB5MiAtIHgyICogeTEgPT09IDAgJiYgeDEgKiB4MiA8PSAwICYmIHkxICogeTIgPD0gMDtcbn1cblxuZnVuY3Rpb24gcmF5SW50ZXJzZWN0KHAsIHAxLCBwMikge1xuICByZXR1cm4gcDFbMV0gPiBwWzFdICE9PSBwMlsxXSA+IHBbMV0gJiYgcFswXSA8IChwMlswXSAtIHAxWzBdKSAqIChwWzFdIC0gcDFbMV0pIC8gKHAyWzFdIC0gcDFbMV0pICsgcDFbMF07XG59XG5cbmZ1bmN0aW9uIHBvaW50V2l0aGluUG9seWdvbihwb2ludCwgcmluZ3MpIHtcbiAgdmFyIGluc2lkZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciByaW5nID0gcmluZ3NbaV07XG5cbiAgICBmb3IgKHZhciBqID0gMCwgbGVuMiA9IHJpbmcubGVuZ3RoOyBqIDwgbGVuMiAtIDE7IGorKykge1xuICAgICAgaWYgKG9uQm91bmRhcnkocG9pbnQsIHJpbmdbal0sIHJpbmdbaiArIDFdKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKHJheUludGVyc2VjdChwb2ludCwgcmluZ1tqXSwgcmluZ1tqICsgMV0pKSBpbnNpZGUgPSAhaW5zaWRlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnNpZGU7XG59XG5cbmZ1bmN0aW9uIHBvaW50V2l0aGluUG9seWdvbnMocG9pbnQsIHBvbHlnb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocG9pbnRXaXRoaW5Qb2x5Z29uKHBvaW50LCBwb2x5Z29uc1tpXSkpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwZXJwKHYxLCB2Mikge1xuICByZXR1cm4gdjFbMF0gKiB2MlsxXSAtIHYxWzFdICogdjJbMF07XG59XG5cbmZ1bmN0aW9uIHR3b1NpZGVkKHAxLCBwMiwgcTEsIHEyKSB7XG4gIHZhciB4MSA9IHAxWzBdIC0gcTFbMF07XG4gIHZhciB5MSA9IHAxWzFdIC0gcTFbMV07XG4gIHZhciB4MiA9IHAyWzBdIC0gcTFbMF07XG4gIHZhciB5MiA9IHAyWzFdIC0gcTFbMV07XG4gIHZhciB4MyA9IHEyWzBdIC0gcTFbMF07XG4gIHZhciB5MyA9IHEyWzFdIC0gcTFbMV07XG4gIHZhciBkZXQxID0geDEgKiB5MyAtIHgzICogeTE7XG4gIHZhciBkZXQyID0geDIgKiB5MyAtIHgzICogeTI7XG4gIGlmIChkZXQxID4gMCAmJiBkZXQyIDwgMCB8fCBkZXQxIDwgMCAmJiBkZXQyID4gMCkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGluZUludGVyc2VjdExpbmUoYSwgYiwgYywgZCkge1xuICB2YXIgdmVjdG9yUCA9IFtiWzBdIC0gYVswXSwgYlsxXSAtIGFbMV1dO1xuICB2YXIgdmVjdG9yUSA9IFtkWzBdIC0gY1swXSwgZFsxXSAtIGNbMV1dO1xuICBpZiAocGVycCh2ZWN0b3JRLCB2ZWN0b3JQKSA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHdvU2lkZWQoYSwgYiwgYywgZCkgJiYgdHdvU2lkZWQoYywgZCwgYSwgYikpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RQb2x5Z29uKHAxLCBwMiwgcG9seWdvbikge1xuICB2YXIgX2l0ZXJhdG9yMTIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwb2x5Z29uKSxcbiAgICAgIF9zdGVwMTI7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjEyLnMoKTsgIShfc3RlcDEyID0gX2l0ZXJhdG9yMTIubigpKS5kb25lOykge1xuICAgICAgdmFyIHJpbmcgPSBfc3RlcDEyLnZhbHVlO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmcubGVuZ3RoIC0gMTsgKytqKSB7XG4gICAgICAgIGlmIChsaW5lSW50ZXJzZWN0TGluZShwMSwgcDIsIHJpbmdbal0sIHJpbmdbaiArIDFdKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IxMi5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMTIuZigpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaW5lU3RyaW5nV2l0aGluUG9seWdvbihsaW5lLCBwb2x5Z29uKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5sZW5ndGg7ICsraSkge1xuICAgIGlmICghcG9pbnRXaXRoaW5Qb2x5Z29uKGxpbmVbaV0sIHBvbHlnb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgbGluZS5sZW5ndGggLSAxOyArK19pNSkge1xuICAgIGlmIChsaW5lSW50ZXJzZWN0UG9seWdvbihsaW5lW19pNV0sIGxpbmVbX2k1ICsgMV0sIHBvbHlnb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29ucyhsaW5lLCBwb2x5Z29ucykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHBvbHlnb25zW2ldKSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFRpbGVQb2x5Z29uKGNvb3JkaW5hdGVzLCBiYm94LCBjYW5vbmljYWwpIHtcbiAgdmFyIHBvbHlnb24gPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHJpbmcgPSBbXTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29vcmRpbmF0ZXNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBjb29yZCA9IGdldFRpbGVDb29yZGluYXRlcyhjb29yZGluYXRlc1tpXVtqXSwgY2Fub25pY2FsKTtcbiAgICAgIHVwZGF0ZUJCb3goYmJveCwgY29vcmQpO1xuICAgICAgcmluZy5wdXNoKGNvb3JkKTtcbiAgICB9XG5cbiAgICBwb2x5Z29uLnB1c2gocmluZyk7XG4gIH1cblxuICByZXR1cm4gcG9seWdvbjtcbn1cblxuZnVuY3Rpb24gZ2V0VGlsZVBvbHlnb25zKGNvb3JkaW5hdGVzLCBiYm94LCBjYW5vbmljYWwpIHtcbiAgdmFyIHBvbHlnb25zID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwb2x5Z29uID0gZ2V0VGlsZVBvbHlnb24oY29vcmRpbmF0ZXNbaV0sIGJib3gsIGNhbm9uaWNhbCk7XG4gICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgfVxuXG4gIHJldHVybiBwb2x5Z29ucztcbn1cblxuZnVuY3Rpb24gdXBkYXRlUG9pbnQocCwgYmJveCwgcG9seUJCb3gsIHdvcmxkU2l6ZSkge1xuICBpZiAocFswXSA8IHBvbHlCQm94WzBdIHx8IHBbMF0gPiBwb2x5QkJveFsyXSkge1xuICAgIHZhciBoYWxmV29ybGRTaXplID0gd29ybGRTaXplICogMC41O1xuICAgIHZhciBzaGlmdCA9IHBbMF0gLSBwb2x5QkJveFswXSA+IGhhbGZXb3JsZFNpemUgPyAtd29ybGRTaXplIDogcG9seUJCb3hbMF0gLSBwWzBdID4gaGFsZldvcmxkU2l6ZSA/IHdvcmxkU2l6ZSA6IDA7XG5cbiAgICBpZiAoc2hpZnQgPT09IDApIHtcbiAgICAgIHNoaWZ0ID0gcFswXSAtIHBvbHlCQm94WzJdID4gaGFsZldvcmxkU2l6ZSA/IC13b3JsZFNpemUgOiBwb2x5QkJveFsyXSAtIHBbMF0gPiBoYWxmV29ybGRTaXplID8gd29ybGRTaXplIDogMDtcbiAgICB9XG5cbiAgICBwWzBdICs9IHNoaWZ0O1xuICB9XG5cbiAgdXBkYXRlQkJveChiYm94LCBwKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRCQm94KGJib3gpIHtcbiAgYmJveFswXSA9IGJib3hbMV0gPSBJbmZpbml0eTtcbiAgYmJveFsyXSA9IGJib3hbM10gPSAtSW5maW5pdHk7XG59XG5cbmZ1bmN0aW9uIGdldFRpbGVQb2ludHMoZ2VvbWV0cnksIHBvaW50QkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCkge1xuICB2YXIgd29ybGRTaXplID0gTWF0aC5wb3coMiwgY2Fub25pY2FsLnopICogRVhURU5UO1xuICB2YXIgc2hpZnRzID0gW2Nhbm9uaWNhbC54ICogRVhURU5ULCBjYW5vbmljYWwueSAqIEVYVEVOVF07XG4gIHZhciB0aWxlUG9pbnRzID0gW107XG5cbiAgdmFyIF9pdGVyYXRvcjEzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZ2VvbWV0cnkpLFxuICAgICAgX3N0ZXAxMztcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMTMucygpOyAhKF9zdGVwMTMgPSBfaXRlcmF0b3IxMy5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgcG9pbnRzID0gX3N0ZXAxMy52YWx1ZTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjE0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocG9pbnRzKSxcbiAgICAgICAgICBfc3RlcDE0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjE0LnMoKTsgIShfc3RlcDE0ID0gX2l0ZXJhdG9yMTQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwb2ludCA9IF9zdGVwMTQudmFsdWU7XG4gICAgICAgICAgdmFyIHAgPSBbcG9pbnQueCArIHNoaWZ0c1swXSwgcG9pbnQueSArIHNoaWZ0c1sxXV07XG4gICAgICAgICAgdXBkYXRlUG9pbnQocCwgcG9pbnRCQm94LCBwb2x5QkJveCwgd29ybGRTaXplKTtcbiAgICAgICAgICB0aWxlUG9pbnRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxNC5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IxMy5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMTMuZigpO1xuICB9XG5cbiAgcmV0dXJuIHRpbGVQb2ludHM7XG59XG5cbmZ1bmN0aW9uIGdldFRpbGVMaW5lcyhnZW9tZXRyeSwgbGluZUJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpIHtcbiAgdmFyIHdvcmxkU2l6ZSA9IE1hdGgucG93KDIsIGNhbm9uaWNhbC56KSAqIEVYVEVOVDtcbiAgdmFyIHNoaWZ0cyA9IFtjYW5vbmljYWwueCAqIEVYVEVOVCwgY2Fub25pY2FsLnkgKiBFWFRFTlRdO1xuICB2YXIgdGlsZUxpbmVzID0gW107XG5cbiAgdmFyIF9pdGVyYXRvcjE1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZ2VvbWV0cnkpLFxuICAgICAgX3N0ZXAxNTtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMTUucygpOyAhKF9zdGVwMTUgPSBfaXRlcmF0b3IxNS5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgX2xpbmUgPSBfc3RlcDE1LnZhbHVlO1xuICAgICAgdmFyIHRpbGVMaW5lID0gW107XG5cbiAgICAgIHZhciBfaXRlcmF0b3IxOCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF9saW5lKSxcbiAgICAgICAgICBfc3RlcDE4O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjE4LnMoKTsgIShfc3RlcDE4ID0gX2l0ZXJhdG9yMTgubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwb2ludCA9IF9zdGVwMTgudmFsdWU7XG4gICAgICAgICAgdmFyIF9wID0gW3BvaW50LnggKyBzaGlmdHNbMF0sIHBvaW50LnkgKyBzaGlmdHNbMV1dO1xuICAgICAgICAgIHVwZGF0ZUJCb3gobGluZUJCb3gsIF9wKTtcbiAgICAgICAgICB0aWxlTGluZS5wdXNoKF9wKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjE4LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjE4LmYoKTtcbiAgICAgIH1cblxuICAgICAgdGlsZUxpbmVzLnB1c2godGlsZUxpbmUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yMTUuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjE1LmYoKTtcbiAgfVxuXG4gIGlmIChsaW5lQkJveFsyXSAtIGxpbmVCQm94WzBdIDw9IHdvcmxkU2l6ZSAvIDIpIHtcbiAgICByZXNldEJCb3gobGluZUJCb3gpO1xuXG4gICAgdmFyIF9pdGVyYXRvcjE2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGlsZUxpbmVzKSxcbiAgICAgICAgX3N0ZXAxNjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjE2LnMoKTsgIShfc3RlcDE2ID0gX2l0ZXJhdG9yMTYubigpKS5kb25lOykge1xuICAgICAgICB2YXIgbGluZSA9IF9zdGVwMTYudmFsdWU7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjE3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobGluZSksXG4gICAgICAgICAgICBfc3RlcDE3O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IxNy5zKCk7ICEoX3N0ZXAxNyA9IF9pdGVyYXRvcjE3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBwID0gX3N0ZXAxNy52YWx1ZTtcbiAgICAgICAgICAgIHVwZGF0ZVBvaW50KHAsIGxpbmVCQm94LCBwb2x5QkJveCwgd29ybGRTaXplKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjE3LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IxNy5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjE2LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMTYuZigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aWxlTGluZXM7XG59XG5cbmZ1bmN0aW9uIHBvaW50c1dpdGhpblBvbHlnb25zKGN0eCwgcG9seWdvbkdlb21ldHJ5KSB7XG4gIHZhciBwb2ludEJCb3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gIHZhciBwb2x5QkJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgdmFyIGNhbm9uaWNhbCA9IGN0eC5jYW5vbmljYWxJRCgpO1xuXG4gIGlmIChwb2x5Z29uR2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgdmFyIHRpbGVQb2x5Z29uID0gZ2V0VGlsZVBvbHlnb24ocG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzLCBwb2x5QkJveCwgY2Fub25pY2FsKTtcbiAgICB2YXIgdGlsZVBvaW50cyA9IGdldFRpbGVQb2ludHMoY3R4Lmdlb21ldHJ5KCksIHBvaW50QkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgaWYgKCFib3hXaXRoaW5Cb3gocG9pbnRCQm94LCBwb2x5QkJveCkpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBfaXRlcmF0b3IxOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRpbGVQb2ludHMpLFxuICAgICAgICBfc3RlcDE5O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMTkucygpOyAhKF9zdGVwMTkgPSBfaXRlcmF0b3IxOS5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBwb2ludCA9IF9zdGVwMTkudmFsdWU7XG4gICAgICAgIGlmICghcG9pbnRXaXRoaW5Qb2x5Z29uKHBvaW50LCB0aWxlUG9seWdvbikpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjE5LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMTkuZigpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwb2x5Z29uR2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICB2YXIgdGlsZVBvbHlnb25zID0gZ2V0VGlsZVBvbHlnb25zKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG5cbiAgICB2YXIgX3RpbGVQb2ludHMgPSBnZXRUaWxlUG9pbnRzKGN0eC5nZW9tZXRyeSgpLCBwb2ludEJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuXG4gICAgaWYgKCFib3hXaXRoaW5Cb3gocG9pbnRCQm94LCBwb2x5QkJveCkpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBfaXRlcmF0b3IyMCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF90aWxlUG9pbnRzKSxcbiAgICAgICAgX3N0ZXAyMDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIwLnMoKTsgIShfc3RlcDIwID0gX2l0ZXJhdG9yMjAubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3BvaW50ID0gX3N0ZXAyMC52YWx1ZTtcbiAgICAgICAgaWYgKCFwb2ludFdpdGhpblBvbHlnb25zKF9wb2ludCwgdGlsZVBvbHlnb25zKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMjAuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IyMC5mKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGxpbmVzV2l0aGluUG9seWdvbnMoY3R4LCBwb2x5Z29uR2VvbWV0cnkpIHtcbiAgdmFyIGxpbmVCQm94ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICB2YXIgcG9seUJCb3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gIHZhciBjYW5vbmljYWwgPSBjdHguY2Fub25pY2FsSUQoKTtcblxuICBpZiAocG9seWdvbkdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgIHZhciB0aWxlUG9seWdvbiA9IGdldFRpbGVQb2x5Z29uKHBvbHlnb25HZW9tZXRyeS5jb29yZGluYXRlcywgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgdmFyIHRpbGVMaW5lcyA9IGdldFRpbGVMaW5lcyhjdHguZ2VvbWV0cnkoKSwgbGluZUJCb3gsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgIGlmICghYm94V2l0aGluQm94KGxpbmVCQm94LCBwb2x5QkJveCkpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBfaXRlcmF0b3IyMSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRpbGVMaW5lcyksXG4gICAgICAgIF9zdGVwMjE7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IyMS5zKCk7ICEoX3N0ZXAyMSA9IF9pdGVyYXRvcjIxLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGxpbmUgPSBfc3RlcDIxLnZhbHVlO1xuICAgICAgICBpZiAoIWxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHRpbGVQb2x5Z29uKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMjEuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IyMS5mKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgIHZhciB0aWxlUG9seWdvbnMgPSBnZXRUaWxlUG9seWdvbnMocG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzLCBwb2x5QkJveCwgY2Fub25pY2FsKTtcblxuICAgIHZhciBfdGlsZUxpbmVzID0gZ2V0VGlsZUxpbmVzKGN0eC5nZW9tZXRyeSgpLCBsaW5lQkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG5cbiAgICBpZiAoIWJveFdpdGhpbkJveChsaW5lQkJveCwgcG9seUJCb3gpKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgX2l0ZXJhdG9yMjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihfdGlsZUxpbmVzKSxcbiAgICAgICAgX3N0ZXAyMjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIyLnMoKTsgIShfc3RlcDIyID0gX2l0ZXJhdG9yMjIubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX2xpbmUyID0gX3N0ZXAyMi52YWx1ZTtcbiAgICAgICAgaWYgKCFsaW5lU3RyaW5nV2l0aGluUG9seWdvbnMoX2xpbmUyLCB0aWxlUG9seWdvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyMi5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIyLmYoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIFdpdGhpbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFdpdGhpbihnZW9qc29uLCBnZW9tZXRyaWVzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdpdGhpbik7XG5cbiAgICB0aGlzLnR5cGUgPSBCb29sZWFuVHlwZTtcbiAgICB0aGlzLmdlb2pzb24gPSBnZW9qc29uO1xuICAgIHRoaXMuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoV2l0aGluLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIGlmIChjdHguZ2VvbWV0cnkoKSAhPSBudWxsICYmIGN0eC5jYW5vbmljYWxJRCgpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKGN0eC5nZW9tZXRyeVR5cGUoKSA9PT0gJ1BvaW50Jykge1xuICAgICAgICAgIHJldHVybiBwb2ludHNXaXRoaW5Qb2x5Z29ucyhjdHgsIHRoaXMuZ2VvbWV0cmllcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3R4Lmdlb21ldHJ5VHlwZSgpID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gbGluZXNXaXRoaW5Qb2x5Z29ucyhjdHgsIHRoaXMuZ2VvbWV0cmllcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKCkge31cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiBbJ3dpdGhpbicsIHRoaXMuZ2VvanNvbl07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSByZXR1cm4gY29udGV4dC5lcnJvcihcIid3aXRoaW4nIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIGJ1dCBmb3VuZCBcIi5jb25jYXQoYXJncy5sZW5ndGggLSAxLCBcIiBpbnN0ZWFkLlwiKSk7XG5cbiAgICAgIGlmIChpc1ZhbHVlKGFyZ3NbMV0pKSB7XG4gICAgICAgIHZhciBnZW9qc29uID0gYXJnc1sxXTtcblxuICAgICAgICBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGdlb2pzb24uZmVhdHVyZXNbaV0uZ2VvbWV0cnkudHlwZTtcblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdQb2x5Z29uJyB8fCB0eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFdpdGhpbihnZW9qc29uLCBnZW9qc29uLmZlYXR1cmVzW2ldLmdlb21ldHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgICB2YXIgX3R5cGUyID0gZ2VvanNvbi5nZW9tZXRyeS50eXBlO1xuXG4gICAgICAgICAgaWYgKF90eXBlMiA9PT0gJ1BvbHlnb24nIHx8IF90eXBlMiA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24uZ2VvbWV0cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChnZW9qc29uLnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9qc29uLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBXaXRoaW4oZ2VvanNvbiwgZ2VvanNvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCInd2l0aGluJyBleHByZXNzaW9uIHJlcXVpcmVzIHZhbGlkIGdlb2pzb24gb2JqZWN0IHRoYXQgY29udGFpbnMgcG9seWdvbiBnZW9tZXRyeSB0eXBlLlwiKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2l0aGluO1xufSgpO1xuXG5mdW5jdGlvbiBpc0ZlYXR1cmVDb25zdGFudChlKSB7XG4gIGlmIChlIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uKSB7XG4gICAgaWYgKGUubmFtZSA9PT0gJ2dldCcgJiYgZS5hcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAnZmVhdHVyZS1zdGF0ZScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGUubmFtZSA9PT0gJ2hhcycgJiYgZS5hcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAncHJvcGVydGllcycgfHwgZS5uYW1lID09PSAnZ2VvbWV0cnktdHlwZScgfHwgZS5uYW1lID09PSAnaWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgvXmZpbHRlci0vLnRlc3QoZS5uYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlIGluc3RhbmNlb2YgV2l0aGluKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIGUuZWFjaENoaWxkKGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAocmVzdWx0ICYmICFpc0ZlYXR1cmVDb25zdGFudChhcmcpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpc1N0YXRlQ29uc3RhbnQoZSkge1xuICBpZiAoZSBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbikge1xuICAgIGlmIChlLm5hbWUgPT09ICdmZWF0dXJlLXN0YXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBlLmVhY2hDaGlsZChmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKHJlc3VsdCAmJiAhaXNTdGF0ZUNvbnN0YW50KGFyZykpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzR2xvYmFsUHJvcGVydHlDb25zdGFudChlLCBwcm9wZXJ0aWVzKSB7XG4gIGlmIChlIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uICYmIHByb3BlcnRpZXMuaW5kZXhPZihlLm5hbWUpID49IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgZS5lYWNoQ2hpbGQoZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChyZXN1bHQgJiYgIWlzR2xvYmFsUHJvcGVydHlDb25zdGFudChhcmcsIHByb3BlcnRpZXMpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgVmFyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmFyKG5hbWUsIGJvdW5kRXhwcmVzc2lvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWYXIpO1xuXG4gICAgdGhpcy50eXBlID0gYm91bmRFeHByZXNzaW9uLnR5cGU7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmJvdW5kRXhwcmVzc2lvbiA9IGJvdW5kRXhwcmVzc2lvbjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhWYXIsIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgcmV0dXJuIHRoaXMuYm91bmRFeHByZXNzaW9uLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIm91dHB1dERlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiBbJ3ZhcicsIHRoaXMubmFtZV07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyIHx8IHR5cGVvZiBhcmdzWzFdICE9PSAnc3RyaW5nJykgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCIndmFyJyBleHByZXNzaW9uIHJlcXVpcmVzIGV4YWN0bHkgb25lIHN0cmluZyBsaXRlcmFsIGFyZ3VtZW50LlwiKTtcbiAgICAgIHZhciBuYW1lID0gYXJnc1sxXTtcblxuICAgICAgaWYgKCFjb250ZXh0LnNjb3BlLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIlVua25vd24gdmFyaWFibGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIuIE1ha2Ugc3VyZSBcXFwiXCIpLmNvbmNhdChuYW1lLCBcIlxcXCIgaGFzIGJlZW4gYm91bmQgaW4gYW4gZW5jbG9zaW5nIFxcXCJsZXRcXFwiIGV4cHJlc3Npb24gYmVmb3JlIHVzaW5nIGl0LlwiKSwgMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgVmFyKG5hbWUsIGNvbnRleHQuc2NvcGUuZ2V0KG5hbWUpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmFyO1xufSgpO1xuXG52YXIgUGFyc2luZ0NvbnRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJzaW5nQ29udGV4dChyZWdpc3RyeSkge1xuICAgIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIHNjb3BlID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBuZXcgU2NvcGUoKTtcbiAgICB2YXIgZXJyb3JzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBbXTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXJzaW5nQ29udGV4dCk7XG5cbiAgICB0aGlzLnJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmtleSA9IHBhdGgubWFwKGZ1bmN0aW9uIChwYXJ0KSB7XG4gICAgICByZXR1cm4gXCJbXCIuY29uY2F0KHBhcnQsIFwiXVwiKTtcbiAgICB9KS5qb2luKCcnKTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgdGhpcy5leHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGFyc2luZ0NvbnRleHQsIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGV4cHIsIGluZGV4LCBleHBlY3RlZFR5cGUsIGJpbmRpbmdzKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDoge307XG5cbiAgICAgIGlmIChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25jYXQoaW5kZXgsIGV4cGVjdGVkVHlwZSwgYmluZGluZ3MpLl9wYXJzZShleHByLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlKGV4cHIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlKGV4cHIsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChleHByID09PSBudWxsIHx8IHR5cGVvZiBleHByID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZXhwciA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiBleHByID09PSAnbnVtYmVyJykge1xuICAgICAgICBleHByID0gWydsaXRlcmFsJywgZXhwcl07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFubm90YXRlKHBhcnNlZCwgdHlwZSwgdHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVBbm5vdGF0aW9uID09PSAnYXNzZXJ0Jykge1xuICAgICAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHR5cGUsIFtwYXJzZWRdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlQW5ub3RhdGlvbiA9PT0gJ2NvZXJjZScpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IENvZXJjaW9uKHR5cGUsIFtwYXJzZWRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4cHIpKSB7XG4gICAgICAgIGlmIChleHByLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiRXhwZWN0ZWQgYW4gYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgZWxlbWVudC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXFxcImxpdGVyYWxcXFwiLCBbXV0uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wID0gZXhwclswXTtcblxuICAgICAgICBpZiAodHlwZW9mIG9wICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuZXJyb3IoXCJFeHByZXNzaW9uIG5hbWUgbXVzdCBiZSBhIHN0cmluZywgYnV0IGZvdW5kIFwiLmNvbmNhdCh0eXBlb2Ygb3AsIFwiIGluc3RlYWQuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1xcXCJsaXRlcmFsXFxcIiwgWy4uLl1dLlwiKSwgMCk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgRXhwciA9IHRoaXMucmVnaXN0cnlbb3BdO1xuXG4gICAgICAgIGlmIChFeHByKSB7XG4gICAgICAgICAgdmFyIHBhcnNlZCA9IEV4cHIucGFyc2UoZXhwciwgdGhpcyk7XG4gICAgICAgICAgaWYgKCFwYXJzZWQpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWQgPSB0aGlzLmV4cGVjdGVkVHlwZTtcbiAgICAgICAgICAgIHZhciBhY3R1YWwgPSBwYXJzZWQudHlwZTtcblxuICAgICAgICAgICAgaWYgKChleHBlY3RlZC5raW5kID09PSAnc3RyaW5nJyB8fCBleHBlY3RlZC5raW5kID09PSAnbnVtYmVyJyB8fCBleHBlY3RlZC5raW5kID09PSAnYm9vbGVhbicgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ29iamVjdCcgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ2FycmF5JykgJiYgYWN0dWFsLmtpbmQgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgcGFyc2VkID0gYW5ub3RhdGUocGFyc2VkLCBleHBlY3RlZCwgb3B0aW9ucy50eXBlQW5ub3RhdGlvbiB8fCAnYXNzZXJ0Jyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChleHBlY3RlZC5raW5kID09PSAnY29sb3InIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdmb3JtYXR0ZWQnIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdyZXNvbHZlZEltYWdlJykgJiYgKGFjdHVhbC5raW5kID09PSAndmFsdWUnIHx8IGFjdHVhbC5raW5kID09PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgcGFyc2VkID0gYW5ub3RhdGUocGFyc2VkLCBleHBlY3RlZCwgb3B0aW9ucy50eXBlQW5ub3RhdGlvbiB8fCAnY29lcmNlJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCBhY3R1YWwpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghKHBhcnNlZCBpbnN0YW5jZW9mIExpdGVyYWwpICYmIHBhcnNlZC50eXBlLmtpbmQgIT09ICdyZXNvbHZlZEltYWdlJyAmJiBpc0NvbnN0YW50KHBhcnNlZCkpIHtcbiAgICAgICAgICAgIHZhciBlYyA9IG5ldyBFdmFsdWF0aW9uQ29udGV4dCgpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwYXJzZWQgPSBuZXcgTGl0ZXJhbChwYXJzZWQudHlwZSwgcGFyc2VkLmV2YWx1YXRlKGVjKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiVW5rbm93biBleHByZXNzaW9uIFxcXCJcIi5jb25jYXQob3AsIFwiXFxcIi4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXFxcImxpdGVyYWxcXFwiLCBbLi4uXV0uXCIpLCAwKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cHIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiJ3VuZGVmaW5lZCcgdmFsdWUgaW52YWxpZC4gVXNlIG51bGwgaW5zdGVhZC5cIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHByID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIkJhcmUgb2JqZWN0cyBpbnZhbGlkLiBVc2UgW1xcXCJsaXRlcmFsXFxcIiwgey4uLn1dIGluc3RlYWQuXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJFeHBlY3RlZCBhbiBhcnJheSwgYnV0IGZvdW5kIFwiLmNvbmNhdCh0eXBlb2YgZXhwciwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KGluZGV4LCBleHBlY3RlZFR5cGUsIGJpbmRpbmdzKSB7XG4gICAgICB2YXIgcGF0aCA9IHR5cGVvZiBpbmRleCA9PT0gJ251bWJlcicgPyB0aGlzLnBhdGguY29uY2F0KGluZGV4KSA6IHRoaXMucGF0aDtcbiAgICAgIHZhciBzY29wZSA9IGJpbmRpbmdzID8gdGhpcy5zY29wZS5jb25jYXQoYmluZGluZ3MpIDogdGhpcy5zY29wZTtcbiAgICAgIHJldHVybiBuZXcgUGFyc2luZ0NvbnRleHQodGhpcy5yZWdpc3RyeSwgcGF0aCwgZXhwZWN0ZWRUeXBlIHx8IG51bGwsIHNjb3BlLCB0aGlzLmVycm9ycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcjMpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwga2V5cyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTQgPSAxOyBfa2V5NCA8IF9sZW4yOyBfa2V5NCsrKSB7XG4gICAgICAgIGtleXNbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXkgPSBcIlwiLmNvbmNhdCh0aGlzLmtleSkuY29uY2F0KGtleXMubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBcIltcIi5jb25jYXQoaywgXCJdXCIpO1xuICAgICAgfSkuam9pbignJykpO1xuICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgUGFyc2luZ0Vycm9yKGtleSwgX2Vycm9yMykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjaGVja1N1YnR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCB0KSB7XG4gICAgICB2YXIgZXJyb3IgPSBfY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCB0KTtcblxuICAgICAgaWYgKGVycm9yKSB0aGlzLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFyc2luZ0NvbnRleHQ7XG59KCk7XG5cbmZ1bmN0aW9uIGlzQ29uc3RhbnQoZXhwcmVzc2lvbikge1xuICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFZhcikge1xuICAgIHJldHVybiBpc0NvbnN0YW50KGV4cHJlc3Npb24uYm91bmRFeHByZXNzaW9uKTtcbiAgfSBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uICYmIGV4cHJlc3Npb24ubmFtZSA9PT0gJ2Vycm9yJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQ29sbGF0b3JFeHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBXaXRoaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNUeXBlQW5ub3RhdGlvbiA9IGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb2VyY2lvbiB8fCBleHByZXNzaW9uIGluc3RhbmNlb2YgQXNzZXJ0aW9uO1xuICB2YXIgY2hpbGRyZW5Db25zdGFudCA9IHRydWU7XG4gIGV4cHJlc3Npb24uZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChpc1R5cGVBbm5vdGF0aW9uKSB7XG4gICAgICBjaGlsZHJlbkNvbnN0YW50ID0gY2hpbGRyZW5Db25zdGFudCAmJiBpc0NvbnN0YW50KGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGRyZW5Db25zdGFudCA9IGNoaWxkcmVuQ29uc3RhbnQgJiYgY2hpbGQgaW5zdGFuY2VvZiBMaXRlcmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKCFjaGlsZHJlbkNvbnN0YW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGlzRmVhdHVyZUNvbnN0YW50KGV4cHJlc3Npb24pICYmIGlzR2xvYmFsUHJvcGVydHlDb25zdGFudChleHByZXNzaW9uLCBbJ3pvb20nLCAnaGVhdG1hcC1kZW5zaXR5JywgJ2xpbmUtcHJvZ3Jlc3MnLCAnc2t5LXJhZGlhbC1wcm9ncmVzcycsICdhY2N1bXVsYXRlZCcsICdpcy1zdXBwb3J0ZWQtc2NyaXB0J10pO1xufVxuXG5mdW5jdGlvbiBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHN0b3BzLCBpbnB1dCkge1xuICB2YXIgbGFzdEluZGV4ID0gc3RvcHMubGVuZ3RoIC0gMTtcbiAgdmFyIGxvd2VySW5kZXggPSAwO1xuICB2YXIgdXBwZXJJbmRleCA9IGxhc3RJbmRleDtcbiAgdmFyIGN1cnJlbnRJbmRleCA9IDA7XG4gIHZhciBjdXJyZW50VmFsdWUsIG5leHRWYWx1ZTtcblxuICB3aGlsZSAobG93ZXJJbmRleCA8PSB1cHBlckluZGV4KSB7XG4gICAgY3VycmVudEluZGV4ID0gTWF0aC5mbG9vcigobG93ZXJJbmRleCArIHVwcGVySW5kZXgpIC8gMik7XG4gICAgY3VycmVudFZhbHVlID0gc3RvcHNbY3VycmVudEluZGV4XTtcbiAgICBuZXh0VmFsdWUgPSBzdG9wc1tjdXJyZW50SW5kZXggKyAxXTtcblxuICAgIGlmIChjdXJyZW50VmFsdWUgPD0gaW5wdXQpIHtcbiAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IGxhc3RJbmRleCB8fCBpbnB1dCA8IG5leHRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gY3VycmVudEluZGV4O1xuICAgICAgfVxuXG4gICAgICBsb3dlckluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWx1ZSA+IGlucHV0KSB7XG4gICAgICB1cHBlckluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcignSW5wdXQgaXMgbm90IGEgbnVtYmVyLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG52YXIgU3RlcCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0ZXAodHlwZSwgaW5wdXQsIHN0b3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0ZXApO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5sYWJlbHMgPSBbXTtcbiAgICB0aGlzLm91dHB1dHMgPSBbXTtcblxuICAgIHZhciBfaXRlcmF0b3IyMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0b3BzKSxcbiAgICAgICAgX3N0ZXAyMztcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIzLnMoKTsgIShfc3RlcDIzID0gX2l0ZXJhdG9yMjMubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0ZXAyMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMjMudmFsdWUsIDIpLFxuICAgICAgICAgICAgbGFiZWwgPSBfc3RlcDIzJHZhbHVlWzBdLFxuICAgICAgICAgICAgX2V4cHJlc3Npb24yID0gX3N0ZXAyMyR2YWx1ZVsxXTtcblxuICAgICAgICB0aGlzLmxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICAgICAgdGhpcy5vdXRwdXRzLnB1c2goX2V4cHJlc3Npb24yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjIzLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMjMuZigpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdGVwLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICAgIHZhciBvdXRwdXRzID0gdGhpcy5vdXRwdXRzO1xuXG4gICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0c1swXS5ldmFsdWF0ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7XG5cbiAgICAgIGlmICh2YWx1ZSA8PSBsYWJlbHNbMF0pIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0b3BDb3VudCA9IGxhYmVscy5sZW5ndGg7XG5cbiAgICAgIGlmICh2YWx1ZSA+PSBsYWJlbHNbc3RvcENvdW50IC0gMV0pIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbc3RvcENvdW50IC0gMV0uZXZhbHVhdGUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhsYWJlbHMsIHZhbHVlKTtcbiAgICAgIHJldHVybiBvdXRwdXRzW2luZGV4XS5ldmFsdWF0ZShjdHgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICBmbih0aGlzLmlucHV0KTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjI0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5vdXRwdXRzKSxcbiAgICAgICAgICBfc3RlcDI0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjI0LnMoKTsgIShfc3RlcDI0ID0gX2l0ZXJhdG9yMjQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfZXhwcmVzc2lvbjMgPSBfc3RlcDI0LnZhbHVlO1xuICAgICAgICAgIGZuKF9leHByZXNzaW9uMyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyNC5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm91dHB1dERlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm91dHB1dHMuZXZlcnkoZnVuY3Rpb24gKG91dCkge1xuICAgICAgICByZXR1cm4gb3V0Lm91dHB1dERlZmluZWQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ3N0ZXAnLCB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5sYWJlbHNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKHRoaXMub3V0cHV0c1tpXS5zZXJpYWxpemUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAtIDEgPCA0KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3QgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCBvbmx5IFwiLmNvbmNhdChhcmdzLmxlbmd0aCAtIDEsIFwiLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgoYXJncy5sZW5ndGggLSAxKSAlIDIgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIE51bWJlclR5cGUpO1xuICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICAgIHZhciBvdXRwdXRUeXBlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gaSA9PT0gMSA/IC1JbmZpbml0eSA6IGFyZ3NbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbaSArIDFdO1xuICAgICAgICB2YXIgbGFiZWxLZXkgPSBpO1xuICAgICAgICB2YXIgdmFsdWVLZXkgPSBpICsgMTtcblxuICAgICAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwic3RlcFwiIGV4cHJlc3Npb25zIG11c3QgYmUgZGVmaW5lZCB1c2luZyBsaXRlcmFsIG51bWVyaWMgdmFsdWVzIChub3QgY29tcHV0ZWQgZXhwcmVzc2lvbnMpIGZvciB0aGUgaW5wdXQgdmFsdWVzLicsIGxhYmVsS2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdG9wcy5sZW5ndGggJiYgc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV1bMF0gPj0gbGFiZWwpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcInN0ZXBcIiBleHByZXNzaW9ucyBtdXN0IGJlIGFycmFuZ2VkIHdpdGggaW5wdXQgdmFsdWVzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4nLCBsYWJlbEtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyc2VkID0gY29udGV4dC5wYXJzZSh2YWx1ZSwgdmFsdWVLZXksIG91dHB1dFR5cGUpO1xuICAgICAgICBpZiAoIXBhcnNlZCkgcmV0dXJuIG51bGw7XG4gICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHBhcnNlZC50eXBlO1xuICAgICAgICBzdG9wcy5wdXNoKFtsYWJlbCwgcGFyc2VkXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU3RlcChvdXRwdXRUeXBlLCBpbnB1dCwgc3RvcHMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdGVwO1xufSgpO1xuLypcbiAqIENvcHlyaWdodCAoQykgMjAwOCBBcHBsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gKiBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnNcbiAqIGFyZSBtZXQ6XG4gKiAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBBUFBMRSBJTkMuIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiAgSU4gTk8gRVZFTlQgU0hBTEwgQVBQTEUgSU5DLiBPUlxuICogQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXG4gKiBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sXG4gKiBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcbiAqIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUllcbiAqIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFBvcnRlZCBmcm9tIFdlYmtpdFxuICogaHR0cDovL3N2bi53ZWJraXQub3JnL3JlcG9zaXRvcnkvd2Via2l0L3RydW5rL1NvdXJjZS9XZWJDb3JlL3BsYXRmb3JtL2dyYXBoaWNzL1VuaXRCZXppZXIuaFxuICovXG5cblxudmFyIHVuaXRiZXppZXIgPSBVbml0QmV6aWVyO1xuXG5mdW5jdGlvbiBVbml0QmV6aWVyKHAxeCwgcDF5LCBwMngsIHAyeSkge1xuICAvLyBDYWxjdWxhdGUgdGhlIHBvbHlub21pYWwgY29lZmZpY2llbnRzLCBpbXBsaWNpdCBmaXJzdCBhbmQgbGFzdCBjb250cm9sIHBvaW50cyBhcmUgKDAsMCkgYW5kICgxLDEpLlxuICB0aGlzLmN4ID0gMy4wICogcDF4O1xuICB0aGlzLmJ4ID0gMy4wICogKHAyeCAtIHAxeCkgLSB0aGlzLmN4O1xuICB0aGlzLmF4ID0gMS4wIC0gdGhpcy5jeCAtIHRoaXMuYng7XG4gIHRoaXMuY3kgPSAzLjAgKiBwMXk7XG4gIHRoaXMuYnkgPSAzLjAgKiAocDJ5IC0gcDF5KSAtIHRoaXMuY3k7XG4gIHRoaXMuYXkgPSAxLjAgLSB0aGlzLmN5IC0gdGhpcy5ieTtcbiAgdGhpcy5wMXggPSBwMXg7XG4gIHRoaXMucDF5ID0gcDJ5O1xuICB0aGlzLnAyeCA9IHAyeDtcbiAgdGhpcy5wMnkgPSBwMnk7XG59XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWCA9IGZ1bmN0aW9uICh0KSB7XG4gIC8vIGBheCB0XjMgKyBieCB0XjIgKyBjeCB0JyBleHBhbmRlZCB1c2luZyBIb3JuZXIncyBydWxlLlxuICByZXR1cm4gKCh0aGlzLmF4ICogdCArIHRoaXMuYngpICogdCArIHRoaXMuY3gpICogdDtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNhbXBsZUN1cnZlWSA9IGZ1bmN0aW9uICh0KSB7XG4gIHJldHVybiAoKHRoaXMuYXkgKiB0ICsgdGhpcy5ieSkgKiB0ICsgdGhpcy5jeSkgKiB0O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCA9IGZ1bmN0aW9uICh0KSB7XG4gIHJldHVybiAoMy4wICogdGhpcy5heCAqIHQgKyAyLjAgKiB0aGlzLmJ4KSAqIHQgKyB0aGlzLmN4O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc29sdmVDdXJ2ZVggPSBmdW5jdGlvbiAoeCwgZXBzaWxvbikge1xuICBpZiAodHlwZW9mIGVwc2lsb24gPT09ICd1bmRlZmluZWQnKSBlcHNpbG9uID0gMWUtNjtcbiAgdmFyIHQwLCB0MSwgdDIsIHgyLCBpOyAvLyBGaXJzdCB0cnkgYSBmZXcgaXRlcmF0aW9ucyBvZiBOZXd0b24ncyBtZXRob2QgLS0gbm9ybWFsbHkgdmVyeSBmYXN0LlxuXG4gIGZvciAodDIgPSB4LCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpIC0geDtcbiAgICBpZiAoTWF0aC5hYnMoeDIpIDwgZXBzaWxvbikgcmV0dXJuIHQyO1xuICAgIHZhciBkMiA9IHRoaXMuc2FtcGxlQ3VydmVEZXJpdmF0aXZlWCh0Mik7XG4gICAgaWYgKE1hdGguYWJzKGQyKSA8IDFlLTYpIGJyZWFrO1xuICAgIHQyID0gdDIgLSB4MiAvIGQyO1xuICB9IC8vIEZhbGwgYmFjayB0byB0aGUgYmlzZWN0aW9uIG1ldGhvZCBmb3IgcmVsaWFiaWxpdHkuXG5cblxuICB0MCA9IDAuMDtcbiAgdDEgPSAxLjA7XG4gIHQyID0geDtcbiAgaWYgKHQyIDwgdDApIHJldHVybiB0MDtcbiAgaWYgKHQyID4gdDEpIHJldHVybiB0MTtcblxuICB3aGlsZSAodDAgPCB0MSkge1xuICAgIHgyID0gdGhpcy5zYW1wbGVDdXJ2ZVgodDIpO1xuICAgIGlmIChNYXRoLmFicyh4MiAtIHgpIDwgZXBzaWxvbikgcmV0dXJuIHQyO1xuXG4gICAgaWYgKHggPiB4Mikge1xuICAgICAgdDAgPSB0MjtcbiAgICB9IGVsc2Uge1xuICAgICAgdDEgPSB0MjtcbiAgICB9XG5cbiAgICB0MiA9ICh0MSAtIHQwKSAqIDAuNSArIHQwO1xuICB9IC8vIEZhaWx1cmUuXG5cblxuICByZXR1cm4gdDI7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uICh4LCBlcHNpbG9uKSB7XG4gIHJldHVybiB0aGlzLnNhbXBsZUN1cnZlWSh0aGlzLnNvbHZlQ3VydmVYKHgsIGVwc2lsb24pKTtcbn07XG5cbmZ1bmN0aW9uIG51bWJlcihhLCBiLCB0KSB7XG4gIHJldHVybiBhICogKDEgLSB0KSArIGIgKiB0O1xufVxuXG5mdW5jdGlvbiBjb2xvcihmcm9tLCB0bywgdCkge1xuICByZXR1cm4gbmV3IENvbG9yKG51bWJlcihmcm9tLnIsIHRvLnIsIHQpLCBudW1iZXIoZnJvbS5nLCB0by5nLCB0KSwgbnVtYmVyKGZyb20uYiwgdG8uYiwgdCksIG51bWJlcihmcm9tLmEsIHRvLmEsIHQpKTtcbn1cblxuZnVuY3Rpb24gYXJyYXkkMShmcm9tLCB0bywgdCkge1xuICByZXR1cm4gZnJvbS5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gbnVtYmVyKGQsIHRvW2ldLCB0KTtcbiAgfSk7XG59XG5cbnZhciBpbnRlcnBvbGF0ZSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBudW1iZXI6IG51bWJlcixcbiAgY29sb3I6IGNvbG9yLFxuICBhcnJheTogYXJyYXkkMVxufSk7XG52YXIgWG4gPSAwLjk1MDQ3LFxuICAgIFluID0gMSxcbiAgICBabiA9IDEuMDg4ODMsXG4gICAgdDAgPSA0IC8gMjksXG4gICAgdDEgPSA2IC8gMjksXG4gICAgdDIgPSAzICogdDEgKiB0MSxcbiAgICB0MyA9IHQxICogdDEgKiB0MSxcbiAgICBkZWcycmFkID0gTWF0aC5QSSAvIDE4MCxcbiAgICByYWQyZGVnID0gMTgwIC8gTWF0aC5QSTtcblxuZnVuY3Rpb24geHl6MmxhYih0KSB7XG4gIHJldHVybiB0ID4gdDMgPyBNYXRoLnBvdyh0LCAxIC8gMykgOiB0IC8gdDIgKyB0MDtcbn1cblxuZnVuY3Rpb24gbGFiMnh5eih0KSB7XG4gIHJldHVybiB0ID4gdDEgPyB0ICogdCAqIHQgOiB0MiAqICh0IC0gdDApO1xufVxuXG5mdW5jdGlvbiB4eXoycmdiKHgpIHtcbiAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5cbmZ1bmN0aW9uIHJnYjJ4eXooeCkge1xuICB4IC89IDI1NTtcbiAgcmV0dXJuIHggPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIHJnYlRvTGFiKHJnYkNvbG9yKSB7XG4gIHZhciBiID0gcmdiMnh5eihyZ2JDb2xvci5yKSxcbiAgICAgIGEgPSByZ2IyeHl6KHJnYkNvbG9yLmcpLFxuICAgICAgbCA9IHJnYjJ4eXoocmdiQ29sb3IuYiksXG4gICAgICB4ID0geHl6MmxhYigoMC40MTI0NTY0ICogYiArIDAuMzU3NTc2MSAqIGEgKyAwLjE4MDQzNzUgKiBsKSAvIFhuKSxcbiAgICAgIHkgPSB4eXoybGFiKCgwLjIxMjY3MjkgKiBiICsgMC43MTUxNTIyICogYSArIDAuMDcyMTc1ICogbCkgLyBZbiksXG4gICAgICB6ID0geHl6MmxhYigoMC4wMTkzMzM5ICogYiArIDAuMTE5MTkyICogYSArIDAuOTUwMzA0MSAqIGwpIC8gWm4pO1xuICByZXR1cm4ge1xuICAgIGw6IDExNiAqIHkgLSAxNixcbiAgICBhOiA1MDAgKiAoeCAtIHkpLFxuICAgIGI6IDIwMCAqICh5IC0geiksXG4gICAgYWxwaGE6IHJnYkNvbG9yLmFcbiAgfTtcbn1cblxuZnVuY3Rpb24gbGFiVG9SZ2IobGFiQ29sb3IpIHtcbiAgdmFyIHkgPSAobGFiQ29sb3IubCArIDE2KSAvIDExNixcbiAgICAgIHggPSBpc05hTihsYWJDb2xvci5hKSA/IHkgOiB5ICsgbGFiQ29sb3IuYSAvIDUwMCxcbiAgICAgIHogPSBpc05hTihsYWJDb2xvci5iKSA/IHkgOiB5IC0gbGFiQ29sb3IuYiAvIDIwMDtcbiAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgeCA9IFhuICogbGFiMnh5eih4KTtcbiAgeiA9IFpuICogbGFiMnh5eih6KTtcbiAgcmV0dXJuIG5ldyBDb2xvcih4eXoycmdiKDMuMjQwNDU0MiAqIHggLSAxLjUzNzEzODUgKiB5IC0gMC40OTg1MzE0ICogeiksIHh5ejJyZ2IoLTAuOTY5MjY2ICogeCArIDEuODc2MDEwOCAqIHkgKyAwLjA0MTU1NiAqIHopLCB4eXoycmdiKDAuMDU1NjQzNCAqIHggLSAwLjIwNDAyNTkgKiB5ICsgMS4wNTcyMjUyICogeiksIGxhYkNvbG9yLmFscGhhKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVMYWIoZnJvbSwgdG8sIHQpIHtcbiAgcmV0dXJuIHtcbiAgICBsOiBudW1iZXIoZnJvbS5sLCB0by5sLCB0KSxcbiAgICBhOiBudW1iZXIoZnJvbS5hLCB0by5hLCB0KSxcbiAgICBiOiBudW1iZXIoZnJvbS5iLCB0by5iLCB0KSxcbiAgICBhbHBoYTogbnVtYmVyKGZyb20uYWxwaGEsIHRvLmFscGhhLCB0KVxuICB9O1xufVxuXG5mdW5jdGlvbiByZ2JUb0hjbChyZ2JDb2xvcikge1xuICB2YXIgX3JnYlRvTGFiID0gcmdiVG9MYWIocmdiQ29sb3IpLFxuICAgICAgbCA9IF9yZ2JUb0xhYi5sLFxuICAgICAgYSA9IF9yZ2JUb0xhYi5hLFxuICAgICAgYiA9IF9yZ2JUb0xhYi5iO1xuXG4gIHZhciBoID0gTWF0aC5hdGFuMihiLCBhKSAqIHJhZDJkZWc7XG4gIHJldHVybiB7XG4gICAgaDogaCA8IDAgPyBoICsgMzYwIDogaCxcbiAgICBjOiBNYXRoLnNxcnQoYSAqIGEgKyBiICogYiksXG4gICAgbDogbCxcbiAgICBhbHBoYTogcmdiQ29sb3IuYVxuICB9O1xufVxuXG5mdW5jdGlvbiBoY2xUb1JnYihoY2xDb2xvcikge1xuICB2YXIgaCA9IGhjbENvbG9yLmggKiBkZWcycmFkLFxuICAgICAgYyA9IGhjbENvbG9yLmMsXG4gICAgICBsID0gaGNsQ29sb3IubDtcbiAgcmV0dXJuIGxhYlRvUmdiKHtcbiAgICBsOiBsLFxuICAgIGE6IE1hdGguY29zKGgpICogYyxcbiAgICBiOiBNYXRoLnNpbihoKSAqIGMsXG4gICAgYWxwaGE6IGhjbENvbG9yLmFscGhhXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUh1ZShhLCBiLCB0KSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBhICsgdCAqIChkID4gMTgwIHx8IGQgPCAtMTgwID8gZCAtIDM2MCAqIE1hdGgucm91bmQoZCAvIDM2MCkgOiBkKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGVIY2woZnJvbSwgdG8sIHQpIHtcbiAgcmV0dXJuIHtcbiAgICBoOiBpbnRlcnBvbGF0ZUh1ZShmcm9tLmgsIHRvLmgsIHQpLFxuICAgIGM6IG51bWJlcihmcm9tLmMsIHRvLmMsIHQpLFxuICAgIGw6IG51bWJlcihmcm9tLmwsIHRvLmwsIHQpLFxuICAgIGFscGhhOiBudW1iZXIoZnJvbS5hbHBoYSwgdG8uYWxwaGEsIHQpXG4gIH07XG59XG5cbnZhciBsYWIgPSB7XG4gIGZvcndhcmQ6IHJnYlRvTGFiLFxuICByZXZlcnNlOiBsYWJUb1JnYixcbiAgaW50ZXJwb2xhdGU6IGludGVycG9sYXRlTGFiXG59O1xudmFyIGhjbCA9IHtcbiAgZm9yd2FyZDogcmdiVG9IY2wsXG4gIHJldmVyc2U6IGhjbFRvUmdiLFxuICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGVIY2xcbn07XG52YXIgY29sb3JTcGFjZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgbGFiOiBsYWIsXG4gIGhjbDogaGNsXG59KTtcblxudmFyIEludGVycG9sYXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW50ZXJwb2xhdGUodHlwZSwgb3BlcmF0b3IsIGludGVycG9sYXRpb24sIGlucHV0LCBzdG9wcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcnBvbGF0ZSk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICB0aGlzLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuXG4gICAgdmFyIF9pdGVyYXRvcjI1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3RvcHMpLFxuICAgICAgICBfc3RlcDI1O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMjUucygpOyAhKF9zdGVwMjUgPSBfaXRlcmF0b3IyNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDI1JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyNS52YWx1ZSwgMiksXG4gICAgICAgICAgICBsYWJlbCA9IF9zdGVwMjUkdmFsdWVbMF0sXG4gICAgICAgICAgICBfZXhwcmVzc2lvbjQgPSBfc3RlcDI1JHZhbHVlWzFdO1xuXG4gICAgICAgIHRoaXMubGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICB0aGlzLm91dHB1dHMucHVzaChfZXhwcmVzc2lvbjQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMjUuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IyNS5mKCk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEludGVycG9sYXRlLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHZhciBsYWJlbHMgPSB0aGlzLmxhYmVscztcbiAgICAgIHZhciBvdXRwdXRzID0gdGhpcy5vdXRwdXRzO1xuXG4gICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0c1swXS5ldmFsdWF0ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7XG5cbiAgICAgIGlmICh2YWx1ZSA8PSBsYWJlbHNbMF0pIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbMF0uZXZhbHVhdGUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0b3BDb3VudCA9IGxhYmVscy5sZW5ndGg7XG5cbiAgICAgIGlmICh2YWx1ZSA+PSBsYWJlbHNbc3RvcENvdW50IC0gMV0pIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dHNbc3RvcENvdW50IC0gMV0uZXZhbHVhdGUoY3R4KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhsYWJlbHMsIHZhbHVlKTtcbiAgICAgIHZhciBsb3dlciA9IGxhYmVsc1tpbmRleF07XG4gICAgICB2YXIgdXBwZXIgPSBsYWJlbHNbaW5kZXggKyAxXTtcbiAgICAgIHZhciB0ID0gSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvcih0aGlzLmludGVycG9sYXRpb24sIHZhbHVlLCBsb3dlciwgdXBwZXIpO1xuICAgICAgdmFyIG91dHB1dExvd2VyID0gb3V0cHV0c1tpbmRleF0uZXZhbHVhdGUoY3R4KTtcbiAgICAgIHZhciBvdXRwdXRVcHBlciA9IG91dHB1dHNbaW5kZXggKyAxXS5ldmFsdWF0ZShjdHgpO1xuXG4gICAgICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJ2ludGVycG9sYXRlJykge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVbdGhpcy50eXBlLmtpbmQudG9Mb3dlckNhc2UoKV0ob3V0cHV0TG93ZXIsIG91dHB1dFVwcGVyLCB0KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcGVyYXRvciA9PT0gJ2ludGVycG9sYXRlLWhjbCcpIHtcbiAgICAgICAgcmV0dXJuIGhjbC5yZXZlcnNlKGhjbC5pbnRlcnBvbGF0ZShoY2wuZm9yd2FyZChvdXRwdXRMb3dlciksIGhjbC5mb3J3YXJkKG91dHB1dFVwcGVyKSwgdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxhYi5yZXZlcnNlKGxhYi5pbnRlcnBvbGF0ZShsYWIuZm9yd2FyZChvdXRwdXRMb3dlciksIGxhYi5mb3J3YXJkKG91dHB1dFVwcGVyKSwgdCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICBmbih0aGlzLmlucHV0KTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjI2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5vdXRwdXRzKSxcbiAgICAgICAgICBfc3RlcDI2O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjI2LnMoKTsgIShfc3RlcDI2ID0gX2l0ZXJhdG9yMjYubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfZXhwcmVzc2lvbjUgPSBfc3RlcDI2LnZhbHVlO1xuICAgICAgICAgIGZuKF9leHByZXNzaW9uNSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyNi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyNi5mKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm91dHB1dERlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm91dHB1dHMuZXZlcnkoZnVuY3Rpb24gKG91dCkge1xuICAgICAgICByZXR1cm4gb3V0Lm91dHB1dERlZmluZWQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIGludGVycG9sYXRpb247XG5cbiAgICAgIGlmICh0aGlzLmludGVycG9sYXRpb24ubmFtZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgaW50ZXJwb2xhdGlvbiA9IFsnbGluZWFyJ107XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVycG9sYXRpb24uYmFzZSA9PT0gMSkge1xuICAgICAgICAgIGludGVycG9sYXRpb24gPSBbJ2xpbmVhciddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRpb24gPSBbJ2V4cG9uZW50aWFsJywgdGhpcy5pbnRlcnBvbGF0aW9uLmJhc2VdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnBvbGF0aW9uID0gWydjdWJpYy1iZXppZXInXS5jb25jYXQodGhpcy5pbnRlcnBvbGF0aW9uLmNvbnRyb2xQb2ludHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWFsaXplZCA9IFt0aGlzLm9wZXJhdG9yLCBpbnRlcnBvbGF0aW9uLCB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5sYWJlbHNbaV0sIHRoaXMub3V0cHV0c1tpXS5zZXJpYWxpemUoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImludGVycG9sYXRpb25GYWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGlvbkZhY3RvcihpbnRlcnBvbGF0aW9uLCBpbnB1dCwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICB2YXIgdCA9IDA7XG5cbiAgICAgIGlmIChpbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgdCA9IGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgaW50ZXJwb2xhdGlvbi5iYXNlLCBsb3dlciwgdXBwZXIpO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdsaW5lYXInKSB7XG4gICAgICAgIHQgPSBleHBvbmVudGlhbEludGVycG9sYXRpb24oaW5wdXQsIDEsIGxvd2VyLCB1cHBlcik7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb24ubmFtZSA9PT0gJ2N1YmljLWJlemllcicpIHtcbiAgICAgICAgdmFyIGMgPSBpbnRlcnBvbGF0aW9uLmNvbnRyb2xQb2ludHM7XG4gICAgICAgIHZhciB1YiA9IG5ldyB1bml0YmV6aWVyKGNbMF0sIGNbMV0sIGNbMl0sIGNbM10pO1xuICAgICAgICB0ID0gdWIuc29sdmUoZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCAxLCBsb3dlciwgdXBwZXIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfYXJncyA9IF90b0FycmF5KGFyZ3MpLFxuICAgICAgICAgIG9wZXJhdG9yID0gX2FyZ3NbMF0sXG4gICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IF9hcmdzWzFdLFxuICAgICAgICAgIGlucHV0ID0gX2FyZ3NbMl0sXG4gICAgICAgICAgcmVzdCA9IF9hcmdzLnNsaWNlKDMpO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW50ZXJwb2xhdGlvbikgfHwgaW50ZXJwb2xhdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBhbiBpbnRlcnBvbGF0aW9uIHR5cGUgZXhwcmVzc2lvbi5cIiwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlcnBvbGF0aW9uWzBdID09PSAnbGluZWFyJykge1xuICAgICAgICBpbnRlcnBvbGF0aW9uID0ge1xuICAgICAgICAgIG5hbWU6ICdsaW5lYXInXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgdmFyIGJhc2UgPSBpbnRlcnBvbGF0aW9uWzFdO1xuICAgICAgICBpZiAodHlwZW9mIGJhc2UgIT09ICdudW1iZXInKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cG9uZW50aWFsIGludGVycG9sYXRpb24gcmVxdWlyZXMgYSBudW1lcmljIGJhc2UuXCIsIDEsIDEpO1xuICAgICAgICBpbnRlcnBvbGF0aW9uID0ge1xuICAgICAgICAgIG5hbWU6ICdleHBvbmVudGlhbCcsXG4gICAgICAgICAgYmFzZTogYmFzZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0aW9uWzBdID09PSAnY3ViaWMtYmV6aWVyJykge1xuICAgICAgICB2YXIgY29udHJvbFBvaW50cyA9IGludGVycG9sYXRpb24uc2xpY2UoMSk7XG5cbiAgICAgICAgaWYgKGNvbnRyb2xQb2ludHMubGVuZ3RoICE9PSA0IHx8IGNvbnRyb2xQb2ludHMuc29tZShmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdCAhPT0gJ251bWJlcicgfHwgdCA8IDAgfHwgdCA+IDE7XG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0N1YmljIGJlemllciBpbnRlcnBvbGF0aW9uIHJlcXVpcmVzIGZvdXIgbnVtZXJpYyBhcmd1bWVudHMgd2l0aCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAxLicsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW50ZXJwb2xhdGlvbiA9IHtcbiAgICAgICAgICBuYW1lOiAnY3ViaWMtYmV6aWVyJyxcbiAgICAgICAgICBjb250cm9sUG9pbnRzOiBjb250cm9sUG9pbnRzXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIlVua25vd24gaW50ZXJwb2xhdGlvbiB0eXBlIFwiLmNvbmNhdChTdHJpbmcoaW50ZXJwb2xhdGlvblswXSkpLCAxLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoIC0gMSA8IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgXCIuY29uY2F0KGFyZ3MubGVuZ3RoIC0gMSwgXCIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChhcmdzLmxlbmd0aCAtIDEpICUgMiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7XG4gICAgICB9XG5cbiAgICAgIGlucHV0ID0gY29udGV4dC5wYXJzZShpbnB1dCwgMiwgTnVtYmVyVHlwZSk7XG4gICAgICBpZiAoIWlucHV0KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzdG9wcyA9IFtdO1xuICAgICAgdmFyIG91dHB1dFR5cGUgPSBudWxsO1xuXG4gICAgICBpZiAob3BlcmF0b3IgPT09ICdpbnRlcnBvbGF0ZS1oY2wnIHx8IG9wZXJhdG9yID09PSAnaW50ZXJwb2xhdGUtbGFiJykge1xuICAgICAgICBvdXRwdXRUeXBlID0gQ29sb3JUeXBlO1xuICAgICAgfSBlbHNlIGlmIChjb250ZXh0LmV4cGVjdGVkVHlwZSAmJiBjb250ZXh0LmV4cGVjdGVkVHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgIG91dHB1dFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHZhciBsYWJlbCA9IHJlc3RbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3RbaSArIDFdO1xuICAgICAgICB2YXIgbGFiZWxLZXkgPSBpICsgMztcbiAgICAgICAgdmFyIHZhbHVlS2V5ID0gaSArIDQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignSW5wdXQvb3V0cHV0IHBhaXJzIGZvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBkZWZpbmVkIHVzaW5nIGxpdGVyYWwgbnVtZXJpYyB2YWx1ZXMgKG5vdCBjb21wdXRlZCBleHByZXNzaW9ucykgZm9yIHRoZSBpbnB1dCB2YWx1ZXMuJywgbGFiZWxLZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0b3BzLmxlbmd0aCAmJiBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXVswXSA+PSBsYWJlbCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9ucyBtdXN0IGJlIGFycmFuZ2VkIHdpdGggaW5wdXQgdmFsdWVzIGluIHN0cmljdGx5IGFzY2VuZGluZyBvcmRlci4nLCBsYWJlbEtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFyc2VkID0gY29udGV4dC5wYXJzZSh2YWx1ZSwgdmFsdWVLZXksIG91dHB1dFR5cGUpO1xuICAgICAgICBpZiAoIXBhcnNlZCkgcmV0dXJuIG51bGw7XG4gICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHBhcnNlZC50eXBlO1xuICAgICAgICBzdG9wcy5wdXNoKFtsYWJlbCwgcGFyc2VkXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdXRwdXRUeXBlLmtpbmQgIT09ICdudW1iZXInICYmIG91dHB1dFR5cGUua2luZCAhPT0gJ2NvbG9yJyAmJiAhKG91dHB1dFR5cGUua2luZCA9PT0gJ2FycmF5JyAmJiBvdXRwdXRUeXBlLml0ZW1UeXBlLmtpbmQgPT09ICdudW1iZXInICYmIHR5cGVvZiBvdXRwdXRUeXBlLk4gPT09ICdudW1iZXInKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIlR5cGUgXCIuY29uY2F0KHRvU3RyaW5nKG91dHB1dFR5cGUpLCBcIiBpcyBub3QgaW50ZXJwb2xhdGFibGUuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBJbnRlcnBvbGF0ZShvdXRwdXRUeXBlLCBvcGVyYXRvciwgaW50ZXJwb2xhdGlvbiwgaW5wdXQsIHN0b3BzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW50ZXJwb2xhdGU7XG59KCk7XG5cbmZ1bmN0aW9uIGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgYmFzZSwgbG93ZXJWYWx1ZSwgdXBwZXJWYWx1ZSkge1xuICB2YXIgZGlmZmVyZW5jZSA9IHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlO1xuICB2YXIgcHJvZ3Jlc3MgPSBpbnB1dCAtIGxvd2VyVmFsdWU7XG5cbiAgaWYgKGRpZmZlcmVuY2UgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChiYXNlID09PSAxKSB7XG4gICAgcmV0dXJuIHByb2dyZXNzIC8gZGlmZmVyZW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKE1hdGgucG93KGJhc2UsIHByb2dyZXNzKSAtIDEpIC8gKE1hdGgucG93KGJhc2UsIGRpZmZlcmVuY2UpIC0gMSk7XG4gIH1cbn1cblxudmFyIENvYWxlc2NlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29hbGVzY2UodHlwZSwgYXJncykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2FsZXNjZSk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29hbGVzY2UsIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICB2YXIgYXJnQ291bnQgPSAwO1xuICAgICAgdmFyIHJlcXVlc3RlZEltYWdlTmFtZTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjI3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5hcmdzKSxcbiAgICAgICAgICBfc3RlcDI3O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjI3LnMoKTsgIShfc3RlcDI3ID0gX2l0ZXJhdG9yMjcubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBhcmcgPSBfc3RlcDI3LnZhbHVlO1xuICAgICAgICAgIGFyZ0NvdW50Kys7XG4gICAgICAgICAgcmVzdWx0ID0gYXJnLmV2YWx1YXRlKGN0eCk7XG5cbiAgICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCBpbnN0YW5jZW9mIFJlc29sdmVkSW1hZ2UgJiYgIXJlc3VsdC5hdmFpbGFibGUpIHtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdGVkSW1hZ2VOYW1lKSB7XG4gICAgICAgICAgICAgIHJlcXVlc3RlZEltYWdlTmFtZSA9IHJlc3VsdC5uYW1lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoYXJnQ291bnQgPT09IHRoaXMuYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVxdWVzdGVkSW1hZ2VOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMjcuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMjcuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm91dHB1dERlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnLm91dHB1dERlZmluZWQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2NvYWxlc2NlJ107XG4gICAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignRXhwZWN0ZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3V0cHV0VHlwZSA9IG51bGw7XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7XG5cbiAgICAgIGlmIChleHBlY3RlZFR5cGUgJiYgZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgb3V0cHV0VHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnNlZEFyZ3MgPSBbXTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjI4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYXJncy5zbGljZSgxKSksXG4gICAgICAgICAgX3N0ZXAyODtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyOC5zKCk7ICEoX3N0ZXAyOCA9IF9pdGVyYXRvcjI4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgYXJnID0gX3N0ZXAyOC52YWx1ZTtcbiAgICAgICAgICB2YXIgcGFyc2VkID0gY29udGV4dC5wYXJzZShhcmcsIDEgKyBwYXJzZWRBcmdzLmxlbmd0aCwgb3V0cHV0VHlwZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICB0eXBlQW5ub3RhdGlvbjogJ29taXQnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFwYXJzZWQpIHJldHVybiBudWxsO1xuICAgICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHBhcnNlZC50eXBlO1xuICAgICAgICAgIHBhcnNlZEFyZ3MucHVzaChwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMjguZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMjguZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmVlZHNBbm5vdGF0aW9uID0gZXhwZWN0ZWRUeXBlICYmIHBhcnNlZEFyZ3Muc29tZShmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBfY2hlY2tTdWJ0eXBlKGV4cGVjdGVkVHlwZSwgYXJnLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmVlZHNBbm5vdGF0aW9uID8gbmV3IENvYWxlc2NlKFZhbHVlVHlwZSwgcGFyc2VkQXJncykgOiBuZXcgQ29hbGVzY2Uob3V0cHV0VHlwZSwgcGFyc2VkQXJncyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvYWxlc2NlO1xufSgpO1xuXG52YXIgTGV0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGV0KGJpbmRpbmdzLCByZXN1bHQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGV0KTtcblxuICAgIHRoaXMudHlwZSA9IHJlc3VsdC50eXBlO1xuICAgIHRoaXMuYmluZGluZ3MgPSBbXS5jb25jYXQoYmluZGluZ3MpO1xuICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExldCwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXN1bHQuZXZhbHVhdGUoY3R4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgICAgdmFyIF9pdGVyYXRvcjI5ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5iaW5kaW5ncyksXG4gICAgICAgICAgX3N0ZXAyOTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyOS5zKCk7ICEoX3N0ZXAyOSA9IF9pdGVyYXRvcjI5Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgYmluZGluZyA9IF9zdGVwMjkudmFsdWU7XG4gICAgICAgICAgZm4oYmluZGluZ1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyOS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyOS5mKCk7XG4gICAgICB9XG5cbiAgICAgIGZuKHRoaXMucmVzdWx0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVzdWx0Lm91dHB1dERlZmluZWQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBzZXJpYWxpemVkID0gWydsZXQnXTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMwID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5iaW5kaW5ncyksXG4gICAgICAgICAgX3N0ZXAzMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzMC5zKCk7ICEoX3N0ZXAzMCA9IF9pdGVyYXRvcjMwLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAzMCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMzAudmFsdWUsIDIpLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0ZXAzMCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgZXhwciA9IF9zdGVwMzAkdmFsdWVbMV07XG5cbiAgICAgICAgICBzZXJpYWxpemVkLnB1c2gobmFtZSwgZXhwci5zZXJpYWxpemUoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzMC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzMC5mKCk7XG4gICAgICB9XG5cbiAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLnJlc3VsdC5zZXJpYWxpemUoKSk7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCA0KSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IDMgYXJndW1lbnRzLCBidXQgZm91bmQgXCIuY29uY2F0KGFyZ3MubGVuZ3RoIC0gMSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgdmFyIGJpbmRpbmdzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBhcmdzW2ldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIHN0cmluZywgYnV0IGZvdW5kIFwiLmNvbmNhdCh0eXBlb2YgbmFtZSwgXCIgaW5zdGVhZC5cIiksIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9bXmEtekEtWjAtOV9dLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJWYXJpYWJsZSBuYW1lcyBtdXN0IGNvbnRhaW4gb25seSBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBvciAnXycuXCIsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlID0gY29udGV4dC5wYXJzZShhcmdzW2kgKyAxXSwgaSArIDEpO1xuICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgYmluZGluZ3MucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBhcmdzLmxlbmd0aCAtIDEsIGNvbnRleHQuZXhwZWN0ZWRUeXBlLCBiaW5kaW5ncyk7XG4gICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbmV3IExldChiaW5kaW5ncywgcmVzdWx0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGV0O1xufSgpO1xuXG52YXIgQXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBdCh0eXBlLCBpbmRleCwgaW5wdXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXQpO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEF0LCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXguZXZhbHVhdGUoY3R4KTtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kczogXCIuY29uY2F0KGluZGV4LCBcIiA8IDAuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ID49IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiQXJyYXkgaW5kZXggb3V0IG9mIGJvdW5kczogXCIuY29uY2F0KGluZGV4LCBcIiA+IFwiKS5jb25jYXQoYXJyYXkubGVuZ3RoIC0gMSwgXCIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICE9PSBNYXRoLmZsb29yKGluZGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiQXJyYXkgaW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZm91bmQgXCIuY29uY2F0KGluZGV4LCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheVtpbmRleF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIGZuKHRoaXMuaW5kZXgpO1xuICAgICAgZm4odGhpcy5pbnB1dCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm91dHB1dERlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiBbJ2F0JywgdGhpcy5pbmRleC5zZXJpYWxpemUoKSwgdGhpcy5pbnB1dC5zZXJpYWxpemUoKV07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAzKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgXCIuY29uY2F0KGFyZ3MubGVuZ3RoIC0gMSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgdmFyIGluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBOdW1iZXJUeXBlKTtcbiAgICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgYXJyYXkoY29udGV4dC5leHBlY3RlZFR5cGUgfHwgVmFsdWVUeXBlKSk7XG4gICAgICBpZiAoIWluZGV4IHx8ICFpbnB1dCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgdCA9IGlucHV0LnR5cGU7XG4gICAgICByZXR1cm4gbmV3IEF0KHQuaXRlbVR5cGUsIGluZGV4LCBpbnB1dCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEF0O1xufSgpO1xuXG52YXIgSW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbihuZWVkbGUsIGhheXN0YWNrKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluKTtcblxuICAgIHRoaXMudHlwZSA9IEJvb2xlYW5UeXBlO1xuICAgIHRoaXMubmVlZGxlID0gbmVlZGxlO1xuICAgIHRoaXMuaGF5c3RhY2sgPSBoYXlzdGFjaztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbiwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICB2YXIgbmVlZGxlID0gdGhpcy5uZWVkbGUuZXZhbHVhdGUoY3R4KTtcbiAgICAgIHZhciBoYXlzdGFjayA9IHRoaXMuaGF5c3RhY2suZXZhbHVhdGUoY3R4KTtcbiAgICAgIGlmICghaGF5c3RhY2spIHJldHVybiBmYWxzZTtcblxuICAgICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShuZWVkbGUsIFsnYm9vbGVhbicsICdzdHJpbmcnLCAnbnVtYmVyJywgJ251bGwnXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kIFwiLmNvbmNhdCh0b1N0cmluZyh0eXBlT2YobmVlZGxlKSksIFwiIGluc3RlYWQuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShoYXlzdGFjaywgWydzdHJpbmcnLCAnYXJyYXknXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIkV4cGVjdGVkIHNlY29uZCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGFycmF5IG9yIHN0cmluZywgYnV0IGZvdW5kIFwiLmNvbmNhdCh0b1N0cmluZyh0eXBlT2YoaGF5c3RhY2spKSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpID49IDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIGZuKHRoaXMubmVlZGxlKTtcbiAgICAgIGZuKHRoaXMuaGF5c3RhY2spO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiBbJ2luJywgdGhpcy5uZWVkbGUuc2VyaWFsaXplKCksIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKCldO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMykge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIDIgYXJndW1lbnRzLCBidXQgZm91bmQgXCIuY29uY2F0KGFyZ3MubGVuZ3RoIC0gMSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmVlZGxlID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgICAgdmFyIGhheXN0YWNrID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBWYWx1ZVR5cGUpO1xuICAgICAgaWYgKCFuZWVkbGUgfHwgIWhheXN0YWNrKSByZXR1cm4gbnVsbDtcblxuICAgICAgaWYgKCFpc1ZhbGlkVHlwZShuZWVkbGUudHlwZSwgW0Jvb2xlYW5UeXBlLCBTdHJpbmdUeXBlLCBOdW1iZXJUeXBlLCBOdWxsVHlwZSwgVmFsdWVUeXBlXSkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCBcIi5jb25jYXQodG9TdHJpbmcobmVlZGxlLnR5cGUpLCBcIiBpbnN0ZWFkXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBJbihuZWVkbGUsIGhheXN0YWNrKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW47XG59KCk7XG5cbnZhciBJbmRleE9mID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW5kZXhPZihuZWVkbGUsIGhheXN0YWNrLCBmcm9tSW5kZXgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5kZXhPZik7XG5cbiAgICB0aGlzLnR5cGUgPSBOdW1iZXJUeXBlO1xuICAgIHRoaXMubmVlZGxlID0gbmVlZGxlO1xuICAgIHRoaXMuaGF5c3RhY2sgPSBoYXlzdGFjaztcbiAgICB0aGlzLmZyb21JbmRleCA9IGZyb21JbmRleDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbmRleE9mLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZShjdHgpO1xuICAgICAgdmFyIGhheXN0YWNrID0gdGhpcy5oYXlzdGFjay5ldmFsdWF0ZShjdHgpO1xuXG4gICAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKG5lZWRsZSwgWydib29sZWFuJywgJ3N0cmluZycsICdudW1iZXInLCAnbnVsbCddKSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgXCIuY29uY2F0KHRvU3RyaW5nKHR5cGVPZihuZWVkbGUpKSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKGhheXN0YWNrLCBbJ3N0cmluZycsICdhcnJheSddKSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiRXhwZWN0ZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgXCIuY29uY2F0KHRvU3RyaW5nKHR5cGVPZihoYXlzdGFjaykpLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZyb21JbmRleCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gdGhpcy5mcm9tSW5kZXguZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgcmV0dXJuIGhheXN0YWNrLmluZGV4T2YobmVlZGxlLCBmcm9tSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICBmbih0aGlzLm5lZWRsZSk7XG4gICAgICBmbih0aGlzLmhheXN0YWNrKTtcblxuICAgICAgaWYgKHRoaXMuZnJvbUluZGV4KSB7XG4gICAgICAgIGZuKHRoaXMuZnJvbUluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgaWYgKHRoaXMuZnJvbUluZGV4ICE9IG51bGwgJiYgdGhpcy5mcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gdGhpcy5mcm9tSW5kZXguc2VyaWFsaXplKCk7XG4gICAgICAgIHJldHVybiBbJ2luZGV4LW9mJywgdGhpcy5uZWVkbGUuc2VyaWFsaXplKCksIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKCksIGZyb21JbmRleF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbJ2luZGV4LW9mJywgdGhpcy5uZWVkbGUuc2VyaWFsaXplKCksIHRoaXMuaGF5c3RhY2suc2VyaWFsaXplKCldO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8PSAyIHx8IGFyZ3MubGVuZ3RoID49IDUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCAzIG9yIDQgYXJndW1lbnRzLCBidXQgZm91bmQgXCIuY29uY2F0KGFyZ3MubGVuZ3RoIC0gMSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmVlZGxlID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgICAgdmFyIGhheXN0YWNrID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBWYWx1ZVR5cGUpO1xuICAgICAgaWYgKCFuZWVkbGUgfHwgIWhheXN0YWNrKSByZXR1cm4gbnVsbDtcblxuICAgICAgaWYgKCFpc1ZhbGlkVHlwZShuZWVkbGUudHlwZSwgW0Jvb2xlYW5UeXBlLCBTdHJpbmdUeXBlLCBOdW1iZXJUeXBlLCBOdWxsVHlwZSwgVmFsdWVUeXBlXSkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCBcIi5jb25jYXQodG9TdHJpbmcobmVlZGxlLnR5cGUpLCBcIiBpbnN0ZWFkXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSBjb250ZXh0LnBhcnNlKGFyZ3NbM10sIDMsIE51bWJlclR5cGUpO1xuICAgICAgICBpZiAoIWZyb21JbmRleCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgSW5kZXhPZihuZWVkbGUsIGhheXN0YWNrLCBmcm9tSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbmRleE9mO1xufSgpO1xuXG52YXIgTWF0Y2ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYXRjaChpbnB1dFR5cGUsIG91dHB1dFR5cGUsIGlucHV0LCBjYXNlcywgb3V0cHV0cywgb3RoZXJ3aXNlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hdGNoKTtcblxuICAgIHRoaXMuaW5wdXRUeXBlID0gaW5wdXRUeXBlO1xuICAgIHRoaXMudHlwZSA9IG91dHB1dFR5cGU7XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMuY2FzZXMgPSBjYXNlcztcbiAgICB0aGlzLm91dHB1dHMgPSBvdXRwdXRzO1xuICAgIHRoaXMub3RoZXJ3aXNlID0gb3RoZXJ3aXNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1hdGNoLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICAgIHZhciBvdXRwdXQgPSB0eXBlT2YoaW5wdXQpID09PSB0aGlzLmlucHV0VHlwZSAmJiB0aGlzLm91dHB1dHNbdGhpcy5jYXNlc1tpbnB1dF1dIHx8IHRoaXMub3RoZXJ3aXNlO1xuICAgICAgcmV0dXJuIG91dHB1dC5ldmFsdWF0ZShjdHgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICBmbih0aGlzLmlucHV0KTtcbiAgICAgIHRoaXMub3V0cHV0cy5mb3JFYWNoKGZuKTtcbiAgICAgIGZuKHRoaXMub3RoZXJ3aXNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHJldHVybiBvdXQub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSkgJiYgdGhpcy5vdGhlcndpc2Uub3V0cHV0RGVmaW5lZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBzZXJpYWxpemVkID0gWydtYXRjaCcsIHRoaXMuaW5wdXQuc2VyaWFsaXplKCldO1xuICAgICAgdmFyIHNvcnRlZExhYmVscyA9IE9iamVjdC5rZXlzKHRoaXMuY2FzZXMpLnNvcnQoKTtcbiAgICAgIHZhciBncm91cGVkQnlPdXRwdXQgPSBbXTtcbiAgICAgIHZhciBvdXRwdXRMb29rdXAgPSB7fTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMxID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc29ydGVkTGFiZWxzKSxcbiAgICAgICAgICBfc3RlcDMxO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMxLnMoKTsgIShfc3RlcDMxID0gX2l0ZXJhdG9yMzEubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBsYWJlbCA9IF9zdGVwMzEudmFsdWU7XG4gICAgICAgICAgdmFyIF9vdXRwdXRJbmRleCA9IG91dHB1dExvb2t1cFt0aGlzLmNhc2VzW2xhYmVsXV07XG5cbiAgICAgICAgICBpZiAoX291dHB1dEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG91dHB1dExvb2t1cFt0aGlzLmNhc2VzW2xhYmVsXV0gPSBncm91cGVkQnlPdXRwdXQubGVuZ3RoO1xuICAgICAgICAgICAgZ3JvdXBlZEJ5T3V0cHV0LnB1c2goW3RoaXMuY2FzZXNbbGFiZWxdLCBbbGFiZWxdXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3VwZWRCeU91dHB1dFtfb3V0cHV0SW5kZXhdWzFdLnB1c2gobGFiZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMxLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMxLmYoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvZXJjZUxhYmVsID0gZnVuY3Rpb24gY29lcmNlTGFiZWwobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5pbnB1dFR5cGUua2luZCA9PT0gJ251bWJlcicgPyBOdW1iZXIobGFiZWwpIDogbGFiZWw7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfaTYgPSAwLCBfZ3JvdXBlZEJ5T3V0cHV0ID0gZ3JvdXBlZEJ5T3V0cHV0OyBfaTYgPCBfZ3JvdXBlZEJ5T3V0cHV0Lmxlbmd0aDsgX2k2KyspIHtcbiAgICAgICAgdmFyIF9ncm91cGVkQnlPdXRwdXQkX2kgPSBfc2xpY2VkVG9BcnJheShfZ3JvdXBlZEJ5T3V0cHV0W19pNl0sIDIpLFxuICAgICAgICAgICAgb3V0cHV0SW5kZXggPSBfZ3JvdXBlZEJ5T3V0cHV0JF9pWzBdLFxuICAgICAgICAgICAgbGFiZWxzID0gX2dyb3VwZWRCeU91dHB1dCRfaVsxXTtcblxuICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChjb2VyY2VMYWJlbChsYWJlbHNbMF0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXJpYWxpemVkLnB1c2gobGFiZWxzLm1hcChjb2VyY2VMYWJlbCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKHRoaXMub3V0cHV0c1tvdXRwdXRJbmRleF0uc2VyaWFsaXplKCkpO1xuICAgICAgfVxuXG4gICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5vdGhlcndpc2Uuc2VyaWFsaXplKCkpO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgNSkgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgXCIuY29uY2F0KGFyZ3MubGVuZ3RoIC0gMSwgXCIuXCIpKTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAlIDIgIT09IDEpIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLlwiKTtcbiAgICAgIHZhciBpbnB1dFR5cGU7XG4gICAgICB2YXIgb3V0cHV0VHlwZTtcblxuICAgICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FzZXMgPSB7fTtcbiAgICAgIHZhciBvdXRwdXRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJncy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGxhYmVscyA9IGFyZ3NbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbaSArIDFdO1xuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsYWJlbHMpKSB7XG4gICAgICAgICAgbGFiZWxzID0gW2xhYmVsc107XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFiZWxDb250ZXh0ID0gY29udGV4dC5jb25jYXQoaSk7XG5cbiAgICAgICAgaWYgKGxhYmVscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKCdFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYnJhbmNoIGxhYmVsLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvcjMyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobGFiZWxzKSxcbiAgICAgICAgICAgIF9zdGVwMzI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMyLnMoKTsgIShfc3RlcDMyID0gX2l0ZXJhdG9yMzIubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gX3N0ZXAzMi52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGxhYmVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKFwiQnJhbmNoIGxhYmVscyBtdXN0IGJlIG51bWJlcnMgb3Igc3RyaW5ncy5cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ251bWJlcicgJiYgTWF0aC5hYnMobGFiZWwpID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcihcIkJyYW5jaCBsYWJlbHMgbXVzdCBiZSBpbnRlZ2VycyBubyBsYXJnZXIgdGhhbiBcIi5jb25jYXQoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIFwiLlwiKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsYWJlbCA9PT0gJ251bWJlcicgJiYgTWF0aC5mbG9vcihsYWJlbCkgIT09IGxhYmVsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoXCJOdW1lcmljIGJyYW5jaCBsYWJlbHMgbXVzdCBiZSBpbnRlZ2VyIHZhbHVlcy5cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dFR5cGUpIHtcbiAgICAgICAgICAgICAgaW5wdXRUeXBlID0gdHlwZU9mKGxhYmVsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxDb250ZXh0LmNoZWNrU3VidHlwZShpbnB1dFR5cGUsIHR5cGVPZihsYWJlbCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhc2VzW1N0cmluZyhsYWJlbCldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKCdCcmFuY2ggbGFiZWxzIG11c3QgYmUgdW5pcXVlLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlc1tTdHJpbmcobGFiZWwpXSA9IG91dHB1dHMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMzIuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjMyLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBjb250ZXh0LnBhcnNlKHZhbHVlLCBpLCBvdXRwdXRUeXBlKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybiBudWxsO1xuICAgICAgICBvdXRwdXRUeXBlID0gb3V0cHV0VHlwZSB8fCByZXN1bHQudHlwZTtcbiAgICAgICAgb3V0cHV0cy5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTtcbiAgICAgIGlmICghaW5wdXQpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG90aGVyd2lzZSA9IGNvbnRleHQucGFyc2UoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBhcmdzLmxlbmd0aCAtIDEsIG91dHB1dFR5cGUpO1xuICAgICAgaWYgKCFvdGhlcndpc2UpIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAoaW5wdXQudHlwZS5raW5kICE9PSAndmFsdWUnICYmIGNvbnRleHQuY29uY2F0KDEpLmNoZWNrU3VidHlwZShpbnB1dFR5cGUsIGlucHV0LnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IE1hdGNoKGlucHV0VHlwZSwgb3V0cHV0VHlwZSwgaW5wdXQsIGNhc2VzLCBvdXRwdXRzLCBvdGhlcndpc2UpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNYXRjaDtcbn0oKTtcblxudmFyIENhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDYXNlKHR5cGUsIGJyYW5jaGVzLCBvdGhlcndpc2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FzZSk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYnJhbmNoZXMgPSBicmFuY2hlcztcbiAgICB0aGlzLm90aGVyd2lzZSA9IG90aGVyd2lzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDYXNlLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IzMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuYnJhbmNoZXMpLFxuICAgICAgICAgIF9zdGVwMzM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMzMucygpOyAhKF9zdGVwMzMgPSBfaXRlcmF0b3IzMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMzMkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDMzLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgdGVzdCA9IF9zdGVwMzMkdmFsdWVbMF0sXG4gICAgICAgICAgICAgIF9leHByZXNzaW9uNiA9IF9zdGVwMzMkdmFsdWVbMV07XG5cbiAgICAgICAgICBpZiAodGVzdC5ldmFsdWF0ZShjdHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gX2V4cHJlc3Npb242LmV2YWx1YXRlKGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMzMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMzMuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5vdGhlcndpc2UuZXZhbHVhdGUoY3R4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgICAgdmFyIF9pdGVyYXRvcjM0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5icmFuY2hlcyksXG4gICAgICAgICAgX3N0ZXAzNDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzNC5zKCk7ICEoX3N0ZXAzNCA9IF9pdGVyYXRvcjM0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAzNCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMzQudmFsdWUsIDIpLFxuICAgICAgICAgICAgICB0ZXN0ID0gX3N0ZXAzNCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgX2V4cHJlc3Npb243ID0gX3N0ZXAzNCR2YWx1ZVsxXTtcblxuICAgICAgICAgIGZuKHRlc3QpO1xuICAgICAgICAgIGZuKF9leHByZXNzaW9uNyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzNC5mKCk7XG4gICAgICB9XG5cbiAgICAgIGZuKHRoaXMub3RoZXJ3aXNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnJhbmNoZXMuZXZlcnkoZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgIHZhciBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAyKSxcbiAgICAgICAgICAgIF8gPSBfcmVmNlswXSxcbiAgICAgICAgICAgIG91dCA9IF9yZWY2WzFdO1xuXG4gICAgICAgIHJldHVybiBvdXQub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSkgJiYgdGhpcy5vdGhlcndpc2Uub3V0cHV0RGVmaW5lZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2Nhc2UnXTtcbiAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCA0KSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IDMgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSBcIi5jb25jYXQoYXJncy5sZW5ndGggLSAxLCBcIi5cIikpO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICUgMiAhPT0gMCkgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBhbiBvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7XG4gICAgICB2YXIgb3V0cHV0VHlwZTtcblxuICAgICAgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgICAgfVxuXG4gICAgICB2YXIgYnJhbmNoZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICB2YXIgdGVzdCA9IGNvbnRleHQucGFyc2UoYXJnc1tpXSwgaSwgQm9vbGVhblR5cGUpO1xuICAgICAgICBpZiAoIXRlc3QpIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29udGV4dC5wYXJzZShhcmdzW2kgKyAxXSwgaSArIDEsIG91dHB1dFR5cGUpO1xuICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIG51bGw7XG4gICAgICAgIGJyYW5jaGVzLnB1c2goW3Rlc3QsIHJlc3VsdF0pO1xuICAgICAgICBvdXRwdXRUeXBlID0gb3V0cHV0VHlwZSB8fCByZXN1bHQudHlwZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG90aGVyd2lzZSA9IGNvbnRleHQucGFyc2UoYXJnc1thcmdzLmxlbmd0aCAtIDFdLCBhcmdzLmxlbmd0aCAtIDEsIG91dHB1dFR5cGUpO1xuICAgICAgaWYgKCFvdGhlcndpc2UpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBDYXNlKG91dHB1dFR5cGUsIGJyYW5jaGVzLCBvdGhlcndpc2UpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDYXNlO1xufSgpO1xuXG52YXIgU2xpY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTbGljZSh0eXBlLCBpbnB1dCwgYmVnaW5JbmRleCwgZW5kSW5kZXgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpY2UpO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5iZWdpbkluZGV4ID0gYmVnaW5JbmRleDtcbiAgICB0aGlzLmVuZEluZGV4ID0gZW5kSW5kZXg7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2xpY2UsIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgICAgdmFyIGJlZ2luSW5kZXggPSB0aGlzLmJlZ2luSW5kZXguZXZhbHVhdGUoY3R4KTtcblxuICAgICAgaWYgKCFpc1ZhbGlkTmF0aXZlVHlwZShpbnB1dCwgWydzdHJpbmcnLCAnYXJyYXknXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgXCIuY29uY2F0KHRvU3RyaW5nKHR5cGVPZihpbnB1dCkpLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVuZEluZGV4KSB7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IHRoaXMuZW5kSW5kZXguZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKGJlZ2luSW5kZXgsIGVuZEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlucHV0LnNsaWNlKGJlZ2luSW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICBmbih0aGlzLmlucHV0KTtcbiAgICAgIGZuKHRoaXMuYmVnaW5JbmRleCk7XG5cbiAgICAgIGlmICh0aGlzLmVuZEluZGV4KSB7XG4gICAgICAgIGZuKHRoaXMuZW5kSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICBpZiAodGhpcy5lbmRJbmRleCAhPSBudWxsICYmIHRoaXMuZW5kSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZW5kSW5kZXggPSB0aGlzLmVuZEluZGV4LnNlcmlhbGl6ZSgpO1xuICAgICAgICByZXR1cm4gWydzbGljZScsIHRoaXMuaW5wdXQuc2VyaWFsaXplKCksIHRoaXMuYmVnaW5JbmRleC5zZXJpYWxpemUoKSwgZW5kSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gWydzbGljZScsIHRoaXMuaW5wdXQuc2VyaWFsaXplKCksIHRoaXMuYmVnaW5JbmRleC5zZXJpYWxpemUoKV07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDIgfHwgYXJncy5sZW5ndGggPj0gNSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIDMgb3IgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCBcIi5jb25jYXQoYXJncy5sZW5ndGggLSAxLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTtcbiAgICAgIHZhciBiZWdpbkluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBOdW1iZXJUeXBlKTtcbiAgICAgIGlmICghaW5wdXQgfHwgIWJlZ2luSW5kZXgpIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAoIWlzVmFsaWRUeXBlKGlucHV0LnR5cGUsIFthcnJheShWYWx1ZVR5cGUpLCBTdHJpbmdUeXBlLCBWYWx1ZVR5cGVdKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgXCIuY29uY2F0KHRvU3RyaW5nKGlucHV0LnR5cGUpLCBcIiBpbnN0ZWFkXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1szXSwgMywgTnVtYmVyVHlwZSk7XG4gICAgICAgIGlmICghZW5kSW5kZXgpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGlucHV0LnR5cGUsIGlucHV0LCBiZWdpbkluZGV4LCBlbmRJbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGlucHV0LnR5cGUsIGlucHV0LCBiZWdpbkluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2xpY2U7XG59KCk7XG5cbmZ1bmN0aW9uIGlzQ29tcGFyYWJsZVR5cGUob3AsIHR5cGUpIHtcbiAgaWYgKG9wID09PSAnPT0nIHx8IG9wID09PSAnIT0nKSB7XG4gICAgcmV0dXJuIHR5cGUua2luZCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGUua2luZCA9PT0gJ3N0cmluZycgfHwgdHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCB0eXBlLmtpbmQgPT09ICdudWxsJyB8fCB0eXBlLmtpbmQgPT09ICd2YWx1ZSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHR5cGUua2luZCA9PT0gJ3N0cmluZycgfHwgdHlwZS5raW5kID09PSAnbnVtYmVyJyB8fCB0eXBlLmtpbmQgPT09ICd2YWx1ZSc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXEoY3R4LCBhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG5mdW5jdGlvbiBuZXEoY3R4LCBhLCBiKSB7XG4gIHJldHVybiBhICE9PSBiO1xufVxuXG5mdW5jdGlvbiBsdChjdHgsIGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiO1xufVxuXG5mdW5jdGlvbiBndChjdHgsIGEsIGIpIHtcbiAgcmV0dXJuIGEgPiBiO1xufVxuXG5mdW5jdGlvbiBsdGVxKGN0eCwgYSwgYikge1xuICByZXR1cm4gYSA8PSBiO1xufVxuXG5mdW5jdGlvbiBndGVxKGN0eCwgYSwgYikge1xuICByZXR1cm4gYSA+PSBiO1xufVxuXG5mdW5jdGlvbiBlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPT09IDA7XG59XG5cbmZ1bmN0aW9uIG5lcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gIHJldHVybiAhZXFDb2xsYXRlKGN0eCwgYSwgYiwgYyk7XG59XG5cbmZ1bmN0aW9uIGx0Q29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA8IDA7XG59XG5cbmZ1bmN0aW9uIGd0Q29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA+IDA7XG59XG5cbmZ1bmN0aW9uIGx0ZXFDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICByZXR1cm4gYy5jb21wYXJlKGEsIGIpIDw9IDA7XG59XG5cbmZ1bmN0aW9uIGd0ZXFDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICByZXR1cm4gYy5jb21wYXJlKGEsIGIpID49IDA7XG59XG5cbmZ1bmN0aW9uIG1ha2VDb21wYXJpc29uKG9wLCBjb21wYXJlQmFzaWMsIGNvbXBhcmVXaXRoQ29sbGF0b3IpIHtcbiAgdmFyIGlzT3JkZXJDb21wYXJpc29uID0gb3AgIT09ICc9PScgJiYgb3AgIT09ICchPSc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbXBhcmlzb24obGhzLCByaHMsIGNvbGxhdG9yKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGFyaXNvbik7XG5cbiAgICAgIHRoaXMudHlwZSA9IEJvb2xlYW5UeXBlO1xuICAgICAgdGhpcy5saHMgPSBsaHM7XG4gICAgICB0aGlzLnJocyA9IHJocztcbiAgICAgIHRoaXMuY29sbGF0b3IgPSBjb2xsYXRvcjtcbiAgICAgIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50ID0gbGhzLnR5cGUua2luZCA9PT0gJ3ZhbHVlJyB8fCByaHMudHlwZS5raW5kID09PSAndmFsdWUnO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDb21wYXJpc29uLCBbe1xuICAgICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICAgIHZhciBsaHMgPSB0aGlzLmxocy5ldmFsdWF0ZShjdHgpO1xuICAgICAgICB2YXIgcmhzID0gdGhpcy5yaHMuZXZhbHVhdGUoY3R4KTtcblxuICAgICAgICBpZiAoaXNPcmRlckNvbXBhcmlzb24gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHtcbiAgICAgICAgICB2YXIgX2x0ID0gdHlwZU9mKGxocyk7XG5cbiAgICAgICAgICB2YXIgcnQgPSB0eXBlT2YocmhzKTtcblxuICAgICAgICAgIGlmIChfbHQua2luZCAhPT0gcnQua2luZCB8fCAhKF9sdC5raW5kID09PSAnc3RyaW5nJyB8fCBfbHQua2luZCA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiRXhwZWN0ZWQgYXJndW1lbnRzIGZvciBcXFwiXCIuY29uY2F0KG9wLCBcIlxcXCIgdG8gYmUgKHN0cmluZywgc3RyaW5nKSBvciAobnVtYmVyLCBudW1iZXIpLCBidXQgZm91bmQgKFwiKS5jb25jYXQoX2x0LmtpbmQsIFwiLCBcIikuY29uY2F0KHJ0LmtpbmQsIFwiKSBpbnN0ZWFkLlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29sbGF0b3IgJiYgIWlzT3JkZXJDb21wYXJpc29uICYmIHRoaXMuaGFzVW50eXBlZEFyZ3VtZW50KSB7XG4gICAgICAgICAgdmFyIF9sdDIgPSB0eXBlT2YobGhzKTtcblxuICAgICAgICAgIHZhciBfcnQgPSB0eXBlT2YocmhzKTtcblxuICAgICAgICAgIGlmIChfbHQyLmtpbmQgIT09ICdzdHJpbmcnIHx8IF9ydC5raW5kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVCYXNpYyhjdHgsIGxocywgcmhzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsYXRvciA/IGNvbXBhcmVXaXRoQ29sbGF0b3IoY3R4LCBsaHMsIHJocywgdGhpcy5jb2xsYXRvci5ldmFsdWF0ZShjdHgpKSA6IGNvbXBhcmVCYXNpYyhjdHgsIGxocywgcmhzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICAgIGZuKHRoaXMubGhzKTtcbiAgICAgICAgZm4odGhpcy5yaHMpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbGxhdG9yKSB7XG4gICAgICAgICAgZm4odGhpcy5jb2xsYXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkID0gW29wXTtcbiAgICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAga2V5OiBcInBhcnNlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDMgJiYgYXJncy5sZW5ndGggIT09IDQpIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cIik7XG4gICAgICAgIHZhciBvcCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBsaHMgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgICAgIGlmICghbGhzKSByZXR1cm4gbnVsbDtcblxuICAgICAgICBpZiAoIWlzQ29tcGFyYWJsZVR5cGUob3AsIGxocy50eXBlKSkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNvbmNhdCgxKS5lcnJvcihcIlxcXCJcIi5jb25jYXQob3AsIFwiXFxcIiBjb21wYXJpc29ucyBhcmUgbm90IHN1cHBvcnRlZCBmb3IgdHlwZSAnXCIpLmNvbmNhdCh0b1N0cmluZyhsaHMudHlwZSksIFwiJy5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJocyA9IGNvbnRleHQucGFyc2UoYXJnc1syXSwgMiwgVmFsdWVUeXBlKTtcbiAgICAgICAgaWYgKCFyaHMpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGlmICghaXNDb21wYXJhYmxlVHlwZShvcCwgcmhzLnR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uY2F0KDIpLmVycm9yKFwiXFxcIlwiLmNvbmNhdChvcCwgXCJcXFwiIGNvbXBhcmlzb25zIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0eXBlICdcIikuY29uY2F0KHRvU3RyaW5nKHJocy50eXBlKSwgXCInLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGhzLnR5cGUua2luZCAhPT0gcmhzLnR5cGUua2luZCAmJiBsaHMudHlwZS5raW5kICE9PSAndmFsdWUnICYmIHJocy50eXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkNhbm5vdCBjb21wYXJlIHR5cGVzICdcIi5jb25jYXQodG9TdHJpbmcobGhzLnR5cGUpLCBcIicgYW5kICdcIikuY29uY2F0KHRvU3RyaW5nKHJocy50eXBlKSwgXCInLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPcmRlckNvbXBhcmlzb24pIHtcbiAgICAgICAgICBpZiAobGhzLnR5cGUua2luZCA9PT0gJ3ZhbHVlJyAmJiByaHMudHlwZS5raW5kICE9PSAndmFsdWUnKSB7XG4gICAgICAgICAgICBsaHMgPSBuZXcgQXNzZXJ0aW9uKHJocy50eXBlLCBbbGhzXSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaHMudHlwZS5raW5kICE9PSAndmFsdWUnICYmIHJocy50eXBlLmtpbmQgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIHJocyA9IG5ldyBBc3NlcnRpb24obGhzLnR5cGUsIFtyaHNdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sbGF0b3IgPSBudWxsO1xuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIGlmIChsaHMudHlwZS5raW5kICE9PSAnc3RyaW5nJyAmJiByaHMudHlwZS5raW5kICE9PSAnc3RyaW5nJyAmJiBsaHMudHlwZS5raW5kICE9PSAndmFsdWUnICYmIHJocy50eXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiQ2Fubm90IHVzZSBjb2xsYXRvciB0byBjb21wYXJlIG5vbi1zdHJpbmcgdHlwZXMuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbGxhdG9yID0gY29udGV4dC5wYXJzZShhcmdzWzNdLCAzLCBDb2xsYXRvclR5cGUpO1xuICAgICAgICAgIGlmICghY29sbGF0b3IpIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb21wYXJpc29uKGxocywgcmhzLCBjb2xsYXRvcik7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENvbXBhcmlzb247XG4gIH0oKTtcbn1cblxudmFyIEVxdWFscyA9IG1ha2VDb21wYXJpc29uKCc9PScsIGVxLCBlcUNvbGxhdGUpO1xudmFyIE5vdEVxdWFscyA9IG1ha2VDb21wYXJpc29uKCchPScsIG5lcSwgbmVxQ29sbGF0ZSk7XG52YXIgTGVzc1RoYW4gPSBtYWtlQ29tcGFyaXNvbignPCcsIGx0LCBsdENvbGxhdGUpO1xudmFyIEdyZWF0ZXJUaGFuID0gbWFrZUNvbXBhcmlzb24oJz4nLCBndCwgZ3RDb2xsYXRlKTtcbnZhciBMZXNzVGhhbk9yRXF1YWwgPSBtYWtlQ29tcGFyaXNvbignPD0nLCBsdGVxLCBsdGVxQ29sbGF0ZSk7XG52YXIgR3JlYXRlclRoYW5PckVxdWFsID0gbWFrZUNvbXBhcmlzb24oJz49JywgZ3RlcSwgZ3RlcUNvbGxhdGUpO1xuXG52YXIgTnVtYmVyRm9ybWF0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTnVtYmVyRm9ybWF0KG51bWJlciwgbG9jYWxlLCBjdXJyZW5jeSwgbWluRnJhY3Rpb25EaWdpdHMsIG1heEZyYWN0aW9uRGlnaXRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE51bWJlckZvcm1hdCk7XG5cbiAgICB0aGlzLnR5cGUgPSBTdHJpbmdUeXBlO1xuICAgIHRoaXMubnVtYmVyID0gbnVtYmVyO1xuICAgIHRoaXMubG9jYWxlID0gbG9jYWxlO1xuICAgIHRoaXMuY3VycmVuY3kgPSBjdXJyZW5jeTtcbiAgICB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID0gbWluRnJhY3Rpb25EaWdpdHM7XG4gICAgdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cyA9IG1heEZyYWN0aW9uRGlnaXRzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE51bWJlckZvcm1hdCwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUuZXZhbHVhdGUoY3R4KSA6IFtdLCB7XG4gICAgICAgIHN0eWxlOiB0aGlzLmN1cnJlbmN5ID8gJ2N1cnJlbmN5JyA6ICdkZWNpbWFsJyxcbiAgICAgICAgY3VycmVuY3k6IHRoaXMuY3VycmVuY3kgPyB0aGlzLmN1cnJlbmN5LmV2YWx1YXRlKGN0eCkgOiB1bmRlZmluZWQsXG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogdGhpcy5taW5GcmFjdGlvbkRpZ2l0cyA/IHRoaXMubWluRnJhY3Rpb25EaWdpdHMuZXZhbHVhdGUoY3R4KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4aW11bUZyYWN0aW9uRGlnaXRzOiB0aGlzLm1heEZyYWN0aW9uRGlnaXRzID8gdGhpcy5tYXhGcmFjdGlvbkRpZ2l0cy5ldmFsdWF0ZShjdHgpIDogdW5kZWZpbmVkXG4gICAgICB9KS5mb3JtYXQodGhpcy5udW1iZXIuZXZhbHVhdGUoY3R4KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIGZuKHRoaXMubnVtYmVyKTtcblxuICAgICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgIGZuKHRoaXMubG9jYWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VycmVuY3kpIHtcbiAgICAgICAgZm4odGhpcy5jdXJyZW5jeSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1pbkZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIGZuKHRoaXMubWluRnJhY3Rpb25EaWdpdHMpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXhGcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICBmbih0aGlzLm1heEZyYWN0aW9uRGlnaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICAgICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgIG9wdGlvbnNbJ2xvY2FsZSddID0gdGhpcy5sb2NhbGUuc2VyaWFsaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbmN5KSB7XG4gICAgICAgIG9wdGlvbnNbJ2N1cnJlbmN5J10gPSB0aGlzLmN1cnJlbmN5LnNlcmlhbGl6ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5taW5GcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICBvcHRpb25zWydtaW4tZnJhY3Rpb24tZGlnaXRzJ10gPSB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzLnNlcmlhbGl6ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXhGcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICBvcHRpb25zWydtYXgtZnJhY3Rpb24tZGlnaXRzJ10gPSB0aGlzLm1heEZyYWN0aW9uRGlnaXRzLnNlcmlhbGl6ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gWydudW1iZXItZm9ybWF0JywgdGhpcy5udW1iZXIuc2VyaWFsaXplKCksIG9wdGlvbnNdO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMykgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCB0d28gYXJndW1lbnRzLlwiKTtcbiAgICAgIHZhciBudW1iZXIgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIE51bWJlclR5cGUpO1xuICAgICAgaWYgKCFudW1iZXIpIHJldHVybiBudWxsO1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmdzWzJdO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMpKSByZXR1cm4gY29udGV4dC5lcnJvcihcIk51bWJlckZvcm1hdCBvcHRpb25zIGFyZ3VtZW50IG11c3QgYmUgYW4gb2JqZWN0LlwiKTtcbiAgICAgIHZhciBsb2NhbGUgPSBudWxsO1xuXG4gICAgICBpZiAob3B0aW9uc1snbG9jYWxlJ10pIHtcbiAgICAgICAgbG9jYWxlID0gY29udGV4dC5wYXJzZShvcHRpb25zWydsb2NhbGUnXSwgMSwgU3RyaW5nVHlwZSk7XG4gICAgICAgIGlmICghbG9jYWxlKSByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbmN5ID0gbnVsbDtcblxuICAgICAgaWYgKG9wdGlvbnNbJ2N1cnJlbmN5J10pIHtcbiAgICAgICAgY3VycmVuY3kgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2N1cnJlbmN5J10sIDEsIFN0cmluZ1R5cGUpO1xuICAgICAgICBpZiAoIWN1cnJlbmN5KSByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1pbkZyYWN0aW9uRGlnaXRzID0gbnVsbDtcblxuICAgICAgaWYgKG9wdGlvbnNbJ21pbi1mcmFjdGlvbi1kaWdpdHMnXSkge1xuICAgICAgICBtaW5GcmFjdGlvbkRpZ2l0cyA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbWluLWZyYWN0aW9uLWRpZ2l0cyddLCAxLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFtaW5GcmFjdGlvbkRpZ2l0cykgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhGcmFjdGlvbkRpZ2l0cyA9IG51bGw7XG5cbiAgICAgIGlmIChvcHRpb25zWydtYXgtZnJhY3Rpb24tZGlnaXRzJ10pIHtcbiAgICAgICAgbWF4RnJhY3Rpb25EaWdpdHMgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ21heC1mcmFjdGlvbi1kaWdpdHMnXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgICAgIGlmICghbWF4RnJhY3Rpb25EaWdpdHMpIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IE51bWJlckZvcm1hdChudW1iZXIsIGxvY2FsZSwgY3VycmVuY3ksIG1pbkZyYWN0aW9uRGlnaXRzLCBtYXhGcmFjdGlvbkRpZ2l0cyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE51bWJlckZvcm1hdDtcbn0oKTtcblxudmFyIExlbmd0aCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExlbmd0aChpbnB1dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMZW5ndGgpO1xuXG4gICAgdGhpcy50eXBlID0gTnVtYmVyVHlwZTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGVuZ3RoLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcblxuICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0Lmxlbmd0aDtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0Lmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBvZiB0eXBlIHN0cmluZyBvciBhcnJheSwgYnV0IGZvdW5kIFwiLmNvbmNhdCh0b1N0cmluZyh0eXBlT2YoaW5wdXQpKSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICBmbih0aGlzLmlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2xlbmd0aCddO1xuICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaChjaGlsZC5zZXJpYWxpemUoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCAxIGFyZ3VtZW50LCBidXQgZm91bmQgXCIuY29uY2F0KGFyZ3MubGVuZ3RoIC0gMSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxKTtcbiAgICAgIGlmICghaW5wdXQpIHJldHVybiBudWxsO1xuICAgICAgaWYgKGlucHV0LnR5cGUua2luZCAhPT0gJ2FycmF5JyAmJiBpbnB1dC50eXBlLmtpbmQgIT09ICdzdHJpbmcnICYmIGlucHV0LnR5cGUua2luZCAhPT0gJ3ZhbHVlJykgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBhcmd1bWVudCBvZiB0eXBlIHN0cmluZyBvciBhcnJheSwgYnV0IGZvdW5kIFwiLmNvbmNhdCh0b1N0cmluZyhpbnB1dC50eXBlKSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgcmV0dXJuIG5ldyBMZW5ndGgoaW5wdXQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMZW5ndGg7XG59KCk7XG5cbnZhciBleHByZXNzaW9ucyA9IHtcbiAgJz09JzogRXF1YWxzLFxuICAnIT0nOiBOb3RFcXVhbHMsXG4gICc+JzogR3JlYXRlclRoYW4sXG4gICc8JzogTGVzc1RoYW4sXG4gICc+PSc6IEdyZWF0ZXJUaGFuT3JFcXVhbCxcbiAgJzw9JzogTGVzc1RoYW5PckVxdWFsLFxuICAnYXJyYXknOiBBc3NlcnRpb24sXG4gICdhdCc6IEF0LFxuICAnYm9vbGVhbic6IEFzc2VydGlvbixcbiAgJ2Nhc2UnOiBDYXNlLFxuICAnY29hbGVzY2UnOiBDb2FsZXNjZSxcbiAgJ2NvbGxhdG9yJzogQ29sbGF0b3JFeHByZXNzaW9uLFxuICAnZm9ybWF0JzogRm9ybWF0RXhwcmVzc2lvbixcbiAgJ2ltYWdlJzogSW1hZ2VFeHByZXNzaW9uLFxuICAnaW4nOiBJbixcbiAgJ2luZGV4LW9mJzogSW5kZXhPZixcbiAgJ2ludGVycG9sYXRlJzogSW50ZXJwb2xhdGUsXG4gICdpbnRlcnBvbGF0ZS1oY2wnOiBJbnRlcnBvbGF0ZSxcbiAgJ2ludGVycG9sYXRlLWxhYic6IEludGVycG9sYXRlLFxuICAnbGVuZ3RoJzogTGVuZ3RoLFxuICAnbGV0JzogTGV0LFxuICAnbGl0ZXJhbCc6IExpdGVyYWwsXG4gICdtYXRjaCc6IE1hdGNoLFxuICAnbnVtYmVyJzogQXNzZXJ0aW9uLFxuICAnbnVtYmVyLWZvcm1hdCc6IE51bWJlckZvcm1hdCxcbiAgJ29iamVjdCc6IEFzc2VydGlvbixcbiAgJ3NsaWNlJzogU2xpY2UsXG4gICdzdGVwJzogU3RlcCxcbiAgJ3N0cmluZyc6IEFzc2VydGlvbixcbiAgJ3RvLWJvb2xlYW4nOiBDb2VyY2lvbixcbiAgJ3RvLWNvbG9yJzogQ29lcmNpb24sXG4gICd0by1udW1iZXInOiBDb2VyY2lvbixcbiAgJ3RvLXN0cmluZyc6IENvZXJjaW9uLFxuICAndmFyJzogVmFyLFxuICAnd2l0aGluJzogV2l0aGluXG59O1xuXG5mdW5jdGlvbiByZ2JhKGN0eCwgX3JlZjcpIHtcbiAgdmFyIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDQpLFxuICAgICAgciA9IF9yZWY4WzBdLFxuICAgICAgZyA9IF9yZWY4WzFdLFxuICAgICAgYiA9IF9yZWY4WzJdLFxuICAgICAgYSA9IF9yZWY4WzNdO1xuXG4gIHIgPSByLmV2YWx1YXRlKGN0eCk7XG4gIGcgPSBnLmV2YWx1YXRlKGN0eCk7XG4gIGIgPSBiLmV2YWx1YXRlKGN0eCk7XG4gIHZhciBhbHBoYSA9IGEgPyBhLmV2YWx1YXRlKGN0eCkgOiAxO1xuICB2YXIgZXJyb3IgPSB2YWxpZGF0ZVJHQkEociwgZywgYiwgYWxwaGEpO1xuICBpZiAoZXJyb3IpIHRocm93IG5ldyBSdW50aW1lRXJyb3IoZXJyb3IpO1xuICByZXR1cm4gbmV3IENvbG9yKHIgLyAyNTUgKiBhbHBoYSwgZyAvIDI1NSAqIGFscGhhLCBiIC8gMjU1ICogYWxwaGEsIGFscGhhKTtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSwgb2JqKSB7XG4gIHJldHVybiBrZXkgaW4gb2JqO1xufVxuXG5mdW5jdGlvbiBnZXQoa2V5LCBvYmopIHtcbiAgdmFyIHYgPSBvYmpba2V5XTtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB2O1xufVxuXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2godiwgYSwgaSwgaikge1xuICB3aGlsZSAoaSA8PSBqKSB7XG4gICAgdmFyIG0gPSBpICsgaiA+PiAxO1xuICAgIGlmIChhW21dID09PSB2KSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYVttXSA+IHYpIGogPSBtIC0gMTtlbHNlIGkgPSBtICsgMTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdmFyYXJncyh0eXBlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZVxuICB9O1xufVxuXG5Db21wb3VuZEV4cHJlc3Npb24ucmVnaXN0ZXIoZXhwcmVzc2lvbnMsIHtcbiAgJ2Vycm9yJzogW0Vycm9yVHlwZSwgW1N0cmluZ1R5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmOSkge1xuICAgIHZhciBfcmVmMTAgPSBfc2xpY2VkVG9BcnJheShfcmVmOSwgMSksXG4gICAgICAgIHYgPSBfcmVmMTBbMF07XG5cbiAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKHYuZXZhbHVhdGUoY3R4KSk7XG4gIH1dLFxuICAndHlwZW9mJzogW1N0cmluZ1R5cGUsIFtWYWx1ZVR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMTEpIHtcbiAgICB2YXIgX3JlZjEyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjExLCAxKSxcbiAgICAgICAgdiA9IF9yZWYxMlswXTtcblxuICAgIHJldHVybiB0b1N0cmluZyh0eXBlT2Yodi5ldmFsdWF0ZShjdHgpKSk7XG4gIH1dLFxuICAndG8tcmdiYSc6IFthcnJheShOdW1iZXJUeXBlLCA0KSwgW0NvbG9yVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYxMykge1xuICAgIHZhciBfcmVmMTQgPSBfc2xpY2VkVG9BcnJheShfcmVmMTMsIDEpLFxuICAgICAgICB2ID0gX3JlZjE0WzBdO1xuXG4gICAgcmV0dXJuIHYuZXZhbHVhdGUoY3R4KS50b0FycmF5KCk7XG4gIH1dLFxuICAncmdiJzogW0NvbG9yVHlwZSwgW051bWJlclR5cGUsIE51bWJlclR5cGUsIE51bWJlclR5cGVdLCByZ2JhXSxcbiAgJ3JnYmEnOiBbQ29sb3JUeXBlLCBbTnVtYmVyVHlwZSwgTnVtYmVyVHlwZSwgTnVtYmVyVHlwZSwgTnVtYmVyVHlwZV0sIHJnYmFdLFxuICAnaGFzJzoge1xuICAgIHR5cGU6IEJvb2xlYW5UeXBlLFxuICAgIG92ZXJsb2FkczogW1tbU3RyaW5nVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYxNSkge1xuICAgICAgdmFyIF9yZWYxNiA9IF9zbGljZWRUb0FycmF5KF9yZWYxNSwgMSksXG4gICAgICAgICAga2V5ID0gX3JlZjE2WzBdO1xuXG4gICAgICByZXR1cm4gaGFzKGtleS5ldmFsdWF0ZShjdHgpLCBjdHgucHJvcGVydGllcygpKTtcbiAgICB9XSwgW1tTdHJpbmdUeXBlLCBPYmplY3RUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjE3KSB7XG4gICAgICB2YXIgX3JlZjE4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE3LCAyKSxcbiAgICAgICAgICBrZXkgPSBfcmVmMThbMF0sXG4gICAgICAgICAgb2JqID0gX3JlZjE4WzFdO1xuXG4gICAgICByZXR1cm4gaGFzKGtleS5ldmFsdWF0ZShjdHgpLCBvYmouZXZhbHVhdGUoY3R4KSk7XG4gICAgfV1dXG4gIH0sXG4gICdnZXQnOiB7XG4gICAgdHlwZTogVmFsdWVUeXBlLFxuICAgIG92ZXJsb2FkczogW1tbU3RyaW5nVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYxOSkge1xuICAgICAgdmFyIF9yZWYyMCA9IF9zbGljZWRUb0FycmF5KF9yZWYxOSwgMSksXG4gICAgICAgICAga2V5ID0gX3JlZjIwWzBdO1xuXG4gICAgICByZXR1cm4gZ2V0KGtleS5ldmFsdWF0ZShjdHgpLCBjdHgucHJvcGVydGllcygpKTtcbiAgICB9XSwgW1tTdHJpbmdUeXBlLCBPYmplY3RUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjIxKSB7XG4gICAgICB2YXIgX3JlZjIyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIxLCAyKSxcbiAgICAgICAgICBrZXkgPSBfcmVmMjJbMF0sXG4gICAgICAgICAgb2JqID0gX3JlZjIyWzFdO1xuXG4gICAgICByZXR1cm4gZ2V0KGtleS5ldmFsdWF0ZShjdHgpLCBvYmouZXZhbHVhdGUoY3R4KSk7XG4gICAgfV1dXG4gIH0sXG4gICdmZWF0dXJlLXN0YXRlJzogW1ZhbHVlVHlwZSwgW1N0cmluZ1R5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMjMpIHtcbiAgICB2YXIgX3JlZjI0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIzLCAxKSxcbiAgICAgICAga2V5ID0gX3JlZjI0WzBdO1xuXG4gICAgcmV0dXJuIGdldChrZXkuZXZhbHVhdGUoY3R4KSwgY3R4LmZlYXR1cmVTdGF0ZSB8fCB7fSk7XG4gIH1dLFxuICAncHJvcGVydGllcyc6IFtPYmplY3RUeXBlLCBbXSwgZnVuY3Rpb24gKGN0eCkge1xuICAgIHJldHVybiBjdHgucHJvcGVydGllcygpO1xuICB9XSxcbiAgJ2dlb21ldHJ5LXR5cGUnOiBbU3RyaW5nVHlwZSwgW10sIGZ1bmN0aW9uIChjdHgpIHtcbiAgICByZXR1cm4gY3R4Lmdlb21ldHJ5VHlwZSgpO1xuICB9XSxcbiAgJ2lkJzogW1ZhbHVlVHlwZSwgW10sIGZ1bmN0aW9uIChjdHgpIHtcbiAgICByZXR1cm4gY3R4LmlkKCk7XG4gIH1dLFxuICAnem9vbSc6IFtOdW1iZXJUeXBlLCBbXSwgZnVuY3Rpb24gKGN0eCkge1xuICAgIHJldHVybiBjdHguZ2xvYmFscy56b29tO1xuICB9XSxcbiAgJ2hlYXRtYXAtZGVuc2l0eSc6IFtOdW1iZXJUeXBlLCBbXSwgZnVuY3Rpb24gKGN0eCkge1xuICAgIHJldHVybiBjdHguZ2xvYmFscy5oZWF0bWFwRGVuc2l0eSB8fCAwO1xuICB9XSxcbiAgJ2xpbmUtcHJvZ3Jlc3MnOiBbTnVtYmVyVHlwZSwgW10sIGZ1bmN0aW9uIChjdHgpIHtcbiAgICByZXR1cm4gY3R4Lmdsb2JhbHMubGluZVByb2dyZXNzIHx8IDA7XG4gIH1dLFxuICAnc2t5LXJhZGlhbC1wcm9ncmVzcyc6IFtOdW1iZXJUeXBlLCBbXSwgZnVuY3Rpb24gKGN0eCkge1xuICAgIHJldHVybiBjdHguZ2xvYmFscy5za3lSYWRpYWxQcm9ncmVzcyB8fCAwO1xuICB9XSxcbiAgJ2FjY3VtdWxhdGVkJzogW1ZhbHVlVHlwZSwgW10sIGZ1bmN0aW9uIChjdHgpIHtcbiAgICByZXR1cm4gY3R4Lmdsb2JhbHMuYWNjdW11bGF0ZWQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjdHguZ2xvYmFscy5hY2N1bXVsYXRlZDtcbiAgfV0sXG4gICcrJzogW051bWJlclR5cGUsIHZhcmFyZ3MoTnVtYmVyVHlwZSksIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICB2YXIgcmVzdWx0ID0gMDtcblxuICAgIHZhciBfaXRlcmF0b3IzNSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGFyZ3MpLFxuICAgICAgICBfc3RlcDM1O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMzUucygpOyAhKF9zdGVwMzUgPSBfaXRlcmF0b3IzNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBhcmcgPSBfc3RlcDM1LnZhbHVlO1xuICAgICAgICByZXN1bHQgKz0gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IzNS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjM1LmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XSxcbiAgJyonOiBbTnVtYmVyVHlwZSwgdmFyYXJncyhOdW1iZXJUeXBlKSwgZnVuY3Rpb24gKGN0eCwgYXJncykge1xuICAgIHZhciByZXN1bHQgPSAxO1xuXG4gICAgdmFyIF9pdGVyYXRvcjM2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYXJncyksXG4gICAgICAgIF9zdGVwMzY7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IzNi5zKCk7ICEoX3N0ZXAzNiA9IF9pdGVyYXRvcjM2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGFyZyA9IF9zdGVwMzYudmFsdWU7XG4gICAgICAgIHJlc3VsdCAqPSBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjM2LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMzYuZigpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1dLFxuICAnLSc6IHtcbiAgICB0eXBlOiBOdW1iZXJUeXBlLFxuICAgIG92ZXJsb2FkczogW1tbTnVtYmVyVHlwZSwgTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYyNSkge1xuICAgICAgdmFyIF9yZWYyNiA9IF9zbGljZWRUb0FycmF5KF9yZWYyNSwgMiksXG4gICAgICAgICAgYSA9IF9yZWYyNlswXSxcbiAgICAgICAgICBiID0gX3JlZjI2WzFdO1xuXG4gICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpIC0gYi5ldmFsdWF0ZShjdHgpO1xuICAgIH1dLCBbW051bWJlclR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMjcpIHtcbiAgICAgIHZhciBfcmVmMjggPSBfc2xpY2VkVG9BcnJheShfcmVmMjcsIDEpLFxuICAgICAgICAgIGEgPSBfcmVmMjhbMF07XG5cbiAgICAgIHJldHVybiAtYS5ldmFsdWF0ZShjdHgpO1xuICAgIH1dXVxuICB9LFxuICAnLyc6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZSwgTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYyOSkge1xuICAgIHZhciBfcmVmMzAgPSBfc2xpY2VkVG9BcnJheShfcmVmMjksIDIpLFxuICAgICAgICBhID0gX3JlZjMwWzBdLFxuICAgICAgICBiID0gX3JlZjMwWzFdO1xuXG4gICAgcmV0dXJuIGEuZXZhbHVhdGUoY3R4KSAvIGIuZXZhbHVhdGUoY3R4KTtcbiAgfV0sXG4gICclJzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlLCBOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjMxKSB7XG4gICAgdmFyIF9yZWYzMiA9IF9zbGljZWRUb0FycmF5KF9yZWYzMSwgMiksXG4gICAgICAgIGEgPSBfcmVmMzJbMF0sXG4gICAgICAgIGIgPSBfcmVmMzJbMV07XG5cbiAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpICUgYi5ldmFsdWF0ZShjdHgpO1xuICB9XSxcbiAgJ2xuMic6IFtOdW1iZXJUeXBlLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLkxOMjtcbiAgfV0sXG4gICdwaSc6IFtOdW1iZXJUeXBlLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLlBJO1xuICB9XSxcbiAgJ2UnOiBbTnVtYmVyVHlwZSwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5FO1xuICB9XSxcbiAgJ14nOiBbTnVtYmVyVHlwZSwgW051bWJlclR5cGUsIE51bWJlclR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMzMpIHtcbiAgICB2YXIgX3JlZjM0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMzLCAyKSxcbiAgICAgICAgYiA9IF9yZWYzNFswXSxcbiAgICAgICAgZSA9IF9yZWYzNFsxXTtcblxuICAgIHJldHVybiBNYXRoLnBvdyhiLmV2YWx1YXRlKGN0eCksIGUuZXZhbHVhdGUoY3R4KSk7XG4gIH1dLFxuICAnc3FydCc6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYzNSkge1xuICAgIHZhciBfcmVmMzYgPSBfc2xpY2VkVG9BcnJheShfcmVmMzUsIDEpLFxuICAgICAgICB4ID0gX3JlZjM2WzBdO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCh4LmV2YWx1YXRlKGN0eCkpO1xuICB9XSxcbiAgJ2xvZzEwJzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjM3KSB7XG4gICAgdmFyIF9yZWYzOCA9IF9zbGljZWRUb0FycmF5KF9yZWYzNywgMSksXG4gICAgICAgIG4gPSBfcmVmMzhbMF07XG5cbiAgICByZXR1cm4gTWF0aC5sb2cobi5ldmFsdWF0ZShjdHgpKSAvIE1hdGguTE4xMDtcbiAgfV0sXG4gICdsbic6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYzOSkge1xuICAgIHZhciBfcmVmNDAgPSBfc2xpY2VkVG9BcnJheShfcmVmMzksIDEpLFxuICAgICAgICBuID0gX3JlZjQwWzBdO1xuXG4gICAgcmV0dXJuIE1hdGgubG9nKG4uZXZhbHVhdGUoY3R4KSk7XG4gIH1dLFxuICAnbG9nMic6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY0MSkge1xuICAgIHZhciBfcmVmNDIgPSBfc2xpY2VkVG9BcnJheShfcmVmNDEsIDEpLFxuICAgICAgICBuID0gX3JlZjQyWzBdO1xuXG4gICAgcmV0dXJuIE1hdGgubG9nKG4uZXZhbHVhdGUoY3R4KSkgLyBNYXRoLkxOMjtcbiAgfV0sXG4gICdzaW4nOiBbTnVtYmVyVHlwZSwgW051bWJlclR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNDMpIHtcbiAgICB2YXIgX3JlZjQ0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjQzLCAxKSxcbiAgICAgICAgbiA9IF9yZWY0NFswXTtcblxuICAgIHJldHVybiBNYXRoLnNpbihuLmV2YWx1YXRlKGN0eCkpO1xuICB9XSxcbiAgJ2Nvcyc6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY0NSkge1xuICAgIHZhciBfcmVmNDYgPSBfc2xpY2VkVG9BcnJheShfcmVmNDUsIDEpLFxuICAgICAgICBuID0gX3JlZjQ2WzBdO1xuXG4gICAgcmV0dXJuIE1hdGguY29zKG4uZXZhbHVhdGUoY3R4KSk7XG4gIH1dLFxuICAndGFuJzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjQ3KSB7XG4gICAgdmFyIF9yZWY0OCA9IF9zbGljZWRUb0FycmF5KF9yZWY0NywgMSksXG4gICAgICAgIG4gPSBfcmVmNDhbMF07XG5cbiAgICByZXR1cm4gTWF0aC50YW4obi5ldmFsdWF0ZShjdHgpKTtcbiAgfV0sXG4gICdhc2luJzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjQ5KSB7XG4gICAgdmFyIF9yZWY1MCA9IF9zbGljZWRUb0FycmF5KF9yZWY0OSwgMSksXG4gICAgICAgIG4gPSBfcmVmNTBbMF07XG5cbiAgICByZXR1cm4gTWF0aC5hc2luKG4uZXZhbHVhdGUoY3R4KSk7XG4gIH1dLFxuICAnYWNvcyc6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY1MSkge1xuICAgIHZhciBfcmVmNTIgPSBfc2xpY2VkVG9BcnJheShfcmVmNTEsIDEpLFxuICAgICAgICBuID0gX3JlZjUyWzBdO1xuXG4gICAgcmV0dXJuIE1hdGguYWNvcyhuLmV2YWx1YXRlKGN0eCkpO1xuICB9XSxcbiAgJ2F0YW4nOiBbTnVtYmVyVHlwZSwgW051bWJlclR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNTMpIHtcbiAgICB2YXIgX3JlZjU0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUzLCAxKSxcbiAgICAgICAgbiA9IF9yZWY1NFswXTtcblxuICAgIHJldHVybiBNYXRoLmF0YW4obi5ldmFsdWF0ZShjdHgpKTtcbiAgfV0sXG4gICdtaW4nOiBbTnVtYmVyVHlwZSwgdmFyYXJncyhOdW1iZXJUeXBlKSwgZnVuY3Rpb24gKGN0eCwgYXJncykge1xuICAgIHJldHVybiBNYXRoLm1pbi5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZy5ldmFsdWF0ZShjdHgpO1xuICAgIH0pKSk7XG4gIH1dLFxuICAnbWF4JzogW051bWJlclR5cGUsIHZhcmFyZ3MoTnVtYmVyVHlwZSksIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICByZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MubWFwKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICB9KSkpO1xuICB9XSxcbiAgJ2Ficyc6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY1NSkge1xuICAgIHZhciBfcmVmNTYgPSBfc2xpY2VkVG9BcnJheShfcmVmNTUsIDEpLFxuICAgICAgICBuID0gX3JlZjU2WzBdO1xuXG4gICAgcmV0dXJuIE1hdGguYWJzKG4uZXZhbHVhdGUoY3R4KSk7XG4gIH1dLFxuICAncm91bmQnOiBbTnVtYmVyVHlwZSwgW051bWJlclR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNTcpIHtcbiAgICB2YXIgX3JlZjU4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjU3LCAxKSxcbiAgICAgICAgbiA9IF9yZWY1OFswXTtcblxuICAgIHZhciB2ID0gbi5ldmFsdWF0ZShjdHgpO1xuICAgIHJldHVybiB2IDwgMCA/IC1NYXRoLnJvdW5kKC12KSA6IE1hdGgucm91bmQodik7XG4gIH1dLFxuICAnZmxvb3InOiBbTnVtYmVyVHlwZSwgW051bWJlclR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNTkpIHtcbiAgICB2YXIgX3JlZjYwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjU5LCAxKSxcbiAgICAgICAgbiA9IF9yZWY2MFswXTtcblxuICAgIHJldHVybiBNYXRoLmZsb29yKG4uZXZhbHVhdGUoY3R4KSk7XG4gIH1dLFxuICAnY2VpbCc6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY2MSkge1xuICAgIHZhciBfcmVmNjIgPSBfc2xpY2VkVG9BcnJheShfcmVmNjEsIDEpLFxuICAgICAgICBuID0gX3JlZjYyWzBdO1xuXG4gICAgcmV0dXJuIE1hdGguY2VpbChuLmV2YWx1YXRlKGN0eCkpO1xuICB9XSxcbiAgJ2ZpbHRlci09PSc6IFtCb29sZWFuVHlwZSwgW1N0cmluZ1R5cGUsIFZhbHVlVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY2Mykge1xuICAgIHZhciBfcmVmNjQgPSBfc2xpY2VkVG9BcnJheShfcmVmNjMsIDIpLFxuICAgICAgICBrID0gX3JlZjY0WzBdLFxuICAgICAgICB2ID0gX3JlZjY0WzFdO1xuXG4gICAgcmV0dXJuIGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV0gPT09IHYudmFsdWU7XG4gIH1dLFxuICAnZmlsdGVyLWlkLT09JzogW0Jvb2xlYW5UeXBlLCBbVmFsdWVUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjY1KSB7XG4gICAgdmFyIF9yZWY2NiA9IF9zbGljZWRUb0FycmF5KF9yZWY2NSwgMSksXG4gICAgICAgIHYgPSBfcmVmNjZbMF07XG5cbiAgICByZXR1cm4gY3R4LmlkKCkgPT09IHYudmFsdWU7XG4gIH1dLFxuICAnZmlsdGVyLXR5cGUtPT0nOiBbQm9vbGVhblR5cGUsIFtTdHJpbmdUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjY3KSB7XG4gICAgdmFyIF9yZWY2OCA9IF9zbGljZWRUb0FycmF5KF9yZWY2NywgMSksXG4gICAgICAgIHYgPSBfcmVmNjhbMF07XG5cbiAgICByZXR1cm4gY3R4Lmdlb21ldHJ5VHlwZSgpID09PSB2LnZhbHVlO1xuICB9XSxcbiAgJ2ZpbHRlci08JzogW0Jvb2xlYW5UeXBlLCBbU3RyaW5nVHlwZSwgVmFsdWVUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjY5KSB7XG4gICAgdmFyIF9yZWY3MCA9IF9zbGljZWRUb0FycmF5KF9yZWY2OSwgMiksXG4gICAgICAgIGsgPSBfcmVmNzBbMF0sXG4gICAgICAgIHYgPSBfcmVmNzBbMV07XG5cbiAgICB2YXIgYSA9IGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV07XG4gICAgdmFyIGIgPSB2LnZhbHVlO1xuICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA8IGI7XG4gIH1dLFxuICAnZmlsdGVyLWlkLTwnOiBbQm9vbGVhblR5cGUsIFtWYWx1ZVR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNzEpIHtcbiAgICB2YXIgX3JlZjcyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcxLCAxKSxcbiAgICAgICAgdiA9IF9yZWY3MlswXTtcblxuICAgIHZhciBhID0gY3R4LmlkKCk7XG4gICAgdmFyIGIgPSB2LnZhbHVlO1xuICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA8IGI7XG4gIH1dLFxuICAnZmlsdGVyLT4nOiBbQm9vbGVhblR5cGUsIFtTdHJpbmdUeXBlLCBWYWx1ZVR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNzMpIHtcbiAgICB2YXIgX3JlZjc0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjczLCAyKSxcbiAgICAgICAgayA9IF9yZWY3NFswXSxcbiAgICAgICAgdiA9IF9yZWY3NFsxXTtcblxuICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTtcbiAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhID4gYjtcbiAgfV0sXG4gICdmaWx0ZXItaWQtPic6IFtCb29sZWFuVHlwZSwgW1ZhbHVlVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY3NSkge1xuICAgIHZhciBfcmVmNzYgPSBfc2xpY2VkVG9BcnJheShfcmVmNzUsIDEpLFxuICAgICAgICB2ID0gX3JlZjc2WzBdO1xuXG4gICAgdmFyIGEgPSBjdHguaWQoKTtcbiAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhID4gYjtcbiAgfV0sXG4gICdmaWx0ZXItPD0nOiBbQm9vbGVhblR5cGUsIFtTdHJpbmdUeXBlLCBWYWx1ZVR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNzcpIHtcbiAgICB2YXIgX3JlZjc4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjc3LCAyKSxcbiAgICAgICAgayA9IF9yZWY3OFswXSxcbiAgICAgICAgdiA9IF9yZWY3OFsxXTtcblxuICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTtcbiAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDw9IGI7XG4gIH1dLFxuICAnZmlsdGVyLWlkLTw9JzogW0Jvb2xlYW5UeXBlLCBbVmFsdWVUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjc5KSB7XG4gICAgdmFyIF9yZWY4MCA9IF9zbGljZWRUb0FycmF5KF9yZWY3OSwgMSksXG4gICAgICAgIHYgPSBfcmVmODBbMF07XG5cbiAgICB2YXIgYSA9IGN0eC5pZCgpO1xuICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPD0gYjtcbiAgfV0sXG4gICdmaWx0ZXItPj0nOiBbQm9vbGVhblR5cGUsIFtTdHJpbmdUeXBlLCBWYWx1ZVR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmODEpIHtcbiAgICB2YXIgX3JlZjgyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjgxLCAyKSxcbiAgICAgICAgayA9IF9yZWY4MlswXSxcbiAgICAgICAgdiA9IF9yZWY4MlsxXTtcblxuICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTtcbiAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhID49IGI7XG4gIH1dLFxuICAnZmlsdGVyLWlkLT49JzogW0Jvb2xlYW5UeXBlLCBbVmFsdWVUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjgzKSB7XG4gICAgdmFyIF9yZWY4NCA9IF9zbGljZWRUb0FycmF5KF9yZWY4MywgMSksXG4gICAgICAgIHYgPSBfcmVmODRbMF07XG5cbiAgICB2YXIgYSA9IGN0eC5pZCgpO1xuICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPj0gYjtcbiAgfV0sXG4gICdmaWx0ZXItaGFzJzogW0Jvb2xlYW5UeXBlLCBbVmFsdWVUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjg1KSB7XG4gICAgdmFyIF9yZWY4NiA9IF9zbGljZWRUb0FycmF5KF9yZWY4NSwgMSksXG4gICAgICAgIGsgPSBfcmVmODZbMF07XG5cbiAgICByZXR1cm4gay52YWx1ZSBpbiBjdHgucHJvcGVydGllcygpO1xuICB9XSxcbiAgJ2ZpbHRlci1oYXMtaWQnOiBbQm9vbGVhblR5cGUsIFtdLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgcmV0dXJuIGN0eC5pZCgpICE9PSBudWxsICYmIGN0eC5pZCgpICE9PSB1bmRlZmluZWQ7XG4gIH1dLFxuICAnZmlsdGVyLXR5cGUtaW4nOiBbQm9vbGVhblR5cGUsIFthcnJheShTdHJpbmdUeXBlKV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY4Nykge1xuICAgIHZhciBfcmVmODggPSBfc2xpY2VkVG9BcnJheShfcmVmODcsIDEpLFxuICAgICAgICB2ID0gX3JlZjg4WzBdO1xuXG4gICAgcmV0dXJuIHYudmFsdWUuaW5kZXhPZihjdHguZ2VvbWV0cnlUeXBlKCkpID49IDA7XG4gIH1dLFxuICAnZmlsdGVyLWlkLWluJzogW0Jvb2xlYW5UeXBlLCBbYXJyYXkoVmFsdWVUeXBlKV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY4OSkge1xuICAgIHZhciBfcmVmOTAgPSBfc2xpY2VkVG9BcnJheShfcmVmODksIDEpLFxuICAgICAgICB2ID0gX3JlZjkwWzBdO1xuXG4gICAgcmV0dXJuIHYudmFsdWUuaW5kZXhPZihjdHguaWQoKSkgPj0gMDtcbiAgfV0sXG4gICdmaWx0ZXItaW4tc21hbGwnOiBbQm9vbGVhblR5cGUsIFtTdHJpbmdUeXBlLCBhcnJheShWYWx1ZVR5cGUpXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjkxKSB7XG4gICAgdmFyIF9yZWY5MiA9IF9zbGljZWRUb0FycmF5KF9yZWY5MSwgMiksXG4gICAgICAgIGsgPSBfcmVmOTJbMF0sXG4gICAgICAgIHYgPSBfcmVmOTJbMV07XG5cbiAgICByZXR1cm4gdi52YWx1ZS5pbmRleE9mKGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV0pID49IDA7XG4gIH1dLFxuICAnZmlsdGVyLWluLWxhcmdlJzogW0Jvb2xlYW5UeXBlLCBbU3RyaW5nVHlwZSwgYXJyYXkoVmFsdWVUeXBlKV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY5Mykge1xuICAgIHZhciBfcmVmOTQgPSBfc2xpY2VkVG9BcnJheShfcmVmOTMsIDIpLFxuICAgICAgICBrID0gX3JlZjk0WzBdLFxuICAgICAgICB2ID0gX3JlZjk0WzFdO1xuXG4gICAgcmV0dXJuIGJpbmFyeVNlYXJjaChjdHgucHJvcGVydGllcygpW2sudmFsdWVdLCB2LnZhbHVlLCAwLCB2LnZhbHVlLmxlbmd0aCAtIDEpO1xuICB9XSxcbiAgJ2FsbCc6IHtcbiAgICB0eXBlOiBCb29sZWFuVHlwZSxcbiAgICBvdmVybG9hZHM6IFtbW0Jvb2xlYW5UeXBlLCBCb29sZWFuVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY5NSkge1xuICAgICAgdmFyIF9yZWY5NiA9IF9zbGljZWRUb0FycmF5KF9yZWY5NSwgMiksXG4gICAgICAgICAgYSA9IF9yZWY5NlswXSxcbiAgICAgICAgICBiID0gX3JlZjk2WzFdO1xuXG4gICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpICYmIGIuZXZhbHVhdGUoY3R4KTtcbiAgICB9XSwgW3ZhcmFyZ3MoQm9vbGVhblR5cGUpLCBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMzcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhcmdzKSxcbiAgICAgICAgICBfc3RlcDM3O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjM3LnMoKTsgIShfc3RlcDM3ID0gX2l0ZXJhdG9yMzcubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBhcmcgPSBfc3RlcDM3LnZhbHVlO1xuICAgICAgICAgIGlmICghYXJnLmV2YWx1YXRlKGN0eCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjM3LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjM3LmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfV1dXG4gIH0sXG4gICdhbnknOiB7XG4gICAgdHlwZTogQm9vbGVhblR5cGUsXG4gICAgb3ZlcmxvYWRzOiBbW1tCb29sZWFuVHlwZSwgQm9vbGVhblR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmOTcpIHtcbiAgICAgIHZhciBfcmVmOTggPSBfc2xpY2VkVG9BcnJheShfcmVmOTcsIDIpLFxuICAgICAgICAgIGEgPSBfcmVmOThbMF0sXG4gICAgICAgICAgYiA9IF9yZWY5OFsxXTtcblxuICAgICAgcmV0dXJuIGEuZXZhbHVhdGUoY3R4KSB8fCBiLmV2YWx1YXRlKGN0eCk7XG4gICAgfV0sIFt2YXJhcmdzKEJvb2xlYW5UeXBlKSwgZnVuY3Rpb24gKGN0eCwgYXJncykge1xuICAgICAgdmFyIF9pdGVyYXRvcjM4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYXJncyksXG4gICAgICAgICAgX3N0ZXAzODtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzOC5zKCk7ICEoX3N0ZXAzOCA9IF9pdGVyYXRvcjM4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgYXJnID0gX3N0ZXAzOC52YWx1ZTtcbiAgICAgICAgICBpZiAoYXJnLmV2YWx1YXRlKGN0eCkpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMzguZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMzguZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfV1dXG4gIH0sXG4gICchJzogW0Jvb2xlYW5UeXBlLCBbQm9vbGVhblR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmOTkpIHtcbiAgICB2YXIgX3JlZjEwMCA9IF9zbGljZWRUb0FycmF5KF9yZWY5OSwgMSksXG4gICAgICAgIGIgPSBfcmVmMTAwWzBdO1xuXG4gICAgcmV0dXJuICFiLmV2YWx1YXRlKGN0eCk7XG4gIH1dLFxuICAnaXMtc3VwcG9ydGVkLXNjcmlwdCc6IFtCb29sZWFuVHlwZSwgW1N0cmluZ1R5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMTAxKSB7XG4gICAgdmFyIF9yZWYxMDIgPSBfc2xpY2VkVG9BcnJheShfcmVmMTAxLCAxKSxcbiAgICAgICAgcyA9IF9yZWYxMDJbMF07XG5cbiAgICB2YXIgaXNTdXBwb3J0ZWRTY3JpcHQgPSBjdHguZ2xvYmFscyAmJiBjdHguZ2xvYmFscy5pc1N1cHBvcnRlZFNjcmlwdDtcblxuICAgIGlmIChpc1N1cHBvcnRlZFNjcmlwdCkge1xuICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkU2NyaXB0KHMuZXZhbHVhdGUoY3R4KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1dLFxuICAndXBjYXNlJzogW1N0cmluZ1R5cGUsIFtTdHJpbmdUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjEwMykge1xuICAgIHZhciBfcmVmMTA0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjEwMywgMSksXG4gICAgICAgIHMgPSBfcmVmMTA0WzBdO1xuXG4gICAgcmV0dXJuIHMuZXZhbHVhdGUoY3R4KS50b1VwcGVyQ2FzZSgpO1xuICB9XSxcbiAgJ2Rvd25jYXNlJzogW1N0cmluZ1R5cGUsIFtTdHJpbmdUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjEwNSkge1xuICAgIHZhciBfcmVmMTA2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjEwNSwgMSksXG4gICAgICAgIHMgPSBfcmVmMTA2WzBdO1xuXG4gICAgcmV0dXJuIHMuZXZhbHVhdGUoY3R4KS50b0xvd2VyQ2FzZSgpO1xuICB9XSxcbiAgJ2NvbmNhdCc6IFtTdHJpbmdUeXBlLCB2YXJhcmdzKFZhbHVlVHlwZSksIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICByZXR1cm4gYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIHRvU3RyaW5nJDEoYXJnLmV2YWx1YXRlKGN0eCkpO1xuICAgIH0pLmpvaW4oJycpO1xuICB9XSxcbiAgJ3Jlc29sdmVkLWxvY2FsZSc6IFtTdHJpbmdUeXBlLCBbQ29sbGF0b3JUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjEwNykge1xuICAgIHZhciBfcmVmMTA4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjEwNywgMSksXG4gICAgICAgIGNvbGxhdG9yID0gX3JlZjEwOFswXTtcblxuICAgIHJldHVybiBjb2xsYXRvci5ldmFsdWF0ZShjdHgpLnJlc29sdmVkTG9jYWxlKCk7XG4gIH1dXG59KTtcblxuZnVuY3Rpb24gc3VjY2Vzcyh2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHJlc3VsdDogJ3N1Y2Nlc3MnLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHJlc3VsdDogJ2Vycm9yJyxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24oc3BlYykge1xuICByZXR1cm4gc3BlY1sncHJvcGVydHktdHlwZSddID09PSAnZGF0YS1kcml2ZW4nIHx8IHNwZWNbJ3Byb3BlcnR5LXR5cGUnXSA9PT0gJ2Nyb3NzLWZhZGVkLWRhdGEtZHJpdmVuJztcbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNab29tRXhwcmVzc2lvbihzcGVjKSB7XG4gIHJldHVybiAhIXNwZWMuZXhwcmVzc2lvbiAmJiBzcGVjLmV4cHJlc3Npb24ucGFyYW1ldGVycy5pbmRleE9mKCd6b29tJykgPiAtMTtcbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNJbnRlcnBvbGF0aW9uKHNwZWMpIHtcbiAgcmV0dXJuICEhc3BlYy5leHByZXNzaW9uICYmIHNwZWMuZXhwcmVzc2lvbi5pbnRlcnBvbGF0ZWQ7XG59XG5cbmZ1bmN0aW9uIGdldFR5cGUodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgcmV0dXJuICdzdHJpbmcnO1xuICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICByZXR1cm4gJ2Jvb2xlYW4nO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbiQxKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHlGdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgdmFyIGlzQ29sb3IgPSBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2NvbG9yJztcbiAgdmFyIHpvb21BbmRGZWF0dXJlRGVwZW5kZW50ID0gcGFyYW1ldGVycy5zdG9wcyAmJiB0eXBlb2YgcGFyYW1ldGVycy5zdG9wc1swXVswXSA9PT0gJ29iamVjdCc7XG4gIHZhciBmZWF0dXJlRGVwZW5kZW50ID0gem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgfHwgcGFyYW1ldGVycy5wcm9wZXJ0eSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgem9vbURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8ICFmZWF0dXJlRGVwZW5kZW50O1xuICB2YXIgdHlwZSA9IHBhcmFtZXRlcnMudHlwZSB8fCAoc3VwcG9ydHNJbnRlcnBvbGF0aW9uKHByb3BlcnR5U3BlYykgPyAnZXhwb25lbnRpYWwnIDogJ2ludGVydmFsJyk7XG5cbiAgaWYgKGlzQ29sb3IpIHtcbiAgICBwYXJhbWV0ZXJzID0gZXh0ZW5kKHt9LCBwYXJhbWV0ZXJzKTtcblxuICAgIGlmIChwYXJhbWV0ZXJzLnN0b3BzKSB7XG4gICAgICBwYXJhbWV0ZXJzLnN0b3BzID0gcGFyYW1ldGVycy5zdG9wcy5tYXAoZnVuY3Rpb24gKHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIFtzdG9wWzBdLCBDb2xvci5wYXJzZShzdG9wWzFdKV07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1ldGVycy5kZWZhdWx0KSB7XG4gICAgICBwYXJhbWV0ZXJzLmRlZmF1bHQgPSBDb2xvci5wYXJzZShwYXJhbWV0ZXJzLmRlZmF1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbWV0ZXJzLmRlZmF1bHQgPSBDb2xvci5wYXJzZShwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcmFtZXRlcnMuY29sb3JTcGFjZSAmJiBwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgIT09ICdyZ2InICYmICFjb2xvclNwYWNlc1twYXJhbWV0ZXJzLmNvbG9yU3BhY2VdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjb2xvciBzcGFjZTogXCIuY29uY2F0KHBhcmFtZXRlcnMuY29sb3JTcGFjZSkpO1xuICB9XG5cbiAgdmFyIGlubmVyRnVuO1xuICB2YXIgaGFzaGVkU3RvcHM7XG4gIHZhciBjYXRlZ29yaWNhbEtleVR5cGU7XG5cbiAgaWYgKHR5cGUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICBpbm5lckZ1biA9IGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnKSB7XG4gICAgaW5uZXJGdW4gPSBldmFsdWF0ZUludGVydmFsRnVuY3Rpb247XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NhdGVnb3JpY2FsJykge1xuICAgIGlubmVyRnVuID0gZXZhbHVhdGVDYXRlZ29yaWNhbEZ1bmN0aW9uO1xuICAgIGhhc2hlZFN0b3BzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIHZhciBfaXRlcmF0b3IzOSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBhcmFtZXRlcnMuc3RvcHMpLFxuICAgICAgICBfc3RlcDM5O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMzkucygpOyAhKF9zdGVwMzkgPSBfaXRlcmF0b3IzOS5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBzdG9wID0gX3N0ZXAzOS52YWx1ZTtcbiAgICAgICAgaGFzaGVkU3RvcHNbc3RvcFswXV0gPSBzdG9wWzFdO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMzkuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IzOS5mKCk7XG4gICAgfVxuXG4gICAgY2F0ZWdvcmljYWxLZXlUeXBlID0gdHlwZW9mIHBhcmFtZXRlcnMuc3RvcHNbMF1bMF07XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2lkZW50aXR5Jykge1xuICAgIGlubmVyRnVuID0gZXZhbHVhdGVJZGVudGl0eUZ1bmN0aW9uO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZnVuY3Rpb24gdHlwZSBcXFwiXCIuY29uY2F0KHR5cGUsIFwiXFxcIlwiKSk7XG4gIH1cblxuICBpZiAoem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQpIHtcbiAgICB2YXIgZmVhdHVyZUZ1bmN0aW9ucyA9IHt9O1xuICAgIHZhciB6b29tU3RvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIHMgPSAwOyBzIDwgcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7IHMrKykge1xuICAgICAgdmFyIF9zdG9wID0gcGFyYW1ldGVycy5zdG9wc1tzXTtcbiAgICAgIHZhciB6b29tID0gX3N0b3BbMF0uem9vbTtcblxuICAgICAgaWYgKGZlYXR1cmVGdW5jdGlvbnNbem9vbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmZWF0dXJlRnVuY3Rpb25zW3pvb21dID0ge1xuICAgICAgICAgIHpvb206IHpvb20sXG4gICAgICAgICAgdHlwZTogcGFyYW1ldGVycy50eXBlLFxuICAgICAgICAgIHByb3BlcnR5OiBwYXJhbWV0ZXJzLnByb3BlcnR5LFxuICAgICAgICAgIGRlZmF1bHQ6IHBhcmFtZXRlcnMuZGVmYXVsdCxcbiAgICAgICAgICBzdG9wczogW11cbiAgICAgICAgfTtcbiAgICAgICAgem9vbVN0b3BzLnB1c2goem9vbSk7XG4gICAgICB9XG5cbiAgICAgIGZlYXR1cmVGdW5jdGlvbnNbem9vbV0uc3RvcHMucHVzaChbX3N0b3BbMF0udmFsdWUsIF9zdG9wWzFdXSk7XG4gICAgfVxuXG4gICAgdmFyIGZlYXR1cmVGdW5jdGlvblN0b3BzID0gW107XG5cbiAgICBmb3IgKHZhciBfaTcgPSAwLCBfem9vbVN0b3BzID0gem9vbVN0b3BzOyBfaTcgPCBfem9vbVN0b3BzLmxlbmd0aDsgX2k3KyspIHtcbiAgICAgIHZhciB6ID0gX3pvb21TdG9wc1tfaTddO1xuICAgICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHMucHVzaChbZmVhdHVyZUZ1bmN0aW9uc1t6XS56b29tLCBjcmVhdGVGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25zW3pdLCBwcm9wZXJ0eVNwZWMpXSk7XG4gICAgfVxuXG4gICAgdmFyIGludGVycG9sYXRpb25UeXBlID0ge1xuICAgICAgbmFtZTogJ2xpbmVhcidcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiAnY29tcG9zaXRlJyxcbiAgICAgIGludGVycG9sYXRpb25UeXBlOiBpbnRlcnBvbGF0aW9uVHlwZSxcbiAgICAgIGludGVycG9sYXRpb25GYWN0b3I6IEludGVycG9sYXRlLmludGVycG9sYXRpb25GYWN0b3IuYmluZCh1bmRlZmluZWQsIGludGVycG9sYXRpb25UeXBlKSxcbiAgICAgIHpvb21TdG9wczogZmVhdHVyZUZ1bmN0aW9uU3RvcHMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzWzBdO1xuICAgICAgfSksXG4gICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUoX3JlZjEwOSwgcHJvcGVydGllcykge1xuICAgICAgICB2YXIgem9vbSA9IF9yZWYxMDkuem9vbTtcbiAgICAgICAgcmV0dXJuIGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbih7XG4gICAgICAgICAgc3RvcHM6IGZlYXR1cmVGdW5jdGlvblN0b3BzLFxuICAgICAgICAgIGJhc2U6IHBhcmFtZXRlcnMuYmFzZVxuICAgICAgICB9LCBwcm9wZXJ0eVNwZWMsIHpvb20pLmV2YWx1YXRlKHpvb20sIHByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAoem9vbURlcGVuZGVudCkge1xuICAgIHZhciBfaW50ZXJwb2xhdGlvblR5cGUgPSB0eXBlID09PSAnZXhwb25lbnRpYWwnID8ge1xuICAgICAgbmFtZTogJ2V4cG9uZW50aWFsJyxcbiAgICAgIGJhc2U6IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMVxuICAgIH0gOiBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6ICdjYW1lcmEnLFxuICAgICAgaW50ZXJwb2xhdGlvblR5cGU6IF9pbnRlcnBvbGF0aW9uVHlwZSxcbiAgICAgIGludGVycG9sYXRpb25GYWN0b3I6IEludGVycG9sYXRlLmludGVycG9sYXRpb25GYWN0b3IuYmluZCh1bmRlZmluZWQsIF9pbnRlcnBvbGF0aW9uVHlwZSksXG4gICAgICB6b29tU3RvcHM6IHBhcmFtZXRlcnMuc3RvcHMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHJldHVybiBzWzBdO1xuICAgICAgfSksXG4gICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUoX3JlZjExMCkge1xuICAgICAgICB2YXIgem9vbSA9IF9yZWYxMTAuem9vbTtcbiAgICAgICAgcmV0dXJuIGlubmVyRnVuKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgem9vbSwgaGFzaGVkU3RvcHMsIGNhdGVnb3JpY2FsS2V5VHlwZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ3NvdXJjZScsXG4gICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUoXywgZmVhdHVyZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBmZWF0dXJlICYmIGZlYXR1cmUucHJvcGVydGllcyA/IGZlYXR1cmUucHJvcGVydGllc1twYXJhbWV0ZXJzLnByb3BlcnR5XSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjb2FsZXNjZShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbm5lckZ1bihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHZhbHVlLCBoYXNoZWRTdG9wcywgY2F0ZWdvcmljYWxLZXlUeXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvYWxlc2NlKGEsIGIsIGMpIHtcbiAgaWYgKGEgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGE7XG4gIGlmIChiICE9PSB1bmRlZmluZWQpIHJldHVybiBiO1xuICBpZiAoYyAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVDYXRlZ29yaWNhbEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQsIGhhc2hlZFN0b3BzLCBrZXlUeXBlKSB7XG4gIHZhciBldmFsdWF0ZWQgPSB0eXBlb2YgaW5wdXQgPT09IGtleVR5cGUgPyBoYXNoZWRTdG9wc1tpbnB1dF0gOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjb2FsZXNjZShldmFsdWF0ZWQsIHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUludGVydmFsRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBpbnB1dCkge1xuICBpZiAoZ2V0VHlwZShpbnB1dCkgIT09ICdudW1iZXInKSByZXR1cm4gY29hbGVzY2UocGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG4gIHZhciBuID0gcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7XG4gIGlmIChuID09PSAxKSByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1swXVsxXTtcbiAgaWYgKGlucHV0IDw9IHBhcmFtZXRlcnMuc3RvcHNbMF1bMF0pIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xuICBpZiAoaW5wdXQgPj0gcGFyYW1ldGVycy5zdG9wc1tuIC0gMV1bMF0pIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVsxXTtcbiAgdmFyIGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhwYXJhbWV0ZXJzLnN0b3BzLm1hcChmdW5jdGlvbiAoc3RvcCkge1xuICAgIHJldHVybiBzdG9wWzBdO1xuICB9KSwgaW5wdXQpO1xuICByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1tpbmRleF1bMV07XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlRXhwb25lbnRpYWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0KSB7XG4gIHZhciBiYXNlID0gcGFyYW1ldGVycy5iYXNlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmJhc2UgOiAxO1xuICBpZiAoZ2V0VHlwZShpbnB1dCkgIT09ICdudW1iZXInKSByZXR1cm4gY29hbGVzY2UocGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG4gIHZhciBuID0gcGFyYW1ldGVycy5zdG9wcy5sZW5ndGg7XG4gIGlmIChuID09PSAxKSByZXR1cm4gcGFyYW1ldGVycy5zdG9wc1swXVsxXTtcbiAgaWYgKGlucHV0IDw9IHBhcmFtZXRlcnMuc3RvcHNbMF1bMF0pIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xuICBpZiAoaW5wdXQgPj0gcGFyYW1ldGVycy5zdG9wc1tuIC0gMV1bMF0pIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVsxXTtcbiAgdmFyIGluZGV4ID0gZmluZFN0b3BMZXNzVGhhbk9yRXF1YWxUbyhwYXJhbWV0ZXJzLnN0b3BzLm1hcChmdW5jdGlvbiAoc3RvcCkge1xuICAgIHJldHVybiBzdG9wWzBdO1xuICB9KSwgaW5wdXQpO1xuICB2YXIgdCA9IGludGVycG9sYXRpb25GYWN0b3IoaW5wdXQsIGJhc2UsIHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzBdLCBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4ICsgMV1bMF0pO1xuICB2YXIgb3V0cHV0TG93ZXIgPSBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4XVsxXTtcbiAgdmFyIG91dHB1dFVwcGVyID0gcGFyYW1ldGVycy5zdG9wc1tpbmRleCArIDFdWzFdO1xuICB2YXIgaW50ZXJwID0gaW50ZXJwb2xhdGVbcHJvcGVydHlTcGVjLnR5cGVdIHx8IGlkZW50aXR5RnVuY3Rpb247XG5cbiAgaWYgKHBhcmFtZXRlcnMuY29sb3JTcGFjZSAmJiBwYXJhbWV0ZXJzLmNvbG9yU3BhY2UgIT09ICdyZ2InKSB7XG4gICAgdmFyIGNvbG9yc3BhY2UgPSBjb2xvclNwYWNlc1twYXJhbWV0ZXJzLmNvbG9yU3BhY2VdO1xuXG4gICAgaW50ZXJwID0gZnVuY3Rpb24gaW50ZXJwKGEsIGIpIHtcbiAgICAgIHJldHVybiBjb2xvcnNwYWNlLnJldmVyc2UoY29sb3JzcGFjZS5pbnRlcnBvbGF0ZShjb2xvcnNwYWNlLmZvcndhcmQoYSksIGNvbG9yc3BhY2UuZm9yd2FyZChiKSwgdCkpO1xuICAgIH07XG4gIH1cblxuICBpZiAodHlwZW9mIG91dHB1dExvd2VyLmV2YWx1YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiBldmFsdWF0ZSgpIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW4zOyBfa2V5NSsrKSB7XG4gICAgICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV2YWx1YXRlZExvd2VyID0gb3V0cHV0TG93ZXIuZXZhbHVhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgdmFyIGV2YWx1YXRlZFVwcGVyID0gb3V0cHV0VXBwZXIuZXZhbHVhdGUuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcblxuICAgICAgICBpZiAoZXZhbHVhdGVkTG93ZXIgPT09IHVuZGVmaW5lZCB8fCBldmFsdWF0ZWRVcHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnRlcnAoZXZhbHVhdGVkTG93ZXIsIGV2YWx1YXRlZFVwcGVyLCB0KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGludGVycChvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIsIHQpO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUlkZW50aXR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBpbnB1dCkge1xuICBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICBpbnB1dCA9IENvbG9yLnBhcnNlKGlucHV0KTtcbiAgfSBlbHNlIGlmIChwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2Zvcm1hdHRlZCcpIHtcbiAgICBpbnB1dCA9IEZvcm1hdHRlZC5mcm9tU3RyaW5nKGlucHV0LnRvU3RyaW5nKCkpO1xuICB9IGVsc2UgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAncmVzb2x2ZWRJbWFnZScpIHtcbiAgICBpbnB1dCA9IFJlc29sdmVkSW1hZ2UuZnJvbVN0cmluZyhpbnB1dC50b1N0cmluZygpKTtcbiAgfSBlbHNlIGlmIChnZXRUeXBlKGlucHV0KSAhPT0gcHJvcGVydHlTcGVjLnR5cGUgJiYgKHByb3BlcnR5U3BlYy50eXBlICE9PSAnZW51bScgfHwgIXByb3BlcnR5U3BlYy52YWx1ZXNbaW5wdXRdKSkge1xuICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmV0dXJuIGNvYWxlc2NlKGlucHV0LCBwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbn1cblxuZnVuY3Rpb24gaW50ZXJwb2xhdGlvbkZhY3RvcihpbnB1dCwgYmFzZSwgbG93ZXJWYWx1ZSwgdXBwZXJWYWx1ZSkge1xuICB2YXIgZGlmZmVyZW5jZSA9IHVwcGVyVmFsdWUgLSBsb3dlclZhbHVlO1xuICB2YXIgcHJvZ3Jlc3MgPSBpbnB1dCAtIGxvd2VyVmFsdWU7XG5cbiAgaWYgKGRpZmZlcmVuY2UgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChiYXNlID09PSAxKSB7XG4gICAgcmV0dXJuIHByb2dyZXNzIC8gZGlmZmVyZW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKE1hdGgucG93KGJhc2UsIHByb2dyZXNzKSAtIDEpIC8gKE1hdGgucG93KGJhc2UsIGRpZmZlcmVuY2UpIC0gMSk7XG4gIH1cbn1cblxudmFyIFN0eWxlRXhwcmVzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0eWxlRXhwcmVzc2lvbihleHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3R5bGVFeHByZXNzaW9uKTtcblxuICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgdGhpcy5fd2FybmluZ0hpc3RvcnkgPSB7fTtcbiAgICB0aGlzLl9ldmFsdWF0b3IgPSBuZXcgRXZhbHVhdGlvbkNvbnRleHQoKTtcbiAgICB0aGlzLl9kZWZhdWx0VmFsdWUgPSBwcm9wZXJ0eVNwZWMgPyBnZXREZWZhdWx0VmFsdWUocHJvcGVydHlTcGVjKSA6IG51bGw7XG4gICAgdGhpcy5fZW51bVZhbHVlcyA9IHByb3BlcnR5U3BlYyAmJiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2VudW0nID8gcHJvcGVydHlTcGVjLnZhbHVlcyA6IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3R5bGVFeHByZXNzaW9uLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgICAgdGhpcy5fZXZhbHVhdG9yLmdsb2JhbHMgPSBnbG9iYWxzO1xuICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IGZlYXR1cmVTdGF0ZTtcbiAgICAgIHRoaXMuX2V2YWx1YXRvci5jYW5vbmljYWwgPSBjYW5vbmljYWw7XG4gICAgICB0aGlzLl9ldmFsdWF0b3IuYXZhaWxhYmxlSW1hZ2VzID0gYXZhaWxhYmxlSW1hZ2VzIHx8IG51bGw7XG4gICAgICB0aGlzLl9ldmFsdWF0b3IuZm9ybWF0dGVkU2VjdGlvbiA9IGZvcm1hdHRlZFNlY3Rpb247XG4gICAgICByZXR1cm4gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHRoaXMuX2V2YWx1YXRvcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICAgIHRoaXMuX2V2YWx1YXRvci5nbG9iYWxzID0gZ2xvYmFscztcbiAgICAgIHRoaXMuX2V2YWx1YXRvci5mZWF0dXJlID0gZmVhdHVyZSB8fCBudWxsO1xuICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmVTdGF0ZSA9IGZlYXR1cmVTdGF0ZSB8fCBudWxsO1xuICAgICAgdGhpcy5fZXZhbHVhdG9yLmNhbm9uaWNhbCA9IGNhbm9uaWNhbDtcbiAgICAgIHRoaXMuX2V2YWx1YXRvci5hdmFpbGFibGVJbWFnZXMgPSBhdmFpbGFibGVJbWFnZXMgfHwgbnVsbDtcbiAgICAgIHRoaXMuX2V2YWx1YXRvci5mb3JtYXR0ZWRTZWN0aW9uID0gZm9ybWF0dGVkU2VjdGlvbiB8fCBudWxsO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5leHByZXNzaW9uLmV2YWx1YXRlKHRoaXMuX2V2YWx1YXRvcik7XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJiB2YWwgIT09IHZhbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZW51bVZhbHVlcyAmJiAhKHZhbCBpbiB0aGlzLl9lbnVtVmFsdWVzKSkge1xuICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJFeHBlY3RlZCB2YWx1ZSB0byBiZSBvbmUgb2YgXCIuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMuX2VudW1WYWx1ZXMpLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICAgIH0pLmpvaW4oJywgJyksIFwiLCBidXQgZm91bmQgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeSh2YWwpLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIXRoaXMuX3dhcm5pbmdIaXN0b3J5W2UubWVzc2FnZV0pIHtcbiAgICAgICAgICB0aGlzLl93YXJuaW5nSGlzdG9yeVtlLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0eWxlRXhwcmVzc2lvbjtcbn0oKTtcblxuZnVuY3Rpb24gaXNFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbikgJiYgZXhwcmVzc2lvbi5sZW5ndGggPiAwICYmIHR5cGVvZiBleHByZXNzaW9uWzBdID09PSAnc3RyaW5nJyAmJiBleHByZXNzaW9uWzBdIGluIGV4cHJlc3Npb25zO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHByb3BlcnR5U3BlYykge1xuICB2YXIgcGFyc2VyID0gbmV3IFBhcnNpbmdDb250ZXh0KGV4cHJlc3Npb25zLCBbXSwgcHJvcGVydHlTcGVjID8gZ2V0RXhwZWN0ZWRUeXBlKHByb3BlcnR5U3BlYykgOiB1bmRlZmluZWQpO1xuICB2YXIgcGFyc2VkID0gcGFyc2VyLnBhcnNlKGV4cHJlc3Npb24sIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHByb3BlcnR5U3BlYyAmJiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ3N0cmluZycgPyB7XG4gICAgdHlwZUFubm90YXRpb246ICdjb2VyY2UnXG4gIH0gOiB1bmRlZmluZWQpO1xuXG4gIGlmICghcGFyc2VkKSB7XG4gICAgcmV0dXJuIGVycm9yKHBhcnNlci5lcnJvcnMpO1xuICB9XG5cbiAgcmV0dXJuIHN1Y2Nlc3MobmV3IFN0eWxlRXhwcmVzc2lvbihwYXJzZWQsIHByb3BlcnR5U3BlYykpO1xufVxuXG52YXIgWm9vbUNvbnN0YW50RXhwcmVzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFpvb21Db25zdGFudEV4cHJlc3Npb24oa2luZCwgZXhwcmVzc2lvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBab29tQ29uc3RhbnRFeHByZXNzaW9uKTtcblxuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy5fc3R5bGVFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB0aGlzLmlzU3RhdGVEZXBlbmRlbnQgPSBraW5kICE9PSAnY29uc3RhbnQnICYmICFpc1N0YXRlQ29uc3RhbnQoZXhwcmVzc2lvbi5leHByZXNzaW9uKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhab29tQ29uc3RhbnRFeHByZXNzaW9uLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBab29tQ29uc3RhbnRFeHByZXNzaW9uO1xufSgpO1xuXG52YXIgWm9vbURlcGVuZGVudEV4cHJlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBab29tRGVwZW5kZW50RXhwcmVzc2lvbihraW5kLCBleHByZXNzaW9uLCB6b29tU3RvcHMsIGludGVycG9sYXRpb25UeXBlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFpvb21EZXBlbmRlbnRFeHByZXNzaW9uKTtcblxuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy56b29tU3RvcHMgPSB6b29tU3RvcHM7XG4gICAgdGhpcy5fc3R5bGVFeHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB0aGlzLmlzU3RhdGVEZXBlbmRlbnQgPSBraW5kICE9PSAnY2FtZXJhJyAmJiAhaXNTdGF0ZUNvbnN0YW50KGV4cHJlc3Npb24uZXhwcmVzc2lvbik7XG4gICAgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9IGludGVycG9sYXRpb25UeXBlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFpvb21EZXBlbmRlbnRFeHByZXNzaW9uLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0eWxlRXhwcmVzc2lvbi5ldmFsdWF0ZVdpdGhvdXRFcnJvckhhbmRsaW5nKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnRlcnBvbGF0aW9uRmFjdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVycG9sYXRpb25GYWN0b3IoaW5wdXQsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGlvblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIEludGVycG9sYXRlLmludGVycG9sYXRpb25GYWN0b3IodGhpcy5pbnRlcnBvbGF0aW9uVHlwZSwgaW5wdXQsIGxvd2VyLCB1cHBlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gWm9vbURlcGVuZGVudEV4cHJlc3Npb247XG59KCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbihleHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpIHtcbiAgZXhwcmVzc2lvbiA9IGNyZWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKTtcblxuICBpZiAoZXhwcmVzc2lvbi5yZXN1bHQgPT09ICdlcnJvcicpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgfVxuXG4gIHZhciBwYXJzZWQgPSBleHByZXNzaW9uLnZhbHVlLmV4cHJlc3Npb247XG4gIHZhciBpc0ZlYXR1cmVDb25zdGFudCQxID0gaXNGZWF0dXJlQ29uc3RhbnQocGFyc2VkKTtcblxuICBpZiAoIWlzRmVhdHVyZUNvbnN0YW50JDEgJiYgIXN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKHByb3BlcnR5U3BlYykpIHtcbiAgICByZXR1cm4gZXJyb3IoW25ldyBQYXJzaW5nRXJyb3IoJycsICdkYXRhIGV4cHJlc3Npb25zIG5vdCBzdXBwb3J0ZWQnKV0pO1xuICB9XG5cbiAgdmFyIGlzWm9vbUNvbnN0YW50ID0gaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KHBhcnNlZCwgWyd6b29tJ10pO1xuXG4gIGlmICghaXNab29tQ29uc3RhbnQgJiYgIXN1cHBvcnRzWm9vbUV4cHJlc3Npb24ocHJvcGVydHlTcGVjKSkge1xuICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJ3pvb20gZXhwcmVzc2lvbnMgbm90IHN1cHBvcnRlZCcpXSk7XG4gIH1cblxuICB2YXIgem9vbUN1cnZlID0gZmluZFpvb21DdXJ2ZShwYXJzZWQpO1xuXG4gIGlmICghem9vbUN1cnZlICYmICFpc1pvb21Db25zdGFudCkge1xuICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJ1wiem9vbVwiIGV4cHJlc3Npb24gbWF5IG9ubHkgYmUgdXNlZCBhcyBpbnB1dCB0byBhIHRvcC1sZXZlbCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbi4nKV0pO1xuICB9IGVsc2UgaWYgKHpvb21DdXJ2ZSBpbnN0YW5jZW9mIFBhcnNpbmdFcnJvcikge1xuICAgIHJldHVybiBlcnJvcihbem9vbUN1cnZlXSk7XG4gIH0gZWxzZSBpZiAoem9vbUN1cnZlIGluc3RhbmNlb2YgSW50ZXJwb2xhdGUgJiYgIXN1cHBvcnRzSW50ZXJwb2xhdGlvbihwcm9wZXJ0eVNwZWMpKSB7XG4gICAgcmV0dXJuIGVycm9yKFtuZXcgUGFyc2luZ0Vycm9yKCcnLCAnXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb25zIGNhbm5vdCBiZSB1c2VkIHdpdGggdGhpcyBwcm9wZXJ0eScpXSk7XG4gIH1cblxuICBpZiAoIXpvb21DdXJ2ZSkge1xuICAgIHJldHVybiBzdWNjZXNzKGlzRmVhdHVyZUNvbnN0YW50JDEgPyBuZXcgWm9vbUNvbnN0YW50RXhwcmVzc2lvbignY29uc3RhbnQnLCBleHByZXNzaW9uLnZhbHVlKSA6IG5ldyBab29tQ29uc3RhbnRFeHByZXNzaW9uKCdzb3VyY2UnLCBleHByZXNzaW9uLnZhbHVlKSk7XG4gIH1cblxuICB2YXIgaW50ZXJwb2xhdGlvblR5cGUgPSB6b29tQ3VydmUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0ZSA/IHpvb21DdXJ2ZS5pbnRlcnBvbGF0aW9uIDogdW5kZWZpbmVkO1xuICByZXR1cm4gc3VjY2Vzcyhpc0ZlYXR1cmVDb25zdGFudCQxID8gbmV3IFpvb21EZXBlbmRlbnRFeHByZXNzaW9uKCdjYW1lcmEnLCBleHByZXNzaW9uLnZhbHVlLCB6b29tQ3VydmUubGFiZWxzLCBpbnRlcnBvbGF0aW9uVHlwZSkgOiBuZXcgWm9vbURlcGVuZGVudEV4cHJlc3Npb24oJ2NvbXBvc2l0ZScsIGV4cHJlc3Npb24udmFsdWUsIHpvb21DdXJ2ZS5sYWJlbHMsIGludGVycG9sYXRpb25UeXBlKSk7XG59XG5cbnZhciBTdHlsZVByb3BlcnR5RnVuY3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgc3BlY2lmaWNhdGlvbikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZVByb3BlcnR5RnVuY3Rpb24pO1xuXG4gICAgdGhpcy5fcGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgdGhpcy5fc3BlY2lmaWNhdGlvbiA9IHNwZWNpZmljYXRpb247XG4gICAgZXh0ZW5kKHRoaXMsIGNyZWF0ZUZ1bmN0aW9uKHRoaXMuX3BhcmFtZXRlcnMsIHRoaXMuX3NwZWNpZmljYXRpb24pKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdHlsZVByb3BlcnR5RnVuY3Rpb24sIG51bGwsIFt7XG4gICAga2V5OiBcImRlc2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHtcbiAgICAgIHJldHVybiBuZXcgU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uKHNlcmlhbGl6ZWQuX3BhcmFtZXRlcnMsIHNlcmlhbGl6ZWQuX3NwZWNpZmljYXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKGlucHV0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBfcGFyYW1ldGVyczogaW5wdXQuX3BhcmFtZXRlcnMsXG4gICAgICAgIF9zcGVjaWZpY2F0aW9uOiBpbnB1dC5fc3BlY2lmaWNhdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uO1xufSgpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wZXJ0eUV4cHJlc3Npb24odmFsdWUsIHNwZWNpZmljYXRpb24pIHtcbiAgaWYgKGlzRnVuY3Rpb24kMSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gbmV3IFN0eWxlUHJvcGVydHlGdW5jdGlvbih2YWx1ZSwgc3BlY2lmaWNhdGlvbik7XG4gIH0gZWxzZSBpZiAoaXNFeHByZXNzaW9uKHZhbHVlKSkge1xuICAgIHZhciBfZXhwcmVzc2lvbjggPSBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb24odmFsdWUsIHNwZWNpZmljYXRpb24pO1xuXG4gICAgaWYgKF9leHByZXNzaW9uOC5yZXN1bHQgPT09ICdlcnJvcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihfZXhwcmVzc2lvbjgudmFsdWUubWFwKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGVyci5rZXksIFwiOiBcIikuY29uY2F0KGVyci5tZXNzYWdlKTtcbiAgICAgIH0pLmpvaW4oJywgJykpO1xuICAgIH1cblxuICAgIHJldHVybiBfZXhwcmVzc2lvbjgudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnN0YW50ID0gdmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBzcGVjaWZpY2F0aW9uLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICAgIGNvbnN0YW50ID0gQ29sb3IucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBraW5kOiAnY29uc3RhbnQnLFxuICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIGV2YWx1YXRlKCkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnQ7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kWm9vbUN1cnZlKGV4cHJlc3Npb24pIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBMZXQpIHtcbiAgICByZXN1bHQgPSBmaW5kWm9vbUN1cnZlKGV4cHJlc3Npb24ucmVzdWx0KTtcbiAgfSBlbHNlIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQ29hbGVzY2UpIHtcbiAgICB2YXIgX2l0ZXJhdG9yNDAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihleHByZXNzaW9uLmFyZ3MpLFxuICAgICAgICBfc3RlcDQwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNDAucygpOyAhKF9zdGVwNDAgPSBfaXRlcmF0b3I0MC5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBhcmcgPSBfc3RlcDQwLnZhbHVlO1xuICAgICAgICByZXN1bHQgPSBmaW5kWm9vbUN1cnZlKGFyZyk7XG5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I0MC5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjQwLmYoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBTdGVwIHx8IGV4cHJlc3Npb24gaW5zdGFuY2VvZiBJbnRlcnBvbGF0ZSkgJiYgZXhwcmVzc2lvbi5pbnB1dCBpbnN0YW5jZW9mIENvbXBvdW5kRXhwcmVzc2lvbiAmJiBleHByZXNzaW9uLmlucHV0Lm5hbWUgPT09ICd6b29tJykge1xuICAgIHJlc3VsdCA9IGV4cHJlc3Npb247XG4gIH1cblxuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGV4cHJlc3Npb24uZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHZhciBjaGlsZFJlc3VsdCA9IGZpbmRab29tQ3VydmUoY2hpbGQpO1xuXG4gICAgaWYgKGNoaWxkUmVzdWx0IGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgICByZXN1bHQgPSBjaGlsZFJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKCFyZXN1bHQgJiYgY2hpbGRSZXN1bHQpIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBQYXJzaW5nRXJyb3IoJycsICdcInpvb21cIiBleHByZXNzaW9uIG1heSBvbmx5IGJlIHVzZWQgYXMgaW5wdXQgdG8gYSB0b3AtbGV2ZWwgXCJzdGVwXCIgb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb24uJyk7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQgJiYgY2hpbGRSZXN1bHQgJiYgcmVzdWx0ICE9PSBjaGlsZFJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gbmV3IFBhcnNpbmdFcnJvcignJywgJ09ubHkgb25lIHpvb20tYmFzZWQgXCJzdGVwXCIgb3IgXCJpbnRlcnBvbGF0ZVwiIHN1YmV4cHJlc3Npb24gbWF5IGJlIHVzZWQgaW4gYW4gZXhwcmVzc2lvbi4nKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRFeHBlY3RlZFR5cGUoc3BlYykge1xuICB2YXIgdHlwZXMgPSB7XG4gICAgY29sb3I6IENvbG9yVHlwZSxcbiAgICBzdHJpbmc6IFN0cmluZ1R5cGUsXG4gICAgbnVtYmVyOiBOdW1iZXJUeXBlLFxuICAgIGVudW06IFN0cmluZ1R5cGUsXG4gICAgYm9vbGVhbjogQm9vbGVhblR5cGUsXG4gICAgZm9ybWF0dGVkOiBGb3JtYXR0ZWRUeXBlLFxuICAgIHJlc29sdmVkSW1hZ2U6IFJlc29sdmVkSW1hZ2VUeXBlXG4gIH07XG5cbiAgaWYgKHNwZWMudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgIHJldHVybiBhcnJheSh0eXBlc1tzcGVjLnZhbHVlXSB8fCBWYWx1ZVR5cGUsIHNwZWMubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlc1tzcGVjLnR5cGVdO1xufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0VmFsdWUoc3BlYykge1xuICBpZiAoc3BlYy50eXBlID09PSAnY29sb3InICYmIGlzRnVuY3Rpb24kMShzcGVjLmRlZmF1bHQpKSB7XG4gICAgcmV0dXJuIG5ldyBDb2xvcigwLCAwLCAwLCAwKTtcbiAgfSBlbHNlIGlmIChzcGVjLnR5cGUgPT09ICdjb2xvcicpIHtcbiAgICByZXR1cm4gQ29sb3IucGFyc2Uoc3BlYy5kZWZhdWx0KSB8fCBudWxsO1xuICB9IGVsc2UgaWYgKHNwZWMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNwZWMuZGVmYXVsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0TGl0ZXJhbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IFsnbGl0ZXJhbCcsIHZhbHVlXSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKSB7XG4gIHZhciBzdG9wcyA9IHBhcmFtZXRlcnMuc3RvcHM7XG5cbiAgaWYgKCFzdG9wcykge1xuICAgIHJldHVybiBjb252ZXJ0SWRlbnRpdHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpO1xuICB9XG5cbiAgdmFyIHpvb21BbmRGZWF0dXJlRGVwZW5kZW50ID0gc3RvcHMgJiYgdHlwZW9mIHN0b3BzWzBdWzBdID09PSAnb2JqZWN0JztcbiAgdmFyIGZlYXR1cmVEZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCBwYXJhbWV0ZXJzLnByb3BlcnR5ICE9PSB1bmRlZmluZWQ7XG4gIHZhciB6b29tRGVwZW5kZW50ID0gem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgfHwgIWZlYXR1cmVEZXBlbmRlbnQ7XG4gIHN0b3BzID0gc3RvcHMubWFwKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgaWYgKCFmZWF0dXJlRGVwZW5kZW50ICYmIHByb3BlcnR5U3BlYy50b2tlbnMgJiYgdHlwZW9mIHN0b3BbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gW3N0b3BbMF0sIGNvbnZlcnRUb2tlblN0cmluZyhzdG9wWzFdKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtzdG9wWzBdLCBjb252ZXJ0TGl0ZXJhbChzdG9wWzFdKV07XG4gIH0pO1xuXG4gIGlmICh6b29tQW5kRmVhdHVyZURlcGVuZGVudCkge1xuICAgIHJldHVybiBjb252ZXJ0Wm9vbUFuZFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcyk7XG4gIH0gZWxzZSBpZiAoem9vbURlcGVuZGVudCkge1xuICAgIHJldHVybiBjb252ZXJ0Wm9vbUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0SWRlbnRpdHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgdmFyIGdldCA9IFsnZ2V0JywgcGFyYW1ldGVycy5wcm9wZXJ0eV07XG5cbiAgaWYgKHBhcmFtZXRlcnMuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5U3BlYy50eXBlID09PSAnc3RyaW5nJyA/IFsnc3RyaW5nJywgZ2V0XSA6IGdldDtcbiAgfSBlbHNlIGlmIChwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2VudW0nKSB7XG4gICAgcmV0dXJuIFsnbWF0Y2gnLCBnZXQsIE9iamVjdC5rZXlzKHByb3BlcnR5U3BlYy52YWx1ZXMpLCBnZXQsIHBhcmFtZXRlcnMuZGVmYXVsdF07XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9leHByZXNzaW9uOSA9IFtwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2NvbG9yJyA/ICd0by1jb2xvcicgOiBwcm9wZXJ0eVNwZWMudHlwZSwgZ2V0LCBjb252ZXJ0TGl0ZXJhbChwYXJhbWV0ZXJzLmRlZmF1bHQpXTtcblxuICAgIGlmIChwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgICAgX2V4cHJlc3Npb245LnNwbGljZSgxLCAwLCBwcm9wZXJ0eVNwZWMudmFsdWUsIHByb3BlcnR5U3BlYy5sZW5ndGggfHwgbnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leHByZXNzaW9uOTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRJbnRlcnBvbGF0ZU9wZXJhdG9yKHBhcmFtZXRlcnMpIHtcbiAgc3dpdGNoIChwYXJhbWV0ZXJzLmNvbG9yU3BhY2UpIHtcbiAgICBjYXNlICdoY2wnOlxuICAgICAgcmV0dXJuICdpbnRlcnBvbGF0ZS1oY2wnO1xuXG4gICAgY2FzZSAnbGFiJzpcbiAgICAgIHJldHVybiAnaW50ZXJwb2xhdGUtbGFiJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJ2ludGVycG9sYXRlJztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0Wm9vbUFuZFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcykge1xuICB2YXIgZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVycyA9IHt9O1xuICB2YXIgZmVhdHVyZUZ1bmN0aW9uU3RvcHMgPSB7fTtcbiAgdmFyIHpvb21TdG9wcyA9IFtdO1xuXG4gIGZvciAodmFyIHMgPSAwOyBzIDwgc3RvcHMubGVuZ3RoOyBzKyspIHtcbiAgICB2YXIgc3RvcCA9IHN0b3BzW3NdO1xuICAgIHZhciB6b29tID0gc3RvcFswXS56b29tO1xuXG4gICAgaWYgKGZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnNbem9vbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVyc1t6b29tXSA9IHtcbiAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgdHlwZTogcGFyYW1ldGVycy50eXBlLFxuICAgICAgICBwcm9wZXJ0eTogcGFyYW1ldGVycy5wcm9wZXJ0eSxcbiAgICAgICAgZGVmYXVsdDogcGFyYW1ldGVycy5kZWZhdWx0XG4gICAgICB9O1xuICAgICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHNbem9vbV0gPSBbXTtcbiAgICAgIHpvb21TdG9wcy5wdXNoKHpvb20pO1xuICAgIH1cblxuICAgIGZlYXR1cmVGdW5jdGlvblN0b3BzW3pvb21dLnB1c2goW3N0b3BbMF0udmFsdWUsIHN0b3BbMV1dKTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvblR5cGUgPSBnZXRGdW5jdGlvblR5cGUoe30sIHByb3BlcnR5U3BlYyk7XG5cbiAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgIHZhciBfZXhwcmVzc2lvbjEwID0gW2dldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycyksIFsnbGluZWFyJ10sIFsnem9vbSddXTtcblxuICAgIHZhciBfaXRlcmF0b3I0MSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHpvb21TdG9wcyksXG4gICAgICAgIF9zdGVwNDE7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I0MS5zKCk7ICEoX3N0ZXA0MSA9IF9pdGVyYXRvcjQxLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHogPSBfc3RlcDQxLnZhbHVlO1xuICAgICAgICB2YXIgb3V0cHV0ID0gY29udmVydFByb3BlcnR5RnVuY3Rpb24oZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVyc1t6XSwgcHJvcGVydHlTcGVjLCBmZWF0dXJlRnVuY3Rpb25TdG9wc1t6XSk7XG4gICAgICAgIGFwcGVuZFN0b3BQYWlyKF9leHByZXNzaW9uMTAsIHosIG91dHB1dCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNDEuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I0MS5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leHByZXNzaW9uMTA7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9leHByZXNzaW9uMTEgPSBbJ3N0ZXAnLCBbJ3pvb20nXV07XG5cbiAgICB2YXIgX2l0ZXJhdG9yNDIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih6b29tU3RvcHMpLFxuICAgICAgICBfc3RlcDQyO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNDIucygpOyAhKF9zdGVwNDIgPSBfaXRlcmF0b3I0Mi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfeiA9IF9zdGVwNDIudmFsdWU7XG5cbiAgICAgICAgdmFyIF9vdXRwdXQgPSBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW196XSwgcHJvcGVydHlTcGVjLCBmZWF0dXJlRnVuY3Rpb25TdG9wc1tfel0pO1xuXG4gICAgICAgIGFwcGVuZFN0b3BQYWlyKF9leHByZXNzaW9uMTEsIF96LCBfb3V0cHV0LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjQyLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNDIuZigpO1xuICAgIH1cblxuICAgIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShfZXhwcmVzc2lvbjExKTtcbiAgICByZXR1cm4gX2V4cHJlc3Npb24xMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb2FsZXNjZSQxKGEsIGIpIHtcbiAgaWYgKGEgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGE7XG4gIGlmIChiICE9PSB1bmRlZmluZWQpIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBnZXRGYWxsYmFjayhwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IGNvbnZlcnRMaXRlcmFsKGNvYWxlc2NlJDEocGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCkpO1xuXG4gIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ3Jlc29sdmVkSW1hZ2UnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gY29udmVydFByb3BlcnR5RnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcykge1xuICB2YXIgdHlwZSA9IGdldEZ1bmN0aW9uVHlwZShwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpO1xuICB2YXIgZ2V0ID0gWydnZXQnLCBwYXJhbWV0ZXJzLnByb3BlcnR5XTtcblxuICBpZiAodHlwZSA9PT0gJ2NhdGVnb3JpY2FsJyAmJiB0eXBlb2Ygc3RvcHNbMF1bMF0gPT09ICdib29sZWFuJykge1xuICAgIHZhciBfZXhwcmVzc2lvbjEyID0gWydjYXNlJ107XG5cbiAgICB2YXIgX2l0ZXJhdG9yNDMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdG9wcyksXG4gICAgICAgIF9zdGVwNDM7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I0My5zKCk7ICEoX3N0ZXA0MyA9IF9pdGVyYXRvcjQzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHN0b3AgPSBfc3RlcDQzLnZhbHVlO1xuXG4gICAgICAgIF9leHByZXNzaW9uMTIucHVzaChbJz09JywgZ2V0LCBzdG9wWzBdXSwgc3RvcFsxXSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I0My5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjQzLmYoKTtcbiAgICB9XG5cbiAgICBfZXhwcmVzc2lvbjEyLnB1c2goZ2V0RmFsbGJhY2socGFyYW1ldGVycywgcHJvcGVydHlTcGVjKSk7XG5cbiAgICByZXR1cm4gX2V4cHJlc3Npb24xMjtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnKSB7XG4gICAgdmFyIF9leHByZXNzaW9uMTMgPSBbJ21hdGNoJywgZ2V0XTtcblxuICAgIHZhciBfaXRlcmF0b3I0NCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0b3BzKSxcbiAgICAgICAgX3N0ZXA0NDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjQ0LnMoKTsgIShfc3RlcDQ0ID0gX2l0ZXJhdG9yNDQubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0b3AyID0gX3N0ZXA0NC52YWx1ZTtcbiAgICAgICAgYXBwZW5kU3RvcFBhaXIoX2V4cHJlc3Npb24xMywgX3N0b3AyWzBdLCBfc3RvcDJbMV0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjQ0LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNDQuZigpO1xuICAgIH1cblxuICAgIF9leHByZXNzaW9uMTMucHVzaChnZXRGYWxsYmFjayhwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpKTtcblxuICAgIHJldHVybiBfZXhwcmVzc2lvbjEzO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnRlcnZhbCcpIHtcbiAgICB2YXIgX2V4cHJlc3Npb24xNCA9IFsnc3RlcCcsIFsnbnVtYmVyJywgZ2V0XV07XG5cbiAgICB2YXIgX2l0ZXJhdG9yNDUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdG9wcyksXG4gICAgICAgIF9zdGVwNDU7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I0NS5zKCk7ICEoX3N0ZXA0NSA9IF9pdGVyYXRvcjQ1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdG9wMyA9IF9zdGVwNDUudmFsdWU7XG4gICAgICAgIGFwcGVuZFN0b3BQYWlyKF9leHByZXNzaW9uMTQsIF9zdG9wM1swXSwgX3N0b3AzWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjQ1LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNDUuZigpO1xuICAgIH1cblxuICAgIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShfZXhwcmVzc2lvbjE0KTtcbiAgICByZXR1cm4gcGFyYW1ldGVycy5kZWZhdWx0ID09PSB1bmRlZmluZWQgPyBfZXhwcmVzc2lvbjE0IDogWydjYXNlJywgWyc9PScsIFsndHlwZW9mJywgZ2V0XSwgJ251bWJlciddLCBfZXhwcmVzc2lvbjE0LCBjb252ZXJ0TGl0ZXJhbChwYXJhbWV0ZXJzLmRlZmF1bHQpXTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgdmFyIGJhc2UgPSBwYXJhbWV0ZXJzLmJhc2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYmFzZSA6IDE7XG4gICAgdmFyIF9leHByZXNzaW9uMTUgPSBbZ2V0SW50ZXJwb2xhdGVPcGVyYXRvcihwYXJhbWV0ZXJzKSwgYmFzZSA9PT0gMSA/IFsnbGluZWFyJ10gOiBbJ2V4cG9uZW50aWFsJywgYmFzZV0sIFsnbnVtYmVyJywgZ2V0XV07XG5cbiAgICB2YXIgX2l0ZXJhdG9yNDYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdG9wcyksXG4gICAgICAgIF9zdGVwNDY7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I0Ni5zKCk7ICEoX3N0ZXA0NiA9IF9pdGVyYXRvcjQ2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdG9wNCA9IF9zdGVwNDYudmFsdWU7XG4gICAgICAgIGFwcGVuZFN0b3BQYWlyKF9leHByZXNzaW9uMTUsIF9zdG9wNFswXSwgX3N0b3A0WzFdLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I0Ni5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjQ2LmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1ldGVycy5kZWZhdWx0ID09PSB1bmRlZmluZWQgPyBfZXhwcmVzc2lvbjE1IDogWydjYXNlJywgWyc9PScsIFsndHlwZW9mJywgZ2V0XSwgJ251bWJlciddLCBfZXhwcmVzc2lvbjE1LCBjb252ZXJ0TGl0ZXJhbChwYXJhbWV0ZXJzLmRlZmF1bHQpXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHByb3BlcnR5IGZ1bmN0aW9uIHR5cGUgXCIuY29uY2F0KHR5cGUpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0Wm9vbUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpIHtcbiAgdmFyIGlucHV0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBbJ3pvb20nXTtcbiAgdmFyIHR5cGUgPSBnZXRGdW5jdGlvblR5cGUocGFyYW1ldGVycywgcHJvcGVydHlTcGVjKTtcbiAgdmFyIGV4cHJlc3Npb247XG4gIHZhciBpc1N0ZXAgPSBmYWxzZTtcblxuICBpZiAodHlwZSA9PT0gJ2ludGVydmFsJykge1xuICAgIGV4cHJlc3Npb24gPSBbJ3N0ZXAnLCBpbnB1dF07XG4gICAgaXNTdGVwID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgdmFyIGJhc2UgPSBwYXJhbWV0ZXJzLmJhc2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYmFzZSA6IDE7XG4gICAgZXhwcmVzc2lvbiA9IFtnZXRJbnRlcnBvbGF0ZU9wZXJhdG9yKHBhcmFtZXRlcnMpLCBiYXNlID09PSAxID8gWydsaW5lYXInXSA6IFsnZXhwb25lbnRpYWwnLCBiYXNlXSwgaW5wdXRdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gem9vbSBmdW5jdGlvbiB0eXBlIFxcXCJcIi5jb25jYXQodHlwZSwgXCJcXFwiXCIpKTtcbiAgfVxuXG4gIHZhciBfaXRlcmF0b3I0NyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0b3BzKSxcbiAgICAgIF9zdGVwNDc7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjQ3LnMoKTsgIShfc3RlcDQ3ID0gX2l0ZXJhdG9yNDcubigpKS5kb25lOykge1xuICAgICAgdmFyIHN0b3AgPSBfc3RlcDQ3LnZhbHVlO1xuICAgICAgYXBwZW5kU3RvcFBhaXIoZXhwcmVzc2lvbiwgc3RvcFswXSwgc3RvcFsxXSwgaXNTdGVwKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjQ3LmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3I0Ny5mKCk7XG4gIH1cblxuICBmaXh1cERlZ2VuZXJhdGVTdGVwQ3VydmUoZXhwcmVzc2lvbik7XG4gIHJldHVybiBleHByZXNzaW9uO1xufVxuXG5mdW5jdGlvbiBmaXh1cERlZ2VuZXJhdGVTdGVwQ3VydmUoZXhwcmVzc2lvbikge1xuICBpZiAoZXhwcmVzc2lvblswXSA9PT0gJ3N0ZXAnICYmIGV4cHJlc3Npb24ubGVuZ3RoID09PSAzKSB7XG4gICAgZXhwcmVzc2lvbi5wdXNoKDApO1xuICAgIGV4cHJlc3Npb24ucHVzaChleHByZXNzaW9uWzNdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBlbmRTdG9wUGFpcihjdXJ2ZSwgaW5wdXQsIG91dHB1dCwgaXNTdGVwKSB7XG4gIGlmIChjdXJ2ZS5sZW5ndGggPiAzICYmIGlucHV0ID09PSBjdXJ2ZVtjdXJ2ZS5sZW5ndGggLSAyXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghKGlzU3RlcCAmJiBjdXJ2ZS5sZW5ndGggPT09IDIpKSB7XG4gICAgY3VydmUucHVzaChpbnB1dCk7XG4gIH1cblxuICBjdXJ2ZS5wdXNoKG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uVHlwZShwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgaWYgKHBhcmFtZXRlcnMudHlwZSkge1xuICAgIHJldHVybiBwYXJhbWV0ZXJzLnR5cGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByb3BlcnR5U3BlYy5leHByZXNzaW9uLmludGVycG9sYXRlZCA/ICdleHBvbmVudGlhbCcgOiAnaW50ZXJ2YWwnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb2tlblN0cmluZyhzKSB7XG4gIHZhciByZXN1bHQgPSBbJ2NvbmNhdCddO1xuICB2YXIgcmUgPSAveyhbXnt9XSspfS9nO1xuICB2YXIgcG9zID0gMDtcblxuICBmb3IgKHZhciBtYXRjaCA9IHJlLmV4ZWMocyk7IG1hdGNoICE9PSBudWxsOyBtYXRjaCA9IHJlLmV4ZWMocykpIHtcbiAgICB2YXIgbGl0ZXJhbCA9IHMuc2xpY2UocG9zLCByZS5sYXN0SW5kZXggLSBtYXRjaFswXS5sZW5ndGgpO1xuICAgIHBvcyA9IHJlLmxhc3RJbmRleDtcbiAgICBpZiAobGl0ZXJhbC5sZW5ndGggPiAwKSByZXN1bHQucHVzaChsaXRlcmFsKTtcbiAgICByZXN1bHQucHVzaChbJ2dldCcsIG1hdGNoWzFdXSk7XG4gIH1cblxuICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgaWYgKHBvcyA8IHMubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnB1c2gocy5zbGljZShwb3MpKTtcbiAgfSBlbHNlIGlmIChyZXN1bHQubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIFsndG8tc3RyaW5nJywgcmVzdWx0WzFdXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbkZpbHRlcihmaWx0ZXIpIHtcbiAgaWYgKGZpbHRlciA9PT0gdHJ1ZSB8fCBmaWx0ZXIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyKSB8fCBmaWx0ZXIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3dpdGNoIChmaWx0ZXJbMF0pIHtcbiAgICBjYXNlICdoYXMnOlxuICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggPj0gMiAmJiBmaWx0ZXJbMV0gIT09ICckaWQnICYmIGZpbHRlclsxXSAhPT0gJyR0eXBlJztcblxuICAgIGNhc2UgJ2luJzpcbiAgICAgIHJldHVybiBmaWx0ZXIubGVuZ3RoID49IDMgJiYgKHR5cGVvZiBmaWx0ZXJbMV0gIT09ICdzdHJpbmcnIHx8IEFycmF5LmlzQXJyYXkoZmlsdGVyWzJdKSk7XG5cbiAgICBjYXNlICchaW4nOlxuICAgIGNhc2UgJyFoYXMnOlxuICAgIGNhc2UgJ25vbmUnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgY2FzZSAnPT0nOlxuICAgIGNhc2UgJyE9JzpcbiAgICBjYXNlICc+JzpcbiAgICBjYXNlICc+PSc6XG4gICAgY2FzZSAnPCc6XG4gICAgY2FzZSAnPD0nOlxuICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggIT09IDMgfHwgQXJyYXkuaXNBcnJheShmaWx0ZXJbMV0pIHx8IEFycmF5LmlzQXJyYXkoZmlsdGVyWzJdKTtcblxuICAgIGNhc2UgJ2FueSc6XG4gICAgY2FzZSAnYWxsJzpcbiAgICAgIHZhciBfaXRlcmF0b3I0OCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpbHRlci5zbGljZSgxKSksXG4gICAgICAgICAgX3N0ZXA0ODtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I0OC5zKCk7ICEoX3N0ZXA0OCA9IF9pdGVyYXRvcjQ4Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgZiA9IF9zdGVwNDgudmFsdWU7XG5cbiAgICAgICAgICBpZiAoIWlzRXhwcmVzc2lvbkZpbHRlcihmKSAmJiB0eXBlb2YgZiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNDguZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNDguZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG52YXIgZmlsdGVyU3BlYyA9IHtcbiAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICdkZWZhdWx0JzogZmFsc2UsXG4gICd0cmFuc2l0aW9uJzogZmFsc2UsXG4gICdwcm9wZXJ0eS10eXBlJzogJ2RhdGEtZHJpdmVuJyxcbiAgJ2V4cHJlc3Npb24nOiB7XG4gICAgJ2ludGVycG9sYXRlZCc6IGZhbHNlLFxuICAgICdwYXJhbWV0ZXJzJzogWyd6b29tJywgJ2ZlYXR1cmUnXVxuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXIoZmlsdGVyKSB7XG4gIGlmIChmaWx0ZXIgPT09IG51bGwgfHwgZmlsdGVyID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIG5lZWRHZW9tZXRyeTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSkge1xuICAgIGZpbHRlciA9IGNvbnZlcnRGaWx0ZXIoZmlsdGVyKTtcbiAgfVxuXG4gIHZhciBjb21waWxlZCA9IGNyZWF0ZUV4cHJlc3Npb24oZmlsdGVyLCBmaWx0ZXJTcGVjKTtcblxuICBpZiAoY29tcGlsZWQucmVzdWx0ID09PSAnZXJyb3InKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGNvbXBpbGVkLnZhbHVlLm1hcChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gXCJcIi5jb25jYXQoZXJyLmtleSwgXCI6IFwiKS5jb25jYXQoZXJyLm1lc3NhZ2UpO1xuICAgIH0pLmpvaW4oJywgJykpO1xuICB9IGVsc2Uge1xuICAgIHZhciBuZWVkR2VvbWV0cnkgPSBnZW9tZXRyeU5lZWRlZChmaWx0ZXIpO1xuICAgIHJldHVybiB7XG4gICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihnbG9iYWxQcm9wZXJ0aWVzLCBmZWF0dXJlLCBjYW5vbmljYWwpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBpbGVkLnZhbHVlLmV2YWx1YXRlKGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmUsIHt9LCBjYW5vbmljYWwpO1xuICAgICAgfSxcbiAgICAgIG5lZWRHZW9tZXRyeTogbmVlZEdlb21ldHJ5XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuXG5mdW5jdGlvbiBnZW9tZXRyeU5lZWRlZChmaWx0ZXIpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlcikpIHJldHVybiBmYWxzZTtcbiAgaWYgKGZpbHRlclswXSA9PT0gJ3dpdGhpbicpIHJldHVybiB0cnVlO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBmaWx0ZXIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgaWYgKGdlb21ldHJ5TmVlZGVkKGZpbHRlcltpbmRleF0pKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udmVydEZpbHRlcihmaWx0ZXIpIHtcbiAgaWYgKCFmaWx0ZXIpIHJldHVybiB0cnVlO1xuICB2YXIgb3AgPSBmaWx0ZXJbMF07XG4gIGlmIChmaWx0ZXIubGVuZ3RoIDw9IDEpIHJldHVybiBvcCAhPT0gJ2FueSc7XG4gIHZhciBjb252ZXJ0ZWQgPSBvcCA9PT0gJz09JyA/IGNvbnZlcnRDb21wYXJpc29uT3AoZmlsdGVyWzFdLCBmaWx0ZXJbMl0sICc9PScpIDogb3AgPT09ICchPScgPyBjb252ZXJ0TmVnYXRpb24oY29udmVydENvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgJz09JykpIDogb3AgPT09ICc8JyB8fCBvcCA9PT0gJz4nIHx8IG9wID09PSAnPD0nIHx8IG9wID09PSAnPj0nID8gY29udmVydENvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgb3ApIDogb3AgPT09ICdhbnknID8gY29udmVydERpc2p1bmN0aW9uT3AoZmlsdGVyLnNsaWNlKDEpKSA6IG9wID09PSAnYWxsJyA/IFsnYWxsJ10uY29uY2F0KGZpbHRlci5zbGljZSgxKS5tYXAoY29udmVydEZpbHRlcikpIDogb3AgPT09ICdub25lJyA/IFsnYWxsJ10uY29uY2F0KGZpbHRlci5zbGljZSgxKS5tYXAoY29udmVydEZpbHRlcikubWFwKGNvbnZlcnROZWdhdGlvbikpIDogb3AgPT09ICdpbicgPyBjb252ZXJ0SW5PcChmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSkgOiBvcCA9PT0gJyFpbicgPyBjb252ZXJ0TmVnYXRpb24oY29udmVydEluT3AoZmlsdGVyWzFdLCBmaWx0ZXIuc2xpY2UoMikpKSA6IG9wID09PSAnaGFzJyA/IGNvbnZlcnRIYXNPcChmaWx0ZXJbMV0pIDogb3AgPT09ICchaGFzJyA/IGNvbnZlcnROZWdhdGlvbihjb252ZXJ0SGFzT3AoZmlsdGVyWzFdKSkgOiBvcCA9PT0gJ3dpdGhpbicgPyBmaWx0ZXIgOiB0cnVlO1xuICByZXR1cm4gY29udmVydGVkO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0Q29tcGFyaXNvbk9wKHByb3BlcnR5LCB2YWx1ZSwgb3ApIHtcbiAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgIGNhc2UgJyR0eXBlJzpcbiAgICAgIHJldHVybiBbXCJmaWx0ZXItdHlwZS1cIi5jb25jYXQob3ApLCB2YWx1ZV07XG5cbiAgICBjYXNlICckaWQnOlxuICAgICAgcmV0dXJuIFtcImZpbHRlci1pZC1cIi5jb25jYXQob3ApLCB2YWx1ZV07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtcImZpbHRlci1cIi5jb25jYXQob3ApLCBwcm9wZXJ0eSwgdmFsdWVdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnREaXNqdW5jdGlvbk9wKGZpbHRlcnMpIHtcbiAgcmV0dXJuIFsnYW55J10uY29uY2F0KGZpbHRlcnMubWFwKGNvbnZlcnRGaWx0ZXIpKTtcbn1cblxuZnVuY3Rpb24gY29udmVydEluT3AocHJvcGVydHksIHZhbHVlcykge1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICBjYXNlICckdHlwZSc6XG4gICAgICByZXR1cm4gW1wiZmlsdGVyLXR5cGUtaW5cIiwgWydsaXRlcmFsJywgdmFsdWVzXV07XG5cbiAgICBjYXNlICckaWQnOlxuICAgICAgcmV0dXJuIFtcImZpbHRlci1pZC1pblwiLCBbJ2xpdGVyYWwnLCB2YWx1ZXNdXTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDIwMCAmJiAhdmFsdWVzLnNvbWUoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ICE9PSB0eXBlb2YgdmFsdWVzWzBdO1xuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuIFsnZmlsdGVyLWluLWxhcmdlJywgcHJvcGVydHksIFsnbGl0ZXJhbCcsIHZhbHVlcy5zb3J0KGNvbXBhcmUpXV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWydmaWx0ZXItaW4tc21hbGwnLCBwcm9wZXJ0eSwgWydsaXRlcmFsJywgdmFsdWVzXV07XG4gICAgICB9XG5cbiAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0SGFzT3AocHJvcGVydHkpIHtcbiAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgIGNhc2UgJyR0eXBlJzpcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSAnJGlkJzpcbiAgICAgIHJldHVybiBbXCJmaWx0ZXItaGFzLWlkXCJdO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXCJmaWx0ZXItaGFzXCIsIHByb3BlcnR5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb252ZXJ0TmVnYXRpb24oZmlsdGVyKSB7XG4gIHJldHVybiBbJyEnLCBmaWx0ZXJdO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0RmlsdGVyJDEoZmlsdGVyKSB7XG4gIHJldHVybiBfY29udmVydEZpbHRlcihmaWx0ZXIsIHt9KTtcbn1cblxuZnVuY3Rpb24gX2NvbnZlcnRGaWx0ZXIoZmlsdGVyLCBleHBlY3RlZFR5cGVzKSB7XG4gIGlmIChpc0V4cHJlc3Npb25GaWx0ZXIoZmlsdGVyKSkge1xuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cblxuICBpZiAoIWZpbHRlcikgcmV0dXJuIHRydWU7XG4gIHZhciBvcCA9IGZpbHRlclswXTtcbiAgaWYgKGZpbHRlci5sZW5ndGggPD0gMSkgcmV0dXJuIG9wICE9PSAnYW55JztcbiAgdmFyIGNvbnZlcnRlZDtcblxuICBpZiAob3AgPT09ICc9PScgfHwgb3AgPT09ICchPScgfHwgb3AgPT09ICc8JyB8fCBvcCA9PT0gJz4nIHx8IG9wID09PSAnPD0nIHx8IG9wID09PSAnPj0nKSB7XG4gICAgdmFyIF9maWx0ZXIgPSBfc2xpY2VkVG9BcnJheShmaWx0ZXIsIDMpLFxuICAgICAgICBwcm9wZXJ0eSA9IF9maWx0ZXJbMV0sXG4gICAgICAgIHZhbHVlID0gX2ZpbHRlclsyXTtcblxuICAgIGNvbnZlcnRlZCA9IGNvbnZlcnRDb21wYXJpc29uT3AkMShwcm9wZXJ0eSwgdmFsdWUsIG9wLCBleHBlY3RlZFR5cGVzKTtcbiAgfSBlbHNlIGlmIChvcCA9PT0gJ2FueScpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBmaWx0ZXIuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICB2YXIgdHlwZXMgPSB7fTtcblxuICAgICAgdmFyIGNoaWxkID0gX2NvbnZlcnRGaWx0ZXIoZiwgdHlwZXMpO1xuXG4gICAgICB2YXIgdHlwZWNoZWNrcyA9IHJ1bnRpbWVUeXBlQ2hlY2tzKHR5cGVzKTtcbiAgICAgIHJldHVybiB0eXBlY2hlY2tzID09PSB0cnVlID8gY2hpbGQgOiBbJ2Nhc2UnLCB0eXBlY2hlY2tzLCBjaGlsZCwgZmFsc2VdO1xuICAgIH0pO1xuICAgIHJldHVybiBbJ2FueSddLmNvbmNhdChjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAob3AgPT09ICdhbGwnKSB7XG4gICAgdmFyIF9yZWYxMTE7XG5cbiAgICB2YXIgX2NoaWxkcmVuID0gZmlsdGVyLnNsaWNlKDEpLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIF9jb252ZXJ0RmlsdGVyKGYsIGV4cGVjdGVkVHlwZXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF9jaGlsZHJlbi5sZW5ndGggPiAxID8gWydhbGwnXS5jb25jYXQoX2NoaWxkcmVuKSA6IChfcmVmMTExID0gW10pLmNvbmNhdC5hcHBseShfcmVmMTExLCBfdG9Db25zdW1hYmxlQXJyYXkoX2NoaWxkcmVuKSk7XG4gIH0gZWxzZSBpZiAob3AgPT09ICdub25lJykge1xuICAgIHJldHVybiBbJyEnLCBfY29udmVydEZpbHRlcihbJ2FueSddLmNvbmNhdChmaWx0ZXIuc2xpY2UoMSkpLCB7fSldO1xuICB9IGVsc2UgaWYgKG9wID09PSAnaW4nKSB7XG4gICAgY29udmVydGVkID0gY29udmVydEluT3AkMShmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSk7XG4gIH0gZWxzZSBpZiAob3AgPT09ICchaW4nKSB7XG4gICAgY29udmVydGVkID0gY29udmVydEluT3AkMShmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAob3AgPT09ICdoYXMnKSB7XG4gICAgY29udmVydGVkID0gY29udmVydEhhc09wJDEoZmlsdGVyWzFdKTtcbiAgfSBlbHNlIGlmIChvcCA9PT0gJyFoYXMnKSB7XG4gICAgY29udmVydGVkID0gWychJywgY29udmVydEhhc09wJDEoZmlsdGVyWzFdKV07XG4gIH0gZWxzZSB7XG4gICAgY29udmVydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59XG5cbmZ1bmN0aW9uIHJ1bnRpbWVUeXBlQ2hlY2tzKGV4cGVjdGVkVHlwZXMpIHtcbiAgdmFyIGNvbmRpdGlvbnMgPSBbXTtcblxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBleHBlY3RlZFR5cGVzKSB7XG4gICAgdmFyIF9nZXQgPSBwcm9wZXJ0eSA9PT0gJyRpZCcgPyBbJ2lkJ10gOiBbJ2dldCcsIHByb3BlcnR5XTtcblxuICAgIGNvbmRpdGlvbnMucHVzaChbJz09JywgWyd0eXBlb2YnLCBfZ2V0XSwgZXhwZWN0ZWRUeXBlc1twcm9wZXJ0eV1dKTtcbiAgfVxuXG4gIGlmIChjb25kaXRpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb25kaXRpb25zLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGNvbmRpdGlvbnNbMF07XG4gIHJldHVybiBbJ2FsbCddLmNvbmNhdChjb25kaXRpb25zKTtcbn1cblxuZnVuY3Rpb24gY29udmVydENvbXBhcmlzb25PcCQxKHByb3BlcnR5LCB2YWx1ZSwgb3AsIGV4cGVjdGVkVHlwZXMpIHtcbiAgdmFyIGdldDtcblxuICBpZiAocHJvcGVydHkgPT09ICckdHlwZScpIHtcbiAgICByZXR1cm4gW29wLCBbJ2dlb21ldHJ5LXR5cGUnXSwgdmFsdWVdO1xuICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAnJGlkJykge1xuICAgIGdldCA9IFsnaWQnXTtcbiAgfSBlbHNlIHtcbiAgICBnZXQgPSBbJ2dldCcsIHByb3BlcnR5XTtcbiAgfVxuXG4gIGlmIChleHBlY3RlZFR5cGVzICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgZXhwZWN0ZWRUeXBlc1twcm9wZXJ0eV0gPSB0eXBlO1xuICB9XG5cbiAgaWYgKG9wID09PSAnPT0nICYmIHByb3BlcnR5ICE9PSAnJGlkJyAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbJ2FsbCcsIFsnaGFzJywgcHJvcGVydHldLCBbJz09JywgZ2V0LCBudWxsXV07XG4gIH0gZWxzZSBpZiAob3AgPT09ICchPScgJiYgcHJvcGVydHkgIT09ICckaWQnICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFsnYW55JywgWychJywgWydoYXMnLCBwcm9wZXJ0eV1dLCBbJyE9JywgZ2V0LCBudWxsXV07XG4gIH1cblxuICByZXR1cm4gW29wLCBnZXQsIHZhbHVlXTtcbn1cblxuZnVuY3Rpb24gY29udmVydEluT3AkMShwcm9wZXJ0eSwgdmFsdWVzKSB7XG4gIHZhciBuZWdhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5lZ2F0ZTtcbiAgdmFyIGdldDtcblxuICBpZiAocHJvcGVydHkgPT09ICckdHlwZScpIHtcbiAgICBnZXQgPSBbJ2dlb21ldHJ5LXR5cGUnXTtcbiAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJyRpZCcpIHtcbiAgICBnZXQgPSBbJ2lkJ107XG4gIH0gZWxzZSB7XG4gICAgZ2V0ID0gWydnZXQnLCBwcm9wZXJ0eV07XG4gIH1cblxuICB2YXIgdW5pZm9ybVR5cGVzID0gdHJ1ZTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWVzWzBdO1xuXG4gIHZhciBfaXRlcmF0b3I0OSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHZhbHVlcyksXG4gICAgICBfc3RlcDQ5O1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3I0OS5zKCk7ICEoX3N0ZXA0OSA9IF9pdGVyYXRvcjQ5Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciB2YWx1ZSA9IF9zdGVwNDkudmFsdWU7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IHR5cGUpIHtcbiAgICAgICAgdW5pZm9ybVR5cGVzID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yNDkuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjQ5LmYoKTtcbiAgfVxuXG4gIGlmICh1bmlmb3JtVHlwZXMgJiYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInKSkge1xuICAgIHZhciB1bmlxdWVWYWx1ZXMgPSB2YWx1ZXMuc29ydCgpLmZpbHRlcihmdW5jdGlvbiAodiwgaSkge1xuICAgICAgcmV0dXJuIGkgPT09IDAgfHwgdmFsdWVzW2kgLSAxXSAhPT0gdjtcbiAgICB9KTtcbiAgICByZXR1cm4gWydtYXRjaCcsIGdldCwgdW5pcXVlVmFsdWVzLCAhbmVnYXRlLCBuZWdhdGVdO1xuICB9XG5cbiAgcmV0dXJuIFtuZWdhdGUgPyAnYWxsJyA6ICdhbnknXS5jb25jYXQodmFsdWVzLm1hcChmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBbbmVnYXRlID8gJyE9JyA6ICc9PScsIGdldCwgdl07XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gY29udmVydEhhc09wJDEocHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ID09PSAnJHR5cGUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAocHJvcGVydHkgPT09ICckaWQnKSB7XG4gICAgcmV0dXJuIFsnIT0nLCBbJ2lkJ10sIG51bGxdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbJ2hhcycsIHByb3BlcnR5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtaWdyYXRlVG9FeHByZXNzaW9ucyhzdHlsZSkge1xuICB2YXIgY29udmVydGVkID0gW107XG4gIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgaWYgKGxheWVyLmZpbHRlcikge1xuICAgICAgbGF5ZXIuZmlsdGVyID0gY29udmVydEZpbHRlciQxKGxheWVyLmZpbHRlcik7XG4gICAgfVxuICB9KTtcbiAgZWFjaFByb3BlcnR5KHN0eWxlLCB7XG4gICAgcGFpbnQ6IHRydWUsXG4gICAgbGF5b3V0OiB0cnVlXG4gIH0sIGZ1bmN0aW9uIChfcmVmMTEyKSB7XG4gICAgdmFyIHBhdGggPSBfcmVmMTEyLnBhdGgsXG4gICAgICAgIHZhbHVlID0gX3JlZjExMi52YWx1ZSxcbiAgICAgICAgcmVmZXJlbmNlID0gX3JlZjExMi5yZWZlcmVuY2UsXG4gICAgICAgIHNldCA9IF9yZWYxMTIuc2V0O1xuICAgIGlmIChpc0V4cHJlc3Npb24odmFsdWUpKSByZXR1cm47XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHNldChjb252ZXJ0RnVuY3Rpb24odmFsdWUsIHJlZmVyZW5jZSkpO1xuICAgICAgY29udmVydGVkLnB1c2gocGF0aC5qb2luKCcuJykpO1xuICAgIH0gZWxzZSBpZiAocmVmZXJlbmNlLnRva2VucyAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZXQoY29udmVydFRva2VuU3RyaW5nKHZhbHVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBtaWdyYXRlKHN0eWxlKSB7XG4gIHZhciBtaWdyYXRlZCA9IGZhbHNlO1xuXG4gIGlmIChzdHlsZS52ZXJzaW9uID09PSA3KSB7XG4gICAgc3R5bGUgPSBtaWdyYXRlVG9WOChzdHlsZSk7XG4gICAgbWlncmF0ZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHN0eWxlLnZlcnNpb24gPT09IDgpIHtcbiAgICBtaWdyYXRlZCA9IG1pZ3JhdGVUb0V4cHJlc3Npb25zKHN0eWxlKTtcbiAgICBtaWdyYXRlZCA9IHRydWU7XG4gIH1cblxuICBpZiAoIW1pZ3JhdGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgbWlncmF0ZSBmcm9tJywgc3R5bGUudmVyc2lvbik7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNvbXBvc2l0ZShzdHlsZSkge1xuICB2YXIgc3R5bGVJRHMgPSBbXTtcbiAgdmFyIHNvdXJjZUlEcyA9IFtdO1xuICB2YXIgY29tcG9zaXRlZFNvdXJjZUxheWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGlkIGluIHN0eWxlLnNvdXJjZXMpIHtcbiAgICB2YXIgX3NvdXJjZSA9IHN0eWxlLnNvdXJjZXNbaWRdO1xuICAgIGlmIChfc291cmNlLnR5cGUgIT09ICd2ZWN0b3InKSBjb250aW51ZTtcbiAgICB2YXIgbWF0Y2ggPSAvXm1hcGJveDpcXC9cXC8oLiopLy5leGVjKF9zb3VyY2UudXJsKTtcbiAgICBpZiAoIW1hdGNoKSBjb250aW51ZTtcbiAgICBzdHlsZUlEcy5wdXNoKGlkKTtcbiAgICBzb3VyY2VJRHMucHVzaChtYXRjaFsxXSk7XG4gIH1cblxuICBpZiAoc3R5bGVJRHMubGVuZ3RoIDwgMikgcmV0dXJuIHN0eWxlO1xuICBzdHlsZUlEcy5mb3JFYWNoKGZ1bmN0aW9uIChpZCkge1xuICAgIGRlbGV0ZSBzdHlsZS5zb3VyY2VzW2lkXTtcbiAgfSk7XG4gIHZhciBjb21wb3NpdGVJRCA9IHNvdXJjZUlEcy5qb2luKCcsJyk7XG4gIHN0eWxlLnNvdXJjZXNbY29tcG9zaXRlSURdID0ge1xuICAgICd0eXBlJzogJ3ZlY3RvcicsXG4gICAgJ3VybCc6IFwibWFwYm94Oi8vXCIuY29uY2F0KGNvbXBvc2l0ZUlEKVxuICB9O1xuICBzdHlsZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICBpZiAoc3R5bGVJRHMuaW5kZXhPZihsYXllci5zb3VyY2UpID49IDApIHtcbiAgICAgIGxheWVyLnNvdXJjZSA9IGNvbXBvc2l0ZUlEO1xuXG4gICAgICBpZiAoJ3NvdXJjZS1sYXllcicgaW4gbGF5ZXIpIHtcbiAgICAgICAgaWYgKGNvbXBvc2l0ZWRTb3VyY2VMYXllcnMuaW5kZXhPZihsYXllclsnc291cmNlLWxheWVyJ10pID49IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZsaWN0aW5nIHNvdXJjZSBsYXllciBuYW1lcycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBvc2l0ZWRTb3VyY2VMYXllcnMucHVzaChsYXllclsnc291cmNlLWxheWVyJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG52YXIgcmVmUHJvcGVydGllcyA9IFsndHlwZScsICdzb3VyY2UnLCAnc291cmNlLWxheWVyJywgJ21pbnpvb20nLCAnbWF4em9vbScsICdmaWx0ZXInLCAnbGF5b3V0J107XG5cbmZ1bmN0aW9uIGRlcmVmKGxheWVyLCBwYXJlbnQpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gIGZvciAodmFyIGsgaW4gbGF5ZXIpIHtcbiAgICBpZiAoayAhPT0gJ3JlZicpIHtcbiAgICAgIHJlc3VsdFtrXSA9IGxheWVyW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJlZlByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGlmIChrIGluIHBhcmVudCkge1xuICAgICAgcmVzdWx0W2tdID0gcGFyZW50W2tdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGRlcmVmTGF5ZXJzKGxheWVycykge1xuICBsYXllcnMgPSBsYXllcnMuc2xpY2UoKTtcbiAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICBtYXBbbGF5ZXJzW2ldLmlkXSA9IGxheWVyc1tpXTtcbiAgfVxuXG4gIGZvciAodmFyIF9pOCA9IDA7IF9pOCA8IGxheWVycy5sZW5ndGg7IF9pOCsrKSB7XG4gICAgaWYgKCdyZWYnIGluIGxheWVyc1tfaThdKSB7XG4gICAgICBsYXllcnNbX2k4XSA9IGRlcmVmKGxheWVyc1tfaThdLCBtYXBbbGF5ZXJzW19pOF0ucmVmXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxheWVycztcbn1cblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYikgfHwgYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCkge1xuICAgIGlmICghKHR5cGVvZiBiID09PSAnb2JqZWN0JykpIHJldHVybiBmYWxzZTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gYSkge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gYSA9PT0gYjtcbn1cblxudmFyIG9wZXJhdGlvbnMgPSB7XG4gIHNldFN0eWxlOiAnc2V0U3R5bGUnLFxuICBhZGRMYXllcjogJ2FkZExheWVyJyxcbiAgcmVtb3ZlTGF5ZXI6ICdyZW1vdmVMYXllcicsXG4gIHNldFBhaW50UHJvcGVydHk6ICdzZXRQYWludFByb3BlcnR5JyxcbiAgc2V0TGF5b3V0UHJvcGVydHk6ICdzZXRMYXlvdXRQcm9wZXJ0eScsXG4gIHNldEZpbHRlcjogJ3NldEZpbHRlcicsXG4gIGFkZFNvdXJjZTogJ2FkZFNvdXJjZScsXG4gIHJlbW92ZVNvdXJjZTogJ3JlbW92ZVNvdXJjZScsXG4gIHNldEdlb0pTT05Tb3VyY2VEYXRhOiAnc2V0R2VvSlNPTlNvdXJjZURhdGEnLFxuICBzZXRMYXllclpvb21SYW5nZTogJ3NldExheWVyWm9vbVJhbmdlJyxcbiAgc2V0TGF5ZXJQcm9wZXJ0eTogJ3NldExheWVyUHJvcGVydHknLFxuICBzZXRDZW50ZXI6ICdzZXRDZW50ZXInLFxuICBzZXRab29tOiAnc2V0Wm9vbScsXG4gIHNldEJlYXJpbmc6ICdzZXRCZWFyaW5nJyxcbiAgc2V0UGl0Y2g6ICdzZXRQaXRjaCcsXG4gIHNldFNwcml0ZTogJ3NldFNwcml0ZScsXG4gIHNldEdseXBoczogJ3NldEdseXBocycsXG4gIHNldFRyYW5zaXRpb246ICdzZXRUcmFuc2l0aW9uJyxcbiAgc2V0TGlnaHQ6ICdzZXRMaWdodCcsXG4gIHNldFRlcnJhaW46ICdzZXRUZXJyYWluJyxcbiAgc2V0Rm9nOiAnc2V0Rm9nJ1xufTtcblxuZnVuY3Rpb24gYWRkU291cmNlKHNvdXJjZUlkLCBhZnRlciwgY29tbWFuZHMpIHtcbiAgY29tbWFuZHMucHVzaCh7XG4gICAgY29tbWFuZDogb3BlcmF0aW9ucy5hZGRTb3VyY2UsXG4gICAgYXJnczogW3NvdXJjZUlkLCBhZnRlcltzb3VyY2VJZF1dXG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTb3VyY2Uoc291cmNlSWQsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCkge1xuICBjb21tYW5kcy5wdXNoKHtcbiAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZVNvdXJjZSxcbiAgICBhcmdzOiBbc291cmNlSWRdXG4gIH0pO1xuICBzb3VyY2VzUmVtb3ZlZFtzb3VyY2VJZF0gPSB0cnVlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpIHtcbiAgcmVtb3ZlU291cmNlKHNvdXJjZUlkLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpO1xuICBhZGRTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcyk7XG59XG5cbmZ1bmN0aW9uIGNhblVwZGF0ZUdlb0pTT04oYmVmb3JlLCBhZnRlciwgc291cmNlSWQpIHtcbiAgdmFyIHByb3A7XG5cbiAgZm9yIChwcm9wIGluIGJlZm9yZVtzb3VyY2VJZF0pIHtcbiAgICBpZiAoIWJlZm9yZVtzb3VyY2VJZF0uaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xuXG4gICAgaWYgKHByb3AgIT09ICdkYXRhJyAmJiAhZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF1bcHJvcF0sIGFmdGVyW3NvdXJjZUlkXVtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHByb3AgaW4gYWZ0ZXJbc291cmNlSWRdKSB7XG4gICAgaWYgKCFhZnRlcltzb3VyY2VJZF0uaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xuXG4gICAgaWYgKHByb3AgIT09ICdkYXRhJyAmJiAhZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF1bcHJvcF0sIGFmdGVyW3NvdXJjZUlkXVtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZGlmZlNvdXJjZXMoYmVmb3JlLCBhZnRlciwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKSB7XG4gIGJlZm9yZSA9IGJlZm9yZSB8fCB7fTtcbiAgYWZ0ZXIgPSBhZnRlciB8fCB7fTtcbiAgdmFyIHNvdXJjZUlkO1xuXG4gIGZvciAoc291cmNlSWQgaW4gYmVmb3JlKSB7XG4gICAgaWYgKCFiZWZvcmUuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSBjb250aW51ZTtcblxuICAgIGlmICghYWZ0ZXIuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSB7XG4gICAgICByZW1vdmVTb3VyY2Uoc291cmNlSWQsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChzb3VyY2VJZCBpbiBhZnRlcikge1xuICAgIGlmICghYWZ0ZXIuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSBjb250aW51ZTtcblxuICAgIGlmICghYmVmb3JlLmhhc093blByb3BlcnR5KHNvdXJjZUlkKSkge1xuICAgICAgYWRkU291cmNlKHNvdXJjZUlkLCBhZnRlciwgY29tbWFuZHMpO1xuICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChiZWZvcmVbc291cmNlSWRdLCBhZnRlcltzb3VyY2VJZF0pKSB7XG4gICAgICBpZiAoYmVmb3JlW3NvdXJjZUlkXS50eXBlID09PSAnZ2VvanNvbicgJiYgYWZ0ZXJbc291cmNlSWRdLnR5cGUgPT09ICdnZW9qc29uJyAmJiBjYW5VcGRhdGVHZW9KU09OKGJlZm9yZSwgYWZ0ZXIsIHNvdXJjZUlkKSkge1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEdlb0pTT05Tb3VyY2VEYXRhLFxuICAgICAgICAgIGFyZ3M6IFtzb3VyY2VJZCwgYWZ0ZXJbc291cmNlSWRdLmRhdGFdXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlU291cmNlKHNvdXJjZUlkLCBhZnRlciwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZSwgYWZ0ZXIsIGNvbW1hbmRzLCBsYXllcklkLCBrbGFzcywgY29tbWFuZCkge1xuICBiZWZvcmUgPSBiZWZvcmUgfHwge307XG4gIGFmdGVyID0gYWZ0ZXIgfHwge307XG4gIHZhciBwcm9wO1xuXG4gIGZvciAocHJvcCBpbiBiZWZvcmUpIHtcbiAgICBpZiAoIWJlZm9yZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVbcHJvcF0sIGFmdGVyW3Byb3BdKSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgIGFyZ3M6IFtsYXllcklkLCBwcm9wLCBhZnRlcltwcm9wXSwga2xhc3NdXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHByb3AgaW4gYWZ0ZXIpIHtcbiAgICBpZiAoIWFmdGVyLmhhc093blByb3BlcnR5KHByb3ApIHx8IGJlZm9yZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVbcHJvcF0sIGFmdGVyW3Byb3BdKSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgIGFyZ3M6IFtsYXllcklkLCBwcm9wLCBhZnRlcltwcm9wXSwga2xhc3NdXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGx1Y2tJZChsYXllcikge1xuICByZXR1cm4gbGF5ZXIuaWQ7XG59XG5cbmZ1bmN0aW9uIGluZGV4QnlJZChncm91cCwgbGF5ZXIpIHtcbiAgZ3JvdXBbbGF5ZXIuaWRdID0gbGF5ZXI7XG4gIHJldHVybiBncm91cDtcbn1cblxuZnVuY3Rpb24gZGlmZkxheWVycyhiZWZvcmUsIGFmdGVyLCBjb21tYW5kcykge1xuICBiZWZvcmUgPSBiZWZvcmUgfHwgW107XG4gIGFmdGVyID0gYWZ0ZXIgfHwgW107XG4gIHZhciBiZWZvcmVPcmRlciA9IGJlZm9yZS5tYXAocGx1Y2tJZCk7XG4gIHZhciBhZnRlck9yZGVyID0gYWZ0ZXIubWFwKHBsdWNrSWQpO1xuICB2YXIgYmVmb3JlSW5kZXggPSBiZWZvcmUucmVkdWNlKGluZGV4QnlJZCwge30pO1xuICB2YXIgYWZ0ZXJJbmRleCA9IGFmdGVyLnJlZHVjZShpbmRleEJ5SWQsIHt9KTtcbiAgdmFyIHRyYWNrZXIgPSBiZWZvcmVPcmRlci5zbGljZSgpO1xuICB2YXIgY2xlYW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgaSwgZCwgbGF5ZXJJZCwgYmVmb3JlTGF5ZXIsIGFmdGVyTGF5ZXIsIGluc2VydEJlZm9yZUxheWVySWQsIHByb3A7XG5cbiAgZm9yIChpID0gMCwgZCA9IDA7IGkgPCBiZWZvcmVPcmRlci5sZW5ndGg7IGkrKykge1xuICAgIGxheWVySWQgPSBiZWZvcmVPcmRlcltpXTtcblxuICAgIGlmICghYWZ0ZXJJbmRleC5oYXNPd25Qcm9wZXJ0eShsYXllcklkKSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlTGF5ZXIsXG4gICAgICAgIGFyZ3M6IFtsYXllcklkXVxuICAgICAgfSk7XG4gICAgICB0cmFja2VyLnNwbGljZSh0cmFja2VyLmluZGV4T2YobGF5ZXJJZCwgZCksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkKys7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMCwgZCA9IDA7IGkgPCBhZnRlck9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgbGF5ZXJJZCA9IGFmdGVyT3JkZXJbYWZ0ZXJPcmRlci5sZW5ndGggLSAxIC0gaV07XG4gICAgaWYgKHRyYWNrZXJbdHJhY2tlci5sZW5ndGggLSAxIC0gaV0gPT09IGxheWVySWQpIGNvbnRpbnVlO1xuXG4gICAgaWYgKGJlZm9yZUluZGV4Lmhhc093blByb3BlcnR5KGxheWVySWQpKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllcixcbiAgICAgICAgYXJnczogW2xheWVySWRdXG4gICAgICB9KTtcbiAgICAgIHRyYWNrZXIuc3BsaWNlKHRyYWNrZXIubGFzdEluZGV4T2YobGF5ZXJJZCwgdHJhY2tlci5sZW5ndGggLSBkKSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQrKztcbiAgICB9XG5cbiAgICBpbnNlcnRCZWZvcmVMYXllcklkID0gdHJhY2tlclt0cmFja2VyLmxlbmd0aCAtIGldO1xuICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5hZGRMYXllcixcbiAgICAgIGFyZ3M6IFthZnRlckluZGV4W2xheWVySWRdLCBpbnNlcnRCZWZvcmVMYXllcklkXVxuICAgIH0pO1xuICAgIHRyYWNrZXIuc3BsaWNlKHRyYWNrZXIubGVuZ3RoIC0gaSwgMCwgbGF5ZXJJZCk7XG4gICAgY2xlYW5bbGF5ZXJJZF0gPSB0cnVlO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGFmdGVyT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBsYXllcklkID0gYWZ0ZXJPcmRlcltpXTtcbiAgICBiZWZvcmVMYXllciA9IGJlZm9yZUluZGV4W2xheWVySWRdO1xuICAgIGFmdGVyTGF5ZXIgPSBhZnRlckluZGV4W2xheWVySWRdO1xuICAgIGlmIChjbGVhbltsYXllcklkXSB8fCBkZWVwRXF1YWwoYmVmb3JlTGF5ZXIsIGFmdGVyTGF5ZXIpKSBjb250aW51ZTtcblxuICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZUxheWVyLnNvdXJjZSwgYWZ0ZXJMYXllci5zb3VyY2UpIHx8ICFkZWVwRXF1YWwoYmVmb3JlTGF5ZXJbJ3NvdXJjZS1sYXllciddLCBhZnRlckxheWVyWydzb3VyY2UtbGF5ZXInXSkgfHwgIWRlZXBFcXVhbChiZWZvcmVMYXllci50eXBlLCBhZnRlckxheWVyLnR5cGUpKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllcixcbiAgICAgICAgYXJnczogW2xheWVySWRdXG4gICAgICB9KTtcbiAgICAgIGluc2VydEJlZm9yZUxheWVySWQgPSB0cmFja2VyW3RyYWNrZXIubGFzdEluZGV4T2YobGF5ZXJJZCkgKyAxXTtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLmFkZExheWVyLFxuICAgICAgICBhcmdzOiBbYWZ0ZXJMYXllciwgaW5zZXJ0QmVmb3JlTGF5ZXJJZF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyLmxheW91dCwgYWZ0ZXJMYXllci5sYXlvdXQsIGNvbW1hbmRzLCBsYXllcklkLCBudWxsLCBvcGVyYXRpb25zLnNldExheW91dFByb3BlcnR5KTtcbiAgICBkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMoYmVmb3JlTGF5ZXIucGFpbnQsIGFmdGVyTGF5ZXIucGFpbnQsIGNvbW1hbmRzLCBsYXllcklkLCBudWxsLCBvcGVyYXRpb25zLnNldFBhaW50UHJvcGVydHkpO1xuXG4gICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIuZmlsdGVyLCBhZnRlckxheWVyLmZpbHRlcikpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEZpbHRlcixcbiAgICAgICAgYXJnczogW2xheWVySWQsIGFmdGVyTGF5ZXIuZmlsdGVyXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIubWluem9vbSwgYWZ0ZXJMYXllci5taW56b29tKSB8fCAhZGVlcEVxdWFsKGJlZm9yZUxheWVyLm1heHpvb20sIGFmdGVyTGF5ZXIubWF4em9vbSkpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldExheWVyWm9vbVJhbmdlLFxuICAgICAgICBhcmdzOiBbbGF5ZXJJZCwgYWZ0ZXJMYXllci5taW56b29tLCBhZnRlckxheWVyLm1heHpvb21dXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHByb3AgaW4gYmVmb3JlTGF5ZXIpIHtcbiAgICAgIGlmICghYmVmb3JlTGF5ZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xuICAgICAgaWYgKHByb3AgPT09ICdsYXlvdXQnIHx8IHByb3AgPT09ICdwYWludCcgfHwgcHJvcCA9PT0gJ2ZpbHRlcicgfHwgcHJvcCA9PT0gJ21ldGFkYXRhJyB8fCBwcm9wID09PSAnbWluem9vbScgfHwgcHJvcCA9PT0gJ21heHpvb20nKSBjb250aW51ZTtcblxuICAgICAgaWYgKHByb3AuaW5kZXhPZigncGFpbnQuJykgPT09IDApIHtcbiAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdLCBjb21tYW5kcywgbGF5ZXJJZCwgcHJvcC5zbGljZSg2KSwgb3BlcmF0aW9ucy5zZXRQYWludFByb3BlcnR5KTtcbiAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllcltwcm9wXSwgYWZ0ZXJMYXllcltwcm9wXSkpIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRMYXllclByb3BlcnR5LFxuICAgICAgICAgIGFyZ3M6IFtsYXllcklkLCBwcm9wLCBhZnRlckxheWVyW3Byb3BdXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHByb3AgaW4gYWZ0ZXJMYXllcikge1xuICAgICAgaWYgKCFhZnRlckxheWVyLmhhc093blByb3BlcnR5KHByb3ApIHx8IGJlZm9yZUxheWVyLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcbiAgICAgIGlmIChwcm9wID09PSAnbGF5b3V0JyB8fCBwcm9wID09PSAncGFpbnQnIHx8IHByb3AgPT09ICdmaWx0ZXInIHx8IHByb3AgPT09ICdtZXRhZGF0YScgfHwgcHJvcCA9PT0gJ21pbnpvb20nIHx8IHByb3AgPT09ICdtYXh6b29tJykgY29udGludWU7XG5cbiAgICAgIGlmIChwcm9wLmluZGV4T2YoJ3BhaW50LicpID09PSAwKSB7XG4gICAgICAgIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmVMYXllcltwcm9wXSwgYWZ0ZXJMYXllcltwcm9wXSwgY29tbWFuZHMsIGxheWVySWQsIHByb3Auc2xpY2UoNiksIG9wZXJhdGlvbnMuc2V0UGFpbnRQcm9wZXJ0eSk7XG4gICAgICB9IGVsc2UgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXJbcHJvcF0sIGFmdGVyTGF5ZXJbcHJvcF0pKSB7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGF5ZXJQcm9wZXJ0eSxcbiAgICAgICAgICBhcmdzOiBbbGF5ZXJJZCwgcHJvcCwgYWZ0ZXJMYXllcltwcm9wXV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRpZmZTdHlsZXMoYmVmb3JlLCBhZnRlcikge1xuICBpZiAoIWJlZm9yZSkgcmV0dXJuIFt7XG4gICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRTdHlsZSxcbiAgICBhcmdzOiBbYWZ0ZXJdXG4gIH1dO1xuICB2YXIgY29tbWFuZHMgPSBbXTtcblxuICB0cnkge1xuICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS52ZXJzaW9uLCBhZnRlci52ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0U3R5bGUsXG4gICAgICAgIGFyZ3M6IFthZnRlcl1cbiAgICAgIH1dO1xuICAgIH1cblxuICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5jZW50ZXIsIGFmdGVyLmNlbnRlcikpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldENlbnRlcixcbiAgICAgICAgYXJnczogW2FmdGVyLmNlbnRlcl1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS56b29tLCBhZnRlci56b29tKSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0Wm9vbSxcbiAgICAgICAgYXJnczogW2FmdGVyLnpvb21dXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUuYmVhcmluZywgYWZ0ZXIuYmVhcmluZykpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEJlYXJpbmcsXG4gICAgICAgIGFyZ3M6IFthZnRlci5iZWFyaW5nXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLnBpdGNoLCBhZnRlci5waXRjaCkpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFBpdGNoLFxuICAgICAgICBhcmdzOiBbYWZ0ZXIucGl0Y2hdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUuc3ByaXRlLCBhZnRlci5zcHJpdGUpKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRTcHJpdGUsXG4gICAgICAgIGFyZ3M6IFthZnRlci5zcHJpdGVdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUuZ2x5cGhzLCBhZnRlci5nbHlwaHMpKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRHbHlwaHMsXG4gICAgICAgIGFyZ3M6IFthZnRlci5nbHlwaHNdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUudHJhbnNpdGlvbiwgYWZ0ZXIudHJhbnNpdGlvbikpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFRyYW5zaXRpb24sXG4gICAgICAgIGFyZ3M6IFthZnRlci50cmFuc2l0aW9uXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmxpZ2h0LCBhZnRlci5saWdodCkpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldExpZ2h0LFxuICAgICAgICBhcmdzOiBbYWZ0ZXIubGlnaHRdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUuZm9nLCBhZnRlci5mb2cpKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRGb2csXG4gICAgICAgIGFyZ3M6IFthZnRlci5mb2ddXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgc291cmNlc1JlbW92ZWQgPSB7fTtcbiAgICB2YXIgcmVtb3ZlT3JBZGRTb3VyY2VDb21tYW5kcyA9IFtdO1xuICAgIGRpZmZTb3VyY2VzKGJlZm9yZS5zb3VyY2VzLCBhZnRlci5zb3VyY2VzLCByZW1vdmVPckFkZFNvdXJjZUNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7XG4gICAgdmFyIGJlZm9yZUxheWVycyA9IFtdO1xuXG4gICAgaWYgKGJlZm9yZS5sYXllcnMpIHtcbiAgICAgIGJlZm9yZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgaWYgKHNvdXJjZXNSZW1vdmVkW2xheWVyLnNvdXJjZV0pIHtcbiAgICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlTGF5ZXIsXG4gICAgICAgICAgICBhcmdzOiBbbGF5ZXIuaWRdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmVmb3JlTGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JlVGVycmFpbiA9IGJlZm9yZS50ZXJyYWluO1xuXG4gICAgaWYgKGJlZm9yZVRlcnJhaW4pIHtcbiAgICAgIGlmIChzb3VyY2VzUmVtb3ZlZFtiZWZvcmVUZXJyYWluLnNvdXJjZV0pIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRUZXJyYWluLFxuICAgICAgICAgIGFyZ3M6IFt1bmRlZmluZWRdXG4gICAgICAgIH0pO1xuICAgICAgICBiZWZvcmVUZXJyYWluID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbW1hbmRzID0gY29tbWFuZHMuY29uY2F0KHJlbW92ZU9yQWRkU291cmNlQ29tbWFuZHMpO1xuXG4gICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlVGVycmFpbiwgYWZ0ZXIudGVycmFpbikpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFRlcnJhaW4sXG4gICAgICAgIGFyZ3M6IFthZnRlci50ZXJyYWluXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGlmZkxheWVycyhiZWZvcmVMYXllcnMsIGFmdGVyLmxheWVycywgY29tbWFuZHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gY29tcHV0ZSBzdHlsZSBkaWZmOicsIGUpO1xuICAgIGNvbW1hbmRzID0gW3tcbiAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0U3R5bGUsXG4gICAgICBhcmdzOiBbYWZ0ZXJdXG4gICAgfV07XG4gIH1cblxuICByZXR1cm4gY29tbWFuZHM7XG59XG5cbnZhciBWYWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbiBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgbWVzc2FnZSwgaWRlbnRpZmllcikge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmFsaWRhdGlvbkVycm9yKTtcblxuICB0aGlzLm1lc3NhZ2UgPSAoa2V5ID8gXCJcIi5jb25jYXQoa2V5LCBcIjogXCIpIDogJycpICsgbWVzc2FnZTtcbiAgaWYgKGlkZW50aWZpZXIpIHRoaXMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuX19saW5lX18pIHtcbiAgICB0aGlzLmxpbmUgPSB2YWx1ZS5fX2xpbmVfXztcbiAgfVxufTtcblxudmFyIFBhcnNpbmdFcnJvciQxID0gZnVuY3Rpb24gUGFyc2luZ0Vycm9yJDEoZXJyb3IpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnNpbmdFcnJvciQxKTtcblxuICB0aGlzLmVycm9yID0gZXJyb3I7XG4gIHRoaXMubWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gIHZhciBtYXRjaCA9IGVycm9yLm1lc3NhZ2UubWF0Y2goL2xpbmUgKFxcZCspLyk7XG4gIHRoaXMubGluZSA9IG1hdGNoID8gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSA6IDA7XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnN0YW50cyhvcHRpb25zKSB7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgdmFyIGNvbnN0YW50cyA9IG9wdGlvbnMudmFsdWU7XG5cbiAgaWYgKGNvbnN0YW50cykge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGNvbnN0YW50cywgJ2NvbnN0YW50cyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBhcyBvZiB2OCcpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5idW5kbGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgIHJldHVybiB2YWx1ZS52YWx1ZU9mKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZXBVbmJ1bmRsZSh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWUubWFwKGRlZXBVbmJ1bmRsZSk7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlciB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZyB8fCB2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4pKSB7XG4gICAgdmFyIHVuYnVuZGxlZFZhbHVlID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIHVuYnVuZGxlZFZhbHVlW2tleV0gPSBkZWVwVW5idW5kbGUodmFsdWVba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuYnVuZGxlZFZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHVuYnVuZGxlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob3B0aW9ucykge1xuICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gIHZhciBvYmplY3QgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIgZWxlbWVudFNwZWNzID0gb3B0aW9ucy52YWx1ZVNwZWMgfHwge307XG4gIHZhciBlbGVtZW50VmFsaWRhdG9ycyA9IG9wdGlvbnMub2JqZWN0RWxlbWVudFZhbGlkYXRvcnMgfHwge307XG4gIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgdHlwZSA9IGdldFR5cGUob2JqZWN0KTtcblxuICBpZiAodHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3QsIFwib2JqZWN0IGV4cGVjdGVkLCBcIi5jb25jYXQodHlwZSwgXCIgZm91bmRcIikpXTtcbiAgfVxuXG4gIGZvciAodmFyIG9iamVjdEtleSBpbiBvYmplY3QpIHtcbiAgICB2YXIgZWxlbWVudFNwZWNLZXkgPSBvYmplY3RLZXkuc3BsaXQoJy4nKVswXTtcbiAgICB2YXIgZWxlbWVudFNwZWMgPSBlbGVtZW50U3BlY3NbZWxlbWVudFNwZWNLZXldIHx8IGVsZW1lbnRTcGVjc1snKiddO1xuICAgIHZhciB2YWxpZGF0ZUVsZW1lbnQgPSB2b2lkIDA7XG5cbiAgICBpZiAoZWxlbWVudFZhbGlkYXRvcnNbZWxlbWVudFNwZWNLZXldKSB7XG4gICAgICB2YWxpZGF0ZUVsZW1lbnQgPSBlbGVtZW50VmFsaWRhdG9yc1tlbGVtZW50U3BlY0tleV07XG4gICAgfSBlbHNlIGlmIChlbGVtZW50U3BlY3NbZWxlbWVudFNwZWNLZXldKSB7XG4gICAgICB2YWxpZGF0ZUVsZW1lbnQgPSB2YWxpZGF0ZTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnRWYWxpZGF0b3JzWycqJ10pIHtcbiAgICAgIHZhbGlkYXRlRWxlbWVudCA9IGVsZW1lbnRWYWxpZGF0b3JzWycqJ107XG4gICAgfSBlbHNlIGlmIChlbGVtZW50U3BlY3NbJyonXSkge1xuICAgICAgdmFsaWRhdGVFbGVtZW50ID0gdmFsaWRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3Rbb2JqZWN0S2V5XSwgXCJ1bmtub3duIHByb3BlcnR5IFxcXCJcIi5jb25jYXQob2JqZWN0S2V5LCBcIlxcXCJcIikpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbGVtZW50KHtcbiAgICAgIGtleTogKGtleSA/IFwiXCIuY29uY2F0KGtleSwgXCIuXCIpIDoga2V5KSArIG9iamVjdEtleSxcbiAgICAgIHZhbHVlOiBvYmplY3Rbb2JqZWN0S2V5XSxcbiAgICAgIHZhbHVlU3BlYzogZWxlbWVudFNwZWMsXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgb2JqZWN0S2V5OiBvYmplY3RLZXlcbiAgICB9LCBvYmplY3QpKTtcbiAgfVxuXG4gIGZvciAodmFyIF9lbGVtZW50U3BlY0tleSBpbiBlbGVtZW50U3BlY3MpIHtcbiAgICBpZiAoZWxlbWVudFZhbGlkYXRvcnNbX2VsZW1lbnRTcGVjS2V5XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRTcGVjc1tfZWxlbWVudFNwZWNLZXldLnJlcXVpcmVkICYmIGVsZW1lbnRTcGVjc1tfZWxlbWVudFNwZWNLZXldWydkZWZhdWx0J10gPT09IHVuZGVmaW5lZCAmJiBvYmplY3RbX2VsZW1lbnRTcGVjS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgb2JqZWN0LCBcIm1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChfZWxlbWVudFNwZWNLZXksIFwiXFxcIlwiKSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkob3B0aW9ucykge1xuICB2YXIgYXJyYXkgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIgYXJyYXlTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgdmFsaWRhdGVBcnJheUVsZW1lbnQgPSBvcHRpb25zLmFycmF5RWxlbWVudFZhbGlkYXRvciB8fCB2YWxpZGF0ZTtcblxuICBpZiAoZ2V0VHlwZShhcnJheSkgIT09ICdhcnJheScpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgXCJhcnJheSBleHBlY3RlZCwgXCIuY29uY2F0KGdldFR5cGUoYXJyYXkpLCBcIiBmb3VuZFwiKSldO1xuICB9XG5cbiAgaWYgKGFycmF5U3BlYy5sZW5ndGggJiYgYXJyYXkubGVuZ3RoICE9PSBhcnJheVNwZWMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgYXJyYXksIFwiYXJyYXkgbGVuZ3RoIFwiLmNvbmNhdChhcnJheVNwZWMubGVuZ3RoLCBcIiBleHBlY3RlZCwgbGVuZ3RoIFwiKS5jb25jYXQoYXJyYXkubGVuZ3RoLCBcIiBmb3VuZFwiKSldO1xuICB9XG5cbiAgaWYgKGFycmF5U3BlY1snbWluLWxlbmd0aCddICYmIGFycmF5Lmxlbmd0aCA8IGFycmF5U3BlY1snbWluLWxlbmd0aCddKSB7XG4gICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgYXJyYXksIFwiYXJyYXkgbGVuZ3RoIGF0IGxlYXN0IFwiLmNvbmNhdChhcnJheVNwZWNbJ21pbi1sZW5ndGgnXSwgXCIgZXhwZWN0ZWQsIGxlbmd0aCBcIikuY29uY2F0KGFycmF5Lmxlbmd0aCwgXCIgZm91bmRcIikpXTtcbiAgfVxuXG4gIHZhciBhcnJheUVsZW1lbnRTcGVjID0ge1xuICAgICd0eXBlJzogYXJyYXlTcGVjLnZhbHVlLFxuICAgICd2YWx1ZXMnOiBhcnJheVNwZWMudmFsdWVzLFxuICAgICdtaW5pbXVtJzogYXJyYXlTcGVjLm1pbmltdW0sXG4gICAgJ21heGltdW0nOiBhcnJheVNwZWMubWF4aW11bVxuICB9O1xuXG4gIGlmIChzdHlsZVNwZWMuJHZlcnNpb24gPCA3KSB7XG4gICAgYXJyYXlFbGVtZW50U3BlYy5mdW5jdGlvbiA9IGFycmF5U3BlYy5mdW5jdGlvbjtcbiAgfVxuXG4gIGlmIChnZXRUeXBlKGFycmF5U3BlYy52YWx1ZSkgPT09ICdvYmplY3QnKSB7XG4gICAgYXJyYXlFbGVtZW50U3BlYyA9IGFycmF5U3BlYy52YWx1ZTtcbiAgfVxuXG4gIHZhciBlcnJvcnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUFycmF5RWxlbWVudCh7XG4gICAgICBhcnJheTogYXJyYXksXG4gICAgICBhcnJheUluZGV4OiBpLFxuICAgICAgdmFsdWU6IGFycmF5W2ldLFxuICAgICAgdmFsdWVTcGVjOiBhcnJheUVsZW1lbnRTcGVjLFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICBrZXk6IFwiXCIuY29uY2F0KGtleSwgXCJbXCIpLmNvbmNhdChpLCBcIl1cIilcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcihvcHRpb25zKSB7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICB0eXBlID0gJ05hTic7XG4gIH1cblxuICBpZiAodHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJudW1iZXIgZXhwZWN0ZWQsIFwiLmNvbmNhdCh0eXBlLCBcIiBmb3VuZFwiKSldO1xuICB9XG5cbiAgaWYgKCdtaW5pbXVtJyBpbiB2YWx1ZVNwZWMpIHtcbiAgICB2YXIgc3BlY01pbiA9IHZhbHVlU3BlYy5taW5pbXVtO1xuXG4gICAgaWYgKGdldFR5cGUodmFsdWVTcGVjLm1pbmltdW0pID09PSAnYXJyYXknKSB7XG4gICAgICB2YXIgaSA9IG9wdGlvbnMuYXJyYXlJbmRleDtcbiAgICAgIHNwZWNNaW4gPSB2YWx1ZVNwZWMubWluaW11bVtpXTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPCBzcGVjTWluKSB7XG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJcIi5jb25jYXQodmFsdWUsIFwiIGlzIGxlc3MgdGhhbiB0aGUgbWluaW11bSB2YWx1ZSBcIikuY29uY2F0KHNwZWNNaW4pKV07XG4gICAgfVxuICB9XG5cbiAgaWYgKCdtYXhpbXVtJyBpbiB2YWx1ZVNwZWMpIHtcbiAgICB2YXIgc3BlY01heCA9IHZhbHVlU3BlYy5tYXhpbXVtO1xuXG4gICAgaWYgKGdldFR5cGUodmFsdWVTcGVjLm1heGltdW0pID09PSAnYXJyYXknKSB7XG4gICAgICB2YXIgX2k5ID0gb3B0aW9ucy5hcnJheUluZGV4O1xuICAgICAgc3BlY01heCA9IHZhbHVlU3BlYy5tYXhpbXVtW19pOV07XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID4gc3BlY01heCkge1xuICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIFwiXCIuY29uY2F0KHZhbHVlLCBcIiBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gdmFsdWUgXCIpLmNvbmNhdChzcGVjTWF4KSldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciBmdW5jdGlvblZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICB2YXIgZnVuY3Rpb25UeXBlID0gdW5idW5kbGUob3B0aW9ucy52YWx1ZS50eXBlKTtcbiAgdmFyIHN0b3BLZXlUeXBlO1xuICB2YXIgc3RvcERvbWFpblZhbHVlcyA9IHt9O1xuICB2YXIgcHJldmlvdXNTdG9wRG9tYWluVmFsdWU7XG4gIHZhciBwcmV2aW91c1N0b3BEb21haW5ab29tO1xuICB2YXIgaXNab29tRnVuY3Rpb24gPSBmdW5jdGlvblR5cGUgIT09ICdjYXRlZ29yaWNhbCcgJiYgb3B0aW9ucy52YWx1ZS5wcm9wZXJ0eSA9PT0gdW5kZWZpbmVkO1xuICB2YXIgaXNQcm9wZXJ0eUZ1bmN0aW9uID0gIWlzWm9vbUZ1bmN0aW9uO1xuICB2YXIgaXNab29tQW5kUHJvcGVydHlGdW5jdGlvbiA9IGdldFR5cGUob3B0aW9ucy52YWx1ZS5zdG9wcykgPT09ICdhcnJheScgJiYgZ2V0VHlwZShvcHRpb25zLnZhbHVlLnN0b3BzWzBdKSA9PT0gJ2FycmF5JyAmJiBnZXRUeXBlKG9wdGlvbnMudmFsdWUuc3RvcHNbMF1bMF0pID09PSAnb2JqZWN0JztcbiAgdmFyIGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHtcbiAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlLFxuICAgIHZhbHVlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMuZnVuY3Rpb24sXG4gICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgc3RvcHM6IHZhbGlkYXRlRnVuY3Rpb25TdG9wcyxcbiAgICAgIGRlZmF1bHQ6IHZhbGlkYXRlRnVuY3Rpb25EZWZhdWx0XG4gICAgfVxuICB9KTtcblxuICBpZiAoZnVuY3Rpb25UeXBlID09PSAnaWRlbnRpdHknICYmIGlzWm9vbUZ1bmN0aW9uKSB7XG4gICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJwcm9wZXJ0eVwiJykpO1xuICB9XG5cbiAgaWYgKGZ1bmN0aW9uVHlwZSAhPT0gJ2lkZW50aXR5JyAmJiAhb3B0aW9ucy52YWx1ZS5zdG9wcykge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IFwic3RvcHNcIicpKTtcbiAgfVxuXG4gIGlmIChmdW5jdGlvblR5cGUgPT09ICdleHBvbmVudGlhbCcgJiYgb3B0aW9ucy52YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiAhc3VwcG9ydHNJbnRlcnBvbGF0aW9uKG9wdGlvbnMudmFsdWVTcGVjKSkge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdleHBvbmVudGlhbCBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZCcpKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnN0eWxlU3BlYy4kdmVyc2lvbiA+PSA4KSB7XG4gICAgaWYgKGlzUHJvcGVydHlGdW5jdGlvbiAmJiAhc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24ob3B0aW9ucy52YWx1ZVNwZWMpKSB7XG4gICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAncHJvcGVydHkgZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgfSBlbHNlIGlmIChpc1pvb21GdW5jdGlvbiAmJiAhc3VwcG9ydHNab29tRXhwcmVzc2lvbihvcHRpb25zLnZhbHVlU3BlYykpIHtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICd6b29tIGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICgoZnVuY3Rpb25UeXBlID09PSAnY2F0ZWdvcmljYWwnIHx8IGlzWm9vbUFuZFByb3BlcnR5RnVuY3Rpb24pICYmIG9wdGlvbnMudmFsdWUucHJvcGVydHkgPT09IHVuZGVmaW5lZCkge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdcInByb3BlcnR5XCIgcHJvcGVydHkgaXMgcmVxdWlyZWQnKSk7XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25TdG9wcyhvcHRpb25zKSB7XG4gICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnaWRlbnRpdHkgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGEgXCJzdG9wc1wiIHByb3BlcnR5JyldO1xuICAgIH1cblxuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVBcnJheSh7XG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgdmFsdWVTcGVjOiBvcHRpb25zLnZhbHVlU3BlYyxcbiAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgIGFycmF5RWxlbWVudFZhbGlkYXRvcjogdmFsaWRhdGVGdW5jdGlvblN0b3BcbiAgICB9KSk7XG5cbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdhcnJheScgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCB2YWx1ZSwgJ2FycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgc3RvcCcpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvblN0b3Aob3B0aW9ucykge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHZhciBrZXkgPSBvcHRpb25zLmtleTtcblxuICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ2FycmF5Jykge1xuICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIFwiYXJyYXkgZXhwZWN0ZWQsIFwiLmNvbmNhdChnZXRUeXBlKHZhbHVlKSwgXCIgZm91bmRcIikpXTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJhcnJheSBsZW5ndGggMiBleHBlY3RlZCwgbGVuZ3RoIFwiLmNvbmNhdCh2YWx1ZS5sZW5ndGgsIFwiIGZvdW5kXCIpKV07XG4gICAgfVxuXG4gICAgaWYgKGlzWm9vbUFuZFByb3BlcnR5RnVuY3Rpb24pIHtcbiAgICAgIGlmIChnZXRUeXBlKHZhbHVlWzBdKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIFwib2JqZWN0IGV4cGVjdGVkLCBcIi5jb25jYXQoZ2V0VHlwZSh2YWx1ZVswXSksIFwiIGZvdW5kXCIpKV07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZVswXS56b29tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdvYmplY3Qgc3RvcCBrZXkgbXVzdCBoYXZlIHpvb20nKV07XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZVswXS52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnb2JqZWN0IHN0b3Aga2V5IG11c3QgaGF2ZSB2YWx1ZScpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZpb3VzU3RvcERvbWFpblpvb20gJiYgcHJldmlvdXNTdG9wRG9tYWluWm9vbSA+IHVuYnVuZGxlKHZhbHVlWzBdLnpvb20pKSB7XG4gICAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlWzBdLnpvb20sICdzdG9wIHpvb20gdmFsdWVzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlcicpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHVuYnVuZGxlKHZhbHVlWzBdLnpvb20pICE9PSBwcmV2aW91c1N0b3BEb21haW5ab29tKSB7XG4gICAgICAgIHByZXZpb3VzU3RvcERvbWFpblpvb20gPSB1bmJ1bmRsZSh2YWx1ZVswXS56b29tKTtcbiAgICAgICAgcHJldmlvdXNTdG9wRG9tYWluVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN0b3BEb21haW5WYWx1ZXMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgIGtleTogXCJcIi5jb25jYXQoa2V5LCBcIlswXVwiKSxcbiAgICAgICAgdmFsdWU6IHZhbHVlWzBdLFxuICAgICAgICB2YWx1ZVNwZWM6IHtcbiAgICAgICAgICB6b29tOiB7fVxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICB6b29tOiB2YWxpZGF0ZU51bWJlcixcbiAgICAgICAgICB2YWx1ZTogdmFsaWRhdGVTdG9wRG9tYWluVmFsdWVcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlU3RvcERvbWFpblZhbHVlKHtcbiAgICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXksIFwiWzBdXCIpLFxuICAgICAgICB2YWx1ZTogdmFsdWVbMF0sXG4gICAgICAgIHZhbHVlU3BlYzoge30sXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgICB9LCB2YWx1ZSkpO1xuICAgIH1cblxuICAgIGlmIChpc0V4cHJlc3Npb24oZGVlcFVuYnVuZGxlKHZhbHVlWzFdKSkpIHtcbiAgICAgIHJldHVybiBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKFwiXCIuY29uY2F0KGtleSwgXCJbMV1cIiksIHZhbHVlWzFdLCAnZXhwcmVzc2lvbnMgYXJlIG5vdCBhbGxvd2VkIGluIGZ1bmN0aW9uIHN0b3BzLicpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXksIFwiWzFdXCIpLFxuICAgICAgdmFsdWU6IHZhbHVlWzFdLFxuICAgICAgdmFsdWVTcGVjOiBmdW5jdGlvblZhbHVlU3BlYyxcbiAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlU3RvcERvbWFpblZhbHVlKG9wdGlvbnMsIHN0b3ApIHtcbiAgICB2YXIgdHlwZSA9IGdldFR5cGUob3B0aW9ucy52YWx1ZSk7XG4gICAgdmFyIHZhbHVlID0gdW5idW5kbGUob3B0aW9ucy52YWx1ZSk7XG4gICAgdmFyIHJlcG9ydFZhbHVlID0gb3B0aW9ucy52YWx1ZSAhPT0gbnVsbCA/IG9wdGlvbnMudmFsdWUgOiBzdG9wO1xuXG4gICAgaWYgKCFzdG9wS2V5VHlwZSkge1xuICAgICAgc3RvcEtleVR5cGUgPSB0eXBlO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gc3RvcEtleVR5cGUpIHtcbiAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsIFwiXCIuY29uY2F0KHR5cGUsIFwiIHN0b3AgZG9tYWluIHR5cGUgbXVzdCBtYXRjaCBwcmV2aW91cyBzdG9wIGRvbWFpbiB0eXBlIFwiKS5jb25jYXQoc3RvcEtleVR5cGUpKV07XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgIT09ICdudW1iZXInICYmIHR5cGUgIT09ICdzdHJpbmcnICYmIHR5cGUgIT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ3N0b3AgZG9tYWluIHZhbHVlIG11c3QgYmUgYSBudW1iZXIsIHN0cmluZywgb3IgYm9vbGVhbicpXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSAhPT0gJ251bWJlcicgJiYgZnVuY3Rpb25UeXBlICE9PSAnY2F0ZWdvcmljYWwnKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IFwibnVtYmVyIGV4cGVjdGVkLCBcIi5jb25jYXQodHlwZSwgXCIgZm91bmRcIik7XG5cbiAgICAgIGlmIChzdXBwb3J0c1Byb3BlcnR5RXhwcmVzc2lvbihmdW5jdGlvblZhbHVlU3BlYykgJiYgZnVuY3Rpb25UeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVzc2FnZSArPSAnXFxuSWYgeW91IGludGVuZGVkIHRvIHVzZSBhIGNhdGVnb3JpY2FsIGZ1bmN0aW9uLCBzcGVjaWZ5IGBcInR5cGVcIjogXCJjYXRlZ29yaWNhbFwiYC4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCBtZXNzYWdlKV07XG4gICAgfVxuXG4gICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2NhdGVnb3JpY2FsJyAmJiB0eXBlID09PSAnbnVtYmVyJyAmJiAoIWlzRmluaXRlKHZhbHVlKSB8fCBNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpKSB7XG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCBcImludGVnZXIgZXhwZWN0ZWQsIGZvdW5kIFwiLmNvbmNhdCh2YWx1ZSkpXTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY3Rpb25UeXBlICE9PSAnY2F0ZWdvcmljYWwnICYmIHR5cGUgPT09ICdudW1iZXInICYmIHByZXZpb3VzU3RvcERvbWFpblZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPCBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSkge1xuICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgJ3N0b3AgZG9tYWluIHZhbHVlcyBtdXN0IGFwcGVhciBpbiBhc2NlbmRpbmcgb3JkZXInKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzU3RvcERvbWFpblZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2NhdGVnb3JpY2FsJyAmJiB2YWx1ZSBpbiBzdG9wRG9tYWluVmFsdWVzKSB7XG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCAnc3RvcCBkb21haW4gdmFsdWVzIG11c3QgYmUgdW5pcXVlJyldO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9wRG9tYWluVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkRlZmF1bHQob3B0aW9ucykge1xuICAgIHJldHVybiB2YWxpZGF0ZSh7XG4gICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICB2YWx1ZVNwZWM6IGZ1bmN0aW9uVmFsdWVTcGVjLFxuICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHByZXNzaW9uKG9wdGlvbnMpIHtcbiAgdmFyIGV4cHJlc3Npb24gPSAob3B0aW9ucy5leHByZXNzaW9uQ29udGV4dCA9PT0gJ3Byb3BlcnR5JyA/IGNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbiA6IGNyZWF0ZUV4cHJlc3Npb24pKGRlZXBVbmJ1bmRsZShvcHRpb25zLnZhbHVlKSwgb3B0aW9ucy52YWx1ZVNwZWMpO1xuXG4gIGlmIChleHByZXNzaW9uLnJlc3VsdCA9PT0gJ2Vycm9yJykge1xuICAgIHJldHVybiBleHByZXNzaW9uLnZhbHVlLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBuZXcgVmFsaWRhdGlvbkVycm9yKFwiXCIuY29uY2F0KG9wdGlvbnMua2V5KS5jb25jYXQoZXJyb3Iua2V5KSwgb3B0aW9ucy52YWx1ZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgZXhwcmVzc2lvbk9iaiA9IGV4cHJlc3Npb24udmFsdWUuZXhwcmVzc2lvbiB8fCBleHByZXNzaW9uLnZhbHVlLl9zdHlsZUV4cHJlc3Npb24uZXhwcmVzc2lvbjtcblxuICBpZiAob3B0aW9ucy5leHByZXNzaW9uQ29udGV4dCA9PT0gJ3Byb3BlcnR5JyAmJiBvcHRpb25zLnByb3BlcnR5S2V5ID09PSAndGV4dC1mb250JyAmJiAhZXhwcmVzc2lvbk9iai5vdXRwdXREZWZpbmVkKCkpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsIFwiSW52YWxpZCBkYXRhIGV4cHJlc3Npb24gZm9yIFxcXCJcIi5jb25jYXQob3B0aW9ucy5wcm9wZXJ0eUtleSwgXCJcXFwiLiBPdXRwdXQgdmFsdWVzIG11c3QgYmUgY29udGFpbmVkIGFzIGxpdGVyYWxzIHdpdGhpbiB0aGUgZXhwcmVzc2lvbi5cIikpXTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAncHJvcGVydHknICYmIG9wdGlvbnMucHJvcGVydHlUeXBlID09PSAnbGF5b3V0JyAmJiAhaXNTdGF0ZUNvbnN0YW50KGV4cHJlc3Npb25PYmopKSB7XG4gICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnXCJmZWF0dXJlLXN0YXRlXCIgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGxheW91dCBwcm9wZXJ0aWVzLicpXTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAnZmlsdGVyJyAmJiAhaXNTdGF0ZUNvbnN0YW50KGV4cHJlc3Npb25PYmopKSB7XG4gICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnXCJmZWF0dXJlLXN0YXRlXCIgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGZpbHRlcnMuJyldO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgJiYgb3B0aW9ucy5leHByZXNzaW9uQ29udGV4dC5pbmRleE9mKCdjbHVzdGVyJykgPT09IDApIHtcbiAgICBpZiAoIWlzR2xvYmFsUHJvcGVydHlDb25zdGFudChleHByZXNzaW9uT2JqLCBbJ3pvb20nLCAnZmVhdHVyZS1zdGF0ZSddKSkge1xuICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnXCJ6b29tXCIgYW5kIFwiZmVhdHVyZS1zdGF0ZVwiIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggY2x1c3RlciBwcm9wZXJ0aWVzLicpXTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5leHByZXNzaW9uQ29udGV4dCA9PT0gJ2NsdXN0ZXItaW5pdGlhbCcgJiYgIWlzRmVhdHVyZUNvbnN0YW50KGV4cHJlc3Npb25PYmopKSB7XG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdGZWF0dXJlIGRhdGEgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBpbml0aWFsIGV4cHJlc3Npb24gcGFydCBvZiBjbHVzdGVyIHByb3BlcnRpZXMuJyldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVCb29sZWFuKG9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gIGlmICh0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJib29sZWFuIGV4cGVjdGVkLCBcIi5jb25jYXQodHlwZSwgXCIgZm91bmRcIikpXTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb2xvcihvcHRpb25zKSB7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcblxuICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJjb2xvciBleHBlY3RlZCwgXCIuY29uY2F0KHR5cGUsIFwiIGZvdW5kXCIpKV07XG4gIH1cblxuICBpZiAoY3NzY29sb3JwYXJzZXIucGFyc2VDU1NDb2xvcih2YWx1ZSkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJjb2xvciBleHBlY3RlZCwgXFxcIlwiLmNvbmNhdCh2YWx1ZSwgXCJcXFwiIGZvdW5kXCIpKV07XG4gIH1cblxuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRW51bShvcHRpb25zKSB7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICB2YXIgZXJyb3JzID0gW107XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVTcGVjLnZhbHVlcykpIHtcbiAgICBpZiAodmFsdWVTcGVjLnZhbHVlcy5pbmRleE9mKHVuYnVuZGxlKHZhbHVlKSkgPT09IC0xKSB7XG4gICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIFwiZXhwZWN0ZWQgb25lIG9mIFtcIi5jb25jYXQodmFsdWVTcGVjLnZhbHVlcy5qb2luKCcsICcpLCBcIl0sIFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBcIiBmb3VuZFwiKSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoT2JqZWN0LmtleXModmFsdWVTcGVjLnZhbHVlcykuaW5kZXhPZih1bmJ1bmRsZSh2YWx1ZSkpID09PSAtMSkge1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcImV4cGVjdGVkIG9uZSBvZiBbXCIuY29uY2F0KE9iamVjdC5rZXlzKHZhbHVlU3BlYy52YWx1ZXMpLmpvaW4oJywgJyksIFwiXSwgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeSh2YWx1ZSksIFwiIGZvdW5kXCIpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGaWx0ZXIob3B0aW9ucykge1xuICBpZiAoaXNFeHByZXNzaW9uRmlsdGVyKGRlZXBVbmJ1bmRsZShvcHRpb25zLnZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVFeHByZXNzaW9uKGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgZXhwcmVzc2lvbkNvbnRleHQ6ICdmaWx0ZXInLFxuICAgICAgdmFsdWVTcGVjOiB7XG4gICAgICAgIHZhbHVlOiAnYm9vbGVhbidcbiAgICAgIH1cbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlTm9uRXhwcmVzc2lvbkZpbHRlcihvcHRpb25zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU5vbkV4cHJlc3Npb25GaWx0ZXIob3B0aW9ucykge1xuICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG5cbiAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnYXJyYXknKSB7XG4gICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIFwiYXJyYXkgZXhwZWN0ZWQsIFwiLmNvbmNhdChnZXRUeXBlKHZhbHVlKSwgXCIgZm91bmRcIikpXTtcbiAgfVxuXG4gIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgdmFyIHR5cGU7XG4gIHZhciBlcnJvcnMgPSBbXTtcblxuICBpZiAodmFsdWUubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnZmlsdGVyIGFycmF5IG11c3QgaGF2ZSBhdCBsZWFzdCAxIGVsZW1lbnQnKV07XG4gIH1cblxuICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlRW51bSh7XG4gICAga2V5OiBcIlwiLmNvbmNhdChrZXksIFwiWzBdXCIpLFxuICAgIHZhbHVlOiB2YWx1ZVswXSxcbiAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5maWx0ZXJfb3BlcmF0b3IsXG4gICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICB9KSk7XG5cbiAgc3dpdGNoICh1bmJ1bmRsZSh2YWx1ZVswXSkpIHtcbiAgICBjYXNlICc8JzpcbiAgICBjYXNlICc8PSc6XG4gICAgY2FzZSAnPic6XG4gICAgY2FzZSAnPj0nOlxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyICYmIHVuYnVuZGxlKHZhbHVlWzFdKSA9PT0gJyR0eXBlJykge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIFwiXFxcIiR0eXBlXFxcIiBjYW5ub3QgYmUgdXNlIHdpdGggb3BlcmF0b3IgXFxcIlwiLmNvbmNhdCh2YWx1ZVswXSwgXCJcXFwiXCIpKSk7XG4gICAgICB9XG5cbiAgICBjYXNlICc9PSc6XG4gICAgY2FzZSAnIT0nOlxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMykge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIFwiZmlsdGVyIGFycmF5IGZvciBvcGVyYXRvciBcXFwiXCIuY29uY2F0KHZhbHVlWzBdLCBcIlxcXCIgbXVzdCBoYXZlIDMgZWxlbWVudHNcIikpKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ2luJzpcbiAgICBjYXNlICchaW4nOlxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlWzFdKTtcblxuICAgICAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKFwiXCIuY29uY2F0KGtleSwgXCJbMV1cIiksIHZhbHVlWzFdLCBcInN0cmluZyBleHBlY3RlZCwgXCIuY29uY2F0KHR5cGUsIFwiIGZvdW5kXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0eXBlID0gZ2V0VHlwZSh2YWx1ZVtpXSk7XG5cbiAgICAgICAgaWYgKHVuYnVuZGxlKHZhbHVlWzFdKSA9PT0gJyR0eXBlJykge1xuICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbnVtKHtcbiAgICAgICAgICAgIGtleTogXCJcIi5jb25jYXQoa2V5LCBcIltcIikuY29uY2F0KGksIFwiXVwiKSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpXSxcbiAgICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmdlb21ldHJ5X3R5cGUsXG4gICAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gJ251bWJlcicgJiYgdHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihcIlwiLmNvbmNhdChrZXksIFwiW1wiKS5jb25jYXQoaSwgXCJdXCIpLCB2YWx1ZVtpXSwgXCJzdHJpbmcsIG51bWJlciwgb3IgYm9vbGVhbiBleHBlY3RlZCwgXCIuY29uY2F0KHR5cGUsIFwiIGZvdW5kXCIpKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhbnknOlxuICAgIGNhc2UgJ2FsbCc6XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICBmb3IgKHZhciBfaTEwID0gMTsgX2kxMCA8IHZhbHVlLmxlbmd0aDsgX2kxMCsrKSB7XG4gICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVOb25FeHByZXNzaW9uRmlsdGVyKHtcbiAgICAgICAgICBrZXk6IFwiXCIuY29uY2F0KGtleSwgXCJbXCIpLmNvbmNhdChfaTEwLCBcIl1cIiksXG4gICAgICAgICAgdmFsdWU6IHZhbHVlW19pMTBdLFxuICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgICAgfSkpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hhcyc6XG4gICAgY2FzZSAnIWhhcyc6XG4gICAgICB0eXBlID0gZ2V0VHlwZSh2YWx1ZVsxXSk7XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcImZpbHRlciBhcnJheSBmb3IgXFxcIlwiLmNvbmNhdCh2YWx1ZVswXSwgXCJcXFwiIG9wZXJhdG9yIG11c3QgaGF2ZSAyIGVsZW1lbnRzXCIpKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJcIi5jb25jYXQoa2V5LCBcIlsxXVwiKSwgdmFsdWVbMV0sIFwic3RyaW5nIGV4cGVjdGVkLCBcIi5jb25jYXQodHlwZSwgXCIgZm91bmRcIikpKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd3aXRoaW4nOlxuICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbMV0pO1xuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJmaWx0ZXIgYXJyYXkgZm9yIFxcXCJcIi5jb25jYXQodmFsdWVbMF0sIFwiXFxcIiBvcGVyYXRvciBtdXN0IGhhdmUgMiBlbGVtZW50c1wiKSkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKFwiXCIuY29uY2F0KGtleSwgXCJbMV1cIiksIHZhbHVlWzFdLCBcIm9iamVjdCBleHBlY3RlZCwgXCIuY29uY2F0KHR5cGUsIFwiIGZvdW5kXCIpKSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eShvcHRpb25zLCBwcm9wZXJ0eVR5cGUpIHtcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gIHZhciBwcm9wZXJ0eUtleSA9IG9wdGlvbnMub2JqZWN0S2V5O1xuICB2YXIgbGF5ZXJTcGVjID0gc3R5bGVTcGVjW1wiXCIuY29uY2F0KHByb3BlcnR5VHlwZSwgXCJfXCIpLmNvbmNhdChvcHRpb25zLmxheWVyVHlwZSldO1xuICBpZiAoIWxheWVyU3BlYykgcmV0dXJuIFtdO1xuICB2YXIgdHJhbnNpdGlvbk1hdGNoID0gcHJvcGVydHlLZXkubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG5cbiAgaWYgKHByb3BlcnR5VHlwZSA9PT0gJ3BhaW50JyAmJiB0cmFuc2l0aW9uTWF0Y2ggJiYgbGF5ZXJTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0gJiYgbGF5ZXJTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0udHJhbnNpdGlvbikge1xuICAgIHJldHVybiB2YWxpZGF0ZSh7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnRyYW5zaXRpb24sXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjIHx8IGxheWVyU3BlY1twcm9wZXJ0eUtleV07XG5cbiAgaWYgKCF2YWx1ZVNwZWMpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJ1bmtub3duIHByb3BlcnR5IFxcXCJcIi5jb25jYXQocHJvcGVydHlLZXksIFwiXFxcIlwiKSldO1xuICB9XG5cbiAgdmFyIHRva2VuTWF0Y2g7XG5cbiAgaWYgKGdldFR5cGUodmFsdWUpID09PSAnc3RyaW5nJyAmJiBzdXBwb3J0c1Byb3BlcnR5RXhwcmVzc2lvbih2YWx1ZVNwZWMpICYmICF2YWx1ZVNwZWMudG9rZW5zICYmICh0b2tlbk1hdGNoID0gL157KFtefV0rKX0kLy5leGVjKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJcXFwiXCIuY29uY2F0KHByb3BlcnR5S2V5LCBcIlxcXCIgZG9lcyBub3Qgc3VwcG9ydCBpbnRlcnBvbGF0aW9uIHN5bnRheFxcblwiKSArIFwiVXNlIGFuIGlkZW50aXR5IHByb3BlcnR5IGZ1bmN0aW9uIGluc3RlYWQ6IGB7IFxcXCJ0eXBlXFxcIjogXFxcImlkZW50aXR5XFxcIiwgXFxcInByb3BlcnR5XFxcIjogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRva2VuTWF0Y2hbMV0pLCBcIiB9YC5cIikpXTtcbiAgfVxuXG4gIHZhciBlcnJvcnMgPSBbXTtcblxuICBpZiAob3B0aW9ucy5sYXllclR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgaWYgKHByb3BlcnR5S2V5ID09PSAndGV4dC1maWVsZCcgJiYgc3R5bGUgJiYgIXN0eWxlLmdseXBocykge1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAndXNlIG9mIFwidGV4dC1maWVsZFwiIHJlcXVpcmVzIGEgc3R5bGUgXCJnbHlwaHNcIiBwcm9wZXJ0eScpKTtcbiAgICB9XG5cbiAgICBpZiAocHJvcGVydHlLZXkgPT09ICd0ZXh0LWZvbnQnICYmIGlzRnVuY3Rpb24kMShkZWVwVW5idW5kbGUodmFsdWUpKSAmJiB1bmJ1bmRsZSh2YWx1ZS50eXBlKSA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCJ0ZXh0LWZvbnRcIiBkb2VzIG5vdCBzdXBwb3J0IGlkZW50aXR5IGZ1bmN0aW9ucycpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAga2V5OiBvcHRpb25zLmtleSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgdmFsdWVTcGVjOiB2YWx1ZVNwZWMsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgIGV4cHJlc3Npb25Db250ZXh0OiAncHJvcGVydHknLFxuICAgIHByb3BlcnR5VHlwZTogcHJvcGVydHlUeXBlLFxuICAgIHByb3BlcnR5S2V5OiBwcm9wZXJ0eUtleVxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGFpbnRQcm9wZXJ0eShvcHRpb25zKSB7XG4gIHJldHVybiB2YWxpZGF0ZVByb3BlcnR5KG9wdGlvbnMsICdwYWludCcpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUxheW91dFByb3BlcnR5KG9wdGlvbnMpIHtcbiAgcmV0dXJuIHZhbGlkYXRlUHJvcGVydHkob3B0aW9ucywgJ2xheW91dCcpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUxheWVyKG9wdGlvbnMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgbGF5ZXIgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcblxuICBpZiAoIWxheWVyLnR5cGUgJiYgIWxheWVyLnJlZikge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgJ2VpdGhlciBcInR5cGVcIiBvciBcInJlZlwiIGlzIHJlcXVpcmVkJykpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSB1bmJ1bmRsZShsYXllci50eXBlKTtcbiAgdmFyIHJlZiA9IHVuYnVuZGxlKGxheWVyLnJlZik7XG5cbiAgaWYgKGxheWVyLmlkKSB7XG4gICAgdmFyIGxheWVySWQgPSB1bmJ1bmRsZShsYXllci5pZCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMuYXJyYXlJbmRleDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJMYXllciA9IHN0eWxlLmxheWVyc1tpXTtcblxuICAgICAgaWYgKHVuYnVuZGxlKG90aGVyTGF5ZXIuaWQpID09PSBsYXllcklkKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5pZCwgXCJkdXBsaWNhdGUgbGF5ZXIgaWQgXFxcIlwiLmNvbmNhdChsYXllci5pZCwgXCJcXFwiLCBwcmV2aW91c2x5IHVzZWQgYXQgbGluZSBcIikuY29uY2F0KG90aGVyTGF5ZXIuaWQuX19saW5lX18pKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCdyZWYnIGluIGxheWVyKSB7XG4gICAgWyd0eXBlJywgJ3NvdXJjZScsICdzb3VyY2UtbGF5ZXInLCAnZmlsdGVyJywgJ2xheW91dCddLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmIChwIGluIGxheWVyKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllcltwXSwgXCJcXFwiXCIuY29uY2F0KHAsIFwiXFxcIiBpcyBwcm9oaWJpdGVkIGZvciByZWYgbGF5ZXJzXCIpKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHBhcmVudDtcbiAgICBzdHlsZS5sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIGlmICh1bmJ1bmRsZShsYXllci5pZCkgPT09IHJlZikgcGFyZW50ID0gbGF5ZXI7XG4gICAgfSk7XG5cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnJlZiwgXCJyZWYgbGF5ZXIgXFxcIlwiLmNvbmNhdChyZWYsIFwiXFxcIiBub3QgZm91bmRcIikpKTtcbiAgICB9IGVsc2UgaWYgKHBhcmVudC5yZWYpIHtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5yZWYsICdyZWYgY2Fubm90IHJlZmVyZW5jZSBhbm90aGVyIHJlZiBsYXllcicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IHVuYnVuZGxlKHBhcmVudC50eXBlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISh0eXBlID09PSAnYmFja2dyb3VuZCcgfHwgdHlwZSA9PT0gJ3NreScpKSB7XG4gICAgaWYgKCFsYXllci5zb3VyY2UpIHtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJzb3VyY2VcIicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9zb3VyY2UyID0gc3R5bGUuc291cmNlcyAmJiBzdHlsZS5zb3VyY2VzW2xheWVyLnNvdXJjZV07XG5cbiAgICAgIHZhciBzb3VyY2VUeXBlID0gX3NvdXJjZTIgJiYgdW5idW5kbGUoX3NvdXJjZTIudHlwZSk7XG5cbiAgICAgIGlmICghX3NvdXJjZTIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgXCJzb3VyY2UgXFxcIlwiLmNvbmNhdChsYXllci5zb3VyY2UsIFwiXFxcIiBub3QgZm91bmRcIikpKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3ZlY3RvcicgJiYgdHlwZSA9PT0gJ3Jhc3RlcicpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgXCJsYXllciBcXFwiXCIuY29uY2F0KGxheWVyLmlkLCBcIlxcXCIgcmVxdWlyZXMgYSByYXN0ZXIgc291cmNlXCIpKSk7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09ICdyYXN0ZXInICYmIHR5cGUgIT09ICdyYXN0ZXInKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5zb3VyY2UsIFwibGF5ZXIgXFxcIlwiLmNvbmNhdChsYXllci5pZCwgXCJcXFwiIHJlcXVpcmVzIGEgdmVjdG9yIHNvdXJjZVwiKSkpO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2VUeXBlID09PSAndmVjdG9yJyAmJiAhbGF5ZXJbJ3NvdXJjZS1sYXllciddKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllciwgXCJsYXllciBcXFwiXCIuY29uY2F0KGxheWVyLmlkLCBcIlxcXCIgbXVzdCBzcGVjaWZ5IGEgXFxcInNvdXJjZS1sYXllclxcXCJcIikpKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3Jhc3Rlci1kZW0nICYmIHR5cGUgIT09ICdoaWxsc2hhZGUnKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsYXllci5zb3VyY2UsICdyYXN0ZXItZGVtIHNvdXJjZSBjYW4gb25seSBiZSB1c2VkIHdpdGggbGF5ZXIgdHlwZSBcXCdoaWxsc2hhZGVcXCcuJykpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbGluZScgJiYgbGF5ZXIucGFpbnQgJiYgbGF5ZXIucGFpbnRbJ2xpbmUtZ3JhZGllbnQnXSAmJiAoc291cmNlVHlwZSAhPT0gJ2dlb2pzb24nIHx8ICFfc291cmNlMi5saW5lTWV0cmljcykpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCBcImxheWVyIFxcXCJcIi5jb25jYXQobGF5ZXIuaWQsIFwiXFxcIiBzcGVjaWZpZXMgYSBsaW5lLWdyYWRpZW50LCB3aGljaCByZXF1aXJlcyBhIEdlb0pTT04gc291cmNlIHdpdGggYGxpbmVNZXRyaWNzYCBlbmFibGVkLlwiKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVPYmplY3Qoe1xuICAgIGtleToga2V5LFxuICAgIHZhbHVlOiBsYXllcixcbiAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5sYXllcixcbiAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAnKic6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0sXG4gICAgICB0eXBlOiBmdW5jdGlvbiB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUoe1xuICAgICAgICAgIGtleTogXCJcIi5jb25jYXQoa2V5LCBcIi50eXBlXCIpLFxuICAgICAgICAgIHZhbHVlOiBsYXllci50eXBlLFxuICAgICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmxheWVyLnR5cGUsXG4gICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgICBvYmplY3Q6IGxheWVyLFxuICAgICAgICAgIG9iamVjdEtleTogJ3R5cGUnXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZpbHRlcjogdmFsaWRhdGVGaWx0ZXIsXG4gICAgICBsYXlvdXQ6IGZ1bmN0aW9uIGxheW91dChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgICAgbGF5ZXI6IGxheWVyLFxuICAgICAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICAgICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYyxcbiAgICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgICAgJyonOiBmdW5jdGlvbiBfKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlTGF5b3V0UHJvcGVydHkoZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBsYXllclR5cGU6IHR5cGVcbiAgICAgICAgICAgICAgfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcGFpbnQ6IGZ1bmN0aW9uIHBhaW50KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICBsYXllcjogbGF5ZXIsXG4gICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAnKic6IGZ1bmN0aW9uIF8ob3B0aW9ucykge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVQYWludFByb3BlcnR5KGV4dGVuZCh7XG4gICAgICAgICAgICAgICAgbGF5ZXJUeXBlOiB0eXBlXG4gICAgICAgICAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSkpO1xuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cmluZyhvcHRpb25zKSB7XG4gIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgdmFyIHR5cGUgPSBnZXRUeXBlKHZhbHVlKTtcblxuICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJzdHJpbmcgZXhwZWN0ZWQsIFwiLmNvbmNhdCh0eXBlLCBcIiBmb3VuZFwiKSldO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG52YXIgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnMgPSB7XG4gIHByb21vdGVJZDogdmFsaWRhdGVQcm9tb3RlSWRcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU291cmNlKG9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgaWYgKCF2YWx1ZS50eXBlKSB7XG4gICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcInR5cGVcIiBpcyByZXF1aXJlZCcpXTtcbiAgfVxuXG4gIHZhciB0eXBlID0gdW5idW5kbGUodmFsdWUudHlwZSk7XG4gIHZhciBlcnJvcnM7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAndmVjdG9yJzpcbiAgICBjYXNlICdyYXN0ZXInOlxuICAgIGNhc2UgJ3Jhc3Rlci1kZW0nOlxuICAgICAgZXJyb3JzID0gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlY1tcInNvdXJjZV9cIi5jb25jYXQodHlwZS5yZXBsYWNlKCctJywgJ18nKSldLFxuICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiBvYmplY3RFbGVtZW50VmFsaWRhdG9yc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZXJyb3JzO1xuXG4gICAgY2FzZSAnZ2VvanNvbic6XG4gICAgICBlcnJvcnMgPSB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnNvdXJjZV9nZW9qc29uLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczogb2JqZWN0RWxlbWVudFZhbGlkYXRvcnNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodmFsdWUuY2x1c3Rlcikge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHZhbHVlLmNsdXN0ZXJQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdmFyIF9lcnJvcnMsIF9lcnJvcnMyO1xuXG4gICAgICAgICAgdmFyIF92YWx1ZSRjbHVzdGVyUHJvcGVydCA9IF9zbGljZWRUb0FycmF5KHZhbHVlLmNsdXN0ZXJQcm9wZXJ0aWVzW3Byb3BdLCAyKSxcbiAgICAgICAgICAgICAgb3BlcmF0b3IgPSBfdmFsdWUkY2x1c3RlclByb3BlcnRbMF0sXG4gICAgICAgICAgICAgIG1hcEV4cHIgPSBfdmFsdWUkY2x1c3RlclByb3BlcnRbMV07XG5cbiAgICAgICAgICB2YXIgcmVkdWNlRXhwciA9IHR5cGVvZiBvcGVyYXRvciA9PT0gJ3N0cmluZycgPyBbb3BlcmF0b3IsIFsnYWNjdW11bGF0ZWQnXSwgWydnZXQnLCBwcm9wXV0gOiBvcGVyYXRvcjtcblxuICAgICAgICAgIChfZXJyb3JzID0gZXJyb3JzKS5wdXNoLmFwcGx5KF9lcnJvcnMsIF90b0NvbnN1bWFibGVBcnJheSh2YWxpZGF0ZUV4cHJlc3Npb24oe1xuICAgICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXksIFwiLlwiKS5jb25jYXQocHJvcCwgXCIubWFwXCIpLFxuICAgICAgICAgICAgdmFsdWU6IG1hcEV4cHIsXG4gICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ2NsdXN0ZXItbWFwJ1xuICAgICAgICAgIH0pKSk7XG5cbiAgICAgICAgICAoX2Vycm9yczIgPSBlcnJvcnMpLnB1c2guYXBwbHkoX2Vycm9yczIsIF90b0NvbnN1bWFibGVBcnJheSh2YWxpZGF0ZUV4cHJlc3Npb24oe1xuICAgICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXksIFwiLlwiKS5jb25jYXQocHJvcCwgXCIucmVkdWNlXCIpLFxuICAgICAgICAgICAgdmFsdWU6IHJlZHVjZUV4cHIsXG4gICAgICAgICAgICBleHByZXNzaW9uQ29udGV4dDogJ2NsdXN0ZXItcmVkdWNlJ1xuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVycm9ycztcblxuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnNvdXJjZV92aWRlbyxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdpbWFnZSc6XG4gICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy5zb3VyY2VfaW1hZ2UsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnY2FudmFzJzpcbiAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG51bGwsIFwiUGxlYXNlIHVzZSBydW50aW1lIEFQSXMgdG8gYWRkIGNhbnZhcyBzb3VyY2VzLCByYXRoZXIgdGhhbiBpbmNsdWRpbmcgdGhlbSBpbiBzdHlsZXNoZWV0cy5cIiwgJ3NvdXJjZS5jYW52YXMnKV07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZhbGlkYXRlRW51bSh7XG4gICAgICAgIGtleTogXCJcIi5jb25jYXQoa2V5LCBcIi50eXBlXCIpLFxuICAgICAgICB2YWx1ZTogdmFsdWUudHlwZSxcbiAgICAgICAgdmFsdWVTcGVjOiB7XG4gICAgICAgICAgdmFsdWVzOiBbJ3ZlY3RvcicsICdyYXN0ZXInLCAncmFzdGVyLWRlbScsICdnZW9qc29uJywgJ3ZpZGVvJywgJ2ltYWdlJ11cbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9tb3RlSWQoX3JlZjExMykge1xuICB2YXIga2V5ID0gX3JlZjExMy5rZXksXG4gICAgICB2YWx1ZSA9IF9yZWYxMTMudmFsdWU7XG5cbiAgaWYgKGdldFR5cGUodmFsdWUpID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWxpZGF0ZVN0cmluZyh7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcnJvcnMgPSBbXTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIHtcbiAgICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgX3RvQ29uc3VtYWJsZUFycmF5KHZhbGlkYXRlU3RyaW5nKHtcbiAgICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXksIFwiLlwiKS5jb25jYXQocHJvcCksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVtwcm9wXVxuICAgICAgfSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGlnaHQob3B0aW9ucykge1xuICB2YXIgbGlnaHQgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gIHZhciBsaWdodFNwZWMgPSBzdHlsZVNwZWMubGlnaHQ7XG4gIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHJvb3RUeXBlID0gZ2V0VHlwZShsaWdodCk7XG5cbiAgaWYgKGxpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZXJyb3JzO1xuICB9IGVsc2UgaWYgKHJvb3RUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3IoJ2xpZ2h0JywgbGlnaHQsIFwib2JqZWN0IGV4cGVjdGVkLCBcIi5jb25jYXQocm9vdFR5cGUsIFwiIGZvdW5kXCIpKV0pO1xuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cblxuICBmb3IgKHZhciBrZXkgaW4gbGlnaHQpIHtcbiAgICB2YXIgdHJhbnNpdGlvbk1hdGNoID0ga2V5Lm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuXG4gICAgaWYgKHRyYW5zaXRpb25NYXRjaCAmJiBsaWdodFNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXSAmJiBsaWdodFNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXS50cmFuc2l0aW9uKSB7XG4gICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiBsaWdodFtrZXldLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy50cmFuc2l0aW9uLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIGlmIChsaWdodFNwZWNba2V5XSkge1xuICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogbGlnaHRba2V5XSxcbiAgICAgICAgdmFsdWVTcGVjOiBsaWdodFNwZWNba2V5XSxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGlnaHRba2V5XSwgXCJ1bmtub3duIHByb3BlcnR5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCJcIikpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUZXJyYWluKG9wdGlvbnMpIHtcbiAgdmFyIHRlcnJhaW4gPSBvcHRpb25zLnZhbHVlO1xuICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgdmFyIHRlcnJhaW5TcGVjID0gc3R5bGVTcGVjLnRlcnJhaW47XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHJvb3RUeXBlID0gZ2V0VHlwZSh0ZXJyYWluKTtcblxuICBpZiAodGVycmFpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycm9ycztcbiAgfSBlbHNlIGlmIChyb290VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKCd0ZXJyYWluJywgdGVycmFpbiwgXCJvYmplY3QgZXhwZWN0ZWQsIFwiLmNvbmNhdChyb290VHlwZSwgXCIgZm91bmRcIikpXSk7XG4gICAgcmV0dXJuIGVycm9ycztcbiAgfVxuXG4gIGZvciAodmFyIF9rZXk2IGluIHRlcnJhaW4pIHtcbiAgICB2YXIgdHJhbnNpdGlvbk1hdGNoID0gX2tleTYubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG5cbiAgICBpZiAodHJhbnNpdGlvbk1hdGNoICYmIHRlcnJhaW5TcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0gJiYgdGVycmFpblNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXS50cmFuc2l0aW9uKSB7XG4gICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAga2V5OiBfa2V5NixcbiAgICAgICAgdmFsdWU6IHRlcnJhaW5bX2tleTZdLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy50cmFuc2l0aW9uLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIGlmICh0ZXJyYWluU3BlY1tfa2V5Nl0pIHtcbiAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICBrZXk6IF9rZXk2LFxuICAgICAgICB2YWx1ZTogdGVycmFpbltfa2V5Nl0sXG4gICAgICAgIHZhbHVlU3BlYzogdGVycmFpblNwZWNbX2tleTZdLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3IoX2tleTYsIHRlcnJhaW5bX2tleTZdLCBcInVua25vd24gcHJvcGVydHkgXFxcIlwiLmNvbmNhdChfa2V5NiwgXCJcXFwiXCIpKV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGVycmFpbi5zb3VyY2UpIHtcbiAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdGVycmFpbiwgXCJ0ZXJyYWluIGlzIG1pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXFxcInNvdXJjZVxcXCJcIikpO1xuICB9IGVsc2Uge1xuICAgIHZhciBfc291cmNlMyA9IHN0eWxlLnNvdXJjZXMgJiYgc3R5bGUuc291cmNlc1t0ZXJyYWluLnNvdXJjZV07XG5cbiAgICB2YXIgc291cmNlVHlwZSA9IF9zb3VyY2UzICYmIHVuYnVuZGxlKF9zb3VyY2UzLnR5cGUpO1xuXG4gICAgaWYgKCFfc291cmNlMykge1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHRlcnJhaW4uc291cmNlLCBcInNvdXJjZSBcXFwiXCIuY29uY2F0KHRlcnJhaW4uc291cmNlLCBcIlxcXCIgbm90IGZvdW5kXCIpKSk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VUeXBlICE9PSAncmFzdGVyLWRlbScpIHtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB0ZXJyYWluLnNvdXJjZSwgXCJ0ZXJyYWluIGNhbm5vdCBiZSB1c2VkIHdpdGggYSBzb3VyY2Ugb2YgdHlwZSBcIi5jb25jYXQoc291cmNlVHlwZSwgXCIsIGl0IG9ubHkgYmUgdXNlZCB3aXRoIGEgXFxcInJhc3Rlci1kZW1cXFwiIHNvdXJjZSB0eXBlXCIpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGb2cob3B0aW9ucykge1xuICB2YXIgZm9nID0gb3B0aW9ucy52YWx1ZTtcbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICB2YXIgZm9nU3BlYyA9IHN0eWxlU3BlYy5mb2c7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHJvb3RUeXBlID0gZ2V0VHlwZShmb2cpO1xuXG4gIGlmIChmb2cgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlcnJvcnM7XG4gIH0gZWxzZSBpZiAocm9vdFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChbbmV3IFZhbGlkYXRpb25FcnJvcignZm9nJywgZm9nLCBcIm9iamVjdCBleHBlY3RlZCwgXCIuY29uY2F0KHJvb3RUeXBlLCBcIiBmb3VuZFwiKSldKTtcbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIGZvZykge1xuICAgIHZhciB0cmFuc2l0aW9uTWF0Y2ggPSBrZXkubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG5cbiAgICBpZiAodHJhbnNpdGlvbk1hdGNoICYmIGZvZ1NwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXSAmJiBmb2dTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0udHJhbnNpdGlvbikge1xuICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogZm9nW2tleV0sXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnRyYW5zaXRpb24sXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgIH0pKTtcbiAgICB9IGVsc2UgaWYgKGZvZ1NwZWNba2V5XSkge1xuICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogZm9nW2tleV0sXG4gICAgICAgIHZhbHVlU3BlYzogZm9nU3BlY1trZXldLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBmb2dba2V5XSwgXCJ1bmtub3duIHByb3BlcnR5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCJcIikpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXR0ZWQob3B0aW9ucykge1xuICBpZiAodmFsaWRhdGVTdHJpbmcob3B0aW9ucykubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlRXhwcmVzc2lvbihvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVJbWFnZShvcHRpb25zKSB7XG4gIGlmICh2YWxpZGF0ZVN0cmluZyhvcHRpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVFeHByZXNzaW9uKG9wdGlvbnMpO1xufVxuXG52YXIgVkFMSURBVE9SUyA9IHtcbiAgJyonOiBmdW5jdGlvbiBfKCkge1xuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgJ2FycmF5JzogdmFsaWRhdGVBcnJheSxcbiAgJ2Jvb2xlYW4nOiB2YWxpZGF0ZUJvb2xlYW4sXG4gICdudW1iZXInOiB2YWxpZGF0ZU51bWJlcixcbiAgJ2NvbG9yJzogdmFsaWRhdGVDb2xvcixcbiAgJ2NvbnN0YW50cyc6IHZhbGlkYXRlQ29uc3RhbnRzLFxuICAnZW51bSc6IHZhbGlkYXRlRW51bSxcbiAgJ2ZpbHRlcic6IHZhbGlkYXRlRmlsdGVyLFxuICAnZnVuY3Rpb24nOiB2YWxpZGF0ZUZ1bmN0aW9uLFxuICAnbGF5ZXInOiB2YWxpZGF0ZUxheWVyLFxuICAnb2JqZWN0JzogdmFsaWRhdGVPYmplY3QsXG4gICdzb3VyY2UnOiB2YWxpZGF0ZVNvdXJjZSxcbiAgJ2xpZ2h0JzogdmFsaWRhdGVMaWdodCxcbiAgJ3RlcnJhaW4nOiB2YWxpZGF0ZVRlcnJhaW4sXG4gICdmb2cnOiB2YWxpZGF0ZUZvZyxcbiAgJ3N0cmluZyc6IHZhbGlkYXRlU3RyaW5nLFxuICAnZm9ybWF0dGVkJzogdmFsaWRhdGVGb3JtYXR0ZWQsXG4gICdyZXNvbHZlZEltYWdlJzogdmFsaWRhdGVJbWFnZVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGUob3B0aW9ucykge1xuICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcblxuICBpZiAodmFsdWVTcGVjLmV4cHJlc3Npb24gJiYgaXNGdW5jdGlvbiQxKHVuYnVuZGxlKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVGdW5jdGlvbihvcHRpb25zKTtcbiAgfSBlbHNlIGlmICh2YWx1ZVNwZWMuZXhwcmVzc2lvbiAmJiBpc0V4cHJlc3Npb24oZGVlcFVuYnVuZGxlKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVFeHByZXNzaW9uKG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHZhbHVlU3BlYy50eXBlICYmIFZBTElEQVRPUlNbdmFsdWVTcGVjLnR5cGVdKSB7XG4gICAgcmV0dXJuIFZBTElEQVRPUlNbdmFsdWVTcGVjLnR5cGVdKG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHZhciB2YWxpZCA9IHZhbGlkYXRlT2JqZWN0KGV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgdmFsdWVTcGVjOiB2YWx1ZVNwZWMudHlwZSA/IHN0eWxlU3BlY1t2YWx1ZVNwZWMudHlwZV0gOiB2YWx1ZVNwZWNcbiAgICB9KSk7XG4gICAgcmV0dXJuIHZhbGlkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlR2x5cGhzVVJMKG9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgZXJyb3JzID0gdmFsaWRhdGVTdHJpbmcob3B0aW9ucyk7XG4gIGlmIChlcnJvcnMubGVuZ3RoKSByZXR1cm4gZXJyb3JzO1xuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCd7Zm9udHN0YWNrfScpID09PSAtMSkge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1wiZ2x5cGhzXCIgdXJsIG11c3QgaW5jbHVkZSBhIFwie2ZvbnRzdGFja31cIiB0b2tlbicpKTtcbiAgfVxuXG4gIGlmICh2YWx1ZS5pbmRleE9mKCd7cmFuZ2V9JykgPT09IC0xKSB7XG4gICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCAnXCJnbHlwaHNcIiB1cmwgbXVzdCBpbmNsdWRlIGEgXCJ7cmFuZ2V9XCIgdG9rZW4nKSk7XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN0eWxlTWluKHN0eWxlKSB7XG4gIHZhciBzdHlsZVNwZWMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHY4O1xuICB2YXIgZXJyb3JzID0gW107XG4gIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgIGtleTogJycsXG4gICAgdmFsdWU6IHN0eWxlLFxuICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLiRyb290LFxuICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgZ2x5cGhzOiB2YWxpZGF0ZUdseXBoc1VSTCxcbiAgICAgICcqJzogZnVuY3Rpb24gXygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH1cbiAgfSkpO1xuXG4gIGlmIChzdHlsZS5jb25zdGFudHMpIHtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlQ29uc3RhbnRzKHtcbiAgICAgIGtleTogJ2NvbnN0YW50cycsXG4gICAgICB2YWx1ZTogc3R5bGUuY29uc3RhbnRzLFxuICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gc29ydEVycm9ycyhlcnJvcnMpO1xufVxuXG52YWxpZGF0ZVN0eWxlTWluLnNvdXJjZSA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZVNvdXJjZSk7XG52YWxpZGF0ZVN0eWxlTWluLmxpZ2h0ID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlTGlnaHQpO1xudmFsaWRhdGVTdHlsZU1pbi50ZXJyYWluID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlVGVycmFpbik7XG52YWxpZGF0ZVN0eWxlTWluLmZvZyA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZUZvZyk7XG52YWxpZGF0ZVN0eWxlTWluLmxheWVyID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlTGF5ZXIpO1xudmFsaWRhdGVTdHlsZU1pbi5maWx0ZXIgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVGaWx0ZXIpO1xudmFsaWRhdGVTdHlsZU1pbi5wYWludFByb3BlcnR5ID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlUGFpbnRQcm9wZXJ0eSk7XG52YWxpZGF0ZVN0eWxlTWluLmxheW91dFByb3BlcnR5ID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlTGF5b3V0UHJvcGVydHkpO1xuXG5mdW5jdGlvbiBzb3J0RXJyb3JzKGVycm9ycykge1xuICByZXR1cm4gW10uY29uY2F0KGVycm9ycykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLmxpbmUgLSBiLmxpbmU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cmFwQ2xlYW5FcnJvcnMoaW5uZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjQ7IF9rZXk3KyspIHtcbiAgICAgIGFyZ3NbX2tleTddID0gYXJndW1lbnRzW19rZXk3XTtcbiAgICB9XG5cbiAgICByZXR1cm4gc29ydEVycm9ycyhpbm5lci5hcHBseSh0aGlzLCBhcmdzKSk7XG4gIH07XG59XG4vKiBwYXJzZXIgZ2VuZXJhdGVkIGJ5IGppc29uIDAuNC4xNSAqL1xuXG5cbnZhciBqc29ubGludCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgLypcbiAgICBSZXR1cm5zIGEgUGFyc2VyIG9iamVjdCBvZiB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbiAgXG4gICAgUGFyc2VyOiB7XG4gICAgICB5eToge31cbiAgICB9XG4gIFxuICAgIFBhcnNlci5wcm90b3R5cGU6IHtcbiAgICAgIHl5OiB7fSxcbiAgICAgIHRyYWNlOiBmdW5jdGlvbigpLFxuICAgICAgc3ltYm9sc186IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBudW1iZXJ9LFxuICAgICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gICAgICBwcm9kdWN0aW9uc186IFsuLi5dLFxuICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUsICQkLCBfJCksXG4gICAgICB0YWJsZTogWy4uLl0sXG4gICAgICBkZWZhdWx0QWN0aW9uczogey4uLn0sXG4gICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0KSxcbiAgXG4gICAgICBsZXhlcjoge1xuICAgICAgICAgIEVPRjogMSxcbiAgICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbihzdHIsIGhhc2gpLFxuICAgICAgICAgIHNldElucHV0OiBmdW5jdGlvbihpbnB1dCksXG4gICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgICAgdW5wdXQ6IGZ1bmN0aW9uKHN0ciksXG4gICAgICAgICAgbW9yZTogZnVuY3Rpb24oKSxcbiAgICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAgICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24oKSxcbiAgICAgICAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uKCksXG4gICAgICAgICAgdGVzdF9tYXRjaDogZnVuY3Rpb24ocmVnZXhfbWF0Y2hfYXJyYXksIHJ1bGVfaW5kZXgpLFxuICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uKCksXG4gICAgICAgICAgbGV4OiBmdW5jdGlvbigpLFxuICAgICAgICAgIGJlZ2luOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICAgICAgICAgIHBvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksXG4gICAgICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbihjb25kaXRpb24pLFxuICBcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgIHJhbmdlczogYm9vbGVhbiAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiB0b2tlbiBsb2NhdGlvbiBpbmZvIHdpbGwgaW5jbHVkZSBhIC5yYW5nZVtdIG1lbWJlcilcbiAgICAgICAgICAgICAgZmxleDogYm9vbGVhbiAgICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IGZsZXgtbGlrZSBsZXhpbmcgYmVoYXZpb3VyIHdoZXJlIHRoZSBydWxlcyBhcmUgdGVzdGVkIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoKVxuICAgICAgICAgICAgICBiYWNrdHJhY2tfbGV4ZXI6IGJvb2xlYW4gIChvcHRpb25hbDogdHJ1ZSA9PT4gbGV4ZXIgcmVnZXhlcyBhcmUgdGVzdGVkIGluIG9yZGVyIGFuZCBmb3IgZWFjaCBtYXRjaGluZyByZWdleCB0aGUgYWN0aW9uIGNvZGUgaXMgaW52b2tlZDsgdGhlIGxleGVyIHRlcm1pbmF0ZXMgdGhlIHNjYW4gd2hlbiBhIHRva2VuIGlzIHJldHVybmVkIGJ5IHRoZSBhY3Rpb24gY29kZSlcbiAgICAgICAgICB9LFxuICBcbiAgICAgICAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbih5eSwgeXlfLCAkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLCBZWV9TVEFSVCksXG4gICAgICAgICAgcnVsZXM6IFsuLi5dLFxuICAgICAgICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICAgICAgfVxuICAgIH1cbiAgXG4gIFxuICAgIHRva2VuIGxvY2F0aW9uIGluZm8gKEAkLCBfJCwgZXRjLik6IHtcbiAgICAgIGZpcnN0X2xpbmU6IG4sXG4gICAgICBsYXN0X2xpbmU6IG4sXG4gICAgICBmaXJzdF9jb2x1bW46IG4sXG4gICAgICBsYXN0X2NvbHVtbjogbixcbiAgICAgIHJhbmdlOiBbc3RhcnRfbnVtYmVyLCBlbmRfbnVtYmVyXSAgICAgICAod2hlcmUgdGhlIG51bWJlcnMgYXJlIGluZGV4ZXMgaW50byB0aGUgaW5wdXQgc3RyaW5nLCByZWd1bGFyIHplcm8tYmFzZWQpXG4gICAgfVxuICBcbiAgXG4gICAgdGhlIHBhcnNlRXJyb3IgZnVuY3Rpb24gcmVjZWl2ZXMgYSAnaGFzaCcgb2JqZWN0IHdpdGggdGhlc2UgbWVtYmVycyBmb3IgbGV4ZXIgYW5kIHBhcnNlciBlcnJvcnM6IHtcbiAgICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICAgICAgdG9rZW46ICAgICAgICh0aGUgcHJvZHVjZWQgdGVybWluYWwgdG9rZW4sIGlmIGFueSlcbiAgICAgIGxpbmU6ICAgICAgICAoeXlsaW5lbm8pXG4gICAgfVxuICAgIHdoaWxlIHBhcnNlciAoZ3JhbW1hcikgZXJyb3JzIHdpbGwgYWxzbyBwcm92aWRlIHRoZXNlIG1lbWJlcnMsIGkuZS4gcGFyc2VyIGVycm9ycyBkZWxpdmVyIGEgc3VwZXJzZXQgb2YgYXR0cmlidXRlczoge1xuICAgICAgbG9jOiAgICAgICAgICh5eWxsb2MpXG4gICAgICBleHBlY3RlZDogICAgKHN0cmluZyBkZXNjcmliaW5nIHRoZSBzZXQgb2YgZXhwZWN0ZWQgdG9rZW5zKVxuICAgICAgcmVjb3ZlcmFibGU6IChib29sZWFuOiBUUlVFIHdoZW4gdGhlIHBhcnNlciBoYXMgYSBlcnJvciByZWNvdmVyeSBydWxlIGF2YWlsYWJsZSBmb3IgdGhpcyBwYXJ0aWN1bGFyIGVycm9yKVxuICAgIH1cbiAgKi9cbiAgdmFyIHBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbyA9IGZ1bmN0aW9uIG8oaywgdiwgX28sIGwpIHtcbiAgICAgIGZvciAoX28gPSBfbyB8fCB7fSwgbCA9IGsubGVuZ3RoOyBsLS07IF9vW2tbbF1dID0gdikge1xuICAgICAgICA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfbztcbiAgICB9LFxuICAgICAgICAkVjAgPSBbMSwgMTJdLFxuICAgICAgICAkVjEgPSBbMSwgMTNdLFxuICAgICAgICAkVjIgPSBbMSwgOV0sXG4gICAgICAgICRWMyA9IFsxLCAxMF0sXG4gICAgICAgICRWNCA9IFsxLCAxMV0sXG4gICAgICAgICRWNSA9IFsxLCAxNF0sXG4gICAgICAgICRWNiA9IFsxLCAxNV0sXG4gICAgICAgICRWNyA9IFsxNCwgMTgsIDIyLCAyNF0sXG4gICAgICAgICRWOCA9IFsxOCwgMjJdLFxuICAgICAgICAkVjkgPSBbMjIsIDI0XTtcblxuICAgIHZhciBwYXJzZXIgPSB7XG4gICAgICB0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7fSxcbiAgICAgIHl5OiB7fSxcbiAgICAgIHN5bWJvbHNfOiB7XG4gICAgICAgIFwiZXJyb3JcIjogMixcbiAgICAgICAgXCJKU09OU3RyaW5nXCI6IDMsXG4gICAgICAgIFwiU1RSSU5HXCI6IDQsXG4gICAgICAgIFwiSlNPTk51bWJlclwiOiA1LFxuICAgICAgICBcIk5VTUJFUlwiOiA2LFxuICAgICAgICBcIkpTT05OdWxsTGl0ZXJhbFwiOiA3LFxuICAgICAgICBcIk5VTExcIjogOCxcbiAgICAgICAgXCJKU09OQm9vbGVhbkxpdGVyYWxcIjogOSxcbiAgICAgICAgXCJUUlVFXCI6IDEwLFxuICAgICAgICBcIkZBTFNFXCI6IDExLFxuICAgICAgICBcIkpTT05UZXh0XCI6IDEyLFxuICAgICAgICBcIkpTT05WYWx1ZVwiOiAxMyxcbiAgICAgICAgXCJFT0ZcIjogMTQsXG4gICAgICAgIFwiSlNPTk9iamVjdFwiOiAxNSxcbiAgICAgICAgXCJKU09OQXJyYXlcIjogMTYsXG4gICAgICAgIFwie1wiOiAxNyxcbiAgICAgICAgXCJ9XCI6IDE4LFxuICAgICAgICBcIkpTT05NZW1iZXJMaXN0XCI6IDE5LFxuICAgICAgICBcIkpTT05NZW1iZXJcIjogMjAsXG4gICAgICAgIFwiOlwiOiAyMSxcbiAgICAgICAgXCIsXCI6IDIyLFxuICAgICAgICBcIltcIjogMjMsXG4gICAgICAgIFwiXVwiOiAyNCxcbiAgICAgICAgXCJKU09ORWxlbWVudExpc3RcIjogMjUsXG4gICAgICAgIFwiJGFjY2VwdFwiOiAwLFxuICAgICAgICBcIiRlbmRcIjogMVxuICAgICAgfSxcbiAgICAgIHRlcm1pbmFsc186IHtcbiAgICAgICAgMjogXCJlcnJvclwiLFxuICAgICAgICA0OiBcIlNUUklOR1wiLFxuICAgICAgICA2OiBcIk5VTUJFUlwiLFxuICAgICAgICA4OiBcIk5VTExcIixcbiAgICAgICAgMTA6IFwiVFJVRVwiLFxuICAgICAgICAxMTogXCJGQUxTRVwiLFxuICAgICAgICAxNDogXCJFT0ZcIixcbiAgICAgICAgMTc6IFwie1wiLFxuICAgICAgICAxODogXCJ9XCIsXG4gICAgICAgIDIxOiBcIjpcIixcbiAgICAgICAgMjI6IFwiLFwiLFxuICAgICAgICAyMzogXCJbXCIsXG4gICAgICAgIDI0OiBcIl1cIlxuICAgICAgfSxcbiAgICAgIHByb2R1Y3Rpb25zXzogWzAsIFszLCAxXSwgWzUsIDFdLCBbNywgMV0sIFs5LCAxXSwgWzksIDFdLCBbMTIsIDJdLCBbMTMsIDFdLCBbMTMsIDFdLCBbMTMsIDFdLCBbMTMsIDFdLCBbMTMsIDFdLCBbMTMsIDFdLCBbMTUsIDJdLCBbMTUsIDNdLCBbMjAsIDNdLCBbMTksIDFdLCBbMTksIDNdLCBbMTYsIDJdLCBbMTYsIDNdLCBbMjUsIDFdLCBbMjUsIDNdXSxcbiAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5LCB5eXN0YXRlXG4gICAgICAvKiBhY3Rpb25bMV0gKi9cbiAgICAgICwgJCRcbiAgICAgIC8qIHZzdGFjayAqL1xuICAgICAgLCBfJFxuICAgICAgLyogbHN0YWNrICovXG4gICAgICApIHtcbiAgICAgICAgLyogdGhpcyA9PSB5eXZhbCAqL1xuICAgICAgICB2YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xuXG4gICAgICAgIHN3aXRjaCAoeXlzdGF0ZSkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIC8vIHJlcGxhY2UgZXNjYXBlZCBjaGFyYWN0ZXJzIHdpdGggYWN0dWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgdGhpcy4kID0gbmV3IFN0cmluZyh5eXRleHQucmVwbGFjZSgvXFxcXChcXFxcfFwiKS9nLCBcIiRcIiArIFwiMVwiKS5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxcXHIvZywgJ1xccicpLnJlcGxhY2UoL1xcXFx0L2csICdcXHQnKS5yZXBsYWNlKC9cXFxcdi9nLCAnXFx2JykucmVwbGFjZSgvXFxcXGYvZywgJ1xcZicpLnJlcGxhY2UoL1xcXFxiL2csICdcXGInKSk7XG4gICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBOdW1iZXIoeXl0ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9IHRoaXMuXyQuZmlyc3RfbGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy4kID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGhpcy4kID0gbmV3IEJvb2xlYW4odHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBCb29sZWFuKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuJC5fX2xpbmVfXyA9IHRoaXMuXyQuZmlyc3RfbGluZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJCA9ICQkWyQwIC0gMV07XG5cbiAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgdGhpcy4kID0ge307XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl8kLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgdGhpcy4kID0gJCRbJDAgLSAxXTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLiQsICdfX2xpbmVfXycsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuXyQuZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgdGhpcy4kID0gWyQkWyQwIC0gMl0sICQkWyQwXV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICB0aGlzLiQgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuJFskJFskMF1bMF1dID0gJCRbJDBdWzFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgdGhpcy4kID0gJCRbJDAgLSAyXTtcbiAgICAgICAgICAgICQkWyQwIC0gMl1bJCRbJDBdWzBdXSA9ICQkWyQwXVsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgIHRoaXMuJCA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuJCwgJ19fbGluZV9fJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICB0aGlzLiQgPSBbJCRbJDBdXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwIC0gMl07XG4gICAgICAgICAgICAkJFskMCAtIDJdLnB1c2goJCRbJDBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGFibGU6IFt7XG4gICAgICAgIDM6IDUsXG4gICAgICAgIDQ6ICRWMCxcbiAgICAgICAgNTogNixcbiAgICAgICAgNjogJFYxLFxuICAgICAgICA3OiAzLFxuICAgICAgICA4OiAkVjIsXG4gICAgICAgIDk6IDQsXG4gICAgICAgIDEwOiAkVjMsXG4gICAgICAgIDExOiAkVjQsXG4gICAgICAgIDEyOiAxLFxuICAgICAgICAxMzogMixcbiAgICAgICAgMTU6IDcsXG4gICAgICAgIDE2OiA4LFxuICAgICAgICAxNzogJFY1LFxuICAgICAgICAyMzogJFY2XG4gICAgICB9LCB7XG4gICAgICAgIDE6IFszXVxuICAgICAgfSwge1xuICAgICAgICAxNDogWzEsIDE2XVxuICAgICAgfSwgbygkVjcsIFsyLCA3XSksIG8oJFY3LCBbMiwgOF0pLCBvKCRWNywgWzIsIDldKSwgbygkVjcsIFsyLCAxMF0pLCBvKCRWNywgWzIsIDExXSksIG8oJFY3LCBbMiwgMTJdKSwgbygkVjcsIFsyLCAzXSksIG8oJFY3LCBbMiwgNF0pLCBvKCRWNywgWzIsIDVdKSwgbyhbMTQsIDE4LCAyMSwgMjIsIDI0XSwgWzIsIDFdKSwgbygkVjcsIFsyLCAyXSksIHtcbiAgICAgICAgMzogMjAsXG4gICAgICAgIDQ6ICRWMCxcbiAgICAgICAgMTg6IFsxLCAxN10sXG4gICAgICAgIDE5OiAxOCxcbiAgICAgICAgMjA6IDE5XG4gICAgICB9LCB7XG4gICAgICAgIDM6IDUsXG4gICAgICAgIDQ6ICRWMCxcbiAgICAgICAgNTogNixcbiAgICAgICAgNjogJFYxLFxuICAgICAgICA3OiAzLFxuICAgICAgICA4OiAkVjIsXG4gICAgICAgIDk6IDQsXG4gICAgICAgIDEwOiAkVjMsXG4gICAgICAgIDExOiAkVjQsXG4gICAgICAgIDEzOiAyMyxcbiAgICAgICAgMTU6IDcsXG4gICAgICAgIDE2OiA4LFxuICAgICAgICAxNzogJFY1LFxuICAgICAgICAyMzogJFY2LFxuICAgICAgICAyNDogWzEsIDIxXSxcbiAgICAgICAgMjU6IDIyXG4gICAgICB9LCB7XG4gICAgICAgIDE6IFsyLCA2XVxuICAgICAgfSwgbygkVjcsIFsyLCAxM10pLCB7XG4gICAgICAgIDE4OiBbMSwgMjRdLFxuICAgICAgICAyMjogWzEsIDI1XVxuICAgICAgfSwgbygkVjgsIFsyLCAxNl0pLCB7XG4gICAgICAgIDIxOiBbMSwgMjZdXG4gICAgICB9LCBvKCRWNywgWzIsIDE4XSksIHtcbiAgICAgICAgMjI6IFsxLCAyOF0sXG4gICAgICAgIDI0OiBbMSwgMjddXG4gICAgICB9LCBvKCRWOSwgWzIsIDIwXSksIG8oJFY3LCBbMiwgMTRdKSwge1xuICAgICAgICAzOiAyMCxcbiAgICAgICAgNDogJFYwLFxuICAgICAgICAyMDogMjlcbiAgICAgIH0sIHtcbiAgICAgICAgMzogNSxcbiAgICAgICAgNDogJFYwLFxuICAgICAgICA1OiA2LFxuICAgICAgICA2OiAkVjEsXG4gICAgICAgIDc6IDMsXG4gICAgICAgIDg6ICRWMixcbiAgICAgICAgOTogNCxcbiAgICAgICAgMTA6ICRWMyxcbiAgICAgICAgMTE6ICRWNCxcbiAgICAgICAgMTM6IDMwLFxuICAgICAgICAxNTogNyxcbiAgICAgICAgMTY6IDgsXG4gICAgICAgIDE3OiAkVjUsXG4gICAgICAgIDIzOiAkVjZcbiAgICAgIH0sIG8oJFY3LCBbMiwgMTldKSwge1xuICAgICAgICAzOiA1LFxuICAgICAgICA0OiAkVjAsXG4gICAgICAgIDU6IDYsXG4gICAgICAgIDY6ICRWMSxcbiAgICAgICAgNzogMyxcbiAgICAgICAgODogJFYyLFxuICAgICAgICA5OiA0LFxuICAgICAgICAxMDogJFYzLFxuICAgICAgICAxMTogJFY0LFxuICAgICAgICAxMzogMzEsXG4gICAgICAgIDE1OiA3LFxuICAgICAgICAxNjogOCxcbiAgICAgICAgMTc6ICRWNSxcbiAgICAgICAgMjM6ICRWNlxuICAgICAgfSwgbygkVjgsIFsyLCAxN10pLCBvKCRWOCwgWzIsIDE1XSksIG8oJFY5LCBbMiwgMjFdKV0sXG4gICAgICBkZWZhdWx0QWN0aW9uczoge1xuICAgICAgICAxNjogWzIsIDZdXG4gICAgICB9LFxuICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24gcGFyc2VFcnJvcihzdHIsIGhhc2gpIHtcbiAgICAgICAgaWYgKGhhc2gucmVjb3ZlcmFibGUpIHtcbiAgICAgICAgICB0aGlzLnRyYWNlKHN0cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgc3RhY2sgPSBbMF0sXG4gICAgICAgICAgICB2c3RhY2sgPSBbbnVsbF0sXG4gICAgICAgICAgICBsc3RhY2sgPSBbXSxcbiAgICAgICAgICAgIHRhYmxlID0gdGhpcy50YWJsZSxcbiAgICAgICAgICAgIHl5dGV4dCA9ICcnLFxuICAgICAgICAgICAgeXlsaW5lbm8gPSAwLFxuICAgICAgICAgICAgeXlsZW5nID0gMCxcbiAgICAgICAgICAgIFRFUlJPUiA9IDIsXG4gICAgICAgICAgICBFT0YgPSAxO1xuICAgICAgICB2YXIgYXJncyA9IGxzdGFjay5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHZhciBsZXhlciA9IE9iamVjdC5jcmVhdGUodGhpcy5sZXhlcik7XG4gICAgICAgIHZhciBzaGFyZWRTdGF0ZSA9IHtcbiAgICAgICAgICB5eToge31cbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMueXkpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMueXksIGspKSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZS55eVtrXSA9IHRoaXMueXlba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTtcbiAgICAgICAgc2hhcmVkU3RhdGUueXkubGV4ZXIgPSBsZXhlcjtcbiAgICAgICAgc2hhcmVkU3RhdGUueXkucGFyc2VyID0gdGhpcztcblxuICAgICAgICBpZiAodHlwZW9mIGxleGVyLnl5bGxvYyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGxleGVyLnl5bGxvYyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgICAgICBsc3RhY2sucHVzaCh5eWxvYyk7XG4gICAgICAgIHZhciByYW5nZXMgPSBsZXhlci5vcHRpb25zICYmIGxleGVyLm9wdGlvbnMucmFuZ2VzO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICAgIHRva2VuID0gbGV4ZXIubGV4KCkgfHwgRU9GO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRva2VuID0gc2VsZi5zeW1ib2xzX1t0b2tlbl0gfHwgdG9rZW47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN5bWJvbCxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIHl5dmFsID0ge30sXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgbGVuLFxuICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICBleHBlY3RlZDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV0pIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3ltYm9sID09PSBudWxsIHx8IHR5cGVvZiBzeW1ib2wgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFjdGlvbiA9IHRhYmxlW3N0YXRlXSAmJiB0YWJsZVtzdGF0ZV1bc3ltYm9sXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3VuZGVmaW5lZCcgfHwgIWFjdGlvbi5sZW5ndGggfHwgIWFjdGlvblswXSkge1xuICAgICAgICAgICAgdmFyIGVyclN0ciA9ICcnO1xuICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy50ZXJtaW5hbHNfW3BdICYmIHAgPiBURVJST1IpIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZC5wdXNoKCdcXCcnICsgdGhpcy50ZXJtaW5hbHNfW3BdICsgJ1xcJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZXhlci5zaG93UG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzpcXG4nICsgbGV4ZXIuc2hvd1Bvc2l0aW9uKCkgKyAnXFxuRXhwZWN0aW5nICcgKyBleHBlY3RlZC5qb2luKCcsICcpICsgJywgZ290IFxcJycgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArICdcXCcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzogVW5leHBlY3RlZCAnICsgKHN5bWJvbCA9PSBFT0YgPyAnZW5kIG9mIGlucHV0JyA6ICdcXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXFwnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGFyc2VFcnJvcihlcnJTdHIsIHtcbiAgICAgICAgICAgICAgdGV4dDogbGV4ZXIubWF0Y2gsXG4gICAgICAgICAgICAgIHRva2VuOiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wsXG4gICAgICAgICAgICAgIGxpbmU6IGxleGVyLnl5bGluZW5vLFxuICAgICAgICAgICAgICBsb2M6IHl5bG9jLFxuICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhY3Rpb25bMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBhY3Rpb24ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZSBFcnJvcjogbXVsdGlwbGUgYWN0aW9ucyBwb3NzaWJsZSBhdCBzdGF0ZTogJyArIHN0YXRlICsgJywgdG9rZW46ICcgKyBzeW1ib2wpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAoYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgdnN0YWNrLnB1c2gobGV4ZXIueXl0ZXh0KTtcbiAgICAgICAgICAgICAgbHN0YWNrLnB1c2gobGV4ZXIueXlsbG9jKTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChhY3Rpb25bMV0pO1xuICAgICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeXlsZW5nID0gbGV4ZXIueXlsZW5nO1xuICAgICAgICAgICAgICAgIHl5dGV4dCA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgICAgICAgICB5eWxpbmVubyA9IGxleGVyLnl5bGluZW5vO1xuICAgICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGxlbiA9IHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMV07XG4gICAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aCAtIGxlbl07XG4gICAgICAgICAgICAgIHl5dmFsLl8kID0ge1xuICAgICAgICAgICAgICAgIGZpcnN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ubGFzdF9jb2x1bW5cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBpZiAocmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgeXl2YWwuXyQucmFuZ2UgPSBbbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5yYW5nZVswXSwgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5yYW5nZVsxXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmFwcGx5KHl5dmFsLCBbeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCBzaGFyZWRTdGF0ZS55eSwgYWN0aW9uWzFdLCB2c3RhY2ssIGxzdGFja10uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgwLCAtMSAqIGxlbiAqIDIpO1xuICAgICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICAgICAgbHN0YWNrID0gbHN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7XG4gICAgICAgICAgICAgIHZzdGFjay5wdXNoKHl5dmFsLiQpO1xuICAgICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1dW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgLyogZ2VuZXJhdGVkIGJ5IGppc29uLWxleCAwLjMuNCAqL1xuXG4gICAgdmFyIGxleGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxleGVyID0ge1xuICAgICAgICBFT0Y6IDEsXG4gICAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgICAgICAgaWYgKHRoaXMueXkucGFyc2VyKSB7XG4gICAgICAgICAgICB0aGlzLnl5LnBhcnNlci5wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gcmVzZXRzIHRoZSBsZXhlciwgc2V0cyBuZXcgaW5wdXRcbiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uIHNldElucHV0KGlucHV0LCB5eSkge1xuICAgICAgICAgIHRoaXMueXkgPSB5eSB8fCB0aGlzLnl5IHx8IHt9O1xuICAgICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2JhY2t0cmFjayA9IHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMueXlsaW5lbm8gPSB0aGlzLnl5bGVuZyA9IDA7XG4gICAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xuICAgICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogMCxcbiAgICAgICAgICAgIGxhc3RfbGluZTogMSxcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiAwXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFswLCAwXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0XG4gICAgICAgIGlucHV0OiBmdW5jdGlvbiBpbnB1dCgpIHtcbiAgICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICAgICAgICB0aGlzLnl5bGVuZysrO1xuICAgICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgdGhpcy5tYXRjaCArPSBjaDtcbiAgICAgICAgICB0aGlzLm1hdGNoZWQgKz0gY2g7XG4gICAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuXG4gICAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vKys7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2xpbmUrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2VbMV0rKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKDEpO1xuICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdW5zaGlmdHMgb25lIGNoYXIgKG9yIGEgc3RyaW5nKSBpbnRvIHRoZSBpbnB1dFxuICAgICAgICB1bnB1dDogZnVuY3Rpb24gdW5wdXQoY2gpIHtcbiAgICAgICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgICAgIHZhciBsaW5lcyA9IGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgICAgdGhpcy5faW5wdXQgPSBjaCArIHRoaXMuX2lucHV0O1xuICAgICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbik7IC8vdGhpcy55eWxlbmcgLT0gbGVuO1xuXG4gICAgICAgICAgdGhpcy5vZmZzZXQgLT0gbGVuO1xuICAgICAgICAgIHZhciBvbGRMaW5lcyA9IHRoaXMubWF0Y2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSAxKTtcblxuICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHIgPSB0aGlzLnl5bGxvYy5yYW5nZTtcbiAgICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgPyAobGluZXMubGVuZ3RoID09PSBvbGRMaW5lcy5sZW5ndGggPyB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gOiAwKSArIG9sZExpbmVzW29sZExpbmVzLmxlbmd0aCAtIGxpbmVzLmxlbmd0aF0ubGVuZ3RoIC0gbGluZXNbMF0ubGVuZ3RoIDogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIC0gbGVuXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgY2FjaGVzIG1hdGNoZWQgdGV4dCBhbmQgYXBwZW5kcyBpdCBvbiBuZXh0IGFjdGlvblxuICAgICAgICBtb3JlOiBmdW5jdGlvbiBtb3JlKCkge1xuICAgICAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgc2lnbmFscyB0aGUgbGV4ZXIgdGhhdCB0aGlzIHJ1bGUgZmFpbHMgdG8gbWF0Y2ggdGhlIGlucHV0LCBzbyB0aGUgbmV4dCBtYXRjaGluZyBydWxlIChyZWdleCkgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxuICAgICAgICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gWW91IGNhbiBvbmx5IGludm9rZSByZWplY3QoKSBpbiB0aGUgbGV4ZXIgd2hlbiB0aGUgbGV4ZXIgaXMgb2YgdGhlIGJhY2t0cmFja2luZyBwZXJzdWFzaW9uIChvcHRpb25zLmJhY2t0cmFja19sZXhlciA9IHRydWUpLlxcbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbiAgICAgICAgbGVzczogZnVuY3Rpb24gbGVzcyhuKSB7XG4gICAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZGlzcGxheXMgYWxyZWFkeSBtYXRjaGVkIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuICAgICAgICBwYXN0SW5wdXQ6IGZ1bmN0aW9uIHBhc3RJbnB1dCgpIHtcbiAgICAgICAgICB2YXIgcGFzdCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIHRoaXMubWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gKHBhc3QubGVuZ3RoID4gMjAgPyAnLi4uJyA6ICcnKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBkaXNwbGF5cyB1cGNvbWluZyBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgdXBjb21pbmdJbnB1dDogZnVuY3Rpb24gdXBjb21pbmdJbnB1dCgpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMubWF0Y2g7XG5cbiAgICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAgLSBuZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIChuZXh0LnN1YnN0cigwLCAyMCkgKyAobmV4dC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGRpc3BsYXlzIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gd2hlcmUgdGhlIGxleGluZyBlcnJvciBvY2N1cnJlZCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbiBzaG93UG9zaXRpb24oKSB7XG4gICAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgICAgdmFyIGMgPSBuZXcgQXJyYXkocHJlLmxlbmd0aCArIDEpLmpvaW4oXCItXCIpO1xuICAgICAgICAgIHJldHVybiBwcmUgKyB0aGlzLnVwY29taW5nSW5wdXQoKSArIFwiXFxuXCIgKyBjICsgXCJeXCI7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHRlc3QgdGhlIGxleGVkIHRva2VuOiByZXR1cm4gRkFMU0Ugd2hlbiBub3QgYSBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiB0b2tlblxuICAgICAgICB0ZXN0X21hdGNoOiBmdW5jdGlvbiB0ZXN0X21hdGNoKG1hdGNoLCBpbmRleGVkX3J1bGUpIHtcbiAgICAgICAgICB2YXIgdG9rZW4sIGxpbmVzLCBiYWNrdXA7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgLy8gc2F2ZSBjb250ZXh0XG4gICAgICAgICAgICBiYWNrdXAgPSB7XG4gICAgICAgICAgICAgIHl5bGluZW5vOiB0aGlzLnl5bGluZW5vLFxuICAgICAgICAgICAgICB5eWxsb2M6IHtcbiAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHl5dGV4dDogdGhpcy55eXRleHQsXG4gICAgICAgICAgICAgIG1hdGNoOiB0aGlzLm1hdGNoLFxuICAgICAgICAgICAgICBtYXRjaGVzOiB0aGlzLm1hdGNoZXMsXG4gICAgICAgICAgICAgIG1hdGNoZWQ6IHRoaXMubWF0Y2hlZCxcbiAgICAgICAgICAgICAgeXlsZW5nOiB0aGlzLnl5bGVuZyxcbiAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgX21vcmU6IHRoaXMuX21vcmUsXG4gICAgICAgICAgICAgIF9pbnB1dDogdGhpcy5faW5wdXQsXG4gICAgICAgICAgICAgIHl5OiB0aGlzLnl5LFxuICAgICAgICAgICAgICBjb25kaXRpb25TdGFjazogdGhpcy5jb25kaXRpb25TdGFjay5zbGljZSgwKSxcbiAgICAgICAgICAgICAgZG9uZTogdGhpcy5kb25lXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgICBiYWNrdXAueXlsbG9jLnJhbmdlID0gdGhpcy55eWxsb2MucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG5cbiAgICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MubGFzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgPyBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggLSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5tYXRjaCgvXFxyP1xcbj8vKVswXS5sZW5ndGggOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy55eXRleHQgKz0gbWF0Y2hbMF07XG4gICAgICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaFswXTtcbiAgICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKz0gdGhpcy55eWxlbmddO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoWzBdO1xuICAgICAgICAgIHRva2VuID0gdGhpcy5wZXJmb3JtQWN0aW9uLmNhbGwodGhpcywgdGhpcy55eSwgdGhpcywgaW5kZXhlZF9ydWxlLCB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZG9uZSAmJiB0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgIC8vIHJlY292ZXIgY29udGV4dFxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBiYWNrdXApIHtcbiAgICAgICAgICAgICAgdGhpc1trXSA9IGJhY2t1cFtrXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBydWxlIGFjdGlvbiBjYWxsZWQgcmVqZWN0KCkgaW1wbHlpbmcgdGhlIG5leHQgcnVsZSBzaG91bGQgYmUgdGVzdGVkIGluc3RlYWQuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICAvLyByZXR1cm4gbmV4dCBtYXRjaCBpbiBpbnB1dFxuICAgICAgICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0b2tlbiwgbWF0Y2gsIHRlbXBNYXRjaCwgaW5kZXg7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX21vcmUpIHtcbiAgICAgICAgICAgIHRoaXMueXl0ZXh0ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5fY3VycmVudFJ1bGVzKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wTWF0Y2ggPSB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLnJ1bGVzW3J1bGVzW2ldXSk7XG5cbiAgICAgICAgICAgIGlmICh0ZW1wTWF0Y2ggJiYgKCFtYXRjaCB8fCB0ZW1wTWF0Y2hbMF0ubGVuZ3RoID4gbWF0Y2hbMF0ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICBtYXRjaCA9IHRlbXBNYXRjaDtcbiAgICAgICAgICAgICAgaW5kZXggPSBpO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2godGVtcE1hdGNoLCBydWxlc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIGEgcnVsZSBNSVNtYXRjaC5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5vcHRpb25zLmZsZXgpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2gobWF0Y2gsIHJ1bGVzW2luZGV4XSk7XG5cbiAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgfSAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG5cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLl9pbnB1dCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuRU9GO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBVbnJlY29nbml6ZWQgdGV4dC5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyByZXR1cm4gbmV4dCBtYXRjaCB0aGF0IGhhcyBhIHRva2VuXG4gICAgICAgIGxleDogZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICAgIHZhciByID0gdGhpcy5uZXh0KCk7XG5cbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gYWN0aXZhdGVzIGEgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSAocHVzaGVzIHRoZSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9udG8gdGhlIGNvbmRpdGlvbiBzdGFjaylcbiAgICAgICAgYmVnaW46IGZ1bmN0aW9uIGJlZ2luKGNvbmRpdGlvbikge1xuICAgICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sucHVzaChjb25kaXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICAvLyBwb3AgdGhlIHByZXZpb3VzbHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvZmYgdGhlIGNvbmRpdGlvbiBzdGFja1xuICAgICAgICBwb3BTdGF0ZTogZnVuY3Rpb24gcG9wU3RhdGUoKSB7XG4gICAgICAgICAgdmFyIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1swXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHByb2R1Y2UgdGhlIGxleGVyIHJ1bGUgc2V0IHdoaWNoIGlzIGFjdGl2ZSBmb3IgdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlXG4gICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uIF9jdXJyZW50UnVsZXMoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoICYmIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dLnJ1bGVzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW1wiSU5JVElBTFwiXS5ydWxlcztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJldHVybiB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGU7IHdoZW4gYW4gaW5kZXggYXJndW1lbnQgaXMgcHJvdmlkZWQgaXQgcHJvZHVjZXMgdGhlIE4tdGggcHJldmlvdXMgY29uZGl0aW9uIHN0YXRlLCBpZiBhdmFpbGFibGVcbiAgICAgICAgdG9wU3RhdGU6IGZ1bmN0aW9uIHRvcFN0YXRlKG4pIHtcbiAgICAgICAgICBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxIC0gTWF0aC5hYnMobiB8fCAwKTtcblxuICAgICAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW25dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJJTklUSUFMXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBhbGlhcyBmb3IgYmVnaW4oY29uZGl0aW9uKVxuICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uIHB1c2hTdGF0ZShjb25kaXRpb24pIHtcbiAgICAgICAgICB0aGlzLmJlZ2luKGNvbmRpdGlvbik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJldHVybiB0aGUgbnVtYmVyIG9mIHN0YXRlcyBjdXJyZW50bHkgb24gdGhlIHN0YWNrXG4gICAgICAgIHN0YXRlU3RhY2tTaXplOiBmdW5jdGlvbiBzdGF0ZVN0YWNrU2l6ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnM6IHt9LFxuICAgICAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpIHtcbiAgICAgICAgICBzd2l0Y2ggKCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgLyogc2tpcCB3aGl0ZXNwYWNlICovXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJldHVybiA2O1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHl5Xy55eXRleHQgPSB5eV8ueXl0ZXh0LnN1YnN0cigxLCB5eV8ueXlsZW5nIC0gMik7XG4gICAgICAgICAgICAgIHJldHVybiA0O1xuXG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJldHVybiAxNztcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICByZXR1cm4gMTg7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgcmV0dXJuIDIzO1xuXG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHJldHVybiAyNDtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICByZXR1cm4gMjI7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIDIxO1xuXG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIHJldHVybiAxMDtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgcmV0dXJuIDExO1xuXG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICByZXR1cm4gODtcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgcmV0dXJuIDE0O1xuXG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICByZXR1cm4gJ0lOVkFMSUQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcnVsZXM6IFsvXig/OlxccyspLywgL14oPzooLT8oWzAtOV18WzEtOV1bMC05XSspKShcXC5bMC05XSspPyhbZUVdWy0rXT9bMC05XSspP1xcYikvLCAvXig/OlwiKD86XFxcXFtcXFxcXCJiZm5ydC9dfFxcXFx1W2EtZkEtRjAtOV17NH18W15cXFxcXFwwLVxceDA5XFx4MGEtXFx4MWZcIl0pKlwiKS8sIC9eKD86XFx7KS8sIC9eKD86XFx9KS8sIC9eKD86XFxbKS8sIC9eKD86XFxdKS8sIC9eKD86LCkvLCAvXig/OjopLywgL14oPzp0cnVlXFxiKS8sIC9eKD86ZmFsc2VcXGIpLywgL14oPzpudWxsXFxiKS8sIC9eKD86JCkvLCAvXig/Oi4pL10sXG4gICAgICAgIGNvbmRpdGlvbnM6IHtcbiAgICAgICAgICBcIklOSVRJQUxcIjoge1xuICAgICAgICAgICAgXCJydWxlc1wiOiBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTNdLFxuICAgICAgICAgICAgXCJpbmNsdXNpdmVcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBsZXhlcjtcbiAgICB9KCk7XG5cbiAgICBwYXJzZXIubGV4ZXIgPSBsZXhlcjtcblxuICAgIGZ1bmN0aW9uIFBhcnNlcigpIHtcbiAgICAgIHRoaXMueXkgPSB7fTtcbiAgICB9XG5cbiAgICBQYXJzZXIucHJvdG90eXBlID0gcGFyc2VyO1xuICAgIHBhcnNlci5QYXJzZXIgPSBQYXJzZXI7XG4gICAgcmV0dXJuIG5ldyBQYXJzZXIoKTtcbiAgfSgpO1xuXG4gIGlmICh0eXBlb2YgY29tbW9uanNSZXF1aXJlICE9PSAndW5kZWZpbmVkJyAmJiAnb2JqZWN0JyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnBhcnNlciA9IHBhcnNlcjtcbiAgICBleHBvcnRzLlBhcnNlciA9IHBhcnNlci5QYXJzZXI7XG5cbiAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZS5hcHBseShwYXJzZXIsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHJlYWRTdHlsZShzdHlsZSkge1xuICBpZiAoc3R5bGUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyB8fCBzdHlsZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ganNvbmxpbnQucGFyc2Uoc3R5bGUudG9TdHJpbmcoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNpbmdFcnJvciQxKGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdHlsZShzdHlsZSkge1xuICB2YXIgc3R5bGVTcGVjID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB2ODtcbiAgdmFyIHMgPSBzdHlsZTtcblxuICB0cnkge1xuICAgIHMgPSByZWFkU3R5bGUocyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gW2VdO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlU3R5bGVNaW4ocywgc3R5bGVTcGVjKTtcbn1cblxudmFyIFNVUFBPUlRFRF9TUEVDX1ZFUlNJT04gPSA4O1xudmFyIE1BWF9TT1VSQ0VTX0lOX1NUWUxFID0gMTU7XG5cbmZ1bmN0aW9uIGlzVmFsaWQodmFsdWUsIHJlZ2V4KSB7XG4gIGlmICghdmFsdWUgfHwgZ2V0VHlwZSh2YWx1ZSkgIT09ICdzdHJpbmcnKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuICEhdmFsdWUubWF0Y2gocmVnZXgpO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VDb3VudChzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZS51cmwpIHtcbiAgICByZXR1cm4gc291cmNlLnVybC5zcGxpdCgnLCcpLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbGxvd2VkS2V5RXJyb3JzKG9iaiwga2V5cywgcGF0aCkge1xuICB2YXIgYWxsb3dlZCA9IG5ldyBTZXQoa2V5cyk7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKCFhbGxvd2VkLmhhcyhrKSkge1xuICAgICAgdmFyIHByb3AgPSBwYXRoID8gXCJcIi5jb25jYXQocGF0aCwgXCIuXCIpLmNvbmNhdChrKSA6IG51bGw7XG4gICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKHByb3AsIG9ialtrXSwgXCJVbnN1cHBvcnRlZCBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGssIFwiXFxcIlwiKSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBlcnJvcnM7XG59XG5cbnZhciBhY2NlcHRlZFNvdXJjZVR5cGVzID0gbmV3IFNldChbJ3ZlY3RvcicsICdyYXN0ZXInLCAncmFzdGVyLWRlbSddKTtcblxuZnVuY3Rpb24gZ2V0U291cmNlRXJyb3JzKHNvdXJjZSwgaSkge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBzb3VyY2VLZXlzID0gWyd0eXBlJywgJ3VybCcsICd0aWxlU2l6ZSddO1xuICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIF90b0NvbnN1bWFibGVBcnJheShnZXRBbGxvd2VkS2V5RXJyb3JzKHNvdXJjZSwgc291cmNlS2V5cywgJ3NvdXJjZScpKSk7XG5cbiAgaWYgKCFhY2NlcHRlZFNvdXJjZVR5cGVzLmhhcyhTdHJpbmcoc291cmNlLnR5cGUpKSkge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJzb3VyY2VzW1wiLmNvbmNhdChpLCBcIl0udHlwZVwiKSwgc291cmNlLnR5cGUsIFwiRXhwZWN0ZWQgb25lIG9mIFtcIi5jb25jYXQoQXJyYXkuZnJvbShhY2NlcHRlZFNvdXJjZVR5cGVzKS5qb2luKCcsICcpLCBcIl1cIikpKTtcbiAgfVxuXG4gIHZhciBzb3VyY2VVcmxQYXR0ZXJuID0gL15tYXBib3g6XFwvXFwvKFteL10qKSQvO1xuXG4gIGlmICghc291cmNlLnVybCB8fCAhaXNWYWxpZChzb3VyY2UudXJsLCBzb3VyY2VVcmxQYXR0ZXJuKSkge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJzb3VyY2VzW1wiLmNvbmNhdChpLCBcIl0udXJsXCIpLCBzb3VyY2UudXJsLCAnRXhwZWN0ZWQgYSB2YWxpZCBNYXBib3ggdGlsZXNldCB1cmwnKSk7XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VzRXJyb3JzKHNvdXJjZXMpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgY291bnQgPSAwO1xuICBPYmplY3Qua2V5cyhzb3VyY2VzKS5mb3JFYWNoKGZ1bmN0aW9uIChzLCBpKSB7XG4gICAgdmFyIHNvdXJjZUVycm9ycyA9IGdldFNvdXJjZUVycm9ycyhzb3VyY2VzW3NdLCBpKTtcblxuICAgIGlmICghc291cmNlRXJyb3JzLmxlbmd0aCkge1xuICAgICAgY291bnQgPSBjb3VudCArIGdldFNvdXJjZUNvdW50KHNvdXJjZXNbc10pO1xuICAgIH1cblxuICAgIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgX3RvQ29uc3VtYWJsZUFycmF5KHNvdXJjZUVycm9ycykpO1xuICB9KTtcblxuICBpZiAoY291bnQgPiBNQVhfU09VUkNFU19JTl9TVFlMRSkge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3NvdXJjZXMnLCBudWxsLCBcIlN0eWxlcyBtdXN0IGNvbnRhaW4gXCIuY29uY2F0KE1BWF9TT1VSQ0VTX0lOX1NUWUxFLCBcIiBvciBmZXdlciBzb3VyY2VzXCIpKSk7XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiBnZXRSb290RXJyb3JzKHN0eWxlLCBzcGVjS2V5cykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBvcHRpb25hbFJvb3RQcm9wZXJ0aWVzID0gWydvd25lcicsICdpZCcsICdjYWNoZUNvbnRyb2wnLCAnZHJhZnQnLCAnY3JlYXRlZCcsICdtb2RpZmllZCcsICd2aXNpYmlsaXR5J107XG4gIHZhciBhbGxvd2VkS2V5RXJyb3JzID0gZ2V0QWxsb3dlZEtleUVycm9ycyhzdHlsZSwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShzcGVjS2V5cyksIG9wdGlvbmFsUm9vdFByb3BlcnRpZXMpKTtcbiAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBfdG9Db25zdW1hYmxlQXJyYXkoYWxsb3dlZEtleUVycm9ycykpO1xuXG4gIGlmIChzdHlsZS52ZXJzaW9uID4gU1VQUE9SVEVEX1NQRUNfVkVSU0lPTiB8fCBzdHlsZS52ZXJzaW9uIDwgU1VQUE9SVEVEX1NQRUNfVkVSU0lPTikge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3ZlcnNpb24nLCBzdHlsZS52ZXJzaW9uLCBcIlN0eWxlIHZlcnNpb24gbXVzdCBiZSBcIi5jb25jYXQoU1VQUE9SVEVEX1NQRUNfVkVSU0lPTikpKTtcbiAgfVxuXG4gIHZhciBnbHlwaFVybFBhdHRlcm4gPSAvXm1hcGJveDpcXC9cXC9mb250c1xcLyhbXi9dKilcXC97Zm9udHN0YWNrfVxcL3tyYW5nZX0ucGJmJC87XG5cbiAgaWYgKCFpc1ZhbGlkKHN0eWxlLmdseXBocywgZ2x5cGhVcmxQYXR0ZXJuKSkge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ2dseXBocycsIHN0eWxlLmdseXBocywgJ1N0eWxlcyBtdXN0IHJlZmVyZW5jZSBnbHlwaHMgaG9zdGVkIGJ5IE1hcGJveCcpKTtcbiAgfVxuXG4gIHZhciBzcHJpdGVVcmxQYXR0ZXJuID0gL15tYXBib3g6XFwvXFwvc3ByaXRlc1xcLyhbXi9dKilcXC8oW14vXSopXFwvPyhbXi9dKik/JC87XG5cbiAgaWYgKCFpc1ZhbGlkKHN0eWxlLnNwcml0ZSwgc3ByaXRlVXJsUGF0dGVybikpIHtcbiAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKCdzcHJpdGUnLCBzdHlsZS5zcHJpdGUsICdTdHlsZXMgbXVzdCByZWZlcmVuY2Ugc3ByaXRlcyBob3N0ZWQgYnkgTWFwYm94JykpO1xuICB9XG5cbiAgdmFyIHZpc2liaWxpdHlQYXR0ZXJuID0gL14ocHVibGljfHByaXZhdGUpJC87XG5cbiAgaWYgKCFpc1ZhbGlkKHN0eWxlLnZpc2liaWxpdHksIHZpc2liaWxpdHlQYXR0ZXJuKSkge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3Zpc2liaWxpdHknLCBzdHlsZS52aXNpYmlsaXR5LCAnU3R5bGUgdmlzaWJpbGl0eSBtdXN0IGJlIHB1YmxpYyBvciBwcml2YXRlJykpO1xuICB9XG5cbiAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNYXBib3hBcGlTdXBwb3J0ZWQoc3R5bGUpIHtcbiAgdmFyIHMgPSBzdHlsZTtcblxuICB0cnkge1xuICAgIHMgPSByZWFkU3R5bGUocyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gW2VdO1xuICB9XG5cbiAgdmFyIGVycm9ycyA9IHZhbGlkYXRlU3R5bGVNaW4ocywgdjgpLmNvbmNhdChnZXRSb290RXJyb3JzKHMsIE9iamVjdC5rZXlzKHY4LiRyb290KSkpO1xuXG4gIGlmIChzLnNvdXJjZXMpIHtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGdldFNvdXJjZXNFcnJvcnMocy5zb3VyY2VzKSk7XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuXG52YXIgZXhwcmVzc2lvbiQxID0ge1xuICBTdHlsZUV4cHJlc3Npb246IFN0eWxlRXhwcmVzc2lvbixcbiAgaXNFeHByZXNzaW9uOiBpc0V4cHJlc3Npb24sXG4gIGlzRXhwcmVzc2lvbkZpbHRlcjogaXNFeHByZXNzaW9uRmlsdGVyLFxuICBjcmVhdGVFeHByZXNzaW9uOiBjcmVhdGVFeHByZXNzaW9uLFxuICBjcmVhdGVQcm9wZXJ0eUV4cHJlc3Npb246IGNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbixcbiAgbm9ybWFsaXplUHJvcGVydHlFeHByZXNzaW9uOiBub3JtYWxpemVQcm9wZXJ0eUV4cHJlc3Npb24sXG4gIFpvb21Db25zdGFudEV4cHJlc3Npb246IFpvb21Db25zdGFudEV4cHJlc3Npb24sXG4gIFpvb21EZXBlbmRlbnRFeHByZXNzaW9uOiBab29tRGVwZW5kZW50RXhwcmVzc2lvbixcbiAgU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uOiBTdHlsZVByb3BlcnR5RnVuY3Rpb25cbn07XG52YXIgc3R5bGVGdW5jdGlvbiA9IHtcbiAgY29udmVydEZ1bmN0aW9uOiBjb252ZXJ0RnVuY3Rpb24sXG4gIGNyZWF0ZUZ1bmN0aW9uOiBjcmVhdGVGdW5jdGlvbixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbiQxXG59O1xudmFyIHZpc2l0ID0ge1xuICBlYWNoU291cmNlOiBlYWNoU291cmNlLFxuICBlYWNoTGF5ZXI6IGVhY2hMYXllcixcbiAgZWFjaFByb3BlcnR5OiBlYWNoUHJvcGVydHlcbn07XG52YWxpZGF0ZVN0eWxlLnBhcnNlZCA9IHZhbGlkYXRlU3R5bGU7XG52YWxpZGF0ZVN0eWxlLmxhdGVzdCA9IHZhbGlkYXRlU3R5bGU7XG5leHBvcnQgeyBDb2xvciwgUGFyc2luZ0Vycm9yJDEgYXMgUGFyc2luZ0Vycm9yLCBWYWxpZGF0aW9uRXJyb3IsIGNvbXBvc2l0ZSwgY29udmVydEZpbHRlciQxIGFzIGNvbnZlcnRGaWx0ZXIsIGRlcmVmTGF5ZXJzLCBkaWZmU3R5bGVzIGFzIGRpZmYsIGV4cHJlc3Npb24kMSBhcyBleHByZXNzaW9uLCBjcmVhdGVGaWx0ZXIgYXMgZmVhdHVyZUZpbHRlciwgZm9ybWF0LCBzdHlsZUZ1bmN0aW9uIGFzIGZ1bmN0aW9uLCB2OCBhcyBsYXRlc3QsIG1pZ3JhdGUsIHY4LCB2YWxpZGF0ZVN0eWxlIGFzIHZhbGlkYXRlLCB2YWxpZGF0ZU1hcGJveEFwaVN1cHBvcnRlZCwgdmlzaXQgfTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3022\n')}}]);