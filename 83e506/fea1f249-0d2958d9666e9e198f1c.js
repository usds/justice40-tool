(self.webpackChunkjustice40_tool=self.webpackChunkjustice40_tool||[]).push([[98],{3022:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Il": function() { return /* binding */ Color; },\n/* harmony export */   "eG": function() { return /* binding */ derefLayers; },\n/* harmony export */   "th": function() { return /* binding */ expression$1; },\n/* harmony export */   "TE": function() { return /* binding */ createFilter; },\n/* harmony export */   "ZI": function() { return /* binding */ styleFunction; },\n/* harmony export */   "pA": function() { return /* binding */ v8; }\n/* harmony export */ });\n/* unused harmony exports ParsingError, ValidationError, composite, convertFilter, diff, format, migrate, v8, validate, validateMapboxApiSupported, visit */\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toArray__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9809);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5061);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8481);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(5991);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6610);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(379);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6616);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7608);\n/* harmony import */ var _home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5366);\n\n\n\n\n\n\n\n\n\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar $version = 8;\nvar $root = {\n  version: {\n    required: true,\n    type: "enum",\n    values: [8],\n    doc: "Style specification version number. Must be 8.",\n    example: 8\n  },\n  name: {\n    type: "string",\n    doc: "A human-readable name for the style.",\n    example: "Bright"\n  },\n  metadata: {\n    type: "*",\n    doc: "Arbitrary properties useful to track with the stylesheet, but do not influence rendering. Properties should be prefixed to avoid collisions, like \'mapbox:\'."\n  },\n  center: {\n    type: "array",\n    value: "number",\n    doc: "Default map center in longitude and latitude.  The style center will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",\n    example: [-73.9749, 40.7736]\n  },\n  zoom: {\n    type: "number",\n    doc: "Default zoom level.  The style zoom will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",\n    example: 12.5\n  },\n  bearing: {\n    type: "number",\n    "default": 0,\n    period: 360,\n    units: "degrees",\n    doc: "Default bearing, in degrees. The bearing is the compass direction that is \\"up\\"; for example, a bearing of 90° orients the map so that east is up. This value will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",\n    example: 29\n  },\n  pitch: {\n    type: "number",\n    "default": 0,\n    units: "degrees",\n    doc: "Default pitch, in degrees. Zero is perpendicular to the surface, for a look straight down at the map, while a greater value like 60 looks ahead towards the horizon. The style pitch will be used only if the map has not been positioned by other means (e.g. map options or user interaction).",\n    example: 50\n  },\n  light: {\n    type: "light",\n    doc: "The global light source.",\n    example: {\n      anchor: "viewport",\n      color: "white",\n      intensity: 0.4\n    }\n  },\n  terrain: {\n    type: "terrain",\n    doc: "A global modifier that elevates layers and markers based on a DEM data source."\n  },\n  fog: {\n    type: "fog",\n    doc: "A global effect that fades layers and markers based on their distance to the camera. The fog can be used to approximate the effect of atmosphere on distant objects and enhance the depth perception of the map when used with terrain or 3D features."\n  },\n  sources: {\n    required: true,\n    type: "sources",\n    doc: "Data source specifications.",\n    example: {\n      "mapbox-streets": {\n        type: "vector",\n        url: "mapbox://mapbox.mapbox-streets-v6"\n      }\n    }\n  },\n  sprite: {\n    type: "string",\n    doc: "A base URL for retrieving the sprite image and metadata. The extensions `.png`, `.json` and scale factor `@2x.png` will be automatically appended. This property is required if any layer uses the `background-pattern`, `fill-pattern`, `line-pattern`, `fill-extrusion-pattern`, or `icon-image` properties. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",\n    example: "mapbox://sprites/mapbox/bright-v8"\n  },\n  glyphs: {\n    type: "string",\n    doc: "A URL template for loading signed-distance-field glyph sets in PBF format. The URL must include `{fontstack}` and `{range}` tokens. This property is required if any layer uses the `text-field` layout property. The URL must be absolute, containing the [scheme, authority and path components](https://en.wikipedia.org/wiki/URL#Syntax).",\n    example: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf"\n  },\n  transition: {\n    type: "transition",\n    doc: "A global transition definition to use as a default across properties, to be used for timing transitions between one value and the next when no property-specific transition is set. Collision-based symbol fading is controlled independently of the style\'s `transition` property.",\n    example: {\n      duration: 300,\n      delay: 0\n    }\n  },\n  layers: {\n    required: true,\n    type: "array",\n    value: "layer",\n    doc: "Layers will be drawn in the order of this array.",\n    example: [{\n      id: "water",\n      source: "mapbox-streets",\n      "source-layer": "water",\n      type: "fill",\n      paint: {\n        "fill-color": "#00ffff"\n      }\n    }]\n  }\n};\nvar sources = {\n  "*": {\n    type: "source",\n    doc: "Specification of a data source. For vector and raster sources, either TileJSON or a URL to a TileJSON must be provided. For image and video sources, a URL must be provided. For GeoJSON sources, a URL or inline GeoJSON must be provided."\n  }\n};\nvar source = ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"];\nvar source_vector = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      vector: {\n        doc: "A vector tile source."\n      }\n    },\n    doc: "The type of the source."\n  },\n  url: {\n    type: "string",\n    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."\n  },\n  tiles: {\n    type: "array",\n    value: "string",\n    doc: "An array of one or more tile source URLs, as in the TileJSON spec."\n  },\n  bounds: {\n    type: "array",\n    value: "number",\n    length: 4,\n    "default": [-180, -85.051129, 180, 85.051129],\n    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source\'s bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."\n  },\n  scheme: {\n    type: "enum",\n    values: {\n      xyz: {\n        doc: "Slippy map tilenames scheme."\n      },\n      tms: {\n        doc: "OSGeo spec scheme."\n      }\n    },\n    "default": "xyz",\n    doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."\n  },\n  minzoom: {\n    type: "number",\n    "default": 0,\n    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."\n  },\n  maxzoom: {\n    type: "number",\n    "default": 22,\n    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."\n  },\n  attribution: {\n    type: "string",\n    doc: "Contains an attribution to be displayed when the map is shown to a user."\n  },\n  promoteId: {\n    type: "promoteId",\n    doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`. If specified as a string for a vector tile source, the same property is used across all its source layers."\n  },\n  volatile: {\n    type: "boolean",\n    "default": false,\n    doc: "A setting to determine whether a source\'s tiles are cached locally.",\n    "sdk-support": {\n      "basic functionality": {\n        android: "9.3.0",\n        ios: "5.10.0"\n      }\n    }\n  },\n  "*": {\n    type: "*",\n    doc: "Other keys to configure the data source."\n  }\n};\nvar source_raster = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      raster: {\n        doc: "A raster tile source."\n      }\n    },\n    doc: "The type of the source."\n  },\n  url: {\n    type: "string",\n    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."\n  },\n  tiles: {\n    type: "array",\n    value: "string",\n    doc: "An array of one or more tile source URLs, as in the TileJSON spec."\n  },\n  bounds: {\n    type: "array",\n    value: "number",\n    length: 4,\n    "default": [-180, -85.051129, 180, 85.051129],\n    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source\'s bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."\n  },\n  minzoom: {\n    type: "number",\n    "default": 0,\n    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."\n  },\n  maxzoom: {\n    type: "number",\n    "default": 22,\n    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."\n  },\n  tileSize: {\n    type: "number",\n    "default": 512,\n    units: "pixels",\n    doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."\n  },\n  scheme: {\n    type: "enum",\n    values: {\n      xyz: {\n        doc: "Slippy map tilenames scheme."\n      },\n      tms: {\n        doc: "OSGeo spec scheme."\n      }\n    },\n    "default": "xyz",\n    doc: "Influences the y direction of the tile coordinates. The global-mercator (aka Spherical Mercator) profile is assumed."\n  },\n  attribution: {\n    type: "string",\n    doc: "Contains an attribution to be displayed when the map is shown to a user."\n  },\n  volatile: {\n    type: "boolean",\n    "default": false,\n    doc: "A setting to determine whether a source\'s tiles are cached locally.",\n    "sdk-support": {\n      "basic functionality": {\n        android: "9.3.0",\n        ios: "5.10.0"\n      }\n    }\n  },\n  "*": {\n    type: "*",\n    doc: "Other keys to configure the data source."\n  }\n};\nvar source_raster_dem = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      "raster-dem": {\n        doc: "A RGB-encoded raster DEM source"\n      }\n    },\n    doc: "The type of the source."\n  },\n  url: {\n    type: "string",\n    doc: "A URL to a TileJSON resource. Supported protocols are `http:`, `https:`, and `mapbox://<Tileset ID>`."\n  },\n  tiles: {\n    type: "array",\n    value: "string",\n    doc: "An array of one or more tile source URLs, as in the TileJSON spec."\n  },\n  bounds: {\n    type: "array",\n    value: "number",\n    length: 4,\n    "default": [-180, -85.051129, 180, 85.051129],\n    doc: "An array containing the longitude and latitude of the southwest and northeast corners of the source\'s bounding box in the following order: `[sw.lng, sw.lat, ne.lng, ne.lat]`. When this property is included in a source, no tiles outside of the given bounds are requested by Mapbox GL."\n  },\n  minzoom: {\n    type: "number",\n    "default": 0,\n    doc: "Minimum zoom level for which tiles are available, as in the TileJSON spec."\n  },\n  maxzoom: {\n    type: "number",\n    "default": 22,\n    doc: "Maximum zoom level for which tiles are available, as in the TileJSON spec. Data from tiles at the maxzoom are used when displaying the map at higher zoom levels."\n  },\n  tileSize: {\n    type: "number",\n    "default": 512,\n    units: "pixels",\n    doc: "The minimum visual size to display tiles for this layer. Only configurable for raster layers."\n  },\n  attribution: {\n    type: "string",\n    doc: "Contains an attribution to be displayed when the map is shown to a user."\n  },\n  encoding: {\n    type: "enum",\n    values: {\n      terrarium: {\n        doc: "Terrarium format PNG tiles. See https://aws.amazon.com/es/public-datasets/terrain/ for more info."\n      },\n      mapbox: {\n        doc: "Mapbox Terrain RGB tiles. See https://www.mapbox.com/help/access-elevation-data/#mapbox-terrain-rgb for more info."\n      }\n    },\n    "default": "mapbox",\n    doc: "The encoding used by this source. Mapbox Terrain RGB is used by default"\n  },\n  volatile: {\n    type: "boolean",\n    "default": false,\n    doc: "A setting to determine whether a source\'s tiles are cached locally.",\n    "sdk-support": {\n      "basic functionality": {\n        android: "9.3.0",\n        ios: "5.10.0"\n      }\n    }\n  },\n  "*": {\n    type: "*",\n    doc: "Other keys to configure the data source."\n  }\n};\nvar source_geojson = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      geojson: {\n        doc: "A GeoJSON data source."\n      }\n    },\n    doc: "The data type of the GeoJSON source."\n  },\n  data: {\n    type: "*",\n    doc: "A URL to a GeoJSON file, or inline GeoJSON."\n  },\n  maxzoom: {\n    type: "number",\n    "default": 18,\n    doc: "Maximum zoom level at which to create vector tiles (higher means greater detail at high zoom levels)."\n  },\n  attribution: {\n    type: "string",\n    doc: "Contains an attribution to be displayed when the map is shown to a user."\n  },\n  buffer: {\n    type: "number",\n    "default": 128,\n    maximum: 512,\n    minimum: 0,\n    doc: "Size of the tile buffer on each side. A value of 0 produces no buffer. A value of 512 produces a buffer as wide as the tile itself. Larger values produce fewer rendering artifacts near tile edges and slower performance."\n  },\n  filter: {\n    type: "*",\n    doc: "An expression for filtering features prior to processing them for rendering."\n  },\n  tolerance: {\n    type: "number",\n    "default": 0.375,\n    doc: "Douglas-Peucker simplification tolerance (higher means simpler geometries and faster performance)."\n  },\n  cluster: {\n    type: "boolean",\n    "default": false,\n    doc: "If the data is a collection of point features, setting this to true clusters the points by radius into groups. Cluster groups become new `Point` features in the source with additional properties:\\n * `cluster` Is `true` if the point is a cluster \\n * `cluster_id` A unqiue id for the cluster to be used in conjunction with the [cluster inspection methods](https://www.mapbox.com/mapbox-gl-js/api/#geojsonsource#getclusterexpansionzoom)\\n * `point_count` Number of original points grouped into this cluster\\n * `point_count_abbreviated` An abbreviated point count"\n  },\n  clusterRadius: {\n    type: "number",\n    "default": 50,\n    minimum: 0,\n    doc: "Radius of each cluster if clustering is enabled. A value of 512 indicates a radius equal to the width of a tile."\n  },\n  clusterMaxZoom: {\n    type: "number",\n    doc: "Max zoom on which to cluster points if clustering is enabled. Defaults to one zoom less than maxzoom (so that last zoom features are not clustered). Clusters are re-evaluated at integer zoom levels so setting clusterMaxZoom to 14 means the clusters will be displayed until z15."\n  },\n  clusterMinPoints: {\n    type: "number",\n    doc: "Minimum number of points necessary to form a cluster if clustering is enabled. Defaults to `2`."\n  },\n  clusterProperties: {\n    type: "*",\n    doc: "An object defining custom properties on the generated clusters if clustering is enabled, aggregating values from clustered points. Has the form `{\\"property_name\\": [operator, map_expression]}`. `operator` is any expression function that accepts at least 2 operands (e.g. `\\"+\\"` or `\\"max\\"`) — it accumulates the property value from clusters/points the cluster contains; `map_expression` produces the value of a single point.\\n\\nExample: `{\\"sum\\": [\\"+\\", [\\"get\\", \\"scalerank\\"]]}`.\\n\\nFor more advanced use cases, in place of `operator`, you can use a custom reduce expression that references a special `[\\"accumulated\\"]` value, e.g.:\\n`{\\"sum\\": [[\\"+\\", [\\"accumulated\\"], [\\"get\\", \\"sum\\"]], [\\"get\\", \\"scalerank\\"]]}`"\n  },\n  lineMetrics: {\n    type: "boolean",\n    "default": false,\n    doc: "Whether to calculate line distance metrics. This is required for line layers that specify `line-gradient` values."\n  },\n  generateId: {\n    type: "boolean",\n    "default": false,\n    doc: "Whether to generate ids for the geojson features. When enabled, the `feature.id` property will be auto assigned based on its index in the `features` array, over-writing any previous values."\n  },\n  promoteId: {\n    type: "promoteId",\n    doc: "A property to use as a feature id (for feature state). Either a property name, or an object of the form `{<sourceLayer>: <propertyName>}`."\n  }\n};\nvar source_video = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      video: {\n        doc: "A video data source."\n      }\n    },\n    doc: "The data type of the video source."\n  },\n  urls: {\n    required: true,\n    type: "array",\n    value: "string",\n    doc: "URLs to video content in order of preferred format."\n  },\n  coordinates: {\n    required: true,\n    doc: "Corners of video specified in longitude, latitude pairs.",\n    type: "array",\n    length: 4,\n    value: {\n      type: "array",\n      length: 2,\n      value: "number",\n      doc: "A single longitude, latitude pair."\n    }\n  }\n};\nvar source_image = {\n  type: {\n    required: true,\n    type: "enum",\n    values: {\n      image: {\n        doc: "An image data source."\n      }\n    },\n    doc: "The data type of the image source."\n  },\n  url: {\n    required: true,\n    type: "string",\n    doc: "URL that points to an image."\n  },\n  coordinates: {\n    required: true,\n    doc: "Corners of image specified in longitude, latitude pairs.",\n    type: "array",\n    length: 4,\n    value: {\n      type: "array",\n      length: 2,\n      value: "number",\n      doc: "A single longitude, latitude pair."\n    }\n  }\n};\nvar layer = {\n  id: {\n    type: "string",\n    doc: "Unique layer name.",\n    required: true\n  },\n  type: {\n    type: "enum",\n    values: {\n      fill: {\n        doc: "A filled polygon with an optional stroked border.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      line: {\n        doc: "A stroked line.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      symbol: {\n        doc: "An icon or a text label.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      circle: {\n        doc: "A filled circle.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      heatmap: {\n        doc: "A heatmap.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.41.0",\n            android: "6.0.0",\n            ios: "4.0.0",\n            macos: "0.7.0"\n          }\n        }\n      },\n      "fill-extrusion": {\n        doc: "An extruded (3D) polygon.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.27.0",\n            android: "5.1.0",\n            ios: "3.6.0",\n            macos: "0.5.0"\n          }\n        }\n      },\n      raster: {\n        doc: "Raster map textures such as satellite imagery.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      hillshade: {\n        doc: "Client-side hillshading visualization based on DEM data. Currently, the implementation only supports Mapbox Terrain RGB and Mapzen Terrarium tiles.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.43.0",\n            android: "6.0.0",\n            ios: "4.0.0",\n            macos: "0.7.0"\n          }\n        }\n      },\n      background: {\n        doc: "The background color or pattern of the map.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "0.10.0",\n            android: "2.0.1",\n            ios: "2.0.0",\n            macos: "0.1.0"\n          }\n        }\n      },\n      sky: {\n        doc: "A spherical dome around the map that is always rendered behind all other layers.",\n        "sdk-support": {\n          "basic functionality": {\n            js: "2.0.0"\n          }\n        }\n      }\n    },\n    doc: "Rendering type of this layer.",\n    required: true\n  },\n  metadata: {\n    type: "*",\n    doc: "Arbitrary properties useful to track with the layer, but do not influence rendering. Properties should be prefixed to avoid collisions, like \'mapbox:\'."\n  },\n  source: {\n    type: "string",\n    doc: "Name of a source description to be used for this layer. Required for all layer types except `background`."\n  },\n  "source-layer": {\n    type: "string",\n    doc: "Layer to use from a vector tile source. Required for vector tile sources; prohibited for all other source types, including GeoJSON sources."\n  },\n  minzoom: {\n    type: "number",\n    minimum: 0,\n    maximum: 24,\n    doc: "The minimum zoom level for the layer. At zoom levels less than the minzoom, the layer will be hidden."\n  },\n  maxzoom: {\n    type: "number",\n    minimum: 0,\n    maximum: 24,\n    doc: "The maximum zoom level for the layer. At zoom levels equal to or greater than the maxzoom, the layer will be hidden."\n  },\n  filter: {\n    type: "filter",\n    doc: "A expression specifying conditions on source features. Only features that match the filter are displayed. Zoom expressions in filters are only evaluated at integer zoom levels. The `feature-state` expression is not supported in filter expressions."\n  },\n  layout: {\n    type: "layout",\n    doc: "Layout properties for the layer."\n  },\n  paint: {\n    type: "paint",\n    doc: "Default paint properties for this layer."\n  }\n};\nvar layout = ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background", "layout_sky"];\nvar layout_background = {\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_sky = {\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_fill = {\n  "fill-sort-key": {\n    type: "number",\n    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "1.2.0",\n        android: "9.1.0",\n        ios: "5.8.0",\n        macos: "0.15.0"\n      },\n      "data-driven styling": {\n        js: "1.2.0",\n        android: "9.1.0",\n        ios: "5.8.0",\n        macos: "0.15.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_circle = {\n  "circle-sort-key": {\n    type: "number",\n    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "1.2.0",\n        android: "9.2.0",\n        ios: "5.9.0",\n        macos: "0.16.0"\n      },\n      "data-driven styling": {\n        js: "1.2.0",\n        android: "9.2.0",\n        ios: "5.9.0",\n        macos: "0.16.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_heatmap = {\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_line = {\n  "line-cap": {\n    type: "enum",\n    values: {\n      butt: {\n        doc: "A cap with a squared-off end which is drawn to the exact endpoint of the line."\n      },\n      round: {\n        doc: "A cap with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line\'s width and centered on the endpoint of the line."\n      },\n      square: {\n        doc: "A cap with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line\'s width."\n      }\n    },\n    "default": "butt",\n    doc: "The display of line endings.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "2.3.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-join": {\n    type: "enum",\n    values: {\n      bevel: {\n        doc: "A join with a squared-off end which is drawn beyond the endpoint of the line at a distance of one-half of the line\'s width."\n      },\n      round: {\n        doc: "A join with a rounded end which is drawn beyond the endpoint of the line at a radius of one-half of the line\'s width and centered on the endpoint of the line."\n      },\n      miter: {\n        doc: "A join with a sharp, angled corner which is drawn with the outer sides beyond the endpoint of the path until they meet."\n      }\n    },\n    "default": "miter",\n    doc: "The display of lines when joining.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.40.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-miter-limit": {\n    type: "number",\n    "default": 2,\n    doc: "Used to automatically convert miter joins to bevel joins for sharp angles.",\n    requires: [{\n      "line-join": "miter"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "line-round-limit": {\n    type: "number",\n    "default": 1.05,\n    doc: "Used to automatically convert round joins to miter joins for shallow angles.",\n    requires: [{\n      "line-join": "round"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "line-sort-key": {\n    type: "number",\n    doc: "Sorts features in ascending order based on this value. Features with a higher sort key will appear above features with a lower sort key.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "1.2.0",\n        android: "9.1.0",\n        ios: "5.8.0",\n        macos: "0.15.0"\n      },\n      "data-driven styling": {\n        js: "1.2.0",\n        android: "9.1.0",\n        ios: "5.8.0",\n        macos: "0.15.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_symbol = {\n  "symbol-placement": {\n    type: "enum",\n    values: {\n      point: {\n        doc: "The label is placed at the point where the geometry is located."\n      },\n      line: {\n        doc: "The label is placed along the line of the geometry. Can only be used on `LineString` and `Polygon` geometries."\n      },\n      "line-center": {\n        doc: "The label is placed at the center of the line of the geometry. Can only be used on `LineString` and `Polygon` geometries. Note that a single feature in a vector tile may contain multiple line geometries."\n      }\n    },\n    "default": "point",\n    doc: "Label placement relative to its geometry.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "`line-center` value": {\n        js: "0.47.0",\n        android: "6.4.0",\n        ios: "4.3.0",\n        macos: "0.10.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "symbol-spacing": {\n    type: "number",\n    "default": 250,\n    minimum: 1,\n    units: "pixels",\n    doc: "Distance between two symbol anchors.",\n    requires: [{\n      "symbol-placement": "line"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "symbol-avoid-edges": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, the symbols will not cross tile edges to avoid mutual collisions. Recommended in layers that don\'t have enough padding in the vector tile to prevent collisions, or if it is a point symbol layer placed after a line symbol layer. When using a client that supports global collision detection, like Mapbox GL JS version 0.42.0 or greater, enabling this property is not needed to prevent clipped labels at tile boundaries.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "symbol-sort-key": {\n    type: "number",\n    doc: "Sorts features in ascending order based on this value. Features with lower sort keys are drawn and placed first.  When `icon-allow-overlap` or `text-allow-overlap` is `false`, features with a lower sort key will have priority during placement. When `icon-allow-overlap` or `text-allow-overlap` is set to `true`, features with a higher sort key will overlap over features with a lower sort key.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.53.0",\n        android: "7.4.0",\n        ios: "4.11.0",\n        macos: "0.14.0"\n      },\n      "data-driven styling": {\n        js: "0.53.0",\n        android: "7.4.0",\n        ios: "4.11.0",\n        macos: "0.14.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "symbol-z-order": {\n    type: "enum",\n    values: {\n      auto: {\n        doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."\n      },\n      "viewport-y": {\n        doc: "Sorts symbols by their y-position relative to the viewport if `icon-allow-overlap` or `text-allow-overlap` is set to `true` or `icon-ignore-placement` or `text-ignore-placement` is `false`."\n      },\n      source: {\n        doc: "Sorts symbols by `symbol-sort-key` if set. Otherwise, no sorting is applied; symbols are rendered in the same order as the source data."\n      }\n    },\n    "default": "auto",\n    doc: "Determines whether overlapping symbols in the same layer are rendered in the order that they appear in the data source or by their y-position relative to the viewport. To control the order and prioritization of symbols otherwise, use `symbol-sort-key`.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.49.0",\n        android: "6.6.0",\n        ios: "4.5.0",\n        macos: "0.12.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-allow-overlap": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, the icon will be visible even if it collides with other previously drawn symbols.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-ignore-placement": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, other symbols can be visible even if they collide with the icon.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-optional": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, text will display without their corresponding icons when the icon collides with other symbols and the text does not.",\n    requires: ["icon-image", "text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-rotation-alignment": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "When `symbol-placement` is set to `point`, aligns icons east-west. When `symbol-placement` is set to `line` or `line-center`, aligns icon x-axes with the line."\n      },\n      viewport: {\n        doc: "Produces icons whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."\n      },\n      auto: {\n        doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."\n      }\n    },\n    "default": "auto",\n    doc: "In combination with `symbol-placement`, determines the rotation behavior of icons.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "`auto` value": {\n        js: "0.25.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.3.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-size": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    units: "factor of the original icon size",\n    doc: "Scales the original size of the icon by the provided factor. The new pixel size of the image will be the original pixel size multiplied by `icon-size`. 1 is the original size; 3 triples the size of the image.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.35.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-text-fit": {\n    type: "enum",\n    values: {\n      none: {\n        doc: "The icon is displayed at its intrinsic aspect ratio."\n      },\n      width: {\n        doc: "The icon is scaled in the x-dimension to fit the width of the text."\n      },\n      height: {\n        doc: "The icon is scaled in the y-dimension to fit the height of the text."\n      },\n      both: {\n        doc: "The icon is scaled in both x- and y-dimensions."\n      }\n    },\n    "default": "none",\n    doc: "Scales the icon to fit around the associated text.",\n    requires: ["icon-image", "text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.21.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.2.1"\n      },\n      "stretchable icons": {\n        js: "1.6.0",\n        android: "9.2.0",\n        ios: "5.8.0",\n        macos: "0.15.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-text-fit-padding": {\n    type: "array",\n    value: "number",\n    length: 4,\n    "default": [0, 0, 0, 0],\n    units: "pixels",\n    doc: "Size of the additional area added to dimensions determined by `icon-text-fit`, in clockwise order: top, right, bottom, left.",\n    requires: ["icon-image", "text-field", {\n      "icon-text-fit": ["both", "width", "height"]\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.21.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.2.1"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-image": {\n    type: "resolvedImage",\n    doc: "Name of image in sprite to use for drawing an image background.",\n    tokens: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.35.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-rotate": {\n    type: "number",\n    "default": 0,\n    period: 360,\n    units: "degrees",\n    doc: "Rotates the icon clockwise.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.21.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-padding": {\n    type: "number",\n    "default": 2,\n    minimum: 0,\n    units: "pixels",\n    doc: "Size of the additional area around the icon bounding box used for detecting symbol collisions.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-keep-upright": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, the icon may be flipped to prevent it from being rendered upside-down.",\n    requires: ["icon-image", {\n      "icon-rotation-alignment": "map"\n    }, {\n      "symbol-placement": ["line", "line-center"]\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-offset": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    doc: "Offset distance of icon from its anchor. Positive values indicate right and down, while negative values indicate left and up. Each component is multiplied by the value of `icon-size` to obtain the final offset in pixels. When combined with `icon-rotate` the offset will be as if the rotated direction was up.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-anchor": {\n    type: "enum",\n    values: {\n      center: {\n        doc: "The center of the icon is placed closest to the anchor."\n      },\n      left: {\n        doc: "The left side of the icon is placed closest to the anchor."\n      },\n      right: {\n        doc: "The right side of the icon is placed closest to the anchor."\n      },\n      top: {\n        doc: "The top of the icon is placed closest to the anchor."\n      },\n      bottom: {\n        doc: "The bottom of the icon is placed closest to the anchor."\n      },\n      "top-left": {\n        doc: "The top left corner of the icon is placed closest to the anchor."\n      },\n      "top-right": {\n        doc: "The top right corner of the icon is placed closest to the anchor."\n      },\n      "bottom-left": {\n        doc: "The bottom left corner of the icon is placed closest to the anchor."\n      },\n      "bottom-right": {\n        doc: "The bottom right corner of the icon is placed closest to the anchor."\n      }\n    },\n    "default": "center",\n    doc: "Part of the icon placed closest to the anchor.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.40.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      },\n      "data-driven styling": {\n        js: "0.40.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-pitch-alignment": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The icon is aligned to the plane of the map."\n      },\n      viewport: {\n        doc: "The icon is aligned to the plane of the viewport."\n      },\n      auto: {\n        doc: "Automatically matches the value of `icon-rotation-alignment`."\n      }\n    },\n    "default": "auto",\n    doc: "Orientation of icon when map is pitched.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.39.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-pitch-alignment": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The text is aligned to the plane of the map."\n      },\n      viewport: {\n        doc: "The text is aligned to the plane of the viewport."\n      },\n      auto: {\n        doc: "Automatically matches the value of `text-rotation-alignment`."\n      }\n    },\n    "default": "auto",\n    doc: "Orientation of text when map is pitched.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.21.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.2.1"\n      },\n      "`auto` value": {\n        js: "0.25.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.3.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-rotation-alignment": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "When `symbol-placement` is set to `point`, aligns text east-west. When `symbol-placement` is set to `line` or `line-center`, aligns text x-axes with the line."\n      },\n      viewport: {\n        doc: "Produces glyphs whose x-axes are aligned with the x-axis of the viewport, regardless of the value of `symbol-placement`."\n      },\n      auto: {\n        doc: "When `symbol-placement` is set to `point`, this is equivalent to `viewport`. When `symbol-placement` is set to `line` or `line-center`, this is equivalent to `map`."\n      }\n    },\n    "default": "auto",\n    doc: "In combination with `symbol-placement`, determines the rotation behavior of the individual glyphs forming the text.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "`auto` value": {\n        js: "0.25.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.3.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-field": {\n    type: "formatted",\n    "default": "",\n    tokens: true,\n    doc: "Value to use for a text label. If a plain `string` is provided, it will be treated as a `formatted` with default/inherited formatting options.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-font": {\n    type: "array",\n    value: "string",\n    "default": ["Open Sans Regular", "Arial Unicode MS Regular"],\n    doc: "Font stack to use for displaying text.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-size": {\n    type: "number",\n    "default": 16,\n    minimum: 0,\n    units: "pixels",\n    doc: "Font size.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.35.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-max-width": {\n    type: "number",\n    "default": 10,\n    minimum: 0,\n    units: "ems",\n    doc: "The maximum line width for text wrapping.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.40.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-line-height": {\n    type: "number",\n    "default": 1.2,\n    units: "ems",\n    doc: "Text leading value for multi-line text.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "2.3.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-letter-spacing": {\n    type: "number",\n    "default": 0,\n    units: "ems",\n    doc: "Text tracking amount.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.40.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-justify": {\n    type: "enum",\n    values: {\n      auto: {\n        doc: "The text is aligned towards the anchor position."\n      },\n      left: {\n        doc: "The text is aligned to the left."\n      },\n      center: {\n        doc: "The text is centered."\n      },\n      right: {\n        doc: "The text is aligned to the right."\n      }\n    },\n    "default": "center",\n    doc: "Text justification options.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.39.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      },\n      auto: {\n        js: "0.54.0",\n        android: "7.4.0",\n        ios: "4.10.0",\n        macos: "0.14.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-radial-offset": {\n    type: "number",\n    units: "ems",\n    "default": 0,\n    doc: "Radial offset of text, in the direction of the symbol\'s anchor. Useful in combination with `text-variable-anchor`, which defaults to using the two-dimensional `text-offset` if present.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.54.0",\n        android: "7.4.0",\n        ios: "4.10.0",\n        macos: "0.14.0"\n      },\n      "data-driven styling": {\n        js: "0.54.0",\n        android: "7.4.0",\n        ios: "4.10.0",\n        macos: "0.14.0"\n      }\n    },\n    requires: ["text-field"],\n    "property-type": "data-driven",\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    }\n  },\n  "text-variable-anchor": {\n    type: "array",\n    value: "enum",\n    values: {\n      center: {\n        doc: "The center of the text is placed closest to the anchor."\n      },\n      left: {\n        doc: "The left side of the text is placed closest to the anchor."\n      },\n      right: {\n        doc: "The right side of the text is placed closest to the anchor."\n      },\n      top: {\n        doc: "The top of the text is placed closest to the anchor."\n      },\n      bottom: {\n        doc: "The bottom of the text is placed closest to the anchor."\n      },\n      "top-left": {\n        doc: "The top left corner of the text is placed closest to the anchor."\n      },\n      "top-right": {\n        doc: "The top right corner of the text is placed closest to the anchor."\n      },\n      "bottom-left": {\n        doc: "The bottom left corner of the text is placed closest to the anchor."\n      },\n      "bottom-right": {\n        doc: "The bottom right corner of the text is placed closest to the anchor."\n      }\n    },\n    requires: ["text-field", {\n      "symbol-placement": ["point"]\n    }],\n    doc: "To increase the chance of placing high-priority labels on the map, you can provide an array of `text-anchor` locations: the renderer will attempt to place the label at each location, in order, before moving onto the next label. Use `text-justify: auto` to choose justification based on anchor position. To apply an offset, use the `text-radial-offset` or the two-dimensional `text-offset`.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.54.0",\n        android: "7.4.0",\n        ios: "4.10.0",\n        macos: "0.14.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-anchor": {\n    type: "enum",\n    values: {\n      center: {\n        doc: "The center of the text is placed closest to the anchor."\n      },\n      left: {\n        doc: "The left side of the text is placed closest to the anchor."\n      },\n      right: {\n        doc: "The right side of the text is placed closest to the anchor."\n      },\n      top: {\n        doc: "The top of the text is placed closest to the anchor."\n      },\n      bottom: {\n        doc: "The bottom of the text is placed closest to the anchor."\n      },\n      "top-left": {\n        doc: "The top left corner of the text is placed closest to the anchor."\n      },\n      "top-right": {\n        doc: "The top right corner of the text is placed closest to the anchor."\n      },\n      "bottom-left": {\n        doc: "The bottom left corner of the text is placed closest to the anchor."\n      },\n      "bottom-right": {\n        doc: "The bottom right corner of the text is placed closest to the anchor."\n      }\n    },\n    "default": "center",\n    doc: "Part of the text placed closest to the anchor.",\n    requires: ["text-field", {\n      "!": "text-variable-anchor"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.39.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-max-angle": {\n    type: "number",\n    "default": 45,\n    units: "degrees",\n    doc: "Maximum angle change between adjacent characters.",\n    requires: ["text-field", {\n      "symbol-placement": ["line", "line-center"]\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-writing-mode": {\n    type: "array",\n    value: "enum",\n    values: {\n      horizontal: {\n        doc: "If a text\'s language supports horizontal writing mode, symbols with point placement would be laid out horizontally."\n      },\n      vertical: {\n        doc: "If a text\'s language supports vertical writing mode, symbols with point placement would be laid out vertically."\n      }\n    },\n    doc: "The property allows control over a symbol\'s orientation. Note that the property values act as a hint, so that a symbol whose language doesn’t support the provided orientation will be laid out in its natural orientation. Example: English point symbol will be rendered horizontally even if array value contains single \'vertical\' enum value. The order of elements in an array define priority order for the placement of an orientation variant.",\n    requires: ["text-field", {\n      "symbol-placement": ["point"]\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "1.3.0",\n        android: "8.3.0",\n        ios: "5.3.0",\n        macos: "0.15.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-rotate": {\n    type: "number",\n    "default": 0,\n    period: 360,\n    units: "degrees",\n    doc: "Rotates the text clockwise.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.35.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-padding": {\n    type: "number",\n    "default": 2,\n    minimum: 0,\n    units: "pixels",\n    doc: "Size of the additional area around the text bounding box used for detecting symbol collisions.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-keep-upright": {\n    type: "boolean",\n    "default": true,\n    doc: "If true, the text may be flipped vertically to prevent it from being rendered upside-down.",\n    requires: ["text-field", {\n      "text-rotation-alignment": "map"\n    }, {\n      "symbol-placement": ["line", "line-center"]\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-transform": {\n    type: "enum",\n    values: {\n      none: {\n        doc: "The text is not altered."\n      },\n      uppercase: {\n        doc: "Forces all letters to be displayed in uppercase."\n      },\n      lowercase: {\n        doc: "Forces all letters to be displayed in lowercase."\n      }\n    },\n    "default": "none",\n    doc: "Specifies how to capitalize text, similar to the CSS `text-transform` property.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-offset": {\n    type: "array",\n    doc: "Offset distance of text from its anchor. Positive values indicate right and down, while negative values indicate left and up. If used with text-variable-anchor, input values will be taken as absolute values. Offsets along the x- and y-axis will be applied automatically based on the anchor position.",\n    value: "number",\n    units: "ems",\n    length: 2,\n    "default": [0, 0],\n    requires: ["text-field", {\n      "!": "text-radial-offset"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.35.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-allow-overlap": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, the text will be visible even if it collides with other previously drawn symbols.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-ignore-placement": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, other symbols can be visible even if they collide with the text.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-optional": {\n    type: "boolean",\n    "default": false,\n    doc: "If true, icons will display without their corresponding text when the text collides with other symbols and the icon does not.",\n    requires: ["text-field", "icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_raster = {\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar layout_hillshade = {\n  visibility: {\n    type: "enum",\n    values: {\n      visible: {\n        doc: "The layer is shown."\n      },\n      none: {\n        doc: "The layer is not shown."\n      }\n    },\n    "default": "visible",\n    doc: "Whether this layer is displayed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    "property-type": "constant"\n  }\n};\nvar filter = {\n  type: "array",\n  value: "*",\n  doc: "A filter selects specific features from a layer."\n};\nvar filter_operator = {\n  type: "enum",\n  values: {\n    "==": {\n      doc: "`[\\"==\\", key, value]` equality: `feature[key] = value`"\n    },\n    "!=": {\n      doc: "`[\\"!=\\", key, value]` inequality: `feature[key] ≠ value`"\n    },\n    ">": {\n      doc: "`[\\">\\", key, value]` greater than: `feature[key] > value`"\n    },\n    ">=": {\n      doc: "`[\\">=\\", key, value]` greater than or equal: `feature[key] ≥ value`"\n    },\n    "<": {\n      doc: "`[\\"<\\", key, value]` less than: `feature[key] < value`"\n    },\n    "<=": {\n      doc: "`[\\"<=\\", key, value]` less than or equal: `feature[key] ≤ value`"\n    },\n    "in": {\n      doc: "`[\\"in\\", key, v0, ..., vn]` set inclusion: `feature[key] ∈ {v0, ..., vn}`"\n    },\n    "!in": {\n      doc: "`[\\"!in\\", key, v0, ..., vn]` set exclusion: `feature[key] ∉ {v0, ..., vn}`"\n    },\n    all: {\n      doc: "`[\\"all\\", f0, ..., fn]` logical `AND`: `f0 ∧ ... ∧ fn`"\n    },\n    any: {\n      doc: "`[\\"any\\", f0, ..., fn]` logical `OR`: `f0 ∨ ... ∨ fn`"\n    },\n    none: {\n      doc: "`[\\"none\\", f0, ..., fn]` logical `NOR`: `¬f0 ∧ ... ∧ ¬fn`"\n    },\n    has: {\n      doc: "`[\\"has\\", key]` `feature[key]` exists"\n    },\n    "!has": {\n      doc: "`[\\"!has\\", key]` `feature[key]` does not exist"\n    },\n    within: {\n      doc: "`[\\"within\\", object]` feature geometry is within object geometry"\n    }\n  },\n  doc: "The filter operator."\n};\nvar geometry_type = {\n  type: "enum",\n  values: {\n    Point: {\n      doc: "Filter to point geometries."\n    },\n    LineString: {\n      doc: "Filter to line geometries."\n    },\n    Polygon: {\n      doc: "Filter to polygon geometries."\n    }\n  },\n  doc: "The geometry type for the filter to select."\n};\nvar function_stop = {\n  type: "array",\n  minimum: 0,\n  maximum: 24,\n  value: ["number", "color"],\n  length: 2,\n  doc: "Zoom level and value pair."\n};\nvar expression = {\n  type: "array",\n  value: "*",\n  minimum: 1,\n  doc: "An expression defines a function that can be used for data-driven style properties or feature filters."\n};\nvar expression_name = {\n  doc: "",\n  type: "enum",\n  values: {\n    "let": {\n      doc: "Binds expressions to named variables, which can then be referenced in the result expression using [\\"var\\", \\"variable_name\\"].",\n      group: "Variable binding",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "var": {\n      doc: "References variable bound using \\"let\\".",\n      group: "Variable binding",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    literal: {\n      doc: "Provides a literal array or object value.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    array: {\n      doc: "Asserts that the input is an array (optionally with a specific item type and length).  If, when the input expression is evaluated, it is not of the asserted type, then this assertion will cause the whole expression to be aborted.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    at: {\n      doc: "Retrieves an item from an array.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "in": {\n      doc: "Determines whether an item exists in an array or a substring exists in a string.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "1.6.0",\n          android: "9.1.0",\n          ios: "5.8.0",\n          macos: "0.15.0"\n        }\n      }\n    },\n    "index-of": {\n      doc: "Returns the first position at which an item can be found in an array or a substring can be found in a string, or `-1` if the input cannot be found. Accepts an optional index from where to begin the search.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "1.10.0"\n        }\n      }\n    },\n    slice: {\n      doc: "Returns an item from an array or a substring from a string from a specified start index, or between a start index and an end index if set. The return value is inclusive of the start index but not of the end index.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "1.10.0"\n        }\n      }\n    },\n    "case": {\n      doc: "Selects the first output whose corresponding test condition evaluates to true, or the fallback value otherwise.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    match: {\n      doc: "Selects the output for which the label value matches the input value, or the fallback value if no match is found. The input can be any expression (for example, `[\\"get\\", \\"building_type\\"]`). Each label must be unique, and must be either:\\n - a single literal value; or\\n - an array of literal values, the values of which must be all strings or all numbers (for example `[100, 101]` or `[\\"c\\", \\"b\\"]`).\\n\\nThe input matches if any of the values in the array matches using strict equality, similar to the `\\"in\\"` operator.\\nIf the input type does not match the type of the labels, the result will be the fallback value.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    coalesce: {\n      doc: "Evaluates each expression in turn until the first non-null value is obtained, and returns that value.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    step: {\n      doc: "Produces discrete, stepped results by evaluating a piecewise-constant function defined by pairs of input and output values (\\"stops\\"). The `input` may be any numeric expression (e.g., `[\\"get\\", \\"population\\"]`). Stop inputs must be numeric literals in strictly ascending order. Returns the output value of the stop just less than the input, or the first output if the input is less than the first stop.",\n      group: "Ramps, scales, curves",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.42.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    interpolate: {\n      doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\\"stops\\"). The `input` may be any numeric expression (e.g., `[\\"get\\", \\"population\\"]`). Stop inputs must be numeric literals in strictly ascending order. The output type must be `number`, `array<number>`, or `color`.\\n\\nInterpolation types:\\n- `[\\"linear\\"]`: Interpolates linearly between the pair of stops just less than and just greater than the input.\\n- `[\\"exponential\\", base]`: Interpolates exponentially between the stops just less than and just greater than the input. `base` controls the rate at which the output increases: higher values make the output increase more towards the high end of the range. With values close to 1 the output increases linearly.\\n- `[\\"cubic-bezier\\", x1, y1, x2, y2]`: Interpolates using the cubic bezier curve defined by the given control points.",\n      group: "Ramps, scales, curves",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.42.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "interpolate-hcl": {\n      doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\\"stops\\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the Hue-Chroma-Luminance color space.",\n      group: "Ramps, scales, curves",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.49.0"\n        }\n      }\n    },\n    "interpolate-lab": {\n      doc: "Produces continuous, smooth results by interpolating between pairs of input and output values (\\"stops\\"). Works like `interpolate`, but the output type must be `color`, and the interpolation is performed in the CIELAB color space.",\n      group: "Ramps, scales, curves",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.49.0"\n        }\n      }\n    },\n    ln2: {\n      doc: "Returns mathematical constant ln(2).",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    pi: {\n      doc: "Returns the mathematical constant pi.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    e: {\n      doc: "Returns the mathematical constant e.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "typeof": {\n      doc: "Returns a string describing the type of the given value.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    string: {\n      doc: "Asserts that the input value is a string. If multiple values are provided, each one is evaluated in order until a string is obtained. If none of the inputs are strings, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    number: {\n      doc: "Asserts that the input value is a number. If multiple values are provided, each one is evaluated in order until a number is obtained. If none of the inputs are numbers, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    boolean: {\n      doc: "Asserts that the input value is a boolean. If multiple values are provided, each one is evaluated in order until a boolean is obtained. If none of the inputs are booleans, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    object: {\n      doc: "Asserts that the input value is an object. If multiple values are provided, each one is evaluated in order until an object is obtained. If none of the inputs are objects, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    collator: {\n      doc: "Returns a `collator` for use in locale-dependent comparison operations. The `case-sensitive` and `diacritic-sensitive` options default to `false`. The `locale` argument specifies the IETF language tag of the locale to use. If none is provided, the default locale is used. If the requested locale is not available, the `collator` will use a system-defined fallback locale. Use `resolved-locale` to test the results of locale fallback behavior.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    format: {\n      doc: "Returns a `formatted` string for displaying mixed-format text in the `text-field` property. The input may contain a string literal or expression, including an [`\'image\'`](#types-image) expression. Strings may be followed by a style override object that supports the following properties:\\n- `\\"text-font\\"`: Overrides the font stack specified by the root layout property.\\n- `\\"text-color\\"`: Overrides the color specified by the root paint property.\\n- `\\"font-scale\\"`: Applies a scaling factor on `text-size` as specified by the root layout property.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.48.0",\n          android: "6.7.0",\n          ios: "4.6.0",\n          macos: "0.12.0"\n        },\n        "text-font": {\n          js: "0.48.0",\n          android: "6.7.0",\n          ios: "4.6.0",\n          macos: "0.12.0"\n        },\n        "font-scale": {\n          js: "0.48.0",\n          android: "6.7.0",\n          ios: "4.6.0",\n          macos: "0.12.0"\n        },\n        "text-color": {\n          js: "1.3.0",\n          android: "7.3.0",\n          ios: "4.10.0",\n          macos: "0.14.0"\n        },\n        image: {\n          js: "1.6.0",\n          android: "8.6.0",\n          ios: "5.7.0",\n          macos: "0.15.0"\n        }\n      }\n    },\n    image: {\n      doc: "Returns an `image` type for use in `icon-image`, `*-pattern` entries and as a section in the `format` expression. If set, the `image` argument will check that the requested image exists in the style and will return either the resolved image name or `null`, depending on whether or not the image is currently in the style. This validation process is synchronous and requires the image to have been added to the style before requesting it in the `image` argument.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "1.4.0",\n          android: "8.6.0",\n          ios: "5.7.0",\n          macos: "0.15.0"\n        }\n      }\n    },\n    "number-format": {\n      doc: "Converts the input number into a string representation using the providing formatting rules. If set, the `locale` argument specifies the locale to use, as a BCP 47 language tag. If set, the `currency` argument specifies an ISO 4217 code to use for currency-style formatting. If set, the `min-fraction-digits` and `max-fraction-digits` arguments specify the minimum and maximum number of fractional digits to include.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.54.0"\n        }\n      }\n    },\n    "to-string": {\n      doc: "Converts the input value to a string. If the input is `null`, the result is `\\"\\"`. If the input is a boolean, the result is `\\"true\\"` or `\\"false\\"`. If the input is a number, it is converted to a string as specified by the [\\"NumberToString\\" algorithm](https://tc39.github.io/ecma262/#sec-tostring-applied-to-the-number-type) of the ECMAScript Language Specification. If the input is a color, it is converted to a string of the form `\\"rgba(r,g,b,a)\\"`, where `r`, `g`, and `b` are numerals ranging from 0 to 255, and `a` ranges from 0 to 1. Otherwise, the input is converted to a string in the format specified by the [`JSON.stringify`](https://tc39.github.io/ecma262/#sec-json.stringify) function of the ECMAScript Language Specification.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "to-number": {\n      doc: "Converts the input value to a number, if possible. If the input is `null` or `false`, the result is 0. If the input is `true`, the result is 1. If the input is a string, it is converted to a number as specified by the [\\"ToNumber Applied to the String Type\\" algorithm](https://tc39.github.io/ecma262/#sec-tonumber-applied-to-the-string-type) of the ECMAScript Language Specification. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "to-boolean": {\n      doc: "Converts the input value to a boolean. The result is `false` when then input is an empty string, 0, `false`, `null`, or `NaN`; otherwise it is `true`.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "to-rgba": {\n      doc: "Returns a four-element array containing the input color\'s red, green, blue, and alpha components, in that order.",\n      group: "Color",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "to-color": {\n      doc: "Converts the input value to a color. If multiple values are provided, each one is evaluated in order until the first successful conversion is obtained. If none of the inputs can be converted, the expression is an error.",\n      group: "Types",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    rgb: {\n      doc: "Creates a color value from red, green, and blue components, which must range between 0 and 255, and an alpha component of 1. If any component is out of range, the expression is an error.",\n      group: "Color",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    rgba: {\n      doc: "Creates a color value from red, green, blue components, which must range between 0 and 255, and an alpha component which must range between 0 and 1. If any component is out of range, the expression is an error.",\n      group: "Color",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    get: {\n      doc: "Retrieves a property value from the current feature\'s properties, or from another object if a second argument is provided. Returns null if the requested property is missing.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    has: {\n      doc: "Tests for the presence of an property value in the current feature\'s properties, or from another object if a second argument is provided.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    length: {\n      doc: "Gets the length of an array or string.",\n      group: "Lookup",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    properties: {\n      doc: "Gets the feature properties object.  Note that in some cases, it may be more efficient to use [\\"get\\", \\"property_name\\"] directly.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "feature-state": {\n      doc: "Retrieves a property value from the current feature\'s state. Returns null if the requested property is not present on the feature\'s state. A feature\'s state is not part of the GeoJSON or vector tile data, and must be set programmatically on each feature. Features are identified by their `id` attribute, which must be an integer or a string that can be cast to an integer. Note that [\\"feature-state\\"] can only be used with paint properties that support data-driven styling.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.46.0"\n        }\n      }\n    },\n    "geometry-type": {\n      doc: "Gets the feature\'s geometry type: `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    id: {\n      doc: "Gets the feature\'s id, if it has one.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    zoom: {\n      doc: "Gets the current zoom level.  Note that in style layout and paint properties, [\\"zoom\\"] may only appear as the input to a top-level \\"step\\" or \\"interpolate\\" expression.",\n      group: "Zoom",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "heatmap-density": {\n      doc: "Gets the kernel density estimation of a pixel in a heatmap layer, which is a relative measure of how many data points are crowded around a particular pixel. Can only be used in the `heatmap-color` property.",\n      group: "Heatmap",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "line-progress": {\n      doc: "Gets the progress along a gradient line. Can only be used in the `line-gradient` property.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.6.0",\n          macos: "0.12.0"\n        }\n      }\n    },\n    "sky-radial-progress": {\n      doc: "Gets the distance of a point on the sky from the sun position. Returns 0 at sun position and 1 when the distance reaches `sky-gradient-radius`. Can only be used in the `sky-gradient` property.",\n      group: "sky",\n      "sdk-support": {\n        "basic functionality": {\n          js: "2.0.0"\n        }\n      }\n    },\n    accumulated: {\n      doc: "Gets the value of a cluster property accumulated so far. Can only be used in the `clusterProperties` option of a clustered GeoJSON source.",\n      group: "Feature data",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.53.0"\n        }\n      }\n    },\n    "+": {\n      doc: "Returns the sum of the inputs.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "*": {\n      doc: "Returns the product of the inputs.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "-": {\n      doc: "For two inputs, returns the result of subtracting the second input from the first. For a single input, returns the result of subtracting it from 0.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "/": {\n      doc: "Returns the result of floating point division of the first input by the second.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "%": {\n      doc: "Returns the remainder after integer division of the first input by the second.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "^": {\n      doc: "Returns the result of raising the first input to the power specified by the second.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    sqrt: {\n      doc: "Returns the square root of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.42.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    log10: {\n      doc: "Returns the base-ten logarithm of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    ln: {\n      doc: "Returns the natural logarithm of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    log2: {\n      doc: "Returns the base-two logarithm of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    sin: {\n      doc: "Returns the sine of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    cos: {\n      doc: "Returns the cosine of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    tan: {\n      doc: "Returns the tangent of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    asin: {\n      doc: "Returns the arcsine of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    acos: {\n      doc: "Returns the arccosine of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    atan: {\n      doc: "Returns the arctangent of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    min: {\n      doc: "Returns the minimum value of the inputs.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    max: {\n      doc: "Returns the maximum value of the inputs.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    round: {\n      doc: "Rounds the input to the nearest integer. Halfway values are rounded away from zero. For example, `[\\"round\\", -1.5]` evaluates to -2.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    abs: {\n      doc: "Returns the absolute value of the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    ceil: {\n      doc: "Returns the smallest integer that is greater than or equal to the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    floor: {\n      doc: "Returns the largest integer that is less than or equal to the input.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    distance: {\n      doc: "Returns the shortest distance in meters between the evaluated feature and the input geometry. The input value can be a valid GeoJSON of type `Point`, `MultiPoint`, `LineString`, `MultiLineString`, `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Distance values returned may vary in precision due to loss in precision from encoding geometries, particularly below zoom level 13.",\n      group: "Math",\n      "sdk-support": {\n        "basic functionality": {\n          android: "9.2.0",\n          ios: "5.9.0",\n          macos: "0.16.0"\n        }\n      }\n    },\n    "==": {\n      doc: "Returns `true` if the input values are equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    "!=": {\n      doc: "Returns `true` if the input values are not equal, `false` otherwise. The comparison is strictly typed: values of different runtime types are always considered unequal. Cases where the types are known to be different at parse time are considered invalid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    ">": {\n      doc: "Returns `true` if the first input is strictly greater than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    "<": {\n      doc: "Returns `true` if the first input is strictly less than the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    ">=": {\n      doc: "Returns `true` if the first input is greater than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    "<=": {\n      doc: "Returns `true` if the first input is less than or equal to the second, `false` otherwise. The arguments are required to be either both strings or both numbers; if during evaluation they are not, expression evaluation produces an error. Cases where this constraint is known not to hold at parse time are considered in valid and will produce a parse error. Accepts an optional `collator` argument to control locale-dependent string comparisons.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        },\n        collator: {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    },\n    all: {\n      doc: "Returns `true` if all the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `false`, the result is `false` and no further input expressions are evaluated.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    any: {\n      doc: "Returns `true` if any of the inputs are `true`, `false` otherwise. The inputs are evaluated in order, and evaluation is short-circuiting: once an input expression evaluates to `true`, the result is `true` and no further input expressions are evaluated.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "!": {\n      doc: "Logical negation. Returns `true` if the input is `false`, and `false` if the input is `true`.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    within: {\n      doc: "Returns `true` if the evaluated feature is fully contained inside a boundary of the input geometry, `false` otherwise. The input value can be a valid GeoJSON of type `Polygon`, `MultiPolygon`, `Feature`, or `FeatureCollection`. Supported features for evaluation:\\n- `Point`: Returns `false` if a point is on the boundary or falls outside the boundary.\\n- `LineString`: Returns `false` if any part of a line falls outside the boundary, the line intersects the boundary, or a line\'s endpoint is on the boundary.",\n      group: "Decision",\n      "sdk-support": {\n        "basic functionality": {\n          js: "1.9.0",\n          android: "9.1.0",\n          ios: "5.8.0",\n          macos: "0.15.0"\n        }\n      }\n    },\n    "is-supported-script": {\n      doc: "Returns `true` if the input string is expected to render legibly. Returns `false` if the input string contains sections that cannot be rendered without potential loss of meaning (e.g. Indic scripts that require complex text shaping, or right-to-left scripts if the the `mapbox-gl-rtl-text` plugin is not in use in Mapbox GL JS).",\n      group: "String",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.6.0"\n        }\n      }\n    },\n    upcase: {\n      doc: "Returns the input string converted to uppercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",\n      group: "String",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    downcase: {\n      doc: "Returns the input string converted to lowercase. Follows the Unicode Default Case Conversion algorithm and the locale-insensitive case mappings in the Unicode Character Database.",\n      group: "String",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    concat: {\n      doc: "Returns a `string` consisting of the concatenation of the inputs. Each input is converted to a string as if by `to-string`.",\n      group: "String",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.41.0",\n          android: "6.0.0",\n          ios: "4.0.0",\n          macos: "0.7.0"\n        }\n      }\n    },\n    "resolved-locale": {\n      doc: "Returns the IETF language tag of the locale being used by the provided `collator`. This can be used to determine the default system locale, or to determine if a requested locale was successfully loaded.",\n      group: "String",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.45.0",\n          android: "6.5.0",\n          ios: "4.2.0",\n          macos: "0.9.0"\n        }\n      }\n    }\n  }\n};\nvar fog = {\n  range: {\n    type: "array",\n    "default": [0.5, 10],\n    minimum: -20,\n    maximum: 20,\n    length: 2,\n    value: "number",\n    "property-type": "data-constant",\n    transition: true,\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    doc: "The start and end distance range in which fog fades from fully transparent to fully opaque. The distance to the point at the center of the map is defined as zero, so that negative range values are closer to the camera, and positive values are farther away.",\n    example: [0.5, 10],\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.3.0"\n      }\n    }\n  },\n  color: {\n    type: "color",\n    "property-type": "data-constant",\n    "default": "#ffffff",\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    transition: true,\n    doc: "The color of the fog. Using opacity is recommended only for smoothly transitioning fog on/off as anything less than 100% opacity results in more tiles loaded and drawn.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.3.0"\n      }\n    }\n  },\n  "horizon-blend": {\n    type: "number",\n    "property-type": "data-constant",\n    "default": 0.1,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    transition: true,\n    doc: "Horizon blend applies a smooth fade from the color of the fog to the color of the sky. A value of zero leaves a sharp transition from fog to sky. Increasing the value blends the color of fog into increasingly high angles of the sky.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.3.0"\n      }\n    }\n  }\n};\nvar light = {\n  anchor: {\n    type: "enum",\n    "default": "viewport",\n    values: {\n      map: {\n        doc: "The position of the light source is aligned to the rotation of the map."\n      },\n      viewport: {\n        doc: "The position of the light source is aligned to the rotation of the viewport."\n      }\n    },\n    "property-type": "data-constant",\n    transition: false,\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    doc: "Whether extruded geometries are lit relative to the map or viewport.",\n    example: "map",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.27.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    }\n  },\n  position: {\n    type: "array",\n    "default": [1.15, 210, 30],\n    length: 3,\n    value: "number",\n    "property-type": "data-constant",\n    transition: true,\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    doc: "Position of the light source relative to lit (extruded) geometries, in [r radial coordinate, a azimuthal angle, p polar angle] where r indicates the distance from the center of the base of an object to its light, a indicates the position of the light relative to 0° (0° when `light.anchor` is set to `viewport` corresponds to the top of the viewport, or 0° when `light.anchor` is set to `map` corresponds to due north, and degrees proceed clockwise), and p indicates the height of the light (from 0°, directly above, to 180°, directly below).",\n    example: [1.5, 90, 80],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.27.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    }\n  },\n  color: {\n    type: "color",\n    "property-type": "data-constant",\n    "default": "#ffffff",\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    transition: true,\n    doc: "Color tint for lighting extruded geometries.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.27.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    }\n  },\n  intensity: {\n    type: "number",\n    "property-type": "data-constant",\n    "default": 0.5,\n    minimum: 0,\n    maximum: 1,\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    transition: true,\n    doc: "Intensity of lighting (on a scale from 0 to 1). Higher numbers will present as more extreme contrast.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.27.0",\n        android: "5.1.0",\n        ios: "3.6.0",\n        macos: "0.5.0"\n      }\n    }\n  }\n};\nvar terrain = {\n  source: {\n    type: "string",\n    doc: "Name of a source of `raster_dem` type to be used for terrain elevation.",\n    required: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    }\n  },\n  exaggeration: {\n    type: "number",\n    "property-type": "data-constant",\n    "default": 1,\n    minimum: 0,\n    maximum: 1000,\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    transition: true,\n    doc: "Exaggerates the elevation of the terrain by multiplying the data from the DEM with this value.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    }\n  }\n};\nvar paint = ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background", "paint_sky"];\nvar paint_fill = {\n  "fill-antialias": {\n    type: "boolean",\n    "default": true,\n    doc: "Whether or not the fill should be antialiased.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "fill-opacity": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    doc: "The opacity of the entire fill layer. In contrast to the `fill-color`, this value will also affect the 1px stroke around the fill, if the stroke is used.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.21.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "fill-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The color of the filled part of this layer. This color can be specified as `rgba` with an alpha component and the color\'s opacity will not affect the opacity of the 1px stroke, if it is used.",\n    transition: true,\n    requires: [{\n      "!": "fill-pattern"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.19.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "fill-outline-color": {\n    type: "color",\n    doc: "The outline color of the fill. Matches the value of `fill-color` if unspecified.",\n    transition: true,\n    requires: [{\n      "!": "fill-pattern"\n    }, {\n      "fill-antialias": true\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.19.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "fill-translate": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    transition: true,\n    units: "pixels",\n    doc: "The geometry\'s offset. Values are [x, y] where negatives indicate left and up, respectively.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "fill-translate-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The fill is translated relative to the map."\n      },\n      viewport: {\n        doc: "The fill is translated relative to the viewport."\n      }\n    },\n    doc: "Controls the frame of reference for `fill-translate`.",\n    "default": "map",\n    requires: ["fill-translate"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "fill-pattern": {\n    type: "resolvedImage",\n    transition: true,\n    doc: "Name of image in sprite to use for drawing image fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.49.0",\n        android: "6.5.0",\n        macos: "0.11.0",\n        ios: "4.4.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "cross-faded-data-driven"\n  }\n};\nvar paint_line = {\n  "line-opacity": {\n    type: "number",\n    doc: "The opacity at which the line will be drawn.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-color": {\n    type: "color",\n    doc: "The color with which the line will be drawn.",\n    "default": "#000000",\n    transition: true,\n    requires: [{\n      "!": "line-pattern"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.23.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-translate": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    transition: true,\n    units: "pixels",\n    doc: "The geometry\'s offset. Values are [x, y] where negatives indicate left and up, respectively.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "line-translate-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The line is translated relative to the map."\n      },\n      viewport: {\n        doc: "The line is translated relative to the viewport."\n      }\n    },\n    doc: "Controls the frame of reference for `line-translate`.",\n    "default": "map",\n    requires: ["line-translate"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "line-width": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Stroke thickness.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.39.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-gap-width": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    doc: "Draws a line casing outside of a line\'s actual path. Value indicates the width of the inner gap.",\n    transition: true,\n    units: "pixels",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-offset": {\n    type: "number",\n    "default": 0,\n    doc: "The line\'s offset. For linear features, a positive value offsets the line to the right, relative to the direction of the line, and a negative value to the left. For polygon features, a positive value results in an inset, and a negative value results in an outset.",\n    transition: true,\n    units: "pixels",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.12.1",\n        android: "3.0.0",\n        ios: "3.1.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-blur": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Blur applied to the line, in pixels.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "line-dasharray": {\n    type: "array",\n    value: "number",\n    doc: "Specifies the lengths of the alternating dashes and gaps that form the dash pattern. The lengths are later scaled by the line width. To convert a dash length to pixels, multiply the length by the current line width. Note that GeoJSON sources with `lineMetrics: true` specified won\'t render dashed lines to the expected scale. Also note that zoom-dependent expressions will be evaluated only at integer zoom levels.",\n    minimum: 0,\n    transition: true,\n    units: "line widths",\n    requires: [{\n      "!": "line-pattern"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "2.3.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "cross-faded-data-driven"\n  },\n  "line-pattern": {\n    type: "resolvedImage",\n    transition: true,\n    doc: "Name of image in sprite to use for drawing image lines. For seamless patterns, image width must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.49.0",\n        android: "6.5.0",\n        macos: "0.11.0",\n        ios: "4.4.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom", "feature"]\n    },\n    "property-type": "cross-faded-data-driven"\n  },\n  "line-gradient": {\n    type: "color",\n    doc: "Defines a gradient with which to color a line feature. Can only be used with GeoJSON sources that specify `\\"lineMetrics\\": true`.",\n    transition: false,\n    requires: [{\n      "!": "line-dasharray"\n    }, {\n      "!": "line-pattern"\n    }, {\n      source: "geojson",\n      has: {\n        lineMetrics: true\n      }\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.45.0",\n        android: "6.5.0",\n        ios: "4.4.0",\n        macos: "0.11.0"\n      },\n      "data-driven styling": {}\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["line-progress"]\n    },\n    "property-type": "color-ramp"\n  }\n};\nvar paint_circle = {\n  "circle-radius": {\n    type: "number",\n    "default": 5,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Circle radius.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.18.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The fill color of the circle.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.18.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-blur": {\n    type: "number",\n    "default": 0,\n    doc: "Amount to blur the circle. 1 blurs the circle such that only the centerpoint is full opacity.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.20.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-opacity": {\n    type: "number",\n    doc: "The opacity at which the circle will be drawn.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.20.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-translate": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    transition: true,\n    units: "pixels",\n    doc: "The geometry\'s offset. Values are [x, y] where negatives indicate left and up, respectively.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "circle-translate-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The circle is translated relative to the map."\n      },\n      viewport: {\n        doc: "The circle is translated relative to the viewport."\n      }\n    },\n    doc: "Controls the frame of reference for `circle-translate`.",\n    "default": "map",\n    requires: ["circle-translate"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "circle-pitch-scale": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "Circles are scaled according to their apparent distance to the camera."\n      },\n      viewport: {\n        doc: "Circles are not scaled."\n      }\n    },\n    "default": "map",\n    doc: "Controls the scaling behavior of the circle when the map is pitched.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.21.0",\n        android: "4.2.0",\n        ios: "3.4.0",\n        macos: "0.2.1"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "circle-pitch-alignment": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The circle is aligned to the plane of the map."\n      },\n      viewport: {\n        doc: "The circle is aligned to the plane of the viewport."\n      }\n    },\n    "default": "viewport",\n    doc: "Orientation of circle when map is pitched.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.39.0",\n        android: "5.2.0",\n        ios: "3.7.0",\n        macos: "0.6.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "circle-stroke-width": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "The width of the circle\'s stroke. Strokes are placed outside of the `circle-radius`.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-stroke-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The stroke color of the circle.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "circle-stroke-opacity": {\n    type: "number",\n    doc: "The opacity of the circle\'s stroke.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      },\n      "data-driven styling": {\n        js: "0.29.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  }\n};\nvar paint_heatmap = {\n  "heatmap-radius": {\n    type: "number",\n    "default": 30,\n    minimum: 1,\n    transition: true,\n    units: "pixels",\n    doc: "Radius of influence of one heatmap point in pixels. Increasing the value makes the heatmap smoother, but less detailed.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      },\n      "data-driven styling": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "heatmap-weight": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    transition: false,\n    doc: "A measure of how much an individual point contributes to the heatmap. A value of 10 would be equivalent to having 10 points of weight 1 in the same spot. Especially useful when combined with clustering.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      },\n      "data-driven styling": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "heatmap-intensity": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    transition: true,\n    doc: "Similar to `heatmap-weight` but controls the intensity of the heatmap globally. Primarily used for adjusting the heatmap based on zoom level.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "heatmap-color": {\n    type: "color",\n    "default": ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"],\n    doc: "Defines the color of each pixel based on its density value in a heatmap.  Should be an expression that uses `[\\"heatmap-density\\"]` as input.",\n    transition: false,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      },\n      "data-driven styling": {}\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["heatmap-density"]\n    },\n    "property-type": "color-ramp"\n  },\n  "heatmap-opacity": {\n    type: "number",\n    doc: "The global opacity at which the heatmap layer will be drawn.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.41.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar paint_symbol = {\n  "icon-opacity": {\n    doc: "The opacity at which the icon will be drawn.",\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-color": {\n    type: "color",\n    "default": "#000000",\n    transition: true,\n    doc: "The color of the icon. This can only be used with sdf icons.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-halo-color": {\n    type: "color",\n    "default": "rgba(0, 0, 0, 0)",\n    transition: true,\n    doc: "The color of the icon\'s halo. Icon halos can only be used with SDF icons.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-halo-width": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Distance of halo to the icon outline.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-halo-blur": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Fade out the halo towards the outside.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "icon-translate": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    transition: true,\n    units: "pixels",\n    doc: "Distance that the icon\'s anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",\n    requires: ["icon-image"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "icon-translate-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "Icons are translated relative to the map."\n      },\n      viewport: {\n        doc: "Icons are translated relative to the viewport."\n      }\n    },\n    doc: "Controls the frame of reference for `icon-translate`.",\n    "default": "map",\n    requires: ["icon-image", "icon-translate"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-opacity": {\n    type: "number",\n    doc: "The opacity at which the text will be drawn.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-color": {\n    type: "color",\n    doc: "The color with which the text will be drawn.",\n    "default": "#000000",\n    transition: true,\n    overridable: true,\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-halo-color": {\n    type: "color",\n    "default": "rgba(0, 0, 0, 0)",\n    transition: true,\n    doc: "The color of the text\'s halo, which helps it stand out from backgrounds.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-halo-width": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "Distance of halo to the font outline. Max text halo width is 1/4 of the font-size.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-halo-blur": {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    transition: true,\n    units: "pixels",\n    doc: "The halo\'s fadeout distance towards the outside.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {\n        js: "0.33.0",\n        android: "5.0.0",\n        ios: "3.5.0",\n        macos: "0.4.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom", "feature", "feature-state"]\n    },\n    "property-type": "data-driven"\n  },\n  "text-translate": {\n    type: "array",\n    value: "number",\n    length: 2,\n    "default": [0, 0],\n    transition: true,\n    units: "pixels",\n    doc: "Distance that the text\'s anchor is moved from its original placement. Positive values indicate right and down, while negative values indicate left and up.",\n    requires: ["text-field"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "text-translate-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The text is translated relative to the map."\n      },\n      viewport: {\n        doc: "The text is translated relative to the viewport."\n      }\n    },\n    doc: "Controls the frame of reference for `text-translate`.",\n    "default": "map",\n    requires: ["text-field", "text-translate"],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar paint_raster = {\n  "raster-opacity": {\n    type: "number",\n    doc: "The opacity at which the image will be drawn.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-hue-rotate": {\n    type: "number",\n    "default": 0,\n    period: 360,\n    transition: true,\n    units: "degrees",\n    doc: "Rotates hues around the color wheel.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-brightness-min": {\n    type: "number",\n    doc: "Increase or reduce the brightness of the image. The value is the minimum brightness.",\n    "default": 0,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-brightness-max": {\n    type: "number",\n    doc: "Increase or reduce the brightness of the image. The value is the maximum brightness.",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-saturation": {\n    type: "number",\n    doc: "Increase or reduce the saturation of the image.",\n    "default": 0,\n    minimum: -1,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-contrast": {\n    type: "number",\n    doc: "Increase or reduce the contrast of the image.",\n    "default": 0,\n    minimum: -1,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-resampling": {\n    type: "enum",\n    doc: "The resampling/interpolation method to use for overscaling, also known as texture magnification filter",\n    values: {\n      linear: {\n        doc: "(Bi)linear filtering interpolates pixel values using the weighted average of the four closest original source pixels creating a smooth but blurry look when overscaled"\n      },\n      nearest: {\n        doc: "Nearest neighbor filtering interpolates pixel values using the nearest original source pixel creating a sharp but pixelated look when overscaled"\n      }\n    },\n    "default": "linear",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.47.0",\n        android: "6.3.0",\n        ios: "4.2.0",\n        macos: "0.9.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "raster-fade-duration": {\n    type: "number",\n    "default": 300,\n    minimum: 0,\n    transition: false,\n    units: "milliseconds",\n    doc: "Fade duration when a new tile is added.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar paint_hillshade = {\n  "hillshade-illumination-direction": {\n    type: "number",\n    "default": 335,\n    minimum: 0,\n    maximum: 359,\n    doc: "The direction of the light source used to generate the hillshading with 0 as the top of the viewport if `hillshade-illumination-anchor` is set to `viewport` and due north if `hillshade-illumination-anchor` is set to `map`.",\n    transition: false,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "hillshade-illumination-anchor": {\n    type: "enum",\n    values: {\n      map: {\n        doc: "The hillshade illumination is relative to the north direction."\n      },\n      viewport: {\n        doc: "The hillshade illumination is relative to the top of the viewport."\n      }\n    },\n    "default": "viewport",\n    doc: "Direction of light source when map is rotated.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "hillshade-exaggeration": {\n    type: "number",\n    doc: "Intensity of the hillshade",\n    "default": 0.5,\n    minimum: 0,\n    maximum: 1,\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "hillshade-shadow-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The shading color of areas that face away from the light source.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "hillshade-highlight-color": {\n    type: "color",\n    "default": "#FFFFFF",\n    doc: "The shading color of areas that faces towards the light source.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "hillshade-accent-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The shading color used to accentuate rugged terrain like sharp cliffs and gorges.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.43.0",\n        android: "6.0.0",\n        ios: "4.0.0",\n        macos: "0.7.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar paint_background = {\n  "background-color": {\n    type: "color",\n    "default": "#000000",\n    doc: "The color with which the background will be drawn.",\n    transition: true,\n    requires: [{\n      "!": "background-pattern"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "background-pattern": {\n    type: "resolvedImage",\n    transition: true,\n    doc: "Name of image in sprite to use for drawing an image background. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      },\n      "data-driven styling": {}\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "cross-faded"\n  },\n  "background-opacity": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    doc: "The opacity at which the background will be drawn.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "0.10.0",\n        android: "2.0.1",\n        ios: "2.0.0",\n        macos: "0.1.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar paint_sky = {\n  "sky-type": {\n    type: "enum",\n    values: {\n      gradient: {\n        doc: "Renders the sky with a gradient that can be configured with `sky-gradient-radius` and `sky-gradient`."\n      },\n      atmosphere: {\n        doc: "Renders the sky with a simulated atmospheric scattering algorithm, the sun direction can be attached to the light position or explicitly set through `sky-atmosphere-sun`."\n      }\n    },\n    "default": "atmosphere",\n    doc: "The type of the sky",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "sky-atmosphere-sun": {\n    type: "array",\n    value: "number",\n    length: 2,\n    units: "degrees",\n    minimum: [0, 0],\n    maximum: [360, 180],\n    transition: false,\n    doc: "Position of the sun center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the sun relative to 0° north, where degrees proceed clockwise. The polar angle indicates the height of the sun, where 0° is directly above, at zenith, and 90° at the horizon. When this property is ommitted, the sun center is directly inherited from the light position.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    requires: [{\n      "sky-type": "atmosphere"\n    }],\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "sky-atmosphere-sun-intensity": {\n    type: "number",\n    requires: [{\n      "sky-type": "atmosphere"\n    }],\n    "default": 10,\n    minimum: 0,\n    maximum: 100,\n    transition: false,\n    doc: "Intensity of the sun as a light source in the atmosphere (on a scale from 0 to a 100). Setting higher values will brighten up the sky.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    "property-type": "data-constant"\n  },\n  "sky-gradient-center": {\n    type: "array",\n    requires: [{\n      "sky-type": "gradient"\n    }],\n    value: "number",\n    "default": [0, 0],\n    length: 2,\n    units: "degrees",\n    minimum: [0, 0],\n    maximum: [360, 180],\n    transition: false,\n    doc: "Position of the gradient center [a azimuthal angle, p polar angle]. The azimuthal angle indicates the position of the gradient center relative to 0° north, where degrees proceed clockwise. The polar angle indicates the height of the gradient center, where 0° is directly above, at zenith, and 90° at the horizon.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "sky-gradient-radius": {\n    type: "number",\n    requires: [{\n      "sky-type": "gradient"\n    }],\n    "default": 90,\n    minimum: 0,\n    maximum: 180,\n    transition: false,\n    doc: "The angular distance (measured in degrees) from `sky-gradient-center` up to which the gradient extends. A value of 180 causes the gradient to wrap around to the opposite direction from `sky-gradient-center`.",\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    expression: {\n      interpolated: false,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  },\n  "sky-gradient": {\n    type: "color",\n    "default": ["interpolate", ["linear"], ["sky-radial-progress"], 0.8, "#87ceeb", 1, "white"],\n    doc: "Defines a radial color gradient with which to color the sky. The color values can be interpolated with an expression using `sky-radial-progress`. The range [0, 1] for the interpolant covers a radial distance (in degrees) of [0, `sky-gradient-radius`] centered at the position specified by `sky-gradient-center`.",\n    transition: false,\n    requires: [{\n      "sky-type": "gradient"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      },\n      "data-driven styling": {}\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["sky-radial-progress"]\n    },\n    "property-type": "color-ramp"\n  },\n  "sky-atmosphere-halo-color": {\n    type: "color",\n    "default": "white",\n    doc: "A color applied to the atmosphere sun halo. The alpha channel describes how strongly the sun halo is represented in an atmosphere sky layer.",\n    transition: false,\n    requires: [{\n      "sky-type": "atmosphere"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    "property-type": "data-constant"\n  },\n  "sky-atmosphere-color": {\n    type: "color",\n    "default": "white",\n    doc: "A color used to tweak the main atmospheric scattering coefficients. Using white applies the default coefficients giving the natural blue color to the atmosphere. This color affects how heavily the corresponding wavelength is represented during scattering. The alpha channel describes the density of the atmosphere, with 1 maximum density and 0 no density.",\n    transition: false,\n    requires: [{\n      "sky-type": "atmosphere"\n    }],\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    "property-type": "data-constant"\n  },\n  "sky-opacity": {\n    type: "number",\n    "default": 1,\n    minimum: 0,\n    maximum: 1,\n    doc: "The opacity of the entire sky layer.",\n    transition: true,\n    "sdk-support": {\n      "basic functionality": {\n        js: "2.0.0"\n      }\n    },\n    expression: {\n      interpolated: true,\n      parameters: ["zoom"]\n    },\n    "property-type": "data-constant"\n  }\n};\nvar transition = {\n  duration: {\n    type: "number",\n    "default": 300,\n    minimum: 0,\n    units: "milliseconds",\n    doc: "Time allotted for transitions to complete."\n  },\n  delay: {\n    type: "number",\n    "default": 0,\n    minimum: 0,\n    units: "milliseconds",\n    doc: "Length of time before a transition begins."\n  }\n};\nvar promoteId = {\n  "*": {\n    type: "string",\n    doc: "A name of a feature property to use as ID for feature state."\n  }\n};\nvar v8 = {\n  $version: $version,\n  $root: $root,\n  sources: sources,\n  source: source,\n  source_vector: source_vector,\n  source_raster: source_raster,\n  source_raster_dem: source_raster_dem,\n  source_geojson: source_geojson,\n  source_video: source_video,\n  source_image: source_image,\n  layer: layer,\n  layout: layout,\n  layout_background: layout_background,\n  layout_sky: layout_sky,\n  layout_fill: layout_fill,\n  layout_circle: layout_circle,\n  layout_heatmap: layout_heatmap,\n  "layout_fill-extrusion": {\n    visibility: {\n      type: "enum",\n      values: {\n        visible: {\n          doc: "The layer is shown."\n        },\n        none: {\n          doc: "The layer is not shown."\n        }\n      },\n      "default": "visible",\n      doc: "Whether this layer is displayed.",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      "property-type": "constant"\n    }\n  },\n  layout_line: layout_line,\n  layout_symbol: layout_symbol,\n  layout_raster: layout_raster,\n  layout_hillshade: layout_hillshade,\n  filter: filter,\n  filter_operator: filter_operator,\n  geometry_type: geometry_type,\n  "function": {\n    expression: {\n      type: "expression",\n      doc: "An expression."\n    },\n    stops: {\n      type: "array",\n      doc: "An array of stops.",\n      value: "function_stop"\n    },\n    base: {\n      type: "number",\n      "default": 1,\n      minimum: 0,\n      doc: "The exponential base of the interpolation curve. It controls the rate at which the result increases. Higher values make the result increase more towards the high end of the range. With `1` the stops are interpolated linearly."\n    },\n    property: {\n      type: "string",\n      doc: "The name of a feature property to use as the function input.",\n      "default": "$zoom"\n    },\n    type: {\n      type: "enum",\n      values: {\n        identity: {\n          doc: "Return the input value as the output value."\n        },\n        exponential: {\n          doc: "Generate an output by interpolating between stops just less than and just greater than the function input."\n        },\n        interval: {\n          doc: "Return the output value of the stop just less than the function input."\n        },\n        categorical: {\n          doc: "Return the output value of the stop equal to the function input."\n        }\n      },\n      doc: "The interpolation strategy to use in function evaluation.",\n      "default": "exponential"\n    },\n    colorSpace: {\n      type: "enum",\n      values: {\n        rgb: {\n          doc: "Use the RGB color space to interpolate color values"\n        },\n        lab: {\n          doc: "Use the LAB color space to interpolate color values."\n        },\n        hcl: {\n          doc: "Use the HCL color space to interpolate color values, interpolating the Hue, Chroma, and Luminance channels individually."\n        }\n      },\n      doc: "The color space in which colors interpolated. Interpolating colors in perceptual color spaces like LAB and HCL tend to produce color ramps that look more consistent and produce colors that can be differentiated more easily than those interpolated in RGB space.",\n      "default": "rgb"\n    },\n    "default": {\n      type: "*",\n      required: false,\n      doc: "A value to serve as a fallback function result when a value isn\'t otherwise available. It is used in the following circumstances:\\n* In categorical functions, when the feature value does not match any of the stop domain values.\\n* In property and zoom-and-property functions, when a feature does not contain a value for the specified property.\\n* In identity functions, when the feature value is not valid for the style property (for example, if the function is being used for a `circle-color` property but the feature property value is not a string or not a valid color).\\n* In interval or exponential property and zoom-and-property functions, when the feature value is not numeric.\\nIf no default is provided, the style property\'s default is used in these circumstances."\n    }\n  },\n  function_stop: function_stop,\n  expression: expression,\n  expression_name: expression_name,\n  fog: fog,\n  light: light,\n  terrain: terrain,\n  paint: paint,\n  paint_fill: paint_fill,\n  "paint_fill-extrusion": {\n    "fill-extrusion-opacity": {\n      type: "number",\n      "default": 1,\n      minimum: 0,\n      maximum: 1,\n      doc: "The opacity of the entire fill extrusion layer. This is rendered on a per-layer, not per-feature, basis, and data-driven styling is not available.",\n      transition: true,\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: true,\n        parameters: ["zoom"]\n      },\n      "property-type": "data-constant"\n    },\n    "fill-extrusion-color": {\n      type: "color",\n      "default": "#000000",\n      doc: "The base color of the extruded fill. The extrusion\'s surfaces will be shaded differently based on this color in combination with the root `light` settings. If this color is specified as `rgba` with an alpha component, the alpha component will be ignored; use `fill-extrusion-opacity` to set layer opacity.",\n      transition: true,\n      requires: [{\n        "!": "fill-extrusion-pattern"\n      }],\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        },\n        "data-driven styling": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: true,\n        parameters: ["zoom", "feature", "feature-state"]\n      },\n      "property-type": "data-driven"\n    },\n    "fill-extrusion-translate": {\n      type: "array",\n      value: "number",\n      length: 2,\n      "default": [0, 0],\n      transition: true,\n      units: "pixels",\n      doc: "The geometry\'s offset. Values are [x, y] where negatives indicate left and up (on the flat plane), respectively.",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: true,\n        parameters: ["zoom"]\n      },\n      "property-type": "data-constant"\n    },\n    "fill-extrusion-translate-anchor": {\n      type: "enum",\n      values: {\n        map: {\n          doc: "The fill extrusion is translated relative to the map."\n        },\n        viewport: {\n          doc: "The fill extrusion is translated relative to the viewport."\n        }\n      },\n      doc: "Controls the frame of reference for `fill-extrusion-translate`.",\n      "default": "map",\n      requires: ["fill-extrusion-translate"],\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: false,\n        parameters: ["zoom"]\n      },\n      "property-type": "data-constant"\n    },\n    "fill-extrusion-pattern": {\n      type: "resolvedImage",\n      transition: true,\n      doc: "Name of image in sprite to use for drawing images on extruded fills. For seamless patterns, image width and height must be a factor of two (2, 4, 8, ..., 512). Note that zoom-dependent expressions will be evaluated only at integer zoom levels.",\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        },\n        "data-driven styling": {\n          js: "0.49.0",\n          android: "6.5.0",\n          macos: "0.11.0",\n          ios: "4.4.0"\n        }\n      },\n      expression: {\n        interpolated: false,\n        parameters: ["zoom", "feature"]\n      },\n      "property-type": "cross-faded-data-driven"\n    },\n    "fill-extrusion-height": {\n      type: "number",\n      "default": 0,\n      minimum: 0,\n      units: "meters",\n      doc: "The height with which to extrude this layer.",\n      transition: true,\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        },\n        "data-driven styling": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: true,\n        parameters: ["zoom", "feature", "feature-state"]\n      },\n      "property-type": "data-driven"\n    },\n    "fill-extrusion-base": {\n      type: "number",\n      "default": 0,\n      minimum: 0,\n      units: "meters",\n      doc: "The height with which to extrude the base of this layer. Must be less than or equal to `fill-extrusion-height`.",\n      transition: true,\n      requires: ["fill-extrusion-height"],\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        },\n        "data-driven styling": {\n          js: "0.27.0",\n          android: "5.1.0",\n          ios: "3.6.0",\n          macos: "0.5.0"\n        }\n      },\n      expression: {\n        interpolated: true,\n        parameters: ["zoom", "feature", "feature-state"]\n      },\n      "property-type": "data-driven"\n    },\n    "fill-extrusion-vertical-gradient": {\n      type: "boolean",\n      "default": true,\n      doc: "Whether to apply a vertical gradient to the sides of a fill-extrusion layer. If true, sides will be shaded slightly darker farther down.",\n      transition: false,\n      "sdk-support": {\n        "basic functionality": {\n          js: "0.50.0",\n          ios: "4.7.0",\n          macos: "0.13.0"\n        }\n      },\n      expression: {\n        interpolated: false,\n        parameters: ["zoom"]\n      },\n      "property-type": "data-constant"\n    }\n  },\n  paint_line: paint_line,\n  paint_circle: paint_circle,\n  paint_heatmap: paint_heatmap,\n  paint_symbol: paint_symbol,\n  paint_raster: paint_raster,\n  paint_hillshade: paint_hillshade,\n  paint_background: paint_background,\n  paint_sky: paint_sky,\n  transition: transition,\n  "property-type": {\n    "data-driven": {\n      type: "property-type",\n      doc: "Property is interpolable and can be represented using a property expression."\n    },\n    "cross-faded": {\n      type: "property-type",\n      doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms."\n    },\n    "cross-faded-data-driven": {\n      type: "property-type",\n      doc: "Property is non-interpolable; rather, its values will be cross-faded to smoothly transition between integer zooms. It can be represented using a property expression."\n    },\n    "color-ramp": {\n      type: "property-type",\n      doc: "Property should be specified using a color ramp from which the output color can be sampled based on a property calculation."\n    },\n    "data-constant": {\n      type: "property-type",\n      doc: "Property is interpolable but cannot be represented using a property expression."\n    },\n    constant: {\n      type: "property-type",\n      doc: "Property is constant across all zoom levels and property values."\n    }\n  },\n  promoteId: promoteId\n}; // Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\n\nvar stringOrChar = /("(?:[^\\\\"]|\\\\.)*")|[:,]/g;\n\nvar jsonStringifyPrettyCompact = function stringify(passedObj, options) {\n  var indent, maxLength, replacer;\n  options = options || {};\n  indent = JSON.stringify([1], undefined, options.indent === undefined ? 2 : options.indent).slice(2, -3);\n  maxLength = indent === "" ? Infinity : options.maxLength === undefined ? 80 : options.maxLength;\n  replacer = options.replacer;\n  return function _stringify(obj, currentIndent, reserved) {\n    // prettier-ignore\n    var end, index, items, key, keyPart, keys, length, nextIndent, prettified, start, string, value;\n\n    if (obj && typeof obj.toJSON === "function") {\n      obj = obj.toJSON();\n    }\n\n    string = JSON.stringify(obj, replacer);\n\n    if (string === undefined) {\n      return string;\n    }\n\n    length = maxLength - currentIndent.length - reserved;\n\n    if (string.length <= length) {\n      prettified = string.replace(stringOrChar, function (match, stringLiteral) {\n        return stringLiteral || match + " ";\n      });\n\n      if (prettified.length <= length) {\n        return prettified;\n      }\n    }\n\n    if (replacer != null) {\n      obj = JSON.parse(string);\n      replacer = undefined;\n    }\n\n    if (typeof obj === "object" && obj !== null) {\n      nextIndent = currentIndent + indent;\n      items = [];\n      index = 0;\n\n      if (Array.isArray(obj)) {\n        start = "[";\n        end = "]";\n        length = obj.length;\n\n        for (; index < length; index++) {\n          items.push(_stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) || "null");\n        }\n      } else {\n        start = "{";\n        end = "}";\n        keys = Object.keys(obj);\n        length = keys.length;\n\n        for (; index < length; index++) {\n          key = keys[index];\n          keyPart = JSON.stringify(key) + ": ";\n          value = _stringify(obj[key], nextIndent, keyPart.length + (index === length - 1 ? 0 : 1));\n\n          if (value !== undefined) {\n            items.push(keyPart + value);\n          }\n        }\n      }\n\n      if (items.length > 0) {\n        return [start, indent + items.join(",\\n" + nextIndent), end].join("\\n" + currentIndent);\n      }\n    }\n\n    return string;\n  }(passedObj, "", 0);\n};\n\nfunction sortKeysBy(obj, reference) {\n  var result = {};\n\n  for (var key in reference) {\n    if (obj[key] !== undefined) {\n      result[key] = obj[key];\n    }\n  }\n\n  for (var _key in obj) {\n    if (result[_key] === undefined) {\n      result[_key] = obj[_key];\n    }\n  }\n\n  return result;\n}\n\nfunction format(style) {\n  var space = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  style = sortKeysBy(style, v8.$root);\n\n  if (style.layers) {\n    style.layers = style.layers.map(function (layer) {\n      return sortKeysBy(layer, v8.layer);\n    });\n  }\n\n  return jsonStringifyPrettyCompact(style, {\n    indent: space\n  });\n}\n\nvar commonjsGlobal = typeof globalThis !== \'undefined\' ? globalThis : typeof window !== \'undefined\' ? window : typeof __webpack_require__.g !== \'undefined\' ? __webpack_require__.g : typeof self !== \'undefined\' ? self : {};\n\nfunction createCommonjsModule(fn) {\n  var module = {\n    exports: {}\n  };\n  return fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire(target) {\n  throw new Error(\'Could not dynamically require "\' + target + \'". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.\');\n}\n/*! https://mths.be/punycode v1.3.2 by @mathias */\n\n\nvar punycode = createCommonjsModule(function (module, exports) {\n  (function (root) {\n    /** Detect free variables */\n    var freeExports = exports && !exports.nodeType && exports;\n    var freeModule = module && !module.nodeType && module;\n    var freeGlobal = typeof commonjsGlobal == \'object\' && commonjsGlobal;\n\n    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n      root = freeGlobal;\n    }\n    /**\n     * The `punycode` object.\n     * @name punycode\n     * @type Object\n     */\n\n\n    var punycode,\n\n    /** Highest positive signed 32-bit float value */\n    maxInt = 2147483647,\n        // aka. 0x7FFFFFFF or 2^31-1\n\n    /** Bootstring parameters */\n    base = 36,\n        tMin = 1,\n        tMax = 26,\n        skew = 38,\n        damp = 700,\n        initialBias = 72,\n        initialN = 128,\n        // 0x80\n    delimiter = \'-\',\n        // \'\\x2D\'\n\n    /** Regular expressions */\n    regexPunycode = /^xn--/,\n        regexNonASCII = /[^\\x20-\\x7E]/,\n        // unprintable ASCII chars + non-ASCII chars\n    regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n        // RFC 3490 separators\n\n    /** Error messages */\n    errors = {\n      \'overflow\': \'Overflow: input needs wider integers to process\',\n      \'not-basic\': \'Illegal input >= 0x80 (not a basic code point)\',\n      \'invalid-input\': \'Invalid input\'\n    },\n\n    /** Convenience shortcuts */\n    baseMinusTMin = base - tMin,\n        floor = Math.floor,\n        stringFromCharCode = String.fromCharCode,\n\n    /** Temporary variable */\n    key;\n    /*--------------------------------------------------------------------------*/\n\n    /**\n     * A generic error utility function.\n     * @private\n     * @param {String} type The error type.\n     * @returns {Error} Throws a `RangeError` with the applicable error message.\n     */\n\n    function error(type) {\n      throw RangeError(errors[type]);\n    }\n    /**\n     * A generic `Array#map` utility function.\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} callback The function that gets called for every array\n     * item.\n     * @returns {Array} A new array of values returned by the callback function.\n     */\n\n\n    function map(array, fn) {\n      var length = array.length;\n      var result = [];\n\n      while (length--) {\n        result[length] = fn(array[length]);\n      }\n\n      return result;\n    }\n    /**\n     * A simple `Array#map`-like wrapper to work with domain name strings or email\n     * addresses.\n     * @private\n     * @param {String} domain The domain name or email address.\n     * @param {Function} callback The function that gets called for every\n     * character.\n     * @returns {Array} A new string of characters returned by the callback\n     * function.\n     */\n\n\n    function mapDomain(string, fn) {\n      var parts = string.split(\'@\');\n      var result = \'\';\n\n      if (parts.length > 1) {\n        // In email addresses, only the domain name should be punycoded. Leave\n        // the local part (i.e. everything up to `@`) intact.\n        result = parts[0] + \'@\';\n        string = parts[1];\n      } // Avoid `split(regex)` for IE8 compatibility. See #17.\n\n\n      string = string.replace(regexSeparators, \'\\x2E\');\n      var labels = string.split(\'.\');\n      var encoded = map(labels, fn).join(\'.\');\n      return result + encoded;\n    }\n    /**\n     * Creates an array containing the numeric code points of each Unicode\n     * character in the string. While JavaScript uses UCS-2 internally,\n     * this function will convert a pair of surrogate halves (each of which\n     * UCS-2 exposes as separate characters) into a single code point,\n     * matching UTF-16.\n     * @see `punycode.ucs2.encode`\n     * @see <https://mathiasbynens.be/notes/javascript-encoding>\n     * @memberOf punycode.ucs2\n     * @name decode\n     * @param {String} string The Unicode input string (UCS-2).\n     * @returns {Array} The new array of code points.\n     */\n\n\n    function ucs2decode(string) {\n      var output = [],\n          counter = 0,\n          length = string.length,\n          value,\n          extra;\n\n      while (counter < length) {\n        value = string.charCodeAt(counter++);\n\n        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n          // high surrogate, and there is a next character\n          extra = string.charCodeAt(counter++);\n\n          if ((extra & 0xFC00) == 0xDC00) {\n            // low surrogate\n            output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n          } else {\n            // unmatched surrogate; only append this code unit, in case the next\n            // code unit is the high surrogate of a surrogate pair\n            output.push(value);\n            counter--;\n          }\n        } else {\n          output.push(value);\n        }\n      }\n\n      return output;\n    }\n    /**\n     * Creates a string based on an array of numeric code points.\n     * @see `punycode.ucs2.decode`\n     * @memberOf punycode.ucs2\n     * @name encode\n     * @param {Array} codePoints The array of numeric code points.\n     * @returns {String} The new Unicode string (UCS-2).\n     */\n\n\n    function ucs2encode(array) {\n      return map(array, function (value) {\n        var output = \'\';\n\n        if (value > 0xFFFF) {\n          value -= 0x10000;\n          output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n          value = 0xDC00 | value & 0x3FF;\n        }\n\n        output += stringFromCharCode(value);\n        return output;\n      }).join(\'\');\n    }\n    /**\n     * Converts a basic code point into a digit/integer.\n     * @see `digitToBasic()`\n     * @private\n     * @param {Number} codePoint The basic numeric code point value.\n     * @returns {Number} The numeric value of a basic code point (for use in\n     * representing integers) in the range `0` to `base - 1`, or `base` if\n     * the code point does not represent a value.\n     */\n\n\n    function basicToDigit(codePoint) {\n      if (codePoint - 48 < 10) {\n        return codePoint - 22;\n      }\n\n      if (codePoint - 65 < 26) {\n        return codePoint - 65;\n      }\n\n      if (codePoint - 97 < 26) {\n        return codePoint - 97;\n      }\n\n      return base;\n    }\n    /**\n     * Converts a digit/integer into a basic code point.\n     * @see `basicToDigit()`\n     * @private\n     * @param {Number} digit The numeric value of a basic code point.\n     * @returns {Number} The basic code point whose value (when used for\n     * representing integers) is `digit`, which needs to be in the range\n     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n     * used; else, the lowercase form is used. The behavior is undefined\n     * if `flag` is non-zero and `digit` has no uppercase form.\n     */\n\n\n    function digitToBasic(digit, flag) {\n      //  0..25 map to ASCII a..z or A..Z\n      // 26..35 map to ASCII 0..9\n      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n    }\n    /**\n     * Bias adaptation function as per section 3.4 of RFC 3492.\n     * http://tools.ietf.org/html/rfc3492#section-3.4\n     * @private\n     */\n\n\n    function adapt(delta, numPoints, firstTime) {\n      var k = 0;\n      delta = firstTime ? floor(delta / damp) : delta >> 1;\n      delta += floor(delta / numPoints);\n\n      for (;\n      /* no initialization */\n      delta > baseMinusTMin * tMax >> 1; k += base) {\n        delta = floor(delta / baseMinusTMin);\n      }\n\n      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n    }\n    /**\n     * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n     * symbols.\n     * @memberOf punycode\n     * @param {String} input The Punycode string of ASCII-only symbols.\n     * @returns {String} The resulting string of Unicode symbols.\n     */\n\n\n    function decode(input) {\n      // Don\'t use UCS-2\n      var output = [],\n          inputLength = input.length,\n          out,\n          i = 0,\n          n = initialN,\n          bias = initialBias,\n          basic,\n          j,\n          index,\n          oldi,\n          w,\n          k,\n          digit,\n          t,\n\n      /** Cached calculation results */\n      baseMinusT; // Handle the basic code points: let `basic` be the number of input code\n      // points before the last delimiter, or `0` if there is none, then copy\n      // the first basic code points to the output.\n\n      basic = input.lastIndexOf(delimiter);\n\n      if (basic < 0) {\n        basic = 0;\n      }\n\n      for (j = 0; j < basic; ++j) {\n        // if it\'s not a basic code point\n        if (input.charCodeAt(j) >= 0x80) {\n          error(\'not-basic\');\n        }\n\n        output.push(input.charCodeAt(j));\n      } // Main decoding loop: start just after the last delimiter if any basic code\n      // points were copied; start at the beginning otherwise.\n\n\n      for (index = basic > 0 ? basic + 1 : 0; index < inputLength;)\n      /* no final expression */\n      {\n        // `index` is the index of the next character to be consumed.\n        // Decode a generalized variable-length integer into `delta`,\n        // which gets added to `i`. The overflow checking is easier\n        // if we increase `i` as we go, then subtract off its starting\n        // value at the end to obtain `delta`.\n        for (oldi = i, w = 1, k = base;;\n        /* no condition */\n        k += base) {\n          if (index >= inputLength) {\n            error(\'invalid-input\');\n          }\n\n          digit = basicToDigit(input.charCodeAt(index++));\n\n          if (digit >= base || digit > floor((maxInt - i) / w)) {\n            error(\'overflow\');\n          }\n\n          i += digit * w;\n          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n          if (digit < t) {\n            break;\n          }\n\n          baseMinusT = base - t;\n\n          if (w > floor(maxInt / baseMinusT)) {\n            error(\'overflow\');\n          }\n\n          w *= baseMinusT;\n        }\n\n        out = output.length + 1;\n        bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,\n        // incrementing `n` each time, so we\'ll fix that now:\n\n        if (floor(i / out) > maxInt - n) {\n          error(\'overflow\');\n        }\n\n        n += floor(i / out);\n        i %= out; // Insert `n` at position `i` of the output\n\n        output.splice(i++, 0, n);\n      }\n\n      return ucs2encode(output);\n    }\n    /**\n     * Converts a string of Unicode symbols (e.g. a domain name label) to a\n     * Punycode string of ASCII-only symbols.\n     * @memberOf punycode\n     * @param {String} input The string of Unicode symbols.\n     * @returns {String} The resulting Punycode string of ASCII-only symbols.\n     */\n\n\n    function encode(input) {\n      var n,\n          delta,\n          handledCPCount,\n          basicLength,\n          bias,\n          j,\n          m,\n          q,\n          k,\n          t,\n          currentValue,\n          output = [],\n\n      /** `inputLength` will hold the number of code points in `input`. */\n      inputLength,\n\n      /** Cached calculation results */\n      handledCPCountPlusOne,\n          baseMinusT,\n          qMinusT; // Convert the input in UCS-2 to Unicode\n\n      input = ucs2decode(input); // Cache the length\n\n      inputLength = input.length; // Initialize the state\n\n      n = initialN;\n      delta = 0;\n      bias = initialBias; // Handle the basic code points\n\n      for (j = 0; j < inputLength; ++j) {\n        currentValue = input[j];\n\n        if (currentValue < 0x80) {\n          output.push(stringFromCharCode(currentValue));\n        }\n      }\n\n      handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;\n      // `basicLength` is the number of basic code points.\n      // Finish the basic string - if it is not empty - with a delimiter\n\n      if (basicLength) {\n        output.push(delimiter);\n      } // Main encoding loop:\n\n\n      while (handledCPCount < inputLength) {\n        // All non-basic code points < n have been handled already. Find the next\n        // larger one:\n        for (m = maxInt, j = 0; j < inputLength; ++j) {\n          currentValue = input[j];\n\n          if (currentValue >= n && currentValue < m) {\n            m = currentValue;\n          }\n        } // Increase `delta` enough to advance the decoder\'s <n,i> state to <m,0>,\n        // but guard against overflow\n\n\n        handledCPCountPlusOne = handledCPCount + 1;\n\n        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n          error(\'overflow\');\n        }\n\n        delta += (m - n) * handledCPCountPlusOne;\n        n = m;\n\n        for (j = 0; j < inputLength; ++j) {\n          currentValue = input[j];\n\n          if (currentValue < n && ++delta > maxInt) {\n            error(\'overflow\');\n          }\n\n          if (currentValue == n) {\n            // Represent delta as a generalized variable-length integer\n            for (q = delta, k = base;;\n            /* no condition */\n            k += base) {\n              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n              if (q < t) {\n                break;\n              }\n\n              qMinusT = q - t;\n              baseMinusT = base - t;\n              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n              q = floor(qMinusT / baseMinusT);\n            }\n\n            output.push(stringFromCharCode(digitToBasic(q, 0)));\n            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n            delta = 0;\n            ++handledCPCount;\n          }\n        }\n\n        ++delta;\n        ++n;\n      }\n\n      return output.join(\'\');\n    }\n    /**\n     * Converts a Punycode string representing a domain name or an email address\n     * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n     * it doesn\'t matter if you call it on a string that has already been\n     * converted to Unicode.\n     * @memberOf punycode\n     * @param {String} input The Punycoded domain name or email address to\n     * convert to Unicode.\n     * @returns {String} The Unicode representation of the given Punycode\n     * string.\n     */\n\n\n    function toUnicode(input) {\n      return mapDomain(input, function (string) {\n        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n      });\n    }\n    /**\n     * Converts a Unicode string representing a domain name or an email address to\n     * Punycode. Only the non-ASCII parts of the domain name will be converted,\n     * i.e. it doesn\'t matter if you call it with a domain that\'s already in\n     * ASCII.\n     * @memberOf punycode\n     * @param {String} input The domain name or email address to convert, as a\n     * Unicode string.\n     * @returns {String} The Punycode representation of the given domain name or\n     * email address.\n     */\n\n\n    function toASCII(input) {\n      return mapDomain(input, function (string) {\n        return regexNonASCII.test(string) ? \'xn--\' + encode(string) : string;\n      });\n    }\n    /*--------------------------------------------------------------------------*/\n\n    /** Define the public API */\n\n\n    punycode = {\n      /**\n       * A string representing the current Punycode.js version number.\n       * @memberOf punycode\n       * @type String\n       */\n      \'version\': \'1.3.2\',\n\n      /**\n       * An object of methods to convert from JavaScript\'s internal character\n       * representation (UCS-2) to Unicode code points, and back.\n       * @see <https://mathiasbynens.be/notes/javascript-encoding>\n       * @memberOf punycode\n       * @type Object\n       */\n      \'ucs2\': {\n        \'decode\': ucs2decode,\n        \'encode\': ucs2encode\n      },\n      \'decode\': decode,\n      \'encode\': encode,\n      \'toASCII\': toASCII,\n      \'toUnicode\': toUnicode\n    };\n    /** Expose `punycode` */\n    // Some AMD build optimizers, like r.js, check for specific condition patterns\n    // like the following:\n\n    if (freeExports && freeModule) {\n      if (module.exports == freeExports) {\n        // in Node.js or RingoJS v0.8.0+\n        freeModule.exports = punycode;\n      } else {\n        // in Narwhal or RingoJS v0.7.0-\n        for (key in punycode) {\n          punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n        }\n      }\n    } else {\n      // in Rhino or a web browser\n      root.punycode = punycode;\n    }\n  })(commonjsGlobal);\n});\nvar util = {\n  isString: function isString(arg) {\n    return typeof arg === \'string\';\n  },\n  isObject: function isObject(arg) {\n    return typeof arg === \'object\' && arg !== null;\n  },\n  isNull: function isNull(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function isNullOrUndefined(arg) {\n    return arg == null;\n  }\n}; // Copyright Joyent, Inc. and other Node contributors.\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar decode = function decode(qs, sep, eq, options) {\n  sep = sep || \'&\';\n  eq = eq || \'=\';\n  var obj = {};\n\n  if (typeof qs !== \'string\' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n  var maxKeys = 1000;\n\n  if (options && typeof options.maxKeys === \'number\') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count\n\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, \'%20\'),\n        idx = x.indexOf(eq),\n        kstr,\n        vstr,\n        k,\n        v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = \'\';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n}; // Copyright Joyent, Inc. and other Node contributors.\n\n\nvar stringifyPrimitive = function stringifyPrimitive(v) {\n  switch (typeof v) {\n    case \'string\':\n      return v;\n\n    case \'boolean\':\n      return v ? \'true\' : \'false\';\n\n    case \'number\':\n      return isFinite(v) ? v : \'\';\n\n    default:\n      return \'\';\n  }\n};\n\nvar encode = function encode(obj, sep, eq, name) {\n  sep = sep || \'&\';\n  eq = eq || \'=\';\n\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === \'object\') {\n    return Object.keys(obj).map(function (k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function (v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n  }\n\n  if (!name) return \'\';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar querystring = createCommonjsModule(function (module, exports) {\n  exports.decode = exports.parse = decode;\n  exports.encode = exports.stringify = encode;\n});\nvar parse = urlParse;\nvar resolve = urlResolve;\nvar resolveObject = urlResolveObject;\nvar format$1 = urlFormat;\nvar Url_1 = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n} // Reference: RFC 3986, RFC 1808, RFC 2396\n// define these here so at least they only have to be\n// compiled once on the first module load.\n\n\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n    // Special case for a simple path URL\nsimplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n    // RFC 2396: characters reserved for delimiting URLs.\n// We actually just auto-escape these.\ndelims = [\'<\', \'>\', \'"\', \'`\', \' \', \'\\r\', \'\\n\', \'\\t\'],\n    // RFC 2396: characters not allowed for various reasons.\nunwise = [\'{\', \'}\', \'|\', \'\\\\\', \'^\', \'`\'].concat(delims),\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\nautoEscape = [\'\\\'\'].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n// Note that any invalid chars are also handled, but these\n// are the ones that are *expected* to be seen, so we fast-path\n// them.\nnonHostChars = [\'%\', \'/\', \'?\', \';\', \'#\'].concat(autoEscape),\n    hostEndingChars = [\'/\', \'?\', \'#\'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow "unsafe" and "unwise" chars.\nunsafeProtocol = {\n  \'javascript\': true,\n  \'javascript:\': true\n},\n    // protocols that never have a hostname.\nhostlessProtocol = {\n  \'javascript\': true,\n  \'javascript:\': true\n},\n    // protocols that always contain a // bit.\nslashedProtocol = {\n  \'http\': true,\n  \'https\': true,\n  \'ftp\': true,\n  \'gopher\': true,\n  \'file\': true,\n  \'http:\': true,\n  \'https:\': true,\n  \'ftp:\': true,\n  \'gopher:\': true,\n  \'file:\': true\n};\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n  var u = new Url();\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError("Parameter \'url\' must be a string, not " + typeof url);\n  } // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n\n\n  var queryIndex = url.indexOf(\'?\'),\n      splitter = queryIndex !== -1 && queryIndex < url.indexOf(\'#\') ? \'?\' : \'#\',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, \'/\');\n  url = uSplit.join(splitter);\n  var rest = url; // trim before proceeding.\n  // This is to support parse stuff like "  http://foo.com  \\n"\n\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split(\'#\').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = \'\';\n        this.query = {};\n      }\n\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  } // figure out if it\'s got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that\'s\n  // how the browser resolves relative URLs.\n\n\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === \'//\';\n\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n    // there\'s a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n    } // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n\n\n    var auth, atSign;\n\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf(\'@\');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf(\'@\', hostEnd);\n    } // Now we have a portion which is definitely the auth.\n    // Pull that off.\n\n\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    } // the host is the remaining to the left of the first non-host char\n\n\n    hostEnd = -1;\n\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n    } // if we still have not hit it, then the entire thing is a host.\n\n\n    if (hostEnd === -1) hostEnd = rest.length;\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd); // pull out port.\n\n    this.parseHost(); // we\'ve indicated that there is a hostname,\n    // so even if it\'s empty, it has to be present.\n\n    this.hostname = this.hostname || \'\'; // if hostname begins with [ and ends with ]\n    // assume that it\'s an IPv6 address.\n\n    var ipv6Hostname = this.hostname[0] === \'[\' && this.hostname[this.hostname.length - 1] === \']\'; // validate a little.\n\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = \'\';\n\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += \'x\';\n            } else {\n              newpart += part[j];\n            }\n          } // we test again with ASCII char only\n\n\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n\n            if (notHost.length) {\n              rest = \'/\' + notHost.join(\'.\') + rest;\n            }\n\n            this.hostname = validParts.join(\'.\');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = \'\';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of "domain".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn\'t matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? \':\' + this.port : \'\';\n    var h = this.hostname || \'\';\n    this.host = h + p;\n    this.href += this.host; // strip [ and ] from the hostname\n    // the host field still retains them, though\n\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n\n      if (rest[0] !== \'/\') {\n        rest = \'/\' + rest;\n      }\n    }\n  } // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n\n\n  if (!unsafeProtocol[lowerProto]) {\n    // First, make 100% sure that any "autoEscape" chars get\n    // escaped, even if encodeURIComponent doesn\'t think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1) continue;\n      var esc = encodeURIComponent(ae);\n\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n\n      rest = rest.split(ae).join(esc);\n    }\n  } // chop off from the tail first.\n\n\n  var hash = rest.indexOf(\'#\');\n\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n\n  var qm = rest.indexOf(\'?\');\n\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = \'\';\n    this.query = {};\n  }\n\n  if (rest) this.pathname = rest;\n\n  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n    this.pathname = \'/\';\n  } //to support http.request\n\n\n  if (this.pathname || this.search) {\n    var p = this.pathname || \'\';\n    var s = this.search || \'\';\n    this.path = p + s;\n  } // finally, reconstruct the href based on what has been validated.\n\n\n  this.href = this.format();\n  return this;\n}; // format a parsed object into a url string\n\n\nfunction urlFormat(obj) {\n  // ensure it\'s an object, and not a string url.\n  // If it\'s an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function () {\n  var auth = this.auth || \'\';\n\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, \':\');\n    auth += \'@\';\n  }\n\n  var protocol = this.protocol || \'\',\n      pathname = this.pathname || \'\',\n      hash = this.hash || \'\',\n      host = false,\n      query = \'\';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(\':\') === -1 ? this.hostname : \'[\' + this.hostname + \']\');\n\n    if (this.port) {\n      host += \':\' + this.port;\n    }\n  }\n\n  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || query && \'?\' + query || \'\';\n  if (protocol && protocol.substr(-1) !== \':\') protocol += \':\'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n\n  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = \'//\' + (host || \'\');\n    if (pathname && pathname.charAt(0) !== \'/\') pathname = \'/\' + pathname;\n  } else if (!host) {\n    host = \'\';\n  }\n\n  if (hash && hash.charAt(0) !== \'#\') hash = \'#\' + hash;\n  if (search && search.charAt(0) !== \'?\') search = \'?\' + search;\n  pathname = pathname.replace(/[?#]/g, function (match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace(\'#\', \'%23\');\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function (relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function (relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  } // hash is always overridden, no matter what.\n  // even href="" will remove it.\n\n\n  result.hash = relative.hash; // if the relative url is empty, then there\'s nothing left to do here.\n\n  if (relative.href === \'\') {\n    result.href = result.format();\n    return result;\n  } // hrefs like //foo/bar always cut to the protocol.\n\n\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== \'protocol\') result[rkey] = relative[rkey];\n    } //urlParse appends trailing / to urls like http://www.example.com\n\n\n    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n      result.path = result.pathname = \'/\';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it\'s a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it\'s not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that\'s known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || \'\').split(\'/\');\n\n      while (relPath.length && !(relative.host = relPath.shift())) {\n        ;\n      }\n\n      if (!relative.host) relative.host = \'\';\n      if (!relative.hostname) relative.hostname = \'\';\n      if (relPath[0] !== \'\') relPath.unshift(\'\');\n      if (relPath.length < 2) relPath.unshift(\'\');\n      result.pathname = relPath.join(\'/\');\n    } else {\n      result.pathname = relative.pathname;\n    }\n\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || \'\';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port; // to support http.request\n\n    if (result.pathname || result.search) {\n      var p = result.pathname || \'\';\n      var s = result.search || \'\';\n      result.path = p + s;\n    }\n\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = result.pathname && result.pathname.charAt(0) === \'/\',\n      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === \'/\',\n      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split(\'/\') || [],\n      relPath = relative.pathname && relative.pathname.split(\'/\') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n\n  if (psychotic) {\n    result.hostname = \'\';\n    result.port = null;\n\n    if (result.host) {\n      if (srcPath[0] === \'\') srcPath[0] = result.host;else srcPath.unshift(result.host);\n    }\n\n    result.host = \'\';\n\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n\n      if (relative.host) {\n        if (relPath[0] === \'\') relPath[0] = relative.host;else relPath.unshift(relative.host);\n      }\n\n      relative.host = null;\n    }\n\n    mustEndAbs = mustEndAbs && (relPath[0] === \'\' || srcPath[0] === \'\');\n  }\n\n  if (isRelAbs) {\n    // it\'s absolute.\n    result.host = relative.host || relative.host === \'\' ? relative.host : result.host;\n    result.hostname = relative.hostname || relative.hostname === \'\' ? relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath; // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it\'s relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href=\'?foo\'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject(\'mailto:local1@domain1\', \'local2@domain2\')\n\n      var authInHost = result.host && result.host.indexOf(\'@\') > 0 ? result.host.split(\'@\') : false;\n\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n\n    result.search = relative.search;\n    result.query = relative.query; //to support http.request\n\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : \'\') + (result.search ? result.search : \'\');\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we\'ve already handled the other stuff above.\n    result.pathname = null; //to support http.request\n\n    if (result.search) {\n      result.path = \'/\' + result.search;\n    } else {\n      result.path = null;\n    }\n\n    result.href = result.format();\n    return result;\n  } // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n\n\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === \'.\' || last === \'..\') || last === \'\'; // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n\n  var up = 0;\n\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n\n    if (last === \'.\') {\n      srcPath.splice(i, 1);\n    } else if (last === \'..\') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  } // if the path is allowed to go above the root, restore leading ..s\n\n\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift(\'..\');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== \'\' && (!srcPath[0] || srcPath[0].charAt(0) !== \'/\')) {\n    srcPath.unshift(\'\');\n  }\n\n  if (hasTrailingSlash && srcPath.join(\'/\').substr(-1) !== \'/\') {\n    srcPath.push(\'\');\n  }\n\n  var isAbsolute = srcPath[0] === \'\' || srcPath[0] && srcPath[0].charAt(0) === \'/\'; // put the host back\n\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? \'\' : srcPath.length ? srcPath.shift() : \'\'; //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject(\'mailto:local1@domain1\', \'local2@domain2\')\n\n    var authInHost = result.host && result.host.indexOf(\'@\') > 0 ? result.host.split(\'@\') : false;\n\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift(\'\');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join(\'/\');\n  } //to support request.http\n\n\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : \'\') + (result.search ? result.search : \'\');\n  }\n\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function () {\n  var host = this.host;\n  var port = portPattern.exec(host);\n\n  if (port) {\n    port = port[0];\n\n    if (port !== \':\') {\n      this.port = port.substr(1);\n    }\n\n    host = host.substr(0, host.length - port.length);\n  }\n\n  if (host) this.hostname = host;\n};\n\nvar url = {\n  parse: parse,\n  resolve: resolve,\n  resolveObject: resolveObject,\n  format: format$1,\n  Url: Url_1\n};\n\nfunction getPropertyReference(propertyName) {\n  for (var i = 0; i < v8.layout.length; i++) {\n    for (var key in v8[v8.layout[i]]) {\n      if (key === propertyName) return v8[v8.layout[i]][key];\n    }\n  }\n\n  for (var _i = 0; _i < v8.paint.length; _i++) {\n    for (var _key2 in v8[v8.paint[_i]]) {\n      if (_key2 === propertyName) return v8[v8.paint[_i]][_key2];\n    }\n  }\n\n  return null;\n}\n\nfunction eachSource(style, callback) {\n  for (var k in style.sources) {\n    callback(style.sources[k]);\n  }\n}\n\nfunction eachLayer(style, callback) {\n  var _iterator = _createForOfIteratorHelper(style.layers),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _layer = _step.value;\n      callback(_layer);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction eachProperty(style, options, callback) {\n  function inner(layer, propertyType) {\n    var properties = layer[propertyType];\n    if (!properties) return;\n    Object.keys(properties).forEach(function (key) {\n      callback({\n        path: [layer.id, propertyType, key],\n        key: key,\n        value: properties[key],\n        reference: getPropertyReference(key),\n        set: function set(x) {\n          properties[key] = x;\n        }\n      });\n    });\n  }\n\n  eachLayer(style, function (layer) {\n    if (options.paint) {\n      inner(layer, \'paint\');\n    }\n\n    if (options.layout) {\n      inner(layer, \'layout\');\n    }\n  });\n}\n\nfunction eachLayout(layer, callback) {\n  for (var k in layer) {\n    if (k.indexOf(\'layout\') === 0) {\n      callback(layer[k], k);\n    }\n  }\n}\n\nfunction eachPaint(layer, callback) {\n  for (var k in layer) {\n    if (k.indexOf(\'paint\') === 0) {\n      callback(layer[k], k);\n    }\n  }\n}\n\nfunction resolveConstant(style, value) {\n  if (typeof value === \'string\' && value[0] === \'@\') {\n    return resolveConstant(style, style.constants[value]);\n  } else {\n    return value;\n  }\n}\n\nfunction isFunction(value) {\n  return Array.isArray(value.stops);\n}\n\nfunction renameProperty(obj, from, to) {\n  obj[to] = obj[from];\n  delete obj[from];\n}\n\nfunction migrateToV8(style) {\n  style.version = 8;\n  eachSource(style, function (source) {\n    if (source.type === \'video\' && source.url !== undefined) {\n      renameProperty(source, \'url\', \'urls\');\n    }\n\n    if (source.type === \'video\') {\n      source.coordinates.forEach(function (coord) {\n        return coord.reverse();\n      });\n    }\n  });\n  eachLayer(style, function (layer) {\n    eachLayout(layer, function (layout) {\n      if (layout[\'symbol-min-distance\'] !== undefined) {\n        renameProperty(layout, \'symbol-min-distance\', \'symbol-spacing\');\n      }\n    });\n    eachPaint(layer, function (paint) {\n      if (paint[\'background-image\'] !== undefined) {\n        renameProperty(paint, \'background-image\', \'background-pattern\');\n      }\n\n      if (paint[\'line-image\'] !== undefined) {\n        renameProperty(paint, \'line-image\', \'line-pattern\');\n      }\n\n      if (paint[\'fill-image\'] !== undefined) {\n        renameProperty(paint, \'fill-image\', \'fill-pattern\');\n      }\n    });\n  });\n  eachProperty(style, {\n    paint: true,\n    layout: true\n  }, function (property) {\n    var value = resolveConstant(style, property.value);\n\n    if (isFunction(value)) {\n      value.stops.forEach(function (stop) {\n        stop[1] = resolveConstant(style, stop[1]);\n      });\n    }\n\n    property.set(value);\n  });\n  delete style.constants;\n  eachLayer(style, function (layer) {\n    eachLayout(layer, function (layout) {\n      delete layout[\'text-max-size\'];\n      delete layout[\'icon-max-size\'];\n    });\n    eachPaint(layer, function (paint) {\n      if (paint[\'text-size\']) {\n        if (!layer.layout) layer.layout = {};\n        layer.layout[\'text-size\'] = paint[\'text-size\'];\n        delete paint[\'text-size\'];\n      }\n\n      if (paint[\'icon-size\']) {\n        if (!layer.layout) layer.layout = {};\n        layer.layout[\'icon-size\'] = paint[\'icon-size\'];\n        delete paint[\'icon-size\'];\n      }\n    });\n  });\n\n  function migrateFontstackURL(input) {\n    var inputParsed = url.parse(input);\n    var inputPathnameParts = inputParsed.pathname.split(\'/\');\n\n    if (inputParsed.protocol !== \'mapbox:\') {\n      return input;\n    } else if (inputParsed.hostname === \'fontstack\') {\n      return \'mapbox://fonts/mapbox/{fontstack}/{range}.pbf\';\n    } else if (inputParsed.hostname === \'fonts\') {\n      return "mapbox://fonts/".concat(inputPathnameParts[2], "/{fontstack}/{range}.pbf");\n    } else ;\n  }\n\n  if (style.glyphs) {\n    style.glyphs = migrateFontstackURL(style.glyphs);\n  }\n\n  function migrateFontStack(font) {\n    function splitAndTrim(string) {\n      return string.split(\',\').map(function (s) {\n        return s.trim();\n      });\n    }\n\n    if (Array.isArray(font)) {\n      return font;\n    } else if (typeof font === \'string\') {\n      return splitAndTrim(font);\n    } else if (typeof font === \'object\') {\n      font.stops.forEach(function (stop) {\n        stop[1] = splitAndTrim(stop[1]);\n      });\n      return font;\n    } else {\n      throw new Error(\'unexpected font value\');\n    }\n  }\n\n  eachLayer(style, function (layer) {\n    eachLayout(layer, function (layout) {\n      if (layout[\'text-font\']) {\n        layout[\'text-font\'] = migrateFontStack(layout[\'text-font\']);\n      }\n    });\n  });\n  var firstSymbolLayer = 0;\n\n  for (var i = style.layers.length - 1; i >= 0; i--) {\n    var _layer2 = style.layers[i];\n\n    if (_layer2.type !== \'symbol\') {\n      firstSymbolLayer = i + 1;\n      break;\n    }\n  }\n\n  var symbolLayers = style.layers.splice(firstSymbolLayer);\n  symbolLayers.reverse();\n  style.layers = style.layers.concat(symbolLayers);\n  return style;\n}\n\nfunction extend(output) {\n  for (var _len = arguments.length, inputs = new Array(_len > 1 ? _len - 1 : 0), _key3 = 1; _key3 < _len; _key3++) {\n    inputs[_key3 - 1] = arguments[_key3];\n  }\n\n  for (var _i2 = 0, _inputs = inputs; _i2 < _inputs.length; _i2++) {\n    var input = _inputs[_i2];\n\n    for (var k in input) {\n      output[k] = input[k];\n    }\n  }\n\n  return output;\n}\n\nvar ParsingError = /*#__PURE__*/function (_Error) {\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z)(ParsingError, _Error);\n\n  var _super = _createSuper(ParsingError);\n\n  function ParsingError(key, message) {\n    var _this;\n\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ParsingError);\n\n    _this = _super.call(this, message);\n    _this.message = message;\n    _this.key = key;\n    return _this;\n  }\n\n  return ParsingError;\n}( /*#__PURE__*/(0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_4__/* .default */ .Z)(Error));\n\nvar Scope = /*#__PURE__*/function () {\n  function Scope(parent) {\n    var bindings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Scope);\n\n    this.parent = parent;\n    this.bindings = {};\n\n    var _iterator2 = _createForOfIteratorHelper(bindings),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step2.value, 2),\n            name = _step2$value[0],\n            _expression = _step2$value[1];\n\n        this.bindings[name] = _expression;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Scope, [{\n    key: "concat",\n    value: function concat(bindings) {\n      return new Scope(this, bindings);\n    }\n  }, {\n    key: "get",\n    value: function get(name) {\n      if (this.bindings[name]) {\n        return this.bindings[name];\n      }\n\n      if (this.parent) {\n        return this.parent.get(name);\n      }\n\n      throw new Error("".concat(name, " not found in scope."));\n    }\n  }, {\n    key: "has",\n    value: function has(name) {\n      if (this.bindings[name]) return true;\n      return this.parent ? this.parent.has(name) : false;\n    }\n  }]);\n\n  return Scope;\n}();\n\nvar NullType = {\n  kind: \'null\'\n};\nvar NumberType = {\n  kind: \'number\'\n};\nvar StringType = {\n  kind: \'string\'\n};\nvar BooleanType = {\n  kind: \'boolean\'\n};\nvar ColorType = {\n  kind: \'color\'\n};\nvar ObjectType = {\n  kind: \'object\'\n};\nvar ValueType = {\n  kind: \'value\'\n};\nvar ErrorType = {\n  kind: \'error\'\n};\nvar CollatorType = {\n  kind: \'collator\'\n};\nvar FormattedType = {\n  kind: \'formatted\'\n};\nvar ResolvedImageType = {\n  kind: \'resolvedImage\'\n};\n\nfunction array(itemType, N) {\n  return {\n    kind: \'array\',\n    itemType: itemType,\n    N: N\n  };\n}\n\nfunction toString(type) {\n  if (type.kind === \'array\') {\n    var itemType = toString(type.itemType);\n    return typeof type.N === \'number\' ? "array<".concat(itemType, ", ").concat(type.N, ">") : type.itemType.kind === \'value\' ? \'array\' : "array<".concat(itemType, ">");\n  } else {\n    return type.kind;\n  }\n}\n\nvar valueMemberTypes = [NullType, NumberType, StringType, BooleanType, ColorType, FormattedType, ObjectType, array(ValueType), ResolvedImageType];\n\nfunction _checkSubtype(expected, t) {\n  if (t.kind === \'error\') {\n    return null;\n  } else if (expected.kind === \'array\') {\n    if (t.kind === \'array\' && (t.N === 0 && t.itemType.kind === \'value\' || !_checkSubtype(expected.itemType, t.itemType)) && (typeof expected.N !== \'number\' || expected.N === t.N)) {\n      return null;\n    }\n  } else if (expected.kind === t.kind) {\n    return null;\n  } else if (expected.kind === \'value\') {\n    var _iterator3 = _createForOfIteratorHelper(valueMemberTypes),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var memberType = _step3.value;\n\n        if (!_checkSubtype(memberType, t)) {\n          return null;\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  return "Expected ".concat(toString(expected), " but found ").concat(toString(t), " instead.");\n}\n\nfunction isValidType(provided, allowedTypes) {\n  return allowedTypes.some(function (t) {\n    return t.kind === provided.kind;\n  });\n}\n\nfunction isValidNativeType(provided, allowedTypes) {\n  return allowedTypes.some(function (t) {\n    if (t === \'null\') {\n      return provided === null;\n    } else if (t === \'array\') {\n      return Array.isArray(provided);\n    } else if (t === \'object\') {\n      return provided && !Array.isArray(provided) && typeof provided === \'object\';\n    } else {\n      return t === typeof provided;\n    }\n  });\n}\n\nvar csscolorparser = createCommonjsModule(function (module, exports) {\n  // (c) Dean McNamee <dean@gmail.com>, 2012.\n  //\n  // https://github.com/deanm/css-color-parser-js\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a copy\n  // of this software and associated documentation files (the "Software"), to\n  // deal in the Software without restriction, including without limitation the\n  // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n  // sell copies of the Software, and to permit persons to whom the Software is\n  // furnished to do so, subject to the following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included in\n  // all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n  // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n  // IN THE SOFTWARE.\n  // http://www.w3.org/TR/css3-color/\n  var kCSSColorTable = {\n    "transparent": [0, 0, 0, 0],\n    "aliceblue": [240, 248, 255, 1],\n    "antiquewhite": [250, 235, 215, 1],\n    "aqua": [0, 255, 255, 1],\n    "aquamarine": [127, 255, 212, 1],\n    "azure": [240, 255, 255, 1],\n    "beige": [245, 245, 220, 1],\n    "bisque": [255, 228, 196, 1],\n    "black": [0, 0, 0, 1],\n    "blanchedalmond": [255, 235, 205, 1],\n    "blue": [0, 0, 255, 1],\n    "blueviolet": [138, 43, 226, 1],\n    "brown": [165, 42, 42, 1],\n    "burlywood": [222, 184, 135, 1],\n    "cadetblue": [95, 158, 160, 1],\n    "chartreuse": [127, 255, 0, 1],\n    "chocolate": [210, 105, 30, 1],\n    "coral": [255, 127, 80, 1],\n    "cornflowerblue": [100, 149, 237, 1],\n    "cornsilk": [255, 248, 220, 1],\n    "crimson": [220, 20, 60, 1],\n    "cyan": [0, 255, 255, 1],\n    "darkblue": [0, 0, 139, 1],\n    "darkcyan": [0, 139, 139, 1],\n    "darkgoldenrod": [184, 134, 11, 1],\n    "darkgray": [169, 169, 169, 1],\n    "darkgreen": [0, 100, 0, 1],\n    "darkgrey": [169, 169, 169, 1],\n    "darkkhaki": [189, 183, 107, 1],\n    "darkmagenta": [139, 0, 139, 1],\n    "darkolivegreen": [85, 107, 47, 1],\n    "darkorange": [255, 140, 0, 1],\n    "darkorchid": [153, 50, 204, 1],\n    "darkred": [139, 0, 0, 1],\n    "darksalmon": [233, 150, 122, 1],\n    "darkseagreen": [143, 188, 143, 1],\n    "darkslateblue": [72, 61, 139, 1],\n    "darkslategray": [47, 79, 79, 1],\n    "darkslategrey": [47, 79, 79, 1],\n    "darkturquoise": [0, 206, 209, 1],\n    "darkviolet": [148, 0, 211, 1],\n    "deeppink": [255, 20, 147, 1],\n    "deepskyblue": [0, 191, 255, 1],\n    "dimgray": [105, 105, 105, 1],\n    "dimgrey": [105, 105, 105, 1],\n    "dodgerblue": [30, 144, 255, 1],\n    "firebrick": [178, 34, 34, 1],\n    "floralwhite": [255, 250, 240, 1],\n    "forestgreen": [34, 139, 34, 1],\n    "fuchsia": [255, 0, 255, 1],\n    "gainsboro": [220, 220, 220, 1],\n    "ghostwhite": [248, 248, 255, 1],\n    "gold": [255, 215, 0, 1],\n    "goldenrod": [218, 165, 32, 1],\n    "gray": [128, 128, 128, 1],\n    "green": [0, 128, 0, 1],\n    "greenyellow": [173, 255, 47, 1],\n    "grey": [128, 128, 128, 1],\n    "honeydew": [240, 255, 240, 1],\n    "hotpink": [255, 105, 180, 1],\n    "indianred": [205, 92, 92, 1],\n    "indigo": [75, 0, 130, 1],\n    "ivory": [255, 255, 240, 1],\n    "khaki": [240, 230, 140, 1],\n    "lavender": [230, 230, 250, 1],\n    "lavenderblush": [255, 240, 245, 1],\n    "lawngreen": [124, 252, 0, 1],\n    "lemonchiffon": [255, 250, 205, 1],\n    "lightblue": [173, 216, 230, 1],\n    "lightcoral": [240, 128, 128, 1],\n    "lightcyan": [224, 255, 255, 1],\n    "lightgoldenrodyellow": [250, 250, 210, 1],\n    "lightgray": [211, 211, 211, 1],\n    "lightgreen": [144, 238, 144, 1],\n    "lightgrey": [211, 211, 211, 1],\n    "lightpink": [255, 182, 193, 1],\n    "lightsalmon": [255, 160, 122, 1],\n    "lightseagreen": [32, 178, 170, 1],\n    "lightskyblue": [135, 206, 250, 1],\n    "lightslategray": [119, 136, 153, 1],\n    "lightslategrey": [119, 136, 153, 1],\n    "lightsteelblue": [176, 196, 222, 1],\n    "lightyellow": [255, 255, 224, 1],\n    "lime": [0, 255, 0, 1],\n    "limegreen": [50, 205, 50, 1],\n    "linen": [250, 240, 230, 1],\n    "magenta": [255, 0, 255, 1],\n    "maroon": [128, 0, 0, 1],\n    "mediumaquamarine": [102, 205, 170, 1],\n    "mediumblue": [0, 0, 205, 1],\n    "mediumorchid": [186, 85, 211, 1],\n    "mediumpurple": [147, 112, 219, 1],\n    "mediumseagreen": [60, 179, 113, 1],\n    "mediumslateblue": [123, 104, 238, 1],\n    "mediumspringgreen": [0, 250, 154, 1],\n    "mediumturquoise": [72, 209, 204, 1],\n    "mediumvioletred": [199, 21, 133, 1],\n    "midnightblue": [25, 25, 112, 1],\n    "mintcream": [245, 255, 250, 1],\n    "mistyrose": [255, 228, 225, 1],\n    "moccasin": [255, 228, 181, 1],\n    "navajowhite": [255, 222, 173, 1],\n    "navy": [0, 0, 128, 1],\n    "oldlace": [253, 245, 230, 1],\n    "olive": [128, 128, 0, 1],\n    "olivedrab": [107, 142, 35, 1],\n    "orange": [255, 165, 0, 1],\n    "orangered": [255, 69, 0, 1],\n    "orchid": [218, 112, 214, 1],\n    "palegoldenrod": [238, 232, 170, 1],\n    "palegreen": [152, 251, 152, 1],\n    "paleturquoise": [175, 238, 238, 1],\n    "palevioletred": [219, 112, 147, 1],\n    "papayawhip": [255, 239, 213, 1],\n    "peachpuff": [255, 218, 185, 1],\n    "peru": [205, 133, 63, 1],\n    "pink": [255, 192, 203, 1],\n    "plum": [221, 160, 221, 1],\n    "powderblue": [176, 224, 230, 1],\n    "purple": [128, 0, 128, 1],\n    "rebeccapurple": [102, 51, 153, 1],\n    "red": [255, 0, 0, 1],\n    "rosybrown": [188, 143, 143, 1],\n    "royalblue": [65, 105, 225, 1],\n    "saddlebrown": [139, 69, 19, 1],\n    "salmon": [250, 128, 114, 1],\n    "sandybrown": [244, 164, 96, 1],\n    "seagreen": [46, 139, 87, 1],\n    "seashell": [255, 245, 238, 1],\n    "sienna": [160, 82, 45, 1],\n    "silver": [192, 192, 192, 1],\n    "skyblue": [135, 206, 235, 1],\n    "slateblue": [106, 90, 205, 1],\n    "slategray": [112, 128, 144, 1],\n    "slategrey": [112, 128, 144, 1],\n    "snow": [255, 250, 250, 1],\n    "springgreen": [0, 255, 127, 1],\n    "steelblue": [70, 130, 180, 1],\n    "tan": [210, 180, 140, 1],\n    "teal": [0, 128, 128, 1],\n    "thistle": [216, 191, 216, 1],\n    "tomato": [255, 99, 71, 1],\n    "turquoise": [64, 224, 208, 1],\n    "violet": [238, 130, 238, 1],\n    "wheat": [245, 222, 179, 1],\n    "white": [255, 255, 255, 1],\n    "whitesmoke": [245, 245, 245, 1],\n    "yellow": [255, 255, 0, 1],\n    "yellowgreen": [154, 205, 50, 1]\n  };\n\n  function clamp_css_byte(i) {\n    // Clamp to integer 0 .. 255.\n    i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n    return i < 0 ? 0 : i > 255 ? 255 : i;\n  }\n\n  function clamp_css_float(f) {\n    // Clamp to float 0.0 .. 1.0.\n    return f < 0 ? 0 : f > 1 ? 1 : f;\n  }\n\n  function parse_css_int(str) {\n    // int or percentage.\n    if (str[str.length - 1] === \'%\') return clamp_css_byte(parseFloat(str) / 100 * 255);\n    return clamp_css_byte(parseInt(str));\n  }\n\n  function parse_css_float(str) {\n    // float or percentage.\n    if (str[str.length - 1] === \'%\') return clamp_css_float(parseFloat(str) / 100);\n    return clamp_css_float(parseFloat(str));\n  }\n\n  function css_hue_to_rgb(m1, m2, h) {\n    if (h < 0) h += 1;else if (h > 1) h -= 1;\n    if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;\n    if (h * 2 < 1) return m2;\n    if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n    return m1;\n  }\n\n  function parseCSSColor(css_str) {\n    // Remove all whitespace, not compliant, but should just be more accepting.\n    var str = css_str.replace(/ /g, \'\').toLowerCase(); // Color keywords (and transparent) lookup.\n\n    if (str in kCSSColorTable) return kCSSColorTable[str].slice(); // dup.\n    // #abc and #abc123 syntax.\n\n    if (str[0] === \'#\') {\n      if (str.length === 4) {\n        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n        if (!(iv >= 0 && iv <= 0xfff)) return null; // Covers NaN.\n\n        return [(iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1];\n      } else if (str.length === 7) {\n        var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n        if (!(iv >= 0 && iv <= 0xffffff)) return null; // Covers NaN.\n\n        return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];\n      }\n\n      return null;\n    }\n\n    var op = str.indexOf(\'(\'),\n        ep = str.indexOf(\')\');\n\n    if (op !== -1 && ep + 1 === str.length) {\n      var fname = str.substr(0, op);\n      var params = str.substr(op + 1, ep - (op + 1)).split(\',\');\n      var alpha = 1; // To allow case fallthrough.\n\n      switch (fname) {\n        case \'rgba\':\n          if (params.length !== 4) return null;\n          alpha = parse_css_float(params.pop());\n        // Fall through.\n\n        case \'rgb\':\n          if (params.length !== 3) return null;\n          return [parse_css_int(params[0]), parse_css_int(params[1]), parse_css_int(params[2]), alpha];\n\n        case \'hsla\':\n          if (params.length !== 4) return null;\n          alpha = parse_css_float(params.pop());\n        // Fall through.\n\n        case \'hsl\':\n          if (params.length !== 3) return null;\n          var h = (parseFloat(params[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n          // NOTE(deanm): According to the CSS spec s/l should only be\n          // percentages, but we don\'t bother and let float or percentage.\n\n          var s = parse_css_float(params[1]);\n          var l = parse_css_float(params[2]);\n          var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n          var m1 = l * 2 - m2;\n          return [clamp_css_byte(css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255), clamp_css_byte(css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];\n\n        default:\n          return null;\n      }\n    }\n\n    return null;\n  }\n\n  try {\n    exports.parseCSSColor = parseCSSColor;\n  } catch (e) {}\n});\n\nvar Color = /*#__PURE__*/function () {\n  function Color(r, g, b) {\n    var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Color);\n\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    this.a = a;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Color, [{\n    key: "toString",\n    value: function toString() {\n      var _this$toArray = this.toArray(),\n          _this$toArray2 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_this$toArray, 4),\n          r = _this$toArray2[0],\n          g = _this$toArray2[1],\n          b = _this$toArray2[2],\n          a = _this$toArray2[3];\n\n      return "rgba(".concat(Math.round(r), ",").concat(Math.round(g), ",").concat(Math.round(b), ",").concat(a, ")");\n    }\n  }, {\n    key: "toArray",\n    value: function toArray() {\n      var r = this.r,\n          g = this.g,\n          b = this.b,\n          a = this.a;\n      return a === 0 ? [0, 0, 0, 0] : [r * 255 / a, g * 255 / a, b * 255 / a, a];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(input) {\n      if (!input) {\n        return undefined;\n      }\n\n      if (input instanceof Color) {\n        return input;\n      }\n\n      if (typeof input !== \'string\') {\n        return undefined;\n      }\n\n      var rgba = csscolorparser.parseCSSColor(input);\n\n      if (!rgba) {\n        return undefined;\n      }\n\n      return new Color(rgba[0] / 255 * rgba[3], rgba[1] / 255 * rgba[3], rgba[2] / 255 * rgba[3], rgba[3]);\n    }\n  }]);\n\n  return Color;\n}();\n\nColor.black = new Color(0, 0, 0, 1);\nColor.white = new Color(1, 1, 1, 1);\nColor.transparent = new Color(0, 0, 0, 0);\nColor.red = new Color(1, 0, 0, 1);\nColor.blue = new Color(0, 0, 1, 1);\n\nvar Collator = /*#__PURE__*/function () {\n  function Collator(caseSensitive, diacriticSensitive, locale) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Collator);\n\n    if (caseSensitive) this.sensitivity = diacriticSensitive ? \'variant\' : \'case\';else this.sensitivity = diacriticSensitive ? \'accent\' : \'base\';\n    this.locale = locale;\n    this.collator = new Intl.Collator(this.locale ? this.locale : [], {\n      sensitivity: this.sensitivity,\n      usage: \'search\'\n    });\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Collator, [{\n    key: "compare",\n    value: function compare(lhs, rhs) {\n      return this.collator.compare(lhs, rhs);\n    }\n  }, {\n    key: "resolvedLocale",\n    value: function resolvedLocale() {\n      return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;\n    }\n  }]);\n\n  return Collator;\n}();\n\nvar FormattedSection = function FormattedSection(text, image, scale, fontStack, textColor) {\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, FormattedSection);\n\n  this.text = text;\n  this.image = image;\n  this.scale = scale;\n  this.fontStack = fontStack;\n  this.textColor = textColor;\n};\n\nvar Formatted = /*#__PURE__*/function () {\n  function Formatted(sections) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Formatted);\n\n    this.sections = sections;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Formatted, [{\n    key: "isEmpty",\n    value: function isEmpty() {\n      if (this.sections.length === 0) return true;\n      return !this.sections.some(function (section) {\n        return section.text.length !== 0 || section.image && section.image.name.length !== 0;\n      });\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      if (this.sections.length === 0) return \'\';\n      return this.sections.map(function (section) {\n        return section.text;\n      }).join(\'\');\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'format\'];\n\n      var _iterator4 = _createForOfIteratorHelper(this.sections),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var section = _step4.value;\n\n          if (section.image) {\n            serialized.push([\'image\', section.image.name]);\n            continue;\n          }\n\n          serialized.push(section.text);\n          var options = {};\n\n          if (section.fontStack) {\n            options[\'text-font\'] = [\'literal\', section.fontStack.split(\',\')];\n          }\n\n          if (section.scale) {\n            options[\'font-scale\'] = section.scale;\n          }\n\n          if (section.textColor) {\n            options[\'text-color\'] = [\'rgba\'].concat(section.textColor.toArray());\n          }\n\n          serialized.push(options);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return serialized;\n    }\n  }], [{\n    key: "fromString",\n    value: function fromString(unformatted) {\n      return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);\n    }\n  }, {\n    key: "factory",\n    value: function factory(text) {\n      if (text instanceof Formatted) {\n        return text;\n      } else {\n        return Formatted.fromString(text);\n      }\n    }\n  }]);\n\n  return Formatted;\n}();\n\nvar ResolvedImage = /*#__PURE__*/function () {\n  function ResolvedImage(options) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ResolvedImage);\n\n    this.name = options.name;\n    this.available = options.available;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(ResolvedImage, [{\n    key: "toString",\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'image\', this.name];\n    }\n  }], [{\n    key: "fromString",\n    value: function fromString(name) {\n      if (!name) return null;\n      return new ResolvedImage({\n        name: name,\n        available: false\n      });\n    }\n  }]);\n\n  return ResolvedImage;\n}();\n\nfunction validateRGBA(r, g, b, a) {\n  if (!(typeof r === \'number\' && r >= 0 && r <= 255 && typeof g === \'number\' && g >= 0 && g <= 255 && typeof b === \'number\' && b >= 0 && b <= 255)) {\n    var value = typeof a === \'number\' ? [r, g, b, a] : [r, g, b];\n    return "Invalid rgba value [".concat(value.join(\', \'), "]: \'r\', \'g\', and \'b\' must be between 0 and 255.");\n  }\n\n  if (!(typeof a === \'undefined\' || typeof a === \'number\' && a >= 0 && a <= 1)) {\n    return "Invalid rgba value [".concat([r, g, b, a].join(\', \'), "]: \'a\' must be between 0 and 1.");\n  }\n\n  return null;\n}\n\nfunction isValue(mixed) {\n  if (mixed === null) {\n    return true;\n  } else if (typeof mixed === \'string\') {\n    return true;\n  } else if (typeof mixed === \'boolean\') {\n    return true;\n  } else if (typeof mixed === \'number\') {\n    return true;\n  } else if (mixed instanceof Color) {\n    return true;\n  } else if (mixed instanceof Collator) {\n    return true;\n  } else if (mixed instanceof Formatted) {\n    return true;\n  } else if (mixed instanceof ResolvedImage) {\n    return true;\n  } else if (Array.isArray(mixed)) {\n    var _iterator5 = _createForOfIteratorHelper(mixed),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var item = _step5.value;\n\n        if (!isValue(item)) {\n          return false;\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    return true;\n  } else if (typeof mixed === \'object\') {\n    for (var key in mixed) {\n      if (!isValue(mixed[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction typeOf(value) {\n  if (value === null) {\n    return NullType;\n  } else if (typeof value === \'string\') {\n    return StringType;\n  } else if (typeof value === \'boolean\') {\n    return BooleanType;\n  } else if (typeof value === \'number\') {\n    return NumberType;\n  } else if (value instanceof Color) {\n    return ColorType;\n  } else if (value instanceof Collator) {\n    return CollatorType;\n  } else if (value instanceof Formatted) {\n    return FormattedType;\n  } else if (value instanceof ResolvedImage) {\n    return ResolvedImageType;\n  } else if (Array.isArray(value)) {\n    var length = value.length;\n    var itemType;\n\n    var _iterator6 = _createForOfIteratorHelper(value),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var item = _step6.value;\n        var t = typeOf(item);\n\n        if (!itemType) {\n          itemType = t;\n        } else if (itemType === t) {\n          continue;\n        } else {\n          itemType = ValueType;\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n\n    return array(itemType || ValueType, length);\n  } else {\n    return ObjectType;\n  }\n}\n\nfunction toString$1(value) {\n  var type = typeof value;\n\n  if (value === null) {\n    return \'\';\n  } else if (type === \'string\' || type === \'number\' || type === \'boolean\') {\n    return String(value);\n  } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {\n    return value.toString();\n  } else {\n    return JSON.stringify(value);\n  }\n}\n\nvar Literal = /*#__PURE__*/function () {\n  function Literal(type, value) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Literal);\n\n    this.type = type;\n    this.value = value;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Literal, [{\n    key: "evaluate",\n    value: function evaluate() {\n      return this.value;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild() {}\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return true;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      if (this.type.kind === \'array\' || this.type.kind === \'object\') {\n        return [\'literal\', this.value];\n      } else if (this.value instanceof Color) {\n        return [\'rgba\'].concat(this.value.toArray());\n      } else if (this.value instanceof Formatted) {\n        return this.value.serialize();\n      } else {\n        return this.value;\n      }\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2) return context.error("\'literal\' expression requires exactly one argument, but found ".concat(args.length - 1, " instead."));\n      if (!isValue(args[1])) return context.error("invalid value");\n      var value = args[1];\n      var type = typeOf(value);\n      var expected = context.expectedType;\n\n      if (type.kind === \'array\' && type.N === 0 && expected && expected.kind === \'array\' && (typeof expected.N !== \'number\' || expected.N === 0)) {\n        type = expected;\n      }\n\n      return new Literal(type, value);\n    }\n  }]);\n\n  return Literal;\n}();\n\nvar RuntimeError = /*#__PURE__*/function () {\n  function RuntimeError(message) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, RuntimeError);\n\n    this.name = \'ExpressionEvaluationError\';\n    this.message = message;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(RuntimeError, [{\n    key: "toJSON",\n    value: function toJSON() {\n      return this.message;\n    }\n  }]);\n\n  return RuntimeError;\n}();\n\nvar types = {\n  string: StringType,\n  number: NumberType,\n  boolean: BooleanType,\n  object: ObjectType\n};\n\nvar Assertion = /*#__PURE__*/function () {\n  function Assertion(type, args) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Assertion);\n\n    this.type = type;\n    this.args = args;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Assertion, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      for (var i = 0; i < this.args.length; i++) {\n        var value = this.args[i].evaluate(ctx);\n\n        var _error = _checkSubtype(this.type, typeOf(value));\n\n        if (!_error) {\n          return value;\n        } else if (i === this.args.length - 1) {\n          throw new RuntimeError("Expected value to be of type ".concat(toString(this.type), ", but found ").concat(toString(typeOf(value)), " instead."));\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      this.args.forEach(fn);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.args.every(function (arg) {\n        return arg.outputDefined();\n      });\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var type = this.type;\n      var serialized = [type.kind];\n\n      if (type.kind === \'array\') {\n        var itemType = type.itemType;\n\n        if (itemType.kind === \'string\' || itemType.kind === \'number\' || itemType.kind === \'boolean\') {\n          serialized.push(itemType.kind);\n          var N = type.N;\n\n          if (typeof N === \'number\' || this.args.length > 1) {\n            serialized.push(N);\n          }\n        }\n      }\n\n      return serialized.concat(this.args.map(function (arg) {\n        return arg.serialize();\n      }));\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 2) return context.error("Expected at least one argument.");\n      var i = 1;\n      var type;\n      var name = args[0];\n\n      if (name === \'array\') {\n        var itemType;\n\n        if (args.length > 2) {\n          var _type = args[1];\n          if (typeof _type !== \'string\' || !(_type in types) || _type === \'object\') return context.error(\'The item type argument of "array" must be one of string, number, boolean\', 1);\n          itemType = types[_type];\n          i++;\n        } else {\n          itemType = ValueType;\n        }\n\n        var N;\n\n        if (args.length > 3) {\n          if (args[2] !== null && (typeof args[2] !== \'number\' || args[2] < 0 || args[2] !== Math.floor(args[2]))) {\n            return context.error(\'The length argument to "array" must be a positive integer literal\', 2);\n          }\n\n          N = args[2];\n          i++;\n        }\n\n        type = array(itemType, N);\n      } else {\n        type = types[name];\n      }\n\n      var parsed = [];\n\n      for (; i < args.length; i++) {\n        var input = context.parse(args[i], i, ValueType);\n        if (!input) return null;\n        parsed.push(input);\n      }\n\n      return new Assertion(type, parsed);\n    }\n  }]);\n\n  return Assertion;\n}();\n\nvar FormatExpression = /*#__PURE__*/function () {\n  function FormatExpression(sections) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, FormatExpression);\n\n    this.type = FormattedType;\n    this.sections = sections;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(FormatExpression, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var evaluateSection = function evaluateSection(section) {\n        var evaluatedContent = section.content.evaluate(ctx);\n\n        if (typeOf(evaluatedContent) === ResolvedImageType) {\n          return new FormattedSection(\'\', evaluatedContent, null, null, null);\n        }\n\n        return new FormattedSection(toString$1(evaluatedContent), null, section.scale ? section.scale.evaluate(ctx) : null, section.font ? section.font.evaluate(ctx).join(\',\') : null, section.textColor ? section.textColor.evaluate(ctx) : null);\n      };\n\n      return new Formatted(this.sections.map(evaluateSection));\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      var _iterator7 = _createForOfIteratorHelper(this.sections),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var section = _step7.value;\n          fn(section.content);\n\n          if (section.scale) {\n            fn(section.scale);\n          }\n\n          if (section.font) {\n            fn(section.font);\n          }\n\n          if (section.textColor) {\n            fn(section.textColor);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'format\'];\n\n      var _iterator8 = _createForOfIteratorHelper(this.sections),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var section = _step8.value;\n          serialized.push(section.content.serialize());\n          var options = {};\n\n          if (section.scale) {\n            options[\'font-scale\'] = section.scale.serialize();\n          }\n\n          if (section.font) {\n            options[\'text-font\'] = section.font.serialize();\n          }\n\n          if (section.textColor) {\n            options[\'text-color\'] = section.textColor.serialize();\n          }\n\n          serialized.push(options);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 2) {\n        return context.error("Expected at least one argument.");\n      }\n\n      var firstArg = args[1];\n\n      if (!Array.isArray(firstArg) && typeof firstArg === \'object\') {\n        return context.error("First argument must be an image or text section.");\n      }\n\n      var sections = [];\n      var nextTokenMayBeObject = false;\n\n      for (var i = 1; i <= args.length - 1; ++i) {\n        var arg = args[i];\n\n        if (nextTokenMayBeObject && typeof arg === \'object\' && !Array.isArray(arg)) {\n          nextTokenMayBeObject = false;\n          var scale = null;\n\n          if (arg[\'font-scale\']) {\n            scale = context.parse(arg[\'font-scale\'], 1, NumberType);\n            if (!scale) return null;\n          }\n\n          var font = null;\n\n          if (arg[\'text-font\']) {\n            font = context.parse(arg[\'text-font\'], 1, array(StringType));\n            if (!font) return null;\n          }\n\n          var textColor = null;\n\n          if (arg[\'text-color\']) {\n            textColor = context.parse(arg[\'text-color\'], 1, ColorType);\n            if (!textColor) return null;\n          }\n\n          var lastExpression = sections[sections.length - 1];\n          lastExpression.scale = scale;\n          lastExpression.font = font;\n          lastExpression.textColor = textColor;\n        } else {\n          var content = context.parse(args[i], 1, ValueType);\n          if (!content) return null;\n          var kind = content.type.kind;\n          if (kind !== \'string\' && kind !== \'value\' && kind !== \'null\' && kind !== \'resolvedImage\') return context.error("Formatted text type must be \'string\', \'value\', \'image\' or \'null\'.");\n          nextTokenMayBeObject = true;\n          sections.push({\n            content: content,\n            scale: null,\n            font: null,\n            textColor: null\n          });\n        }\n      }\n\n      return new FormatExpression(sections);\n    }\n  }]);\n\n  return FormatExpression;\n}();\n\nvar ImageExpression = /*#__PURE__*/function () {\n  function ImageExpression(input) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ImageExpression);\n\n    this.type = ResolvedImageType;\n    this.input = input;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(ImageExpression, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var evaluatedImageName = this.input.evaluate(ctx);\n      var value = ResolvedImage.fromString(evaluatedImageName);\n      if (value && ctx.availableImages) value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;\n      return value;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'image\', this.input.serialize()];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2) {\n        return context.error("Expected two arguments.");\n      }\n\n      var name = context.parse(args[1], 1, StringType);\n      if (!name) return context.error("No image name provided.");\n      return new ImageExpression(name);\n    }\n  }]);\n\n  return ImageExpression;\n}();\n\nvar types$1 = {\n  \'to-boolean\': BooleanType,\n  \'to-color\': ColorType,\n  \'to-number\': NumberType,\n  \'to-string\': StringType\n};\n\nvar Coercion = /*#__PURE__*/function () {\n  function Coercion(type, args) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Coercion);\n\n    this.type = type;\n    this.args = args;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Coercion, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      if (this.type.kind === \'boolean\') {\n        return Boolean(this.args[0].evaluate(ctx));\n      } else if (this.type.kind === \'color\') {\n        var input;\n\n        var _error2;\n\n        var _iterator9 = _createForOfIteratorHelper(this.args),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var arg = _step9.value;\n            input = arg.evaluate(ctx);\n            _error2 = null;\n\n            if (input instanceof Color) {\n              return input;\n            } else if (typeof input === \'string\') {\n              var c = ctx.parseColor(input);\n              if (c) return c;\n            } else if (Array.isArray(input)) {\n              if (input.length < 3 || input.length > 4) {\n                _error2 = "Invalid rbga value ".concat(JSON.stringify(input), ": expected an array containing either three or four numeric values.");\n              } else {\n                _error2 = validateRGBA(input[0], input[1], input[2], input[3]);\n              }\n\n              if (!_error2) {\n                return new Color(input[0] / 255, input[1] / 255, input[2] / 255, input[3]);\n              }\n            }\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        throw new RuntimeError(_error2 || "Could not parse color from value \'".concat(typeof input === \'string\' ? input : String(JSON.stringify(input)), "\'"));\n      } else if (this.type.kind === \'number\') {\n        var value = null;\n\n        var _iterator10 = _createForOfIteratorHelper(this.args),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var _arg = _step10.value;\n            value = _arg.evaluate(ctx);\n            if (value === null) return 0;\n            var num = Number(value);\n            if (isNaN(num)) continue;\n            return num;\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        throw new RuntimeError("Could not convert ".concat(JSON.stringify(value), " to number."));\n      } else if (this.type.kind === \'formatted\') {\n        return Formatted.fromString(toString$1(this.args[0].evaluate(ctx)));\n      } else if (this.type.kind === \'resolvedImage\') {\n        return ResolvedImage.fromString(toString$1(this.args[0].evaluate(ctx)));\n      } else {\n        return toString$1(this.args[0].evaluate(ctx));\n      }\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      this.args.forEach(fn);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.args.every(function (arg) {\n        return arg.outputDefined();\n      });\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      if (this.type.kind === \'formatted\') {\n        return new FormatExpression([{\n          content: this.args[0],\n          scale: null,\n          font: null,\n          textColor: null\n        }]).serialize();\n      }\n\n      if (this.type.kind === \'resolvedImage\') {\n        return new ImageExpression(this.args[0]).serialize();\n      }\n\n      var serialized = ["to-".concat(this.type.kind)];\n      this.eachChild(function (child) {\n        serialized.push(child.serialize());\n      });\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 2) return context.error("Expected at least one argument.");\n      var name = args[0];\n      if ((name === \'to-boolean\' || name === \'to-string\') && args.length !== 2) return context.error("Expected one argument.");\n      var type = types$1[name];\n      var parsed = [];\n\n      for (var i = 1; i < args.length; i++) {\n        var input = context.parse(args[i], i, ValueType);\n        if (!input) return null;\n        parsed.push(input);\n      }\n\n      return new Coercion(type, parsed);\n    }\n  }]);\n\n  return Coercion;\n}();\n\nvar geometryTypes = [\'Unknown\', \'Point\', \'LineString\', \'Polygon\'];\n\nvar EvaluationContext = /*#__PURE__*/function () {\n  function EvaluationContext() {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, EvaluationContext);\n\n    this.globals = null;\n    this.feature = null;\n    this.featureState = null;\n    this.formattedSection = null;\n    this._parseColorCache = {};\n    this.availableImages = null;\n    this.canonical = null;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(EvaluationContext, [{\n    key: "id",\n    value: function id() {\n      return this.feature && \'id\' in this.feature ? this.feature.id : null;\n    }\n  }, {\n    key: "geometryType",\n    value: function geometryType() {\n      return this.feature ? typeof this.feature.type === \'number\' ? geometryTypes[this.feature.type] : this.feature.type : null;\n    }\n  }, {\n    key: "geometry",\n    value: function geometry() {\n      return this.feature && \'geometry\' in this.feature ? this.feature.geometry : null;\n    }\n  }, {\n    key: "canonicalID",\n    value: function canonicalID() {\n      return this.canonical;\n    }\n  }, {\n    key: "properties",\n    value: function properties() {\n      return this.feature && this.feature.properties || {};\n    }\n  }, {\n    key: "parseColor",\n    value: function parseColor(input) {\n      var cached = this._parseColorCache[input];\n\n      if (!cached) {\n        cached = this._parseColorCache[input] = Color.parse(input);\n      }\n\n      return cached;\n    }\n  }]);\n\n  return EvaluationContext;\n}();\n\nvar CompoundExpression = /*#__PURE__*/function () {\n  function CompoundExpression(name, type, evaluate, args) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, CompoundExpression);\n\n    this.name = name;\n    this.type = type;\n    this._evaluate = evaluate;\n    this.args = args;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(CompoundExpression, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      return this._evaluate(ctx, this.args);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      this.args.forEach(fn);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [this.name].concat(this.args.map(function (arg) {\n        return arg.serialize();\n      }));\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      var op = args[0];\n      var definition = CompoundExpression.definitions[op];\n\n      if (!definition) {\n        return context.error("Unknown expression \\"".concat(op, "\\". If you wanted a literal array, use [\\"literal\\", [...]]."), 0);\n      }\n\n      var type = Array.isArray(definition) ? definition[0] : definition.type;\n      var availableOverloads = Array.isArray(definition) ? [[definition[1], definition[2]]] : definition.overloads;\n      var overloads = availableOverloads.filter(function (_ref) {\n        var _ref2 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref, 1),\n            signature = _ref2[0];\n\n        return !Array.isArray(signature) || signature.length === args.length - 1;\n      });\n      var signatureContext = null;\n\n      var _iterator11 = _createForOfIteratorHelper(overloads),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var _step11$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step11.value, 2),\n              params = _step11$value[0],\n              evaluate = _step11$value[1];\n\n          signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);\n          var parsedArgs = [];\n          var argParseFailed = false;\n\n          for (var _i3 = 1; _i3 < args.length; _i3++) {\n            var arg = args[_i3];\n            var expectedType = Array.isArray(params) ? params[_i3 - 1] : params.type;\n\n            var _parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);\n\n            if (!_parsed) {\n              argParseFailed = true;\n              break;\n            }\n\n            parsedArgs.push(_parsed);\n          }\n\n          if (argParseFailed) {\n            continue;\n          }\n\n          if (Array.isArray(params)) {\n            if (params.length !== parsedArgs.length) {\n              signatureContext.error("Expected ".concat(params.length, " arguments, but found ").concat(parsedArgs.length, " instead."));\n              continue;\n            }\n          }\n\n          for (var _i4 = 0; _i4 < parsedArgs.length; _i4++) {\n            var _expected = Array.isArray(params) ? params[_i4] : params.type;\n\n            var _arg2 = parsedArgs[_i4];\n            signatureContext.concat(_i4 + 1).checkSubtype(_expected, _arg2.type);\n          }\n\n          if (signatureContext.errors.length === 0) {\n            return new CompoundExpression(op, type, evaluate, parsedArgs);\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      if (overloads.length === 1) {\n        var _context$errors;\n\n        (_context$errors = context.errors).push.apply(_context$errors, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(signatureContext.errors));\n      } else {\n        var expected = overloads.length ? overloads : availableOverloads;\n        var signatures = expected.map(function (_ref3) {\n          var _ref4 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref3, 1),\n              params = _ref4[0];\n\n          return stringifySignature(params);\n        }).join(\' | \');\n        var actualTypes = [];\n\n        for (var i = 1; i < args.length; i++) {\n          var parsed = context.parse(args[i], 1 + actualTypes.length);\n          if (!parsed) return null;\n          actualTypes.push(toString(parsed.type));\n        }\n\n        context.error("Expected arguments of type ".concat(signatures, ", but found (").concat(actualTypes.join(\', \'), ") instead."));\n      }\n\n      return null;\n    }\n  }, {\n    key: "register",\n    value: function register(registry, definitions) {\n      CompoundExpression.definitions = definitions;\n\n      for (var name in definitions) {\n        registry[name] = CompoundExpression;\n      }\n    }\n  }]);\n\n  return CompoundExpression;\n}();\n\nfunction stringifySignature(signature) {\n  if (Array.isArray(signature)) {\n    return "(".concat(signature.map(toString).join(\', \'), ")");\n  } else {\n    return "(".concat(toString(signature.type), "...)");\n  }\n}\n\nvar CollatorExpression = /*#__PURE__*/function () {\n  function CollatorExpression(caseSensitive, diacriticSensitive, locale) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, CollatorExpression);\n\n    this.type = CollatorType;\n    this.locale = locale;\n    this.caseSensitive = caseSensitive;\n    this.diacriticSensitive = diacriticSensitive;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(CollatorExpression, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.caseSensitive);\n      fn(this.diacriticSensitive);\n\n      if (this.locale) {\n        fn(this.locale);\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var options = {};\n      options[\'case-sensitive\'] = this.caseSensitive.serialize();\n      options[\'diacritic-sensitive\'] = this.diacriticSensitive.serialize();\n\n      if (this.locale) {\n        options[\'locale\'] = this.locale.serialize();\n      }\n\n      return [\'collator\', options];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2) return context.error("Expected one argument.");\n      var options = args[1];\n      if (typeof options !== \'object\' || Array.isArray(options)) return context.error("Collator options argument must be an object.");\n      var caseSensitive = context.parse(options[\'case-sensitive\'] === undefined ? false : options[\'case-sensitive\'], 1, BooleanType);\n      if (!caseSensitive) return null;\n      var diacriticSensitive = context.parse(options[\'diacritic-sensitive\'] === undefined ? false : options[\'diacritic-sensitive\'], 1, BooleanType);\n      if (!diacriticSensitive) return null;\n      var locale = null;\n\n      if (options[\'locale\']) {\n        locale = context.parse(options[\'locale\'], 1, StringType);\n        if (!locale) return null;\n      }\n\n      return new CollatorExpression(caseSensitive, diacriticSensitive, locale);\n    }\n  }]);\n\n  return CollatorExpression;\n}();\n\nvar EXTENT = 8192;\n\nfunction updateBBox(bbox, coord) {\n  bbox[0] = Math.min(bbox[0], coord[0]);\n  bbox[1] = Math.min(bbox[1], coord[1]);\n  bbox[2] = Math.max(bbox[2], coord[0]);\n  bbox[3] = Math.max(bbox[3], coord[1]);\n}\n\nfunction mercatorXfromLng(lng) {\n  return (180 + lng) / 360;\n}\n\nfunction mercatorYfromLat(lat) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;\n}\n\nfunction boxWithinBox(bbox1, bbox2) {\n  if (bbox1[0] <= bbox2[0]) return false;\n  if (bbox1[2] >= bbox2[2]) return false;\n  if (bbox1[1] <= bbox2[1]) return false;\n  if (bbox1[3] >= bbox2[3]) return false;\n  return true;\n}\n\nfunction getTileCoordinates(p, canonical) {\n  var x = mercatorXfromLng(p[0]);\n  var y = mercatorYfromLat(p[1]);\n  var tilesAtZoom = Math.pow(2, canonical.z);\n  return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];\n}\n\nfunction onBoundary(p, p1, p2) {\n  var x1 = p[0] - p1[0];\n  var y1 = p[1] - p1[1];\n  var x2 = p[0] - p2[0];\n  var y2 = p[1] - p2[1];\n  return x1 * y2 - x2 * y1 === 0 && x1 * x2 <= 0 && y1 * y2 <= 0;\n}\n\nfunction rayIntersect(p, p1, p2) {\n  return p1[1] > p[1] !== p2[1] > p[1] && p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0];\n}\n\nfunction pointWithinPolygon(point, rings) {\n  var inside = false;\n\n  for (var i = 0, len = rings.length; i < len; i++) {\n    var ring = rings[i];\n\n    for (var j = 0, len2 = ring.length; j < len2 - 1; j++) {\n      if (onBoundary(point, ring[j], ring[j + 1])) return false;\n      if (rayIntersect(point, ring[j], ring[j + 1])) inside = !inside;\n    }\n  }\n\n  return inside;\n}\n\nfunction pointWithinPolygons(point, polygons) {\n  for (var i = 0; i < polygons.length; i++) {\n    if (pointWithinPolygon(point, polygons[i])) return true;\n  }\n\n  return false;\n}\n\nfunction perp(v1, v2) {\n  return v1[0] * v2[1] - v1[1] * v2[0];\n}\n\nfunction twoSided(p1, p2, q1, q2) {\n  var x1 = p1[0] - q1[0];\n  var y1 = p1[1] - q1[1];\n  var x2 = p2[0] - q1[0];\n  var y2 = p2[1] - q1[1];\n  var x3 = q2[0] - q1[0];\n  var y3 = q2[1] - q1[1];\n  var det1 = x1 * y3 - x3 * y1;\n  var det2 = x2 * y3 - x3 * y2;\n  if (det1 > 0 && det2 < 0 || det1 < 0 && det2 > 0) return true;\n  return false;\n}\n\nfunction lineIntersectLine(a, b, c, d) {\n  var vectorP = [b[0] - a[0], b[1] - a[1]];\n  var vectorQ = [d[0] - c[0], d[1] - c[1]];\n  if (perp(vectorQ, vectorP) === 0) return false;\n  if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) return true;\n  return false;\n}\n\nfunction lineIntersectPolygon(p1, p2, polygon) {\n  var _iterator12 = _createForOfIteratorHelper(polygon),\n      _step12;\n\n  try {\n    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n      var ring = _step12.value;\n\n      for (var j = 0; j < ring.length - 1; ++j) {\n        if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {\n          return true;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator12.e(err);\n  } finally {\n    _iterator12.f();\n  }\n\n  return false;\n}\n\nfunction lineStringWithinPolygon(line, polygon) {\n  for (var i = 0; i < line.length; ++i) {\n    if (!pointWithinPolygon(line[i], polygon)) {\n      return false;\n    }\n  }\n\n  for (var _i5 = 0; _i5 < line.length - 1; ++_i5) {\n    if (lineIntersectPolygon(line[_i5], line[_i5 + 1], polygon)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction lineStringWithinPolygons(line, polygons) {\n  for (var i = 0; i < polygons.length; i++) {\n    if (lineStringWithinPolygon(line, polygons[i])) return true;\n  }\n\n  return false;\n}\n\nfunction getTilePolygon(coordinates, bbox, canonical) {\n  var polygon = [];\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var ring = [];\n\n    for (var j = 0; j < coordinates[i].length; j++) {\n      var coord = getTileCoordinates(coordinates[i][j], canonical);\n      updateBBox(bbox, coord);\n      ring.push(coord);\n    }\n\n    polygon.push(ring);\n  }\n\n  return polygon;\n}\n\nfunction getTilePolygons(coordinates, bbox, canonical) {\n  var polygons = [];\n\n  for (var i = 0; i < coordinates.length; i++) {\n    var polygon = getTilePolygon(coordinates[i], bbox, canonical);\n    polygons.push(polygon);\n  }\n\n  return polygons;\n}\n\nfunction updatePoint(p, bbox, polyBBox, worldSize) {\n  if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {\n    var halfWorldSize = worldSize * 0.5;\n    var shift = p[0] - polyBBox[0] > halfWorldSize ? -worldSize : polyBBox[0] - p[0] > halfWorldSize ? worldSize : 0;\n\n    if (shift === 0) {\n      shift = p[0] - polyBBox[2] > halfWorldSize ? -worldSize : polyBBox[2] - p[0] > halfWorldSize ? worldSize : 0;\n    }\n\n    p[0] += shift;\n  }\n\n  updateBBox(bbox, p);\n}\n\nfunction resetBBox(bbox) {\n  bbox[0] = bbox[1] = Infinity;\n  bbox[2] = bbox[3] = -Infinity;\n}\n\nfunction getTilePoints(geometry, pointBBox, polyBBox, canonical) {\n  var worldSize = Math.pow(2, canonical.z) * EXTENT;\n  var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];\n  var tilePoints = [];\n\n  var _iterator13 = _createForOfIteratorHelper(geometry),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var points = _step13.value;\n\n      var _iterator14 = _createForOfIteratorHelper(points),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var point = _step14.value;\n          var p = [point.x + shifts[0], point.y + shifts[1]];\n          updatePoint(p, pointBBox, polyBBox, worldSize);\n          tilePoints.push(p);\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n\n  return tilePoints;\n}\n\nfunction getTileLines(geometry, lineBBox, polyBBox, canonical) {\n  var worldSize = Math.pow(2, canonical.z) * EXTENT;\n  var shifts = [canonical.x * EXTENT, canonical.y * EXTENT];\n  var tileLines = [];\n\n  var _iterator15 = _createForOfIteratorHelper(geometry),\n      _step15;\n\n  try {\n    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n      var _line = _step15.value;\n      var tileLine = [];\n\n      var _iterator18 = _createForOfIteratorHelper(_line),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var point = _step18.value;\n          var _p = [point.x + shifts[0], point.y + shifts[1]];\n          updateBBox(lineBBox, _p);\n          tileLine.push(_p);\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      tileLines.push(tileLine);\n    }\n  } catch (err) {\n    _iterator15.e(err);\n  } finally {\n    _iterator15.f();\n  }\n\n  if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {\n    resetBBox(lineBBox);\n\n    var _iterator16 = _createForOfIteratorHelper(tileLines),\n        _step16;\n\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var line = _step16.value;\n\n        var _iterator17 = _createForOfIteratorHelper(line),\n            _step17;\n\n        try {\n          for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n            var p = _step17.value;\n            updatePoint(p, lineBBox, polyBBox, worldSize);\n          }\n        } catch (err) {\n          _iterator17.e(err);\n        } finally {\n          _iterator17.f();\n        }\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n  }\n\n  return tileLines;\n}\n\nfunction pointsWithinPolygons(ctx, polygonGeometry) {\n  var pointBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var canonical = ctx.canonicalID();\n\n  if (polygonGeometry.type === \'Polygon\') {\n    var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);\n    var tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);\n    if (!boxWithinBox(pointBBox, polyBBox)) return false;\n\n    var _iterator19 = _createForOfIteratorHelper(tilePoints),\n        _step19;\n\n    try {\n      for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n        var point = _step19.value;\n        if (!pointWithinPolygon(point, tilePolygon)) return false;\n      }\n    } catch (err) {\n      _iterator19.e(err);\n    } finally {\n      _iterator19.f();\n    }\n  }\n\n  if (polygonGeometry.type === \'MultiPolygon\') {\n    var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);\n\n    var _tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);\n\n    if (!boxWithinBox(pointBBox, polyBBox)) return false;\n\n    var _iterator20 = _createForOfIteratorHelper(_tilePoints),\n        _step20;\n\n    try {\n      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n        var _point = _step20.value;\n        if (!pointWithinPolygons(_point, tilePolygons)) return false;\n      }\n    } catch (err) {\n      _iterator20.e(err);\n    } finally {\n      _iterator20.f();\n    }\n  }\n\n  return true;\n}\n\nfunction linesWithinPolygons(ctx, polygonGeometry) {\n  var lineBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var polyBBox = [Infinity, Infinity, -Infinity, -Infinity];\n  var canonical = ctx.canonicalID();\n\n  if (polygonGeometry.type === \'Polygon\') {\n    var tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);\n    var tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);\n    if (!boxWithinBox(lineBBox, polyBBox)) return false;\n\n    var _iterator21 = _createForOfIteratorHelper(tileLines),\n        _step21;\n\n    try {\n      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n        var line = _step21.value;\n        if (!lineStringWithinPolygon(line, tilePolygon)) return false;\n      }\n    } catch (err) {\n      _iterator21.e(err);\n    } finally {\n      _iterator21.f();\n    }\n  }\n\n  if (polygonGeometry.type === \'MultiPolygon\') {\n    var tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);\n\n    var _tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);\n\n    if (!boxWithinBox(lineBBox, polyBBox)) return false;\n\n    var _iterator22 = _createForOfIteratorHelper(_tileLines),\n        _step22;\n\n    try {\n      for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n        var _line2 = _step22.value;\n        if (!lineStringWithinPolygons(_line2, tilePolygons)) return false;\n      }\n    } catch (err) {\n      _iterator22.e(err);\n    } finally {\n      _iterator22.f();\n    }\n  }\n\n  return true;\n}\n\nvar Within = /*#__PURE__*/function () {\n  function Within(geojson, geometries) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Within);\n\n    this.type = BooleanType;\n    this.geojson = geojson;\n    this.geometries = geometries;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Within, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      if (ctx.geometry() != null && ctx.canonicalID() != null) {\n        if (ctx.geometryType() === \'Point\') {\n          return pointsWithinPolygons(ctx, this.geometries);\n        } else if (ctx.geometryType() === \'LineString\') {\n          return linesWithinPolygons(ctx, this.geometries);\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild() {}\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return true;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'within\', this.geojson];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2) return context.error("\'within\' expression requires exactly one argument, but found ".concat(args.length - 1, " instead."));\n\n      if (isValue(args[1])) {\n        var geojson = args[1];\n\n        if (geojson.type === \'FeatureCollection\') {\n          for (var i = 0; i < geojson.features.length; ++i) {\n            var type = geojson.features[i].geometry.type;\n\n            if (type === \'Polygon\' || type === \'MultiPolygon\') {\n              return new Within(geojson, geojson.features[i].geometry);\n            }\n          }\n        } else if (geojson.type === \'Feature\') {\n          var _type2 = geojson.geometry.type;\n\n          if (_type2 === \'Polygon\' || _type2 === \'MultiPolygon\') {\n            return new Within(geojson, geojson.geometry);\n          }\n        } else if (geojson.type === \'Polygon\' || geojson.type === \'MultiPolygon\') {\n          return new Within(geojson, geojson);\n        }\n      }\n\n      return context.error("\'within\' expression requires valid geojson object that contains polygon geometry type.");\n    }\n  }]);\n\n  return Within;\n}();\n\nfunction isFeatureConstant(e) {\n  if (e instanceof CompoundExpression) {\n    if (e.name === \'get\' && e.args.length === 1) {\n      return false;\n    } else if (e.name === \'feature-state\') {\n      return false;\n    } else if (e.name === \'has\' && e.args.length === 1) {\n      return false;\n    } else if (e.name === \'properties\' || e.name === \'geometry-type\' || e.name === \'id\') {\n      return false;\n    } else if (/^filter-/.test(e.name)) {\n      return false;\n    }\n  }\n\n  if (e instanceof Within) {\n    return false;\n  }\n\n  var result = true;\n  e.eachChild(function (arg) {\n    if (result && !isFeatureConstant(arg)) {\n      result = false;\n    }\n  });\n  return result;\n}\n\nfunction isStateConstant(e) {\n  if (e instanceof CompoundExpression) {\n    if (e.name === \'feature-state\') {\n      return false;\n    }\n  }\n\n  var result = true;\n  e.eachChild(function (arg) {\n    if (result && !isStateConstant(arg)) {\n      result = false;\n    }\n  });\n  return result;\n}\n\nfunction isGlobalPropertyConstant(e, properties) {\n  if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) {\n    return false;\n  }\n\n  var result = true;\n  e.eachChild(function (arg) {\n    if (result && !isGlobalPropertyConstant(arg, properties)) {\n      result = false;\n    }\n  });\n  return result;\n}\n\nvar Var = /*#__PURE__*/function () {\n  function Var(name, boundExpression) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Var);\n\n    this.type = boundExpression.type;\n    this.name = name;\n    this.boundExpression = boundExpression;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Var, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      return this.boundExpression.evaluate(ctx);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild() {}\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'var\', this.name];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2 || typeof args[1] !== \'string\') return context.error("\'var\' expression requires exactly one string literal argument.");\n      var name = args[1];\n\n      if (!context.scope.has(name)) {\n        return context.error("Unknown variable \\"".concat(name, "\\". Make sure \\"").concat(name, "\\" has been bound in an enclosing \\"let\\" expression before using it."), 1);\n      }\n\n      return new Var(name, context.scope.get(name));\n    }\n  }]);\n\n  return Var;\n}();\n\nvar ParsingContext = /*#__PURE__*/function () {\n  function ParsingContext(registry) {\n    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var expectedType = arguments.length > 2 ? arguments[2] : undefined;\n    var scope = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Scope();\n    var errors = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ParsingContext);\n\n    this.registry = registry;\n    this.path = path;\n    this.key = path.map(function (part) {\n      return "[".concat(part, "]");\n    }).join(\'\');\n    this.scope = scope;\n    this.errors = errors;\n    this.expectedType = expectedType;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(ParsingContext, [{\n    key: "parse",\n    value: function parse(expr, index, expectedType, bindings) {\n      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n      if (index) {\n        return this.concat(index, expectedType, bindings)._parse(expr, options);\n      }\n\n      return this._parse(expr, options);\n    }\n  }, {\n    key: "_parse",\n    value: function _parse(expr, options) {\n      if (expr === null || typeof expr === \'string\' || typeof expr === \'boolean\' || typeof expr === \'number\') {\n        expr = [\'literal\', expr];\n      }\n\n      function annotate(parsed, type, typeAnnotation) {\n        if (typeAnnotation === \'assert\') {\n          return new Assertion(type, [parsed]);\n        } else if (typeAnnotation === \'coerce\') {\n          return new Coercion(type, [parsed]);\n        } else {\n          return parsed;\n        }\n      }\n\n      if (Array.isArray(expr)) {\n        if (expr.length === 0) {\n          return this.error("Expected an array with at least one element. If you wanted a literal array, use [\\"literal\\", []].");\n        }\n\n        var op = expr[0];\n\n        if (typeof op !== \'string\') {\n          this.error("Expression name must be a string, but found ".concat(typeof op, " instead. If you wanted a literal array, use [\\"literal\\", [...]]."), 0);\n          return null;\n        }\n\n        var Expr = this.registry[op];\n\n        if (Expr) {\n          var parsed = Expr.parse(expr, this);\n          if (!parsed) return null;\n\n          if (this.expectedType) {\n            var expected = this.expectedType;\n            var actual = parsed.type;\n\n            if ((expected.kind === \'string\' || expected.kind === \'number\' || expected.kind === \'boolean\' || expected.kind === \'object\' || expected.kind === \'array\') && actual.kind === \'value\') {\n              parsed = annotate(parsed, expected, options.typeAnnotation || \'assert\');\n            } else if ((expected.kind === \'color\' || expected.kind === \'formatted\' || expected.kind === \'resolvedImage\') && (actual.kind === \'value\' || actual.kind === \'string\')) {\n              parsed = annotate(parsed, expected, options.typeAnnotation || \'coerce\');\n            } else if (this.checkSubtype(expected, actual)) {\n              return null;\n            }\n          }\n\n          if (!(parsed instanceof Literal) && parsed.type.kind !== \'resolvedImage\' && isConstant(parsed)) {\n            var ec = new EvaluationContext();\n\n            try {\n              parsed = new Literal(parsed.type, parsed.evaluate(ec));\n            } catch (e) {\n              this.error(e.message);\n              return null;\n            }\n          }\n\n          return parsed;\n        }\n\n        return this.error("Unknown expression \\"".concat(op, "\\". If you wanted a literal array, use [\\"literal\\", [...]]."), 0);\n      } else if (typeof expr === \'undefined\') {\n        return this.error("\'undefined\' value invalid. Use null instead.");\n      } else if (typeof expr === \'object\') {\n        return this.error("Bare objects invalid. Use [\\"literal\\", {...}] instead.");\n      } else {\n        return this.error("Expected an array, but found ".concat(typeof expr, " instead."));\n      }\n    }\n  }, {\n    key: "concat",\n    value: function concat(index, expectedType, bindings) {\n      var path = typeof index === \'number\' ? this.path.concat(index) : this.path;\n      var scope = bindings ? this.scope.concat(bindings) : this.scope;\n      return new ParsingContext(this.registry, path, expectedType || null, scope, this.errors);\n    }\n  }, {\n    key: "error",\n    value: function error(_error3) {\n      for (var _len2 = arguments.length, keys = new Array(_len2 > 1 ? _len2 - 1 : 0), _key4 = 1; _key4 < _len2; _key4++) {\n        keys[_key4 - 1] = arguments[_key4];\n      }\n\n      var key = "".concat(this.key).concat(keys.map(function (k) {\n        return "[".concat(k, "]");\n      }).join(\'\'));\n      this.errors.push(new ParsingError(key, _error3));\n    }\n  }, {\n    key: "checkSubtype",\n    value: function checkSubtype(expected, t) {\n      var error = _checkSubtype(expected, t);\n\n      if (error) this.error(error);\n      return error;\n    }\n  }]);\n\n  return ParsingContext;\n}();\n\nfunction isConstant(expression) {\n  if (expression instanceof Var) {\n    return isConstant(expression.boundExpression);\n  } else if (expression instanceof CompoundExpression && expression.name === \'error\') {\n    return false;\n  } else if (expression instanceof CollatorExpression) {\n    return false;\n  } else if (expression instanceof Within) {\n    return false;\n  }\n\n  var isTypeAnnotation = expression instanceof Coercion || expression instanceof Assertion;\n  var childrenConstant = true;\n  expression.eachChild(function (child) {\n    if (isTypeAnnotation) {\n      childrenConstant = childrenConstant && isConstant(child);\n    } else {\n      childrenConstant = childrenConstant && child instanceof Literal;\n    }\n  });\n\n  if (!childrenConstant) {\n    return false;\n  }\n\n  return isFeatureConstant(expression) && isGlobalPropertyConstant(expression, [\'zoom\', \'heatmap-density\', \'line-progress\', \'sky-radial-progress\', \'accumulated\', \'is-supported-script\']);\n}\n\nfunction findStopLessThanOrEqualTo(stops, input) {\n  var lastIndex = stops.length - 1;\n  var lowerIndex = 0;\n  var upperIndex = lastIndex;\n  var currentIndex = 0;\n  var currentValue, nextValue;\n\n  while (lowerIndex <= upperIndex) {\n    currentIndex = Math.floor((lowerIndex + upperIndex) / 2);\n    currentValue = stops[currentIndex];\n    nextValue = stops[currentIndex + 1];\n\n    if (currentValue <= input) {\n      if (currentIndex === lastIndex || input < nextValue) {\n        return currentIndex;\n      }\n\n      lowerIndex = currentIndex + 1;\n    } else if (currentValue > input) {\n      upperIndex = currentIndex - 1;\n    } else {\n      throw new RuntimeError(\'Input is not a number.\');\n    }\n  }\n\n  return 0;\n}\n\nvar Step = /*#__PURE__*/function () {\n  function Step(type, input, stops) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Step);\n\n    this.type = type;\n    this.input = input;\n    this.labels = [];\n    this.outputs = [];\n\n    var _iterator23 = _createForOfIteratorHelper(stops),\n        _step23;\n\n    try {\n      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n        var _step23$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step23.value, 2),\n            label = _step23$value[0],\n            _expression2 = _step23$value[1];\n\n        this.labels.push(label);\n        this.outputs.push(_expression2);\n      }\n    } catch (err) {\n      _iterator23.e(err);\n    } finally {\n      _iterator23.f();\n    }\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Step, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var labels = this.labels;\n      var outputs = this.outputs;\n\n      if (labels.length === 1) {\n        return outputs[0].evaluate(ctx);\n      }\n\n      var value = this.input.evaluate(ctx);\n\n      if (value <= labels[0]) {\n        return outputs[0].evaluate(ctx);\n      }\n\n      var stopCount = labels.length;\n\n      if (value >= labels[stopCount - 1]) {\n        return outputs[stopCount - 1].evaluate(ctx);\n      }\n\n      var index = findStopLessThanOrEqualTo(labels, value);\n      return outputs[index].evaluate(ctx);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n\n      var _iterator24 = _createForOfIteratorHelper(this.outputs),\n          _step24;\n\n      try {\n        for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n          var _expression3 = _step24.value;\n          fn(_expression3);\n        }\n      } catch (err) {\n        _iterator24.e(err);\n      } finally {\n        _iterator24.f();\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.outputs.every(function (out) {\n        return out.outputDefined();\n      });\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'step\', this.input.serialize()];\n\n      for (var i = 0; i < this.labels.length; i++) {\n        if (i > 0) {\n          serialized.push(this.labels[i]);\n        }\n\n        serialized.push(this.outputs[i].serialize());\n      }\n\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length - 1 < 4) {\n        return context.error("Expected at least 4 arguments, but found only ".concat(args.length - 1, "."));\n      }\n\n      if ((args.length - 1) % 2 !== 0) {\n        return context.error("Expected an even number of arguments.");\n      }\n\n      var input = context.parse(args[1], 1, NumberType);\n      if (!input) return null;\n      var stops = [];\n      var outputType = null;\n\n      if (context.expectedType && context.expectedType.kind !== \'value\') {\n        outputType = context.expectedType;\n      }\n\n      for (var i = 1; i < args.length; i += 2) {\n        var label = i === 1 ? -Infinity : args[i];\n        var value = args[i + 1];\n        var labelKey = i;\n        var valueKey = i + 1;\n\n        if (typeof label !== \'number\') {\n          return context.error(\'Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.\', labelKey);\n        }\n\n        if (stops.length && stops[stops.length - 1][0] >= label) {\n          return context.error(\'Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.\', labelKey);\n        }\n\n        var parsed = context.parse(value, valueKey, outputType);\n        if (!parsed) return null;\n        outputType = outputType || parsed.type;\n        stops.push([label, parsed]);\n      }\n\n      return new Step(outputType, input, stops);\n    }\n  }]);\n\n  return Step;\n}();\n/*\n * Copyright (C) 2008 Apple Inc. All Rights Reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS\'\' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * Ported from Webkit\n * http://svn.webkit.org/repository/webkit/trunk/Source/WebCore/platform/graphics/UnitBezier.h\n */\n\n\nvar unitbezier = UnitBezier;\n\nfunction UnitBezier(p1x, p1y, p2x, p2y) {\n  // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).\n  this.cx = 3.0 * p1x;\n  this.bx = 3.0 * (p2x - p1x) - this.cx;\n  this.ax = 1.0 - this.cx - this.bx;\n  this.cy = 3.0 * p1y;\n  this.by = 3.0 * (p2y - p1y) - this.cy;\n  this.ay = 1.0 - this.cy - this.by;\n  this.p1x = p1x;\n  this.p1y = p2y;\n  this.p2x = p2x;\n  this.p2y = p2y;\n}\n\nUnitBezier.prototype.sampleCurveX = function (t) {\n  // `ax t^3 + bx t^2 + cx t\' expanded using Horner\'s rule.\n  return ((this.ax * t + this.bx) * t + this.cx) * t;\n};\n\nUnitBezier.prototype.sampleCurveY = function (t) {\n  return ((this.ay * t + this.by) * t + this.cy) * t;\n};\n\nUnitBezier.prototype.sampleCurveDerivativeX = function (t) {\n  return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n};\n\nUnitBezier.prototype.solveCurveX = function (x, epsilon) {\n  if (typeof epsilon === \'undefined\') epsilon = 1e-6;\n  var t0, t1, t2, x2, i; // First try a few iterations of Newton\'s method -- normally very fast.\n\n  for (t2 = x, i = 0; i < 8; i++) {\n    x2 = this.sampleCurveX(t2) - x;\n    if (Math.abs(x2) < epsilon) return t2;\n    var d2 = this.sampleCurveDerivativeX(t2);\n    if (Math.abs(d2) < 1e-6) break;\n    t2 = t2 - x2 / d2;\n  } // Fall back to the bisection method for reliability.\n\n\n  t0 = 0.0;\n  t1 = 1.0;\n  t2 = x;\n  if (t2 < t0) return t0;\n  if (t2 > t1) return t1;\n\n  while (t0 < t1) {\n    x2 = this.sampleCurveX(t2);\n    if (Math.abs(x2 - x) < epsilon) return t2;\n\n    if (x > x2) {\n      t0 = t2;\n    } else {\n      t1 = t2;\n    }\n\n    t2 = (t1 - t0) * 0.5 + t0;\n  } // Failure.\n\n\n  return t2;\n};\n\nUnitBezier.prototype.solve = function (x, epsilon) {\n  return this.sampleCurveY(this.solveCurveX(x, epsilon));\n};\n\nfunction number(a, b, t) {\n  return a * (1 - t) + b * t;\n}\n\nfunction color(from, to, t) {\n  return new Color(number(from.r, to.r, t), number(from.g, to.g, t), number(from.b, to.b, t), number(from.a, to.a, t));\n}\n\nfunction array$1(from, to, t) {\n  return from.map(function (d, i) {\n    return number(d, to[i], t);\n  });\n}\n\nvar interpolate = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  number: number,\n  color: color,\n  array: array$1\n});\nvar Xn = 0.95047,\n    Yn = 1,\n    Zn = 1.08883,\n    t0 = 4 / 29,\n    t1 = 6 / 29,\n    t2 = 3 * t1 * t1,\n    t3 = t1 * t1 * t1,\n    deg2rad = Math.PI / 180,\n    rad2deg = 180 / Math.PI;\n\nfunction xyz2lab(t) {\n  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\n\nfunction lab2xyz(t) {\n  return t > t1 ? t * t * t : t2 * (t - t0);\n}\n\nfunction xyz2rgb(x) {\n  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\n\nfunction rgb2xyz(x) {\n  x /= 255;\n  return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n\nfunction rgbToLab(rgbColor) {\n  var b = rgb2xyz(rgbColor.r),\n      a = rgb2xyz(rgbColor.g),\n      l = rgb2xyz(rgbColor.b),\n      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),\n      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.072175 * l) / Yn),\n      z = xyz2lab((0.0193339 * b + 0.119192 * a + 0.9503041 * l) / Zn);\n  return {\n    l: 116 * y - 16,\n    a: 500 * (x - y),\n    b: 200 * (y - z),\n    alpha: rgbColor.a\n  };\n}\n\nfunction labToRgb(labColor) {\n  var y = (labColor.l + 16) / 116,\n      x = isNaN(labColor.a) ? y : y + labColor.a / 500,\n      z = isNaN(labColor.b) ? y : y - labColor.b / 200;\n  y = Yn * lab2xyz(y);\n  x = Xn * lab2xyz(x);\n  z = Zn * lab2xyz(z);\n  return new Color(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), xyz2rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor.alpha);\n}\n\nfunction interpolateLab(from, to, t) {\n  return {\n    l: number(from.l, to.l, t),\n    a: number(from.a, to.a, t),\n    b: number(from.b, to.b, t),\n    alpha: number(from.alpha, to.alpha, t)\n  };\n}\n\nfunction rgbToHcl(rgbColor) {\n  var _rgbToLab = rgbToLab(rgbColor),\n      l = _rgbToLab.l,\n      a = _rgbToLab.a,\n      b = _rgbToLab.b;\n\n  var h = Math.atan2(b, a) * rad2deg;\n  return {\n    h: h < 0 ? h + 360 : h,\n    c: Math.sqrt(a * a + b * b),\n    l: l,\n    alpha: rgbColor.a\n  };\n}\n\nfunction hclToRgb(hclColor) {\n  var h = hclColor.h * deg2rad,\n      c = hclColor.c,\n      l = hclColor.l;\n  return labToRgb({\n    l: l,\n    a: Math.cos(h) * c,\n    b: Math.sin(h) * c,\n    alpha: hclColor.alpha\n  });\n}\n\nfunction interpolateHue(a, b, t) {\n  var d = b - a;\n  return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);\n}\n\nfunction interpolateHcl(from, to, t) {\n  return {\n    h: interpolateHue(from.h, to.h, t),\n    c: number(from.c, to.c, t),\n    l: number(from.l, to.l, t),\n    alpha: number(from.alpha, to.alpha, t)\n  };\n}\n\nvar lab = {\n  forward: rgbToLab,\n  reverse: labToRgb,\n  interpolate: interpolateLab\n};\nvar hcl = {\n  forward: rgbToHcl,\n  reverse: hclToRgb,\n  interpolate: interpolateHcl\n};\nvar colorSpaces = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  lab: lab,\n  hcl: hcl\n});\n\nvar Interpolate = /*#__PURE__*/function () {\n  function Interpolate(type, operator, interpolation, input, stops) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Interpolate);\n\n    this.type = type;\n    this.operator = operator;\n    this.interpolation = interpolation;\n    this.input = input;\n    this.labels = [];\n    this.outputs = [];\n\n    var _iterator25 = _createForOfIteratorHelper(stops),\n        _step25;\n\n    try {\n      for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n        var _step25$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step25.value, 2),\n            label = _step25$value[0],\n            _expression4 = _step25$value[1];\n\n        this.labels.push(label);\n        this.outputs.push(_expression4);\n      }\n    } catch (err) {\n      _iterator25.e(err);\n    } finally {\n      _iterator25.f();\n    }\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Interpolate, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var labels = this.labels;\n      var outputs = this.outputs;\n\n      if (labels.length === 1) {\n        return outputs[0].evaluate(ctx);\n      }\n\n      var value = this.input.evaluate(ctx);\n\n      if (value <= labels[0]) {\n        return outputs[0].evaluate(ctx);\n      }\n\n      var stopCount = labels.length;\n\n      if (value >= labels[stopCount - 1]) {\n        return outputs[stopCount - 1].evaluate(ctx);\n      }\n\n      var index = findStopLessThanOrEqualTo(labels, value);\n      var lower = labels[index];\n      var upper = labels[index + 1];\n      var t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);\n      var outputLower = outputs[index].evaluate(ctx);\n      var outputUpper = outputs[index + 1].evaluate(ctx);\n\n      if (this.operator === \'interpolate\') {\n        return interpolate[this.type.kind.toLowerCase()](outputLower, outputUpper, t);\n      } else if (this.operator === \'interpolate-hcl\') {\n        return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));\n      } else {\n        return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));\n      }\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n\n      var _iterator26 = _createForOfIteratorHelper(this.outputs),\n          _step26;\n\n      try {\n        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n          var _expression5 = _step26.value;\n          fn(_expression5);\n        }\n      } catch (err) {\n        _iterator26.e(err);\n      } finally {\n        _iterator26.f();\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.outputs.every(function (out) {\n        return out.outputDefined();\n      });\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var interpolation;\n\n      if (this.interpolation.name === \'linear\') {\n        interpolation = [\'linear\'];\n      } else if (this.interpolation.name === \'exponential\') {\n        if (this.interpolation.base === 1) {\n          interpolation = [\'linear\'];\n        } else {\n          interpolation = [\'exponential\', this.interpolation.base];\n        }\n      } else {\n        interpolation = [\'cubic-bezier\'].concat(this.interpolation.controlPoints);\n      }\n\n      var serialized = [this.operator, interpolation, this.input.serialize()];\n\n      for (var i = 0; i < this.labels.length; i++) {\n        serialized.push(this.labels[i], this.outputs[i].serialize());\n      }\n\n      return serialized;\n    }\n  }], [{\n    key: "interpolationFactor",\n    value: function interpolationFactor(interpolation, input, lower, upper) {\n      var t = 0;\n\n      if (interpolation.name === \'exponential\') {\n        t = exponentialInterpolation(input, interpolation.base, lower, upper);\n      } else if (interpolation.name === \'linear\') {\n        t = exponentialInterpolation(input, 1, lower, upper);\n      } else if (interpolation.name === \'cubic-bezier\') {\n        var c = interpolation.controlPoints;\n        var ub = new unitbezier(c[0], c[1], c[2], c[3]);\n        t = ub.solve(exponentialInterpolation(input, 1, lower, upper));\n      }\n\n      return t;\n    }\n  }, {\n    key: "parse",\n    value: function parse(args, context) {\n      var _args = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toArray__WEBPACK_IMPORTED_MODULE_8__/* .default */ .Z)(args),\n          operator = _args[0],\n          interpolation = _args[1],\n          input = _args[2],\n          rest = _args.slice(3);\n\n      if (!Array.isArray(interpolation) || interpolation.length === 0) {\n        return context.error("Expected an interpolation type expression.", 1);\n      }\n\n      if (interpolation[0] === \'linear\') {\n        interpolation = {\n          name: \'linear\'\n        };\n      } else if (interpolation[0] === \'exponential\') {\n        var base = interpolation[1];\n        if (typeof base !== \'number\') return context.error("Exponential interpolation requires a numeric base.", 1, 1);\n        interpolation = {\n          name: \'exponential\',\n          base: base\n        };\n      } else if (interpolation[0] === \'cubic-bezier\') {\n        var controlPoints = interpolation.slice(1);\n\n        if (controlPoints.length !== 4 || controlPoints.some(function (t) {\n          return typeof t !== \'number\' || t < 0 || t > 1;\n        })) {\n          return context.error(\'Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.\', 1);\n        }\n\n        interpolation = {\n          name: \'cubic-bezier\',\n          controlPoints: controlPoints\n        };\n      } else {\n        return context.error("Unknown interpolation type ".concat(String(interpolation[0])), 1, 0);\n      }\n\n      if (args.length - 1 < 4) {\n        return context.error("Expected at least 4 arguments, but found only ".concat(args.length - 1, "."));\n      }\n\n      if ((args.length - 1) % 2 !== 0) {\n        return context.error("Expected an even number of arguments.");\n      }\n\n      input = context.parse(input, 2, NumberType);\n      if (!input) return null;\n      var stops = [];\n      var outputType = null;\n\n      if (operator === \'interpolate-hcl\' || operator === \'interpolate-lab\') {\n        outputType = ColorType;\n      } else if (context.expectedType && context.expectedType.kind !== \'value\') {\n        outputType = context.expectedType;\n      }\n\n      for (var i = 0; i < rest.length; i += 2) {\n        var label = rest[i];\n        var value = rest[i + 1];\n        var labelKey = i + 3;\n        var valueKey = i + 4;\n\n        if (typeof label !== \'number\') {\n          return context.error(\'Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.\', labelKey);\n        }\n\n        if (stops.length && stops[stops.length - 1][0] >= label) {\n          return context.error(\'Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.\', labelKey);\n        }\n\n        var parsed = context.parse(value, valueKey, outputType);\n        if (!parsed) return null;\n        outputType = outputType || parsed.type;\n        stops.push([label, parsed]);\n      }\n\n      if (outputType.kind !== \'number\' && outputType.kind !== \'color\' && !(outputType.kind === \'array\' && outputType.itemType.kind === \'number\' && typeof outputType.N === \'number\')) {\n        return context.error("Type ".concat(toString(outputType), " is not interpolatable."));\n      }\n\n      return new Interpolate(outputType, operator, interpolation, input, stops);\n    }\n  }]);\n\n  return Interpolate;\n}();\n\nfunction exponentialInterpolation(input, base, lowerValue, upperValue) {\n  var difference = upperValue - lowerValue;\n  var progress = input - lowerValue;\n\n  if (difference === 0) {\n    return 0;\n  } else if (base === 1) {\n    return progress / difference;\n  } else {\n    return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n  }\n}\n\nvar Coalesce = /*#__PURE__*/function () {\n  function Coalesce(type, args) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Coalesce);\n\n    this.type = type;\n    this.args = args;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Coalesce, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var result = null;\n      var argCount = 0;\n      var requestedImageName;\n\n      var _iterator27 = _createForOfIteratorHelper(this.args),\n          _step27;\n\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var arg = _step27.value;\n          argCount++;\n          result = arg.evaluate(ctx);\n\n          if (result && result instanceof ResolvedImage && !result.available) {\n            if (!requestedImageName) {\n              requestedImageName = result.name;\n            }\n\n            result = null;\n\n            if (argCount === this.args.length) {\n              result = requestedImageName;\n            }\n          }\n\n          if (result !== null) break;\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      this.args.forEach(fn);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.args.every(function (arg) {\n        return arg.outputDefined();\n      });\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'coalesce\'];\n      this.eachChild(function (child) {\n        serialized.push(child.serialize());\n      });\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 2) {\n        return context.error(\'Expectected at least one argument.\');\n      }\n\n      var outputType = null;\n      var expectedType = context.expectedType;\n\n      if (expectedType && expectedType.kind !== \'value\') {\n        outputType = expectedType;\n      }\n\n      var parsedArgs = [];\n\n      var _iterator28 = _createForOfIteratorHelper(args.slice(1)),\n          _step28;\n\n      try {\n        for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n          var arg = _step28.value;\n          var parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, {\n            typeAnnotation: \'omit\'\n          });\n          if (!parsed) return null;\n          outputType = outputType || parsed.type;\n          parsedArgs.push(parsed);\n        }\n      } catch (err) {\n        _iterator28.e(err);\n      } finally {\n        _iterator28.f();\n      }\n\n      var needsAnnotation = expectedType && parsedArgs.some(function (arg) {\n        return _checkSubtype(expectedType, arg.type);\n      });\n      return needsAnnotation ? new Coalesce(ValueType, parsedArgs) : new Coalesce(outputType, parsedArgs);\n    }\n  }]);\n\n  return Coalesce;\n}();\n\nvar Let = /*#__PURE__*/function () {\n  function Let(bindings, result) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Let);\n\n    this.type = result.type;\n    this.bindings = [].concat(bindings);\n    this.result = result;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Let, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      return this.result.evaluate(ctx);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      var _iterator29 = _createForOfIteratorHelper(this.bindings),\n          _step29;\n\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var binding = _step29.value;\n          fn(binding[1]);\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n\n      fn(this.result);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.result.outputDefined();\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'let\'];\n\n      var _iterator30 = _createForOfIteratorHelper(this.bindings),\n          _step30;\n\n      try {\n        for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n          var _step30$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step30.value, 2),\n              name = _step30$value[0],\n              expr = _step30$value[1];\n\n          serialized.push(name, expr.serialize());\n        }\n      } catch (err) {\n        _iterator30.e(err);\n      } finally {\n        _iterator30.f();\n      }\n\n      serialized.push(this.result.serialize());\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 4) return context.error("Expected at least 3 arguments, but found ".concat(args.length - 1, " instead."));\n      var bindings = [];\n\n      for (var i = 1; i < args.length - 1; i += 2) {\n        var name = args[i];\n\n        if (typeof name !== \'string\') {\n          return context.error("Expected string, but found ".concat(typeof name, " instead."), i);\n        }\n\n        if (/[^a-zA-Z0-9_]/.test(name)) {\n          return context.error("Variable names must contain only alphanumeric characters or \'_\'.", i);\n        }\n\n        var value = context.parse(args[i + 1], i + 1);\n        if (!value) return null;\n        bindings.push([name, value]);\n      }\n\n      var result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);\n      if (!result) return null;\n      return new Let(bindings, result);\n    }\n  }]);\n\n  return Let;\n}();\n\nvar At = /*#__PURE__*/function () {\n  function At(type, index, input) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, At);\n\n    this.type = type;\n    this.index = index;\n    this.input = input;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(At, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var index = this.index.evaluate(ctx);\n      var array = this.input.evaluate(ctx);\n\n      if (index < 0) {\n        throw new RuntimeError("Array index out of bounds: ".concat(index, " < 0."));\n      }\n\n      if (index >= array.length) {\n        throw new RuntimeError("Array index out of bounds: ".concat(index, " > ").concat(array.length - 1, "."));\n      }\n\n      if (index !== Math.floor(index)) {\n        throw new RuntimeError("Array index must be an integer, but found ".concat(index, " instead."));\n      }\n\n      return array[index];\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.index);\n      fn(this.input);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'at\', this.index.serialize(), this.input.serialize()];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 3) return context.error("Expected 2 arguments, but found ".concat(args.length - 1, " instead."));\n      var index = context.parse(args[1], 1, NumberType);\n      var input = context.parse(args[2], 2, array(context.expectedType || ValueType));\n      if (!index || !input) return null;\n      var t = input.type;\n      return new At(t.itemType, index, input);\n    }\n  }]);\n\n  return At;\n}();\n\nvar In = /*#__PURE__*/function () {\n  function In(needle, haystack) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, In);\n\n    this.type = BooleanType;\n    this.needle = needle;\n    this.haystack = haystack;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(In, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var needle = this.needle.evaluate(ctx);\n      var haystack = this.haystack.evaluate(ctx);\n      if (!haystack) return false;\n\n      if (!isValidNativeType(needle, [\'boolean\', \'string\', \'number\', \'null\'])) {\n        throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(typeOf(needle)), " instead."));\n      }\n\n      if (!isValidNativeType(haystack, [\'string\', \'array\'])) {\n        throw new RuntimeError("Expected second argument to be of type array or string, but found ".concat(toString(typeOf(haystack)), " instead."));\n      }\n\n      return haystack.indexOf(needle) >= 0;\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.needle);\n      fn(this.haystack);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return true;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      return [\'in\', this.needle.serialize(), this.haystack.serialize()];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 3) {\n        return context.error("Expected 2 arguments, but found ".concat(args.length - 1, " instead."));\n      }\n\n      var needle = context.parse(args[1], 1, ValueType);\n      var haystack = context.parse(args[2], 2, ValueType);\n      if (!needle || !haystack) return null;\n\n      if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {\n        return context.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(needle.type), " instead"));\n      }\n\n      return new In(needle, haystack);\n    }\n  }]);\n\n  return In;\n}();\n\nvar IndexOf = /*#__PURE__*/function () {\n  function IndexOf(needle, haystack, fromIndex) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, IndexOf);\n\n    this.type = NumberType;\n    this.needle = needle;\n    this.haystack = haystack;\n    this.fromIndex = fromIndex;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(IndexOf, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var needle = this.needle.evaluate(ctx);\n      var haystack = this.haystack.evaluate(ctx);\n\n      if (!isValidNativeType(needle, [\'boolean\', \'string\', \'number\', \'null\'])) {\n        throw new RuntimeError("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(typeOf(needle)), " instead."));\n      }\n\n      if (!isValidNativeType(haystack, [\'string\', \'array\'])) {\n        throw new RuntimeError("Expected second argument to be of type array or string, but found ".concat(toString(typeOf(haystack)), " instead."));\n      }\n\n      if (this.fromIndex) {\n        var fromIndex = this.fromIndex.evaluate(ctx);\n        return haystack.indexOf(needle, fromIndex);\n      }\n\n      return haystack.indexOf(needle);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.needle);\n      fn(this.haystack);\n\n      if (this.fromIndex) {\n        fn(this.fromIndex);\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      if (this.fromIndex != null && this.fromIndex !== undefined) {\n        var fromIndex = this.fromIndex.serialize();\n        return [\'index-of\', this.needle.serialize(), this.haystack.serialize(), fromIndex];\n      }\n\n      return [\'index-of\', this.needle.serialize(), this.haystack.serialize()];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length <= 2 || args.length >= 5) {\n        return context.error("Expected 3 or 4 arguments, but found ".concat(args.length - 1, " instead."));\n      }\n\n      var needle = context.parse(args[1], 1, ValueType);\n      var haystack = context.parse(args[2], 2, ValueType);\n      if (!needle || !haystack) return null;\n\n      if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {\n        return context.error("Expected first argument to be of type boolean, string, number or null, but found ".concat(toString(needle.type), " instead"));\n      }\n\n      if (args.length === 4) {\n        var fromIndex = context.parse(args[3], 3, NumberType);\n        if (!fromIndex) return null;\n        return new IndexOf(needle, haystack, fromIndex);\n      } else {\n        return new IndexOf(needle, haystack);\n      }\n    }\n  }]);\n\n  return IndexOf;\n}();\n\nvar Match = /*#__PURE__*/function () {\n  function Match(inputType, outputType, input, cases, outputs, otherwise) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Match);\n\n    this.inputType = inputType;\n    this.type = outputType;\n    this.input = input;\n    this.cases = cases;\n    this.outputs = outputs;\n    this.otherwise = otherwise;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Match, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var input = this.input.evaluate(ctx);\n      var output = typeOf(input) === this.inputType && this.outputs[this.cases[input]] || this.otherwise;\n      return output.evaluate(ctx);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n      this.outputs.forEach(fn);\n      fn(this.otherwise);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.outputs.every(function (out) {\n        return out.outputDefined();\n      }) && this.otherwise.outputDefined();\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var _this2 = this;\n\n      var serialized = [\'match\', this.input.serialize()];\n      var sortedLabels = Object.keys(this.cases).sort();\n      var groupedByOutput = [];\n      var outputLookup = {};\n\n      var _iterator31 = _createForOfIteratorHelper(sortedLabels),\n          _step31;\n\n      try {\n        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n          var label = _step31.value;\n          var _outputIndex = outputLookup[this.cases[label]];\n\n          if (_outputIndex === undefined) {\n            outputLookup[this.cases[label]] = groupedByOutput.length;\n            groupedByOutput.push([this.cases[label], [label]]);\n          } else {\n            groupedByOutput[_outputIndex][1].push(label);\n          }\n        }\n      } catch (err) {\n        _iterator31.e(err);\n      } finally {\n        _iterator31.f();\n      }\n\n      var coerceLabel = function coerceLabel(label) {\n        return _this2.inputType.kind === \'number\' ? Number(label) : label;\n      };\n\n      for (var _i6 = 0, _groupedByOutput = groupedByOutput; _i6 < _groupedByOutput.length; _i6++) {\n        var _groupedByOutput$_i = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_groupedByOutput[_i6], 2),\n            outputIndex = _groupedByOutput$_i[0],\n            labels = _groupedByOutput$_i[1];\n\n        if (labels.length === 1) {\n          serialized.push(coerceLabel(labels[0]));\n        } else {\n          serialized.push(labels.map(coerceLabel));\n        }\n\n        serialized.push(this.outputs[outputIndex].serialize());\n      }\n\n      serialized.push(this.otherwise.serialize());\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 5) return context.error("Expected at least 4 arguments, but found only ".concat(args.length - 1, "."));\n      if (args.length % 2 !== 1) return context.error("Expected an even number of arguments.");\n      var inputType;\n      var outputType;\n\n      if (context.expectedType && context.expectedType.kind !== \'value\') {\n        outputType = context.expectedType;\n      }\n\n      var cases = {};\n      var outputs = [];\n\n      for (var i = 2; i < args.length - 1; i += 2) {\n        var labels = args[i];\n        var value = args[i + 1];\n\n        if (!Array.isArray(labels)) {\n          labels = [labels];\n        }\n\n        var labelContext = context.concat(i);\n\n        if (labels.length === 0) {\n          return labelContext.error(\'Expected at least one branch label.\');\n        }\n\n        var _iterator32 = _createForOfIteratorHelper(labels),\n            _step32;\n\n        try {\n          for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n            var label = _step32.value;\n\n            if (typeof label !== \'number\' && typeof label !== \'string\') {\n              return labelContext.error("Branch labels must be numbers or strings.");\n            } else if (typeof label === \'number\' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {\n              return labelContext.error("Branch labels must be integers no larger than ".concat(Number.MAX_SAFE_INTEGER, "."));\n            } else if (typeof label === \'number\' && Math.floor(label) !== label) {\n              return labelContext.error("Numeric branch labels must be integer values.");\n            } else if (!inputType) {\n              inputType = typeOf(label);\n            } else if (labelContext.checkSubtype(inputType, typeOf(label))) {\n              return null;\n            }\n\n            if (typeof cases[String(label)] !== \'undefined\') {\n              return labelContext.error(\'Branch labels must be unique.\');\n            }\n\n            cases[String(label)] = outputs.length;\n          }\n        } catch (err) {\n          _iterator32.e(err);\n        } finally {\n          _iterator32.f();\n        }\n\n        var result = context.parse(value, i, outputType);\n        if (!result) return null;\n        outputType = outputType || result.type;\n        outputs.push(result);\n      }\n\n      var input = context.parse(args[1], 1, ValueType);\n      if (!input) return null;\n      var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n      if (!otherwise) return null;\n\n      if (input.type.kind !== \'value\' && context.concat(1).checkSubtype(inputType, input.type)) {\n        return null;\n      }\n\n      return new Match(inputType, outputType, input, cases, outputs, otherwise);\n    }\n  }]);\n\n  return Match;\n}();\n\nvar Case = /*#__PURE__*/function () {\n  function Case(type, branches, otherwise) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Case);\n\n    this.type = type;\n    this.branches = branches;\n    this.otherwise = otherwise;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Case, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var _iterator33 = _createForOfIteratorHelper(this.branches),\n          _step33;\n\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var _step33$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step33.value, 2),\n              test = _step33$value[0],\n              _expression6 = _step33$value[1];\n\n          if (test.evaluate(ctx)) {\n            return _expression6.evaluate(ctx);\n          }\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n\n      return this.otherwise.evaluate(ctx);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      var _iterator34 = _createForOfIteratorHelper(this.branches),\n          _step34;\n\n      try {\n        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n          var _step34$value = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_step34.value, 2),\n              test = _step34$value[0],\n              _expression7 = _step34$value[1];\n\n          fn(test);\n          fn(_expression7);\n        }\n      } catch (err) {\n        _iterator34.e(err);\n      } finally {\n        _iterator34.f();\n      }\n\n      fn(this.otherwise);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return this.branches.every(function (_ref5) {\n        var _ref6 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref5, 2),\n            _ = _ref6[0],\n            out = _ref6[1];\n\n        return out.outputDefined();\n      }) && this.otherwise.outputDefined();\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'case\'];\n      this.eachChild(function (child) {\n        serialized.push(child.serialize());\n      });\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length < 4) return context.error("Expected at least 3 arguments, but found only ".concat(args.length - 1, "."));\n      if (args.length % 2 !== 0) return context.error("Expected an odd number of arguments.");\n      var outputType;\n\n      if (context.expectedType && context.expectedType.kind !== \'value\') {\n        outputType = context.expectedType;\n      }\n\n      var branches = [];\n\n      for (var i = 1; i < args.length - 1; i += 2) {\n        var test = context.parse(args[i], i, BooleanType);\n        if (!test) return null;\n        var result = context.parse(args[i + 1], i + 1, outputType);\n        if (!result) return null;\n        branches.push([test, result]);\n        outputType = outputType || result.type;\n      }\n\n      var otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n      if (!otherwise) return null;\n      return new Case(outputType, branches, otherwise);\n    }\n  }]);\n\n  return Case;\n}();\n\nvar Slice = /*#__PURE__*/function () {\n  function Slice(type, input, beginIndex, endIndex) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Slice);\n\n    this.type = type;\n    this.input = input;\n    this.beginIndex = beginIndex;\n    this.endIndex = endIndex;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Slice, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var input = this.input.evaluate(ctx);\n      var beginIndex = this.beginIndex.evaluate(ctx);\n\n      if (!isValidNativeType(input, [\'string\', \'array\'])) {\n        throw new RuntimeError("Expected first argument to be of type array or string, but found ".concat(toString(typeOf(input)), " instead."));\n      }\n\n      if (this.endIndex) {\n        var endIndex = this.endIndex.evaluate(ctx);\n        return input.slice(beginIndex, endIndex);\n      }\n\n      return input.slice(beginIndex);\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n      fn(this.beginIndex);\n\n      if (this.endIndex) {\n        fn(this.endIndex);\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      if (this.endIndex != null && this.endIndex !== undefined) {\n        var endIndex = this.endIndex.serialize();\n        return [\'slice\', this.input.serialize(), this.beginIndex.serialize(), endIndex];\n      }\n\n      return [\'slice\', this.input.serialize(), this.beginIndex.serialize()];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length <= 2 || args.length >= 5) {\n        return context.error("Expected 3 or 4 arguments, but found ".concat(args.length - 1, " instead."));\n      }\n\n      var input = context.parse(args[1], 1, ValueType);\n      var beginIndex = context.parse(args[2], 2, NumberType);\n      if (!input || !beginIndex) return null;\n\n      if (!isValidType(input.type, [array(ValueType), StringType, ValueType])) {\n        return context.error("Expected first argument to be of type array or string, but found ".concat(toString(input.type), " instead"));\n      }\n\n      if (args.length === 4) {\n        var endIndex = context.parse(args[3], 3, NumberType);\n        if (!endIndex) return null;\n        return new Slice(input.type, input, beginIndex, endIndex);\n      } else {\n        return new Slice(input.type, input, beginIndex);\n      }\n    }\n  }]);\n\n  return Slice;\n}();\n\nfunction isComparableType(op, type) {\n  if (op === \'==\' || op === \'!=\') {\n    return type.kind === \'boolean\' || type.kind === \'string\' || type.kind === \'number\' || type.kind === \'null\' || type.kind === \'value\';\n  } else {\n    return type.kind === \'string\' || type.kind === \'number\' || type.kind === \'value\';\n  }\n}\n\nfunction eq(ctx, a, b) {\n  return a === b;\n}\n\nfunction neq(ctx, a, b) {\n  return a !== b;\n}\n\nfunction lt(ctx, a, b) {\n  return a < b;\n}\n\nfunction gt(ctx, a, b) {\n  return a > b;\n}\n\nfunction lteq(ctx, a, b) {\n  return a <= b;\n}\n\nfunction gteq(ctx, a, b) {\n  return a >= b;\n}\n\nfunction eqCollate(ctx, a, b, c) {\n  return c.compare(a, b) === 0;\n}\n\nfunction neqCollate(ctx, a, b, c) {\n  return !eqCollate(ctx, a, b, c);\n}\n\nfunction ltCollate(ctx, a, b, c) {\n  return c.compare(a, b) < 0;\n}\n\nfunction gtCollate(ctx, a, b, c) {\n  return c.compare(a, b) > 0;\n}\n\nfunction lteqCollate(ctx, a, b, c) {\n  return c.compare(a, b) <= 0;\n}\n\nfunction gteqCollate(ctx, a, b, c) {\n  return c.compare(a, b) >= 0;\n}\n\nfunction makeComparison(op, compareBasic, compareWithCollator) {\n  var isOrderComparison = op !== \'==\' && op !== \'!=\';\n  return /*#__PURE__*/function () {\n    function Comparison(lhs, rhs, collator) {\n      (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Comparison);\n\n      this.type = BooleanType;\n      this.lhs = lhs;\n      this.rhs = rhs;\n      this.collator = collator;\n      this.hasUntypedArgument = lhs.type.kind === \'value\' || rhs.type.kind === \'value\';\n    }\n\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Comparison, [{\n      key: "evaluate",\n      value: function evaluate(ctx) {\n        var lhs = this.lhs.evaluate(ctx);\n        var rhs = this.rhs.evaluate(ctx);\n\n        if (isOrderComparison && this.hasUntypedArgument) {\n          var _lt = typeOf(lhs);\n\n          var rt = typeOf(rhs);\n\n          if (_lt.kind !== rt.kind || !(_lt.kind === \'string\' || _lt.kind === \'number\')) {\n            throw new RuntimeError("Expected arguments for \\"".concat(op, "\\" to be (string, string) or (number, number), but found (").concat(_lt.kind, ", ").concat(rt.kind, ") instead."));\n          }\n        }\n\n        if (this.collator && !isOrderComparison && this.hasUntypedArgument) {\n          var _lt2 = typeOf(lhs);\n\n          var _rt = typeOf(rhs);\n\n          if (_lt2.kind !== \'string\' || _rt.kind !== \'string\') {\n            return compareBasic(ctx, lhs, rhs);\n          }\n        }\n\n        return this.collator ? compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) : compareBasic(ctx, lhs, rhs);\n      }\n    }, {\n      key: "eachChild",\n      value: function eachChild(fn) {\n        fn(this.lhs);\n        fn(this.rhs);\n\n        if (this.collator) {\n          fn(this.collator);\n        }\n      }\n    }, {\n      key: "outputDefined",\n      value: function outputDefined() {\n        return true;\n      }\n    }, {\n      key: "serialize",\n      value: function serialize() {\n        var serialized = [op];\n        this.eachChild(function (child) {\n          serialized.push(child.serialize());\n        });\n        return serialized;\n      }\n    }], [{\n      key: "parse",\n      value: function parse(args, context) {\n        if (args.length !== 3 && args.length !== 4) return context.error("Expected two or three arguments.");\n        var op = args[0];\n        var lhs = context.parse(args[1], 1, ValueType);\n        if (!lhs) return null;\n\n        if (!isComparableType(op, lhs.type)) {\n          return context.concat(1).error("\\"".concat(op, "\\" comparisons are not supported for type \'").concat(toString(lhs.type), "\'."));\n        }\n\n        var rhs = context.parse(args[2], 2, ValueType);\n        if (!rhs) return null;\n\n        if (!isComparableType(op, rhs.type)) {\n          return context.concat(2).error("\\"".concat(op, "\\" comparisons are not supported for type \'").concat(toString(rhs.type), "\'."));\n        }\n\n        if (lhs.type.kind !== rhs.type.kind && lhs.type.kind !== \'value\' && rhs.type.kind !== \'value\') {\n          return context.error("Cannot compare types \'".concat(toString(lhs.type), "\' and \'").concat(toString(rhs.type), "\'."));\n        }\n\n        if (isOrderComparison) {\n          if (lhs.type.kind === \'value\' && rhs.type.kind !== \'value\') {\n            lhs = new Assertion(rhs.type, [lhs]);\n          } else if (lhs.type.kind !== \'value\' && rhs.type.kind === \'value\') {\n            rhs = new Assertion(lhs.type, [rhs]);\n          }\n        }\n\n        var collator = null;\n\n        if (args.length === 4) {\n          if (lhs.type.kind !== \'string\' && rhs.type.kind !== \'string\' && lhs.type.kind !== \'value\' && rhs.type.kind !== \'value\') {\n            return context.error("Cannot use collator to compare non-string types.");\n          }\n\n          collator = context.parse(args[3], 3, CollatorType);\n          if (!collator) return null;\n        }\n\n        return new Comparison(lhs, rhs, collator);\n      }\n    }]);\n\n    return Comparison;\n  }();\n}\n\nvar Equals = makeComparison(\'==\', eq, eqCollate);\nvar NotEquals = makeComparison(\'!=\', neq, neqCollate);\nvar LessThan = makeComparison(\'<\', lt, ltCollate);\nvar GreaterThan = makeComparison(\'>\', gt, gtCollate);\nvar LessThanOrEqual = makeComparison(\'<=\', lteq, lteqCollate);\nvar GreaterThanOrEqual = makeComparison(\'>=\', gteq, gteqCollate);\n\nvar NumberFormat = /*#__PURE__*/function () {\n  function NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, NumberFormat);\n\n    this.type = StringType;\n    this.number = number;\n    this.locale = locale;\n    this.currency = currency;\n    this.minFractionDigits = minFractionDigits;\n    this.maxFractionDigits = maxFractionDigits;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(NumberFormat, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [], {\n        style: this.currency ? \'currency\' : \'decimal\',\n        currency: this.currency ? this.currency.evaluate(ctx) : undefined,\n        minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,\n        maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined\n      }).format(this.number.evaluate(ctx));\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.number);\n\n      if (this.locale) {\n        fn(this.locale);\n      }\n\n      if (this.currency) {\n        fn(this.currency);\n      }\n\n      if (this.minFractionDigits) {\n        fn(this.minFractionDigits);\n      }\n\n      if (this.maxFractionDigits) {\n        fn(this.maxFractionDigits);\n      }\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var options = {};\n\n      if (this.locale) {\n        options[\'locale\'] = this.locale.serialize();\n      }\n\n      if (this.currency) {\n        options[\'currency\'] = this.currency.serialize();\n      }\n\n      if (this.minFractionDigits) {\n        options[\'min-fraction-digits\'] = this.minFractionDigits.serialize();\n      }\n\n      if (this.maxFractionDigits) {\n        options[\'max-fraction-digits\'] = this.maxFractionDigits.serialize();\n      }\n\n      return [\'number-format\', this.number.serialize(), options];\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 3) return context.error("Expected two arguments.");\n      var number = context.parse(args[1], 1, NumberType);\n      if (!number) return null;\n      var options = args[2];\n      if (typeof options !== \'object\' || Array.isArray(options)) return context.error("NumberFormat options argument must be an object.");\n      var locale = null;\n\n      if (options[\'locale\']) {\n        locale = context.parse(options[\'locale\'], 1, StringType);\n        if (!locale) return null;\n      }\n\n      var currency = null;\n\n      if (options[\'currency\']) {\n        currency = context.parse(options[\'currency\'], 1, StringType);\n        if (!currency) return null;\n      }\n\n      var minFractionDigits = null;\n\n      if (options[\'min-fraction-digits\']) {\n        minFractionDigits = context.parse(options[\'min-fraction-digits\'], 1, NumberType);\n        if (!minFractionDigits) return null;\n      }\n\n      var maxFractionDigits = null;\n\n      if (options[\'max-fraction-digits\']) {\n        maxFractionDigits = context.parse(options[\'max-fraction-digits\'], 1, NumberType);\n        if (!maxFractionDigits) return null;\n      }\n\n      return new NumberFormat(number, locale, currency, minFractionDigits, maxFractionDigits);\n    }\n  }]);\n\n  return NumberFormat;\n}();\n\nvar Length = /*#__PURE__*/function () {\n  function Length(input) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, Length);\n\n    this.type = NumberType;\n    this.input = input;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(Length, [{\n    key: "evaluate",\n    value: function evaluate(ctx) {\n      var input = this.input.evaluate(ctx);\n\n      if (typeof input === \'string\') {\n        return input.length;\n      } else if (Array.isArray(input)) {\n        return input.length;\n      } else {\n        throw new RuntimeError("Expected value to be of type string or array, but found ".concat(toString(typeOf(input)), " instead."));\n      }\n    }\n  }, {\n    key: "eachChild",\n    value: function eachChild(fn) {\n      fn(this.input);\n    }\n  }, {\n    key: "outputDefined",\n    value: function outputDefined() {\n      return false;\n    }\n  }, {\n    key: "serialize",\n    value: function serialize() {\n      var serialized = [\'length\'];\n      this.eachChild(function (child) {\n        serialized.push(child.serialize());\n      });\n      return serialized;\n    }\n  }], [{\n    key: "parse",\n    value: function parse(args, context) {\n      if (args.length !== 2) return context.error("Expected 1 argument, but found ".concat(args.length - 1, " instead."));\n      var input = context.parse(args[1], 1);\n      if (!input) return null;\n      if (input.type.kind !== \'array\' && input.type.kind !== \'string\' && input.type.kind !== \'value\') return context.error("Expected argument of type string or array, but found ".concat(toString(input.type), " instead."));\n      return new Length(input);\n    }\n  }]);\n\n  return Length;\n}();\n\nvar expressions = {\n  \'==\': Equals,\n  \'!=\': NotEquals,\n  \'>\': GreaterThan,\n  \'<\': LessThan,\n  \'>=\': GreaterThanOrEqual,\n  \'<=\': LessThanOrEqual,\n  \'array\': Assertion,\n  \'at\': At,\n  \'boolean\': Assertion,\n  \'case\': Case,\n  \'coalesce\': Coalesce,\n  \'collator\': CollatorExpression,\n  \'format\': FormatExpression,\n  \'image\': ImageExpression,\n  \'in\': In,\n  \'index-of\': IndexOf,\n  \'interpolate\': Interpolate,\n  \'interpolate-hcl\': Interpolate,\n  \'interpolate-lab\': Interpolate,\n  \'length\': Length,\n  \'let\': Let,\n  \'literal\': Literal,\n  \'match\': Match,\n  \'number\': Assertion,\n  \'number-format\': NumberFormat,\n  \'object\': Assertion,\n  \'slice\': Slice,\n  \'step\': Step,\n  \'string\': Assertion,\n  \'to-boolean\': Coercion,\n  \'to-color\': Coercion,\n  \'to-number\': Coercion,\n  \'to-string\': Coercion,\n  \'var\': Var,\n  \'within\': Within\n};\n\nfunction rgba(ctx, _ref7) {\n  var _ref8 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref7, 4),\n      r = _ref8[0],\n      g = _ref8[1],\n      b = _ref8[2],\n      a = _ref8[3];\n\n  r = r.evaluate(ctx);\n  g = g.evaluate(ctx);\n  b = b.evaluate(ctx);\n  var alpha = a ? a.evaluate(ctx) : 1;\n  var error = validateRGBA(r, g, b, alpha);\n  if (error) throw new RuntimeError(error);\n  return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);\n}\n\nfunction has(key, obj) {\n  return key in obj;\n}\n\nfunction get(key, obj) {\n  var v = obj[key];\n  return typeof v === \'undefined\' ? null : v;\n}\n\nfunction binarySearch(v, a, i, j) {\n  while (i <= j) {\n    var m = i + j >> 1;\n    if (a[m] === v) return true;\n    if (a[m] > v) j = m - 1;else i = m + 1;\n  }\n\n  return false;\n}\n\nfunction varargs(type) {\n  return {\n    type: type\n  };\n}\n\nCompoundExpression.register(expressions, {\n  \'error\': [ErrorType, [StringType], function (ctx, _ref9) {\n    var _ref10 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref9, 1),\n        v = _ref10[0];\n\n    throw new RuntimeError(v.evaluate(ctx));\n  }],\n  \'typeof\': [StringType, [ValueType], function (ctx, _ref11) {\n    var _ref12 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref11, 1),\n        v = _ref12[0];\n\n    return toString(typeOf(v.evaluate(ctx)));\n  }],\n  \'to-rgba\': [array(NumberType, 4), [ColorType], function (ctx, _ref13) {\n    var _ref14 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref13, 1),\n        v = _ref14[0];\n\n    return v.evaluate(ctx).toArray();\n  }],\n  \'rgb\': [ColorType, [NumberType, NumberType, NumberType], rgba],\n  \'rgba\': [ColorType, [NumberType, NumberType, NumberType, NumberType], rgba],\n  \'has\': {\n    type: BooleanType,\n    overloads: [[[StringType], function (ctx, _ref15) {\n      var _ref16 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref15, 1),\n          key = _ref16[0];\n\n      return has(key.evaluate(ctx), ctx.properties());\n    }], [[StringType, ObjectType], function (ctx, _ref17) {\n      var _ref18 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref17, 2),\n          key = _ref18[0],\n          obj = _ref18[1];\n\n      return has(key.evaluate(ctx), obj.evaluate(ctx));\n    }]]\n  },\n  \'get\': {\n    type: ValueType,\n    overloads: [[[StringType], function (ctx, _ref19) {\n      var _ref20 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref19, 1),\n          key = _ref20[0];\n\n      return get(key.evaluate(ctx), ctx.properties());\n    }], [[StringType, ObjectType], function (ctx, _ref21) {\n      var _ref22 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref21, 2),\n          key = _ref22[0],\n          obj = _ref22[1];\n\n      return get(key.evaluate(ctx), obj.evaluate(ctx));\n    }]]\n  },\n  \'feature-state\': [ValueType, [StringType], function (ctx, _ref23) {\n    var _ref24 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref23, 1),\n        key = _ref24[0];\n\n    return get(key.evaluate(ctx), ctx.featureState || {});\n  }],\n  \'properties\': [ObjectType, [], function (ctx) {\n    return ctx.properties();\n  }],\n  \'geometry-type\': [StringType, [], function (ctx) {\n    return ctx.geometryType();\n  }],\n  \'id\': [ValueType, [], function (ctx) {\n    return ctx.id();\n  }],\n  \'zoom\': [NumberType, [], function (ctx) {\n    return ctx.globals.zoom;\n  }],\n  \'heatmap-density\': [NumberType, [], function (ctx) {\n    return ctx.globals.heatmapDensity || 0;\n  }],\n  \'line-progress\': [NumberType, [], function (ctx) {\n    return ctx.globals.lineProgress || 0;\n  }],\n  \'sky-radial-progress\': [NumberType, [], function (ctx) {\n    return ctx.globals.skyRadialProgress || 0;\n  }],\n  \'accumulated\': [ValueType, [], function (ctx) {\n    return ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated;\n  }],\n  \'+\': [NumberType, varargs(NumberType), function (ctx, args) {\n    var result = 0;\n\n    var _iterator35 = _createForOfIteratorHelper(args),\n        _step35;\n\n    try {\n      for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n        var arg = _step35.value;\n        result += arg.evaluate(ctx);\n      }\n    } catch (err) {\n      _iterator35.e(err);\n    } finally {\n      _iterator35.f();\n    }\n\n    return result;\n  }],\n  \'*\': [NumberType, varargs(NumberType), function (ctx, args) {\n    var result = 1;\n\n    var _iterator36 = _createForOfIteratorHelper(args),\n        _step36;\n\n    try {\n      for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n        var arg = _step36.value;\n        result *= arg.evaluate(ctx);\n      }\n    } catch (err) {\n      _iterator36.e(err);\n    } finally {\n      _iterator36.f();\n    }\n\n    return result;\n  }],\n  \'-\': {\n    type: NumberType,\n    overloads: [[[NumberType, NumberType], function (ctx, _ref25) {\n      var _ref26 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref25, 2),\n          a = _ref26[0],\n          b = _ref26[1];\n\n      return a.evaluate(ctx) - b.evaluate(ctx);\n    }], [[NumberType], function (ctx, _ref27) {\n      var _ref28 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref27, 1),\n          a = _ref28[0];\n\n      return -a.evaluate(ctx);\n    }]]\n  },\n  \'/\': [NumberType, [NumberType, NumberType], function (ctx, _ref29) {\n    var _ref30 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref29, 2),\n        a = _ref30[0],\n        b = _ref30[1];\n\n    return a.evaluate(ctx) / b.evaluate(ctx);\n  }],\n  \'%\': [NumberType, [NumberType, NumberType], function (ctx, _ref31) {\n    var _ref32 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref31, 2),\n        a = _ref32[0],\n        b = _ref32[1];\n\n    return a.evaluate(ctx) % b.evaluate(ctx);\n  }],\n  \'ln2\': [NumberType, [], function () {\n    return Math.LN2;\n  }],\n  \'pi\': [NumberType, [], function () {\n    return Math.PI;\n  }],\n  \'e\': [NumberType, [], function () {\n    return Math.E;\n  }],\n  \'^\': [NumberType, [NumberType, NumberType], function (ctx, _ref33) {\n    var _ref34 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref33, 2),\n        b = _ref34[0],\n        e = _ref34[1];\n\n    return Math.pow(b.evaluate(ctx), e.evaluate(ctx));\n  }],\n  \'sqrt\': [NumberType, [NumberType], function (ctx, _ref35) {\n    var _ref36 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref35, 1),\n        x = _ref36[0];\n\n    return Math.sqrt(x.evaluate(ctx));\n  }],\n  \'log10\': [NumberType, [NumberType], function (ctx, _ref37) {\n    var _ref38 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref37, 1),\n        n = _ref38[0];\n\n    return Math.log(n.evaluate(ctx)) / Math.LN10;\n  }],\n  \'ln\': [NumberType, [NumberType], function (ctx, _ref39) {\n    var _ref40 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref39, 1),\n        n = _ref40[0];\n\n    return Math.log(n.evaluate(ctx));\n  }],\n  \'log2\': [NumberType, [NumberType], function (ctx, _ref41) {\n    var _ref42 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref41, 1),\n        n = _ref42[0];\n\n    return Math.log(n.evaluate(ctx)) / Math.LN2;\n  }],\n  \'sin\': [NumberType, [NumberType], function (ctx, _ref43) {\n    var _ref44 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref43, 1),\n        n = _ref44[0];\n\n    return Math.sin(n.evaluate(ctx));\n  }],\n  \'cos\': [NumberType, [NumberType], function (ctx, _ref45) {\n    var _ref46 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref45, 1),\n        n = _ref46[0];\n\n    return Math.cos(n.evaluate(ctx));\n  }],\n  \'tan\': [NumberType, [NumberType], function (ctx, _ref47) {\n    var _ref48 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref47, 1),\n        n = _ref48[0];\n\n    return Math.tan(n.evaluate(ctx));\n  }],\n  \'asin\': [NumberType, [NumberType], function (ctx, _ref49) {\n    var _ref50 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref49, 1),\n        n = _ref50[0];\n\n    return Math.asin(n.evaluate(ctx));\n  }],\n  \'acos\': [NumberType, [NumberType], function (ctx, _ref51) {\n    var _ref52 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref51, 1),\n        n = _ref52[0];\n\n    return Math.acos(n.evaluate(ctx));\n  }],\n  \'atan\': [NumberType, [NumberType], function (ctx, _ref53) {\n    var _ref54 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref53, 1),\n        n = _ref54[0];\n\n    return Math.atan(n.evaluate(ctx));\n  }],\n  \'min\': [NumberType, varargs(NumberType), function (ctx, args) {\n    return Math.min.apply(Math, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(args.map(function (arg) {\n      return arg.evaluate(ctx);\n    })));\n  }],\n  \'max\': [NumberType, varargs(NumberType), function (ctx, args) {\n    return Math.max.apply(Math, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(args.map(function (arg) {\n      return arg.evaluate(ctx);\n    })));\n  }],\n  \'abs\': [NumberType, [NumberType], function (ctx, _ref55) {\n    var _ref56 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref55, 1),\n        n = _ref56[0];\n\n    return Math.abs(n.evaluate(ctx));\n  }],\n  \'round\': [NumberType, [NumberType], function (ctx, _ref57) {\n    var _ref58 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref57, 1),\n        n = _ref58[0];\n\n    var v = n.evaluate(ctx);\n    return v < 0 ? -Math.round(-v) : Math.round(v);\n  }],\n  \'floor\': [NumberType, [NumberType], function (ctx, _ref59) {\n    var _ref60 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref59, 1),\n        n = _ref60[0];\n\n    return Math.floor(n.evaluate(ctx));\n  }],\n  \'ceil\': [NumberType, [NumberType], function (ctx, _ref61) {\n    var _ref62 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref61, 1),\n        n = _ref62[0];\n\n    return Math.ceil(n.evaluate(ctx));\n  }],\n  \'filter-==\': [BooleanType, [StringType, ValueType], function (ctx, _ref63) {\n    var _ref64 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref63, 2),\n        k = _ref64[0],\n        v = _ref64[1];\n\n    return ctx.properties()[k.value] === v.value;\n  }],\n  \'filter-id-==\': [BooleanType, [ValueType], function (ctx, _ref65) {\n    var _ref66 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref65, 1),\n        v = _ref66[0];\n\n    return ctx.id() === v.value;\n  }],\n  \'filter-type-==\': [BooleanType, [StringType], function (ctx, _ref67) {\n    var _ref68 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref67, 1),\n        v = _ref68[0];\n\n    return ctx.geometryType() === v.value;\n  }],\n  \'filter-<\': [BooleanType, [StringType, ValueType], function (ctx, _ref69) {\n    var _ref70 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref69, 2),\n        k = _ref70[0],\n        v = _ref70[1];\n\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a < b;\n  }],\n  \'filter-id-<\': [BooleanType, [ValueType], function (ctx, _ref71) {\n    var _ref72 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref71, 1),\n        v = _ref72[0];\n\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a < b;\n  }],\n  \'filter->\': [BooleanType, [StringType, ValueType], function (ctx, _ref73) {\n    var _ref74 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref73, 2),\n        k = _ref74[0],\n        v = _ref74[1];\n\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a > b;\n  }],\n  \'filter-id->\': [BooleanType, [ValueType], function (ctx, _ref75) {\n    var _ref76 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref75, 1),\n        v = _ref76[0];\n\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a > b;\n  }],\n  \'filter-<=\': [BooleanType, [StringType, ValueType], function (ctx, _ref77) {\n    var _ref78 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref77, 2),\n        k = _ref78[0],\n        v = _ref78[1];\n\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a <= b;\n  }],\n  \'filter-id-<=\': [BooleanType, [ValueType], function (ctx, _ref79) {\n    var _ref80 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref79, 1),\n        v = _ref80[0];\n\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a <= b;\n  }],\n  \'filter->=\': [BooleanType, [StringType, ValueType], function (ctx, _ref81) {\n    var _ref82 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref81, 2),\n        k = _ref82[0],\n        v = _ref82[1];\n\n    var a = ctx.properties()[k.value];\n    var b = v.value;\n    return typeof a === typeof b && a >= b;\n  }],\n  \'filter-id->=\': [BooleanType, [ValueType], function (ctx, _ref83) {\n    var _ref84 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref83, 1),\n        v = _ref84[0];\n\n    var a = ctx.id();\n    var b = v.value;\n    return typeof a === typeof b && a >= b;\n  }],\n  \'filter-has\': [BooleanType, [ValueType], function (ctx, _ref85) {\n    var _ref86 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref85, 1),\n        k = _ref86[0];\n\n    return k.value in ctx.properties();\n  }],\n  \'filter-has-id\': [BooleanType, [], function (ctx) {\n    return ctx.id() !== null && ctx.id() !== undefined;\n  }],\n  \'filter-type-in\': [BooleanType, [array(StringType)], function (ctx, _ref87) {\n    var _ref88 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref87, 1),\n        v = _ref88[0];\n\n    return v.value.indexOf(ctx.geometryType()) >= 0;\n  }],\n  \'filter-id-in\': [BooleanType, [array(ValueType)], function (ctx, _ref89) {\n    var _ref90 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref89, 1),\n        v = _ref90[0];\n\n    return v.value.indexOf(ctx.id()) >= 0;\n  }],\n  \'filter-in-small\': [BooleanType, [StringType, array(ValueType)], function (ctx, _ref91) {\n    var _ref92 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref91, 2),\n        k = _ref92[0],\n        v = _ref92[1];\n\n    return v.value.indexOf(ctx.properties()[k.value]) >= 0;\n  }],\n  \'filter-in-large\': [BooleanType, [StringType, array(ValueType)], function (ctx, _ref93) {\n    var _ref94 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref93, 2),\n        k = _ref94[0],\n        v = _ref94[1];\n\n    return binarySearch(ctx.properties()[k.value], v.value, 0, v.value.length - 1);\n  }],\n  \'all\': {\n    type: BooleanType,\n    overloads: [[[BooleanType, BooleanType], function (ctx, _ref95) {\n      var _ref96 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref95, 2),\n          a = _ref96[0],\n          b = _ref96[1];\n\n      return a.evaluate(ctx) && b.evaluate(ctx);\n    }], [varargs(BooleanType), function (ctx, args) {\n      var _iterator37 = _createForOfIteratorHelper(args),\n          _step37;\n\n      try {\n        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n          var arg = _step37.value;\n          if (!arg.evaluate(ctx)) return false;\n        }\n      } catch (err) {\n        _iterator37.e(err);\n      } finally {\n        _iterator37.f();\n      }\n\n      return true;\n    }]]\n  },\n  \'any\': {\n    type: BooleanType,\n    overloads: [[[BooleanType, BooleanType], function (ctx, _ref97) {\n      var _ref98 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref97, 2),\n          a = _ref98[0],\n          b = _ref98[1];\n\n      return a.evaluate(ctx) || b.evaluate(ctx);\n    }], [varargs(BooleanType), function (ctx, args) {\n      var _iterator38 = _createForOfIteratorHelper(args),\n          _step38;\n\n      try {\n        for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n          var arg = _step38.value;\n          if (arg.evaluate(ctx)) return true;\n        }\n      } catch (err) {\n        _iterator38.e(err);\n      } finally {\n        _iterator38.f();\n      }\n\n      return false;\n    }]]\n  },\n  \'!\': [BooleanType, [BooleanType], function (ctx, _ref99) {\n    var _ref100 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref99, 1),\n        b = _ref100[0];\n\n    return !b.evaluate(ctx);\n  }],\n  \'is-supported-script\': [BooleanType, [StringType], function (ctx, _ref101) {\n    var _ref102 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref101, 1),\n        s = _ref102[0];\n\n    var isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;\n\n    if (isSupportedScript) {\n      return isSupportedScript(s.evaluate(ctx));\n    }\n\n    return true;\n  }],\n  \'upcase\': [StringType, [StringType], function (ctx, _ref103) {\n    var _ref104 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref103, 1),\n        s = _ref104[0];\n\n    return s.evaluate(ctx).toUpperCase();\n  }],\n  \'downcase\': [StringType, [StringType], function (ctx, _ref105) {\n    var _ref106 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref105, 1),\n        s = _ref106[0];\n\n    return s.evaluate(ctx).toLowerCase();\n  }],\n  \'concat\': [StringType, varargs(ValueType), function (ctx, args) {\n    return args.map(function (arg) {\n      return toString$1(arg.evaluate(ctx));\n    }).join(\'\');\n  }],\n  \'resolved-locale\': [StringType, [CollatorType], function (ctx, _ref107) {\n    var _ref108 = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(_ref107, 1),\n        collator = _ref108[0];\n\n    return collator.evaluate(ctx).resolvedLocale();\n  }]\n});\n\nfunction success(value) {\n  return {\n    result: \'success\',\n    value: value\n  };\n}\n\nfunction error(value) {\n  return {\n    result: \'error\',\n    value: value\n  };\n}\n\nfunction supportsPropertyExpression(spec) {\n  return spec[\'property-type\'] === \'data-driven\' || spec[\'property-type\'] === \'cross-faded-data-driven\';\n}\n\nfunction supportsZoomExpression(spec) {\n  return !!spec.expression && spec.expression.parameters.indexOf(\'zoom\') > -1;\n}\n\nfunction supportsInterpolation(spec) {\n  return !!spec.expression && spec.expression.interpolated;\n}\n\nfunction getType(val) {\n  if (val instanceof Number) {\n    return \'number\';\n  } else if (val instanceof String) {\n    return \'string\';\n  } else if (val instanceof Boolean) {\n    return \'boolean\';\n  } else if (Array.isArray(val)) {\n    return \'array\';\n  } else if (val === null) {\n    return \'null\';\n  } else {\n    return typeof val;\n  }\n}\n\nfunction isFunction$1(value) {\n  return typeof value === \'object\' && value !== null && !Array.isArray(value);\n}\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction createFunction(parameters, propertySpec) {\n  var isColor = propertySpec.type === \'color\';\n  var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === \'object\';\n  var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n  var zoomDependent = zoomAndFeatureDependent || !featureDependent;\n  var type = parameters.type || (supportsInterpolation(propertySpec) ? \'exponential\' : \'interval\');\n\n  if (isColor) {\n    parameters = extend({}, parameters);\n\n    if (parameters.stops) {\n      parameters.stops = parameters.stops.map(function (stop) {\n        return [stop[0], Color.parse(stop[1])];\n      });\n    }\n\n    if (parameters.default) {\n      parameters.default = Color.parse(parameters.default);\n    } else {\n      parameters.default = Color.parse(propertySpec.default);\n    }\n  }\n\n  if (parameters.colorSpace && parameters.colorSpace !== \'rgb\' && !colorSpaces[parameters.colorSpace]) {\n    throw new Error("Unknown color space: ".concat(parameters.colorSpace));\n  }\n\n  var innerFun;\n  var hashedStops;\n  var categoricalKeyType;\n\n  if (type === \'exponential\') {\n    innerFun = evaluateExponentialFunction;\n  } else if (type === \'interval\') {\n    innerFun = evaluateIntervalFunction;\n  } else if (type === \'categorical\') {\n    innerFun = evaluateCategoricalFunction;\n    hashedStops = Object.create(null);\n\n    var _iterator39 = _createForOfIteratorHelper(parameters.stops),\n        _step39;\n\n    try {\n      for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n        var stop = _step39.value;\n        hashedStops[stop[0]] = stop[1];\n      }\n    } catch (err) {\n      _iterator39.e(err);\n    } finally {\n      _iterator39.f();\n    }\n\n    categoricalKeyType = typeof parameters.stops[0][0];\n  } else if (type === \'identity\') {\n    innerFun = evaluateIdentityFunction;\n  } else {\n    throw new Error("Unknown function type \\"".concat(type, "\\""));\n  }\n\n  if (zoomAndFeatureDependent) {\n    var featureFunctions = {};\n    var zoomStops = [];\n\n    for (var s = 0; s < parameters.stops.length; s++) {\n      var _stop = parameters.stops[s];\n      var zoom = _stop[0].zoom;\n\n      if (featureFunctions[zoom] === undefined) {\n        featureFunctions[zoom] = {\n          zoom: zoom,\n          type: parameters.type,\n          property: parameters.property,\n          default: parameters.default,\n          stops: []\n        };\n        zoomStops.push(zoom);\n      }\n\n      featureFunctions[zoom].stops.push([_stop[0].value, _stop[1]]);\n    }\n\n    var featureFunctionStops = [];\n\n    for (var _i7 = 0, _zoomStops = zoomStops; _i7 < _zoomStops.length; _i7++) {\n      var z = _zoomStops[_i7];\n      featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);\n    }\n\n    var interpolationType = {\n      name: \'linear\'\n    };\n    return {\n      kind: \'composite\',\n      interpolationType: interpolationType,\n      interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),\n      zoomStops: featureFunctionStops.map(function (s) {\n        return s[0];\n      }),\n      evaluate: function evaluate(_ref109, properties) {\n        var zoom = _ref109.zoom;\n        return evaluateExponentialFunction({\n          stops: featureFunctionStops,\n          base: parameters.base\n        }, propertySpec, zoom).evaluate(zoom, properties);\n      }\n    };\n  } else if (zoomDependent) {\n    var _interpolationType = type === \'exponential\' ? {\n      name: \'exponential\',\n      base: parameters.base !== undefined ? parameters.base : 1\n    } : null;\n\n    return {\n      kind: \'camera\',\n      interpolationType: _interpolationType,\n      interpolationFactor: Interpolate.interpolationFactor.bind(undefined, _interpolationType),\n      zoomStops: parameters.stops.map(function (s) {\n        return s[0];\n      }),\n      evaluate: function evaluate(_ref110) {\n        var zoom = _ref110.zoom;\n        return innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType);\n      }\n    };\n  } else {\n    return {\n      kind: \'source\',\n      evaluate: function evaluate(_, feature) {\n        var value = feature && feature.properties ? feature.properties[parameters.property] : undefined;\n\n        if (value === undefined) {\n          return coalesce(parameters.default, propertySpec.default);\n        }\n\n        return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);\n      }\n    };\n  }\n}\n\nfunction coalesce(a, b, c) {\n  if (a !== undefined) return a;\n  if (b !== undefined) return b;\n  if (c !== undefined) return c;\n}\n\nfunction evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {\n  var evaluated = typeof input === keyType ? hashedStops[input] : undefined;\n  return coalesce(evaluated, parameters.default, propertySpec.default);\n}\n\nfunction evaluateIntervalFunction(parameters, propertySpec, input) {\n  if (getType(input) !== \'number\') return coalesce(parameters.default, propertySpec.default);\n  var n = parameters.stops.length;\n  if (n === 1) return parameters.stops[0][1];\n  if (input <= parameters.stops[0][0]) return parameters.stops[0][1];\n  if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];\n  var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {\n    return stop[0];\n  }), input);\n  return parameters.stops[index][1];\n}\n\nfunction evaluateExponentialFunction(parameters, propertySpec, input) {\n  var base = parameters.base !== undefined ? parameters.base : 1;\n  if (getType(input) !== \'number\') return coalesce(parameters.default, propertySpec.default);\n  var n = parameters.stops.length;\n  if (n === 1) return parameters.stops[0][1];\n  if (input <= parameters.stops[0][0]) return parameters.stops[0][1];\n  if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];\n  var index = findStopLessThanOrEqualTo(parameters.stops.map(function (stop) {\n    return stop[0];\n  }), input);\n  var t = interpolationFactor(input, base, parameters.stops[index][0], parameters.stops[index + 1][0]);\n  var outputLower = parameters.stops[index][1];\n  var outputUpper = parameters.stops[index + 1][1];\n  var interp = interpolate[propertySpec.type] || identityFunction;\n\n  if (parameters.colorSpace && parameters.colorSpace !== \'rgb\') {\n    var colorspace = colorSpaces[parameters.colorSpace];\n\n    interp = function interp(a, b) {\n      return colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));\n    };\n  }\n\n  if (typeof outputLower.evaluate === \'function\') {\n    return {\n      evaluate: function evaluate() {\n        for (var _len3 = arguments.length, args = new Array(_len3), _key5 = 0; _key5 < _len3; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n\n        var evaluatedLower = outputLower.evaluate.apply(undefined, args);\n        var evaluatedUpper = outputUpper.evaluate.apply(undefined, args);\n\n        if (evaluatedLower === undefined || evaluatedUpper === undefined) {\n          return undefined;\n        }\n\n        return interp(evaluatedLower, evaluatedUpper, t);\n      }\n    };\n  }\n\n  return interp(outputLower, outputUpper, t);\n}\n\nfunction evaluateIdentityFunction(parameters, propertySpec, input) {\n  if (propertySpec.type === \'color\') {\n    input = Color.parse(input);\n  } else if (propertySpec.type === \'formatted\') {\n    input = Formatted.fromString(input.toString());\n  } else if (propertySpec.type === \'resolvedImage\') {\n    input = ResolvedImage.fromString(input.toString());\n  } else if (getType(input) !== propertySpec.type && (propertySpec.type !== \'enum\' || !propertySpec.values[input])) {\n    input = undefined;\n  }\n\n  return coalesce(input, parameters.default, propertySpec.default);\n}\n\nfunction interpolationFactor(input, base, lowerValue, upperValue) {\n  var difference = upperValue - lowerValue;\n  var progress = input - lowerValue;\n\n  if (difference === 0) {\n    return 0;\n  } else if (base === 1) {\n    return progress / difference;\n  } else {\n    return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n  }\n}\n\nvar StyleExpression = /*#__PURE__*/function () {\n  function StyleExpression(expression, propertySpec) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, StyleExpression);\n\n    this.expression = expression;\n    this._warningHistory = {};\n    this._evaluator = new EvaluationContext();\n    this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;\n    this._enumValues = propertySpec && propertySpec.type === \'enum\' ? propertySpec.values : null;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(StyleExpression, [{\n    key: "evaluateWithoutErrorHandling",\n    value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      this._evaluator.globals = globals;\n      this._evaluator.feature = feature;\n      this._evaluator.featureState = featureState;\n      this._evaluator.canonical = canonical;\n      this._evaluator.availableImages = availableImages || null;\n      this._evaluator.formattedSection = formattedSection;\n      return this.expression.evaluate(this._evaluator);\n    }\n  }, {\n    key: "evaluate",\n    value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      this._evaluator.globals = globals;\n      this._evaluator.feature = feature || null;\n      this._evaluator.featureState = featureState || null;\n      this._evaluator.canonical = canonical;\n      this._evaluator.availableImages = availableImages || null;\n      this._evaluator.formattedSection = formattedSection || null;\n\n      try {\n        var val = this.expression.evaluate(this._evaluator);\n\n        if (val === null || val === undefined || typeof val === \'number\' && val !== val) {\n          return this._defaultValue;\n        }\n\n        if (this._enumValues && !(val in this._enumValues)) {\n          throw new RuntimeError("Expected value to be one of ".concat(Object.keys(this._enumValues).map(function (v) {\n            return JSON.stringify(v);\n          }).join(\', \'), ", but found ").concat(JSON.stringify(val), " instead."));\n        }\n\n        return val;\n      } catch (e) {\n        if (!this._warningHistory[e.message]) {\n          this._warningHistory[e.message] = true;\n\n          if (typeof console !== \'undefined\') {\n            console.warn(e.message);\n          }\n        }\n\n        return this._defaultValue;\n      }\n    }\n  }]);\n\n  return StyleExpression;\n}();\n\nfunction isExpression(expression) {\n  return Array.isArray(expression) && expression.length > 0 && typeof expression[0] === \'string\' && expression[0] in expressions;\n}\n\nfunction createExpression(expression, propertySpec) {\n  var parser = new ParsingContext(expressions, [], propertySpec ? getExpectedType(propertySpec) : undefined);\n  var parsed = parser.parse(expression, undefined, undefined, undefined, propertySpec && propertySpec.type === \'string\' ? {\n    typeAnnotation: \'coerce\'\n  } : undefined);\n\n  if (!parsed) {\n    return error(parser.errors);\n  }\n\n  return success(new StyleExpression(parsed, propertySpec));\n}\n\nvar ZoomConstantExpression = /*#__PURE__*/function () {\n  function ZoomConstantExpression(kind, expression) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ZoomConstantExpression);\n\n    this.kind = kind;\n    this._styleExpression = expression;\n    this.isStateDependent = kind !== \'constant\' && !isStateConstant(expression.expression);\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(ZoomConstantExpression, [{\n    key: "evaluateWithoutErrorHandling",\n    value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n  }, {\n    key: "evaluate",\n    value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n  }]);\n\n  return ZoomConstantExpression;\n}();\n\nvar ZoomDependentExpression = /*#__PURE__*/function () {\n  function ZoomDependentExpression(kind, expression, zoomStops, interpolationType) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ZoomDependentExpression);\n\n    this.kind = kind;\n    this.zoomStops = zoomStops;\n    this._styleExpression = expression;\n    this.isStateDependent = kind !== \'camera\' && !isStateConstant(expression.expression);\n    this.interpolationType = interpolationType;\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(ZoomDependentExpression, [{\n    key: "evaluateWithoutErrorHandling",\n    value: function evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n  }, {\n    key: "evaluate",\n    value: function evaluate(globals, feature, featureState, canonical, availableImages, formattedSection) {\n      return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n  }, {\n    key: "interpolationFactor",\n    value: function interpolationFactor(input, lower, upper) {\n      if (this.interpolationType) {\n        return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);\n      } else {\n        return 0;\n      }\n    }\n  }]);\n\n  return ZoomDependentExpression;\n}();\n\nfunction createPropertyExpression(expression, propertySpec) {\n  expression = createExpression(expression, propertySpec);\n\n  if (expression.result === \'error\') {\n    return expression;\n  }\n\n  var parsed = expression.value.expression;\n  var isFeatureConstant$1 = isFeatureConstant(parsed);\n\n  if (!isFeatureConstant$1 && !supportsPropertyExpression(propertySpec)) {\n    return error([new ParsingError(\'\', \'data expressions not supported\')]);\n  }\n\n  var isZoomConstant = isGlobalPropertyConstant(parsed, [\'zoom\']);\n\n  if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {\n    return error([new ParsingError(\'\', \'zoom expressions not supported\')]);\n  }\n\n  var zoomCurve = findZoomCurve(parsed);\n\n  if (!zoomCurve && !isZoomConstant) {\n    return error([new ParsingError(\'\', \'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\')]);\n  } else if (zoomCurve instanceof ParsingError) {\n    return error([zoomCurve]);\n  } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {\n    return error([new ParsingError(\'\', \'"interpolate" expressions cannot be used with this property\')]);\n  }\n\n  if (!zoomCurve) {\n    return success(isFeatureConstant$1 ? new ZoomConstantExpression(\'constant\', expression.value) : new ZoomConstantExpression(\'source\', expression.value));\n  }\n\n  var interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;\n  return success(isFeatureConstant$1 ? new ZoomDependentExpression(\'camera\', expression.value, zoomCurve.labels, interpolationType) : new ZoomDependentExpression(\'composite\', expression.value, zoomCurve.labels, interpolationType));\n}\n\nvar StylePropertyFunction = /*#__PURE__*/function () {\n  function StylePropertyFunction(parameters, specification) {\n    (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, StylePropertyFunction);\n\n    this._parameters = parameters;\n    this._specification = specification;\n    extend(this, createFunction(this._parameters, this._specification));\n  }\n\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_6__/* .default */ .Z)(StylePropertyFunction, null, [{\n    key: "deserialize",\n    value: function deserialize(serialized) {\n      return new StylePropertyFunction(serialized._parameters, serialized._specification);\n    }\n  }, {\n    key: "serialize",\n    value: function serialize(input) {\n      return {\n        _parameters: input._parameters,\n        _specification: input._specification\n      };\n    }\n  }]);\n\n  return StylePropertyFunction;\n}();\n\nfunction normalizePropertyExpression(value, specification) {\n  if (isFunction$1(value)) {\n    return new StylePropertyFunction(value, specification);\n  } else if (isExpression(value)) {\n    var _expression8 = createPropertyExpression(value, specification);\n\n    if (_expression8.result === \'error\') {\n      throw new Error(_expression8.value.map(function (err) {\n        return "".concat(err.key, ": ").concat(err.message);\n      }).join(\', \'));\n    }\n\n    return _expression8.value;\n  } else {\n    var constant = value;\n\n    if (typeof value === \'string\' && specification.type === \'color\') {\n      constant = Color.parse(value);\n    }\n\n    return {\n      kind: \'constant\',\n      evaluate: function evaluate() {\n        return constant;\n      }\n    };\n  }\n}\n\nfunction findZoomCurve(expression) {\n  var result = null;\n\n  if (expression instanceof Let) {\n    result = findZoomCurve(expression.result);\n  } else if (expression instanceof Coalesce) {\n    var _iterator40 = _createForOfIteratorHelper(expression.args),\n        _step40;\n\n    try {\n      for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n        var arg = _step40.value;\n        result = findZoomCurve(arg);\n\n        if (result) {\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator40.e(err);\n    } finally {\n      _iterator40.f();\n    }\n  } else if ((expression instanceof Step || expression instanceof Interpolate) && expression.input instanceof CompoundExpression && expression.input.name === \'zoom\') {\n    result = expression;\n  }\n\n  if (result instanceof ParsingError) {\n    return result;\n  }\n\n  expression.eachChild(function (child) {\n    var childResult = findZoomCurve(child);\n\n    if (childResult instanceof ParsingError) {\n      result = childResult;\n    } else if (!result && childResult) {\n      result = new ParsingError(\'\', \'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.\');\n    } else if (result && childResult && result !== childResult) {\n      result = new ParsingError(\'\', \'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.\');\n    }\n  });\n  return result;\n}\n\nfunction getExpectedType(spec) {\n  var types = {\n    color: ColorType,\n    string: StringType,\n    number: NumberType,\n    enum: StringType,\n    boolean: BooleanType,\n    formatted: FormattedType,\n    resolvedImage: ResolvedImageType\n  };\n\n  if (spec.type === \'array\') {\n    return array(types[spec.value] || ValueType, spec.length);\n  }\n\n  return types[spec.type];\n}\n\nfunction getDefaultValue(spec) {\n  if (spec.type === \'color\' && isFunction$1(spec.default)) {\n    return new Color(0, 0, 0, 0);\n  } else if (spec.type === \'color\') {\n    return Color.parse(spec.default) || null;\n  } else if (spec.default === undefined) {\n    return null;\n  } else {\n    return spec.default;\n  }\n}\n\nfunction convertLiteral(value) {\n  return typeof value === \'object\' ? [\'literal\', value] : value;\n}\n\nfunction convertFunction(parameters, propertySpec) {\n  var stops = parameters.stops;\n\n  if (!stops) {\n    return convertIdentityFunction(parameters, propertySpec);\n  }\n\n  var zoomAndFeatureDependent = stops && typeof stops[0][0] === \'object\';\n  var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n  var zoomDependent = zoomAndFeatureDependent || !featureDependent;\n  stops = stops.map(function (stop) {\n    if (!featureDependent && propertySpec.tokens && typeof stop[1] === \'string\') {\n      return [stop[0], convertTokenString(stop[1])];\n    }\n\n    return [stop[0], convertLiteral(stop[1])];\n  });\n\n  if (zoomAndFeatureDependent) {\n    return convertZoomAndPropertyFunction(parameters, propertySpec, stops);\n  } else if (zoomDependent) {\n    return convertZoomFunction(parameters, propertySpec, stops);\n  } else {\n    return convertPropertyFunction(parameters, propertySpec, stops);\n  }\n}\n\nfunction convertIdentityFunction(parameters, propertySpec) {\n  var get = [\'get\', parameters.property];\n\n  if (parameters.default === undefined) {\n    return propertySpec.type === \'string\' ? [\'string\', get] : get;\n  } else if (propertySpec.type === \'enum\') {\n    return [\'match\', get, Object.keys(propertySpec.values), get, parameters.default];\n  } else {\n    var _expression9 = [propertySpec.type === \'color\' ? \'to-color\' : propertySpec.type, get, convertLiteral(parameters.default)];\n\n    if (propertySpec.type === \'array\') {\n      _expression9.splice(1, 0, propertySpec.value, propertySpec.length || null);\n    }\n\n    return _expression9;\n  }\n}\n\nfunction getInterpolateOperator(parameters) {\n  switch (parameters.colorSpace) {\n    case \'hcl\':\n      return \'interpolate-hcl\';\n\n    case \'lab\':\n      return \'interpolate-lab\';\n\n    default:\n      return \'interpolate\';\n  }\n}\n\nfunction convertZoomAndPropertyFunction(parameters, propertySpec, stops) {\n  var featureFunctionParameters = {};\n  var featureFunctionStops = {};\n  var zoomStops = [];\n\n  for (var s = 0; s < stops.length; s++) {\n    var stop = stops[s];\n    var zoom = stop[0].zoom;\n\n    if (featureFunctionParameters[zoom] === undefined) {\n      featureFunctionParameters[zoom] = {\n        zoom: zoom,\n        type: parameters.type,\n        property: parameters.property,\n        default: parameters.default\n      };\n      featureFunctionStops[zoom] = [];\n      zoomStops.push(zoom);\n    }\n\n    featureFunctionStops[zoom].push([stop[0].value, stop[1]]);\n  }\n\n  var functionType = getFunctionType({}, propertySpec);\n\n  if (functionType === \'exponential\') {\n    var _expression10 = [getInterpolateOperator(parameters), [\'linear\'], [\'zoom\']];\n\n    var _iterator41 = _createForOfIteratorHelper(zoomStops),\n        _step41;\n\n    try {\n      for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n        var z = _step41.value;\n        var output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);\n        appendStopPair(_expression10, z, output, false);\n      }\n    } catch (err) {\n      _iterator41.e(err);\n    } finally {\n      _iterator41.f();\n    }\n\n    return _expression10;\n  } else {\n    var _expression11 = [\'step\', [\'zoom\']];\n\n    var _iterator42 = _createForOfIteratorHelper(zoomStops),\n        _step42;\n\n    try {\n      for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n        var _z = _step42.value;\n\n        var _output = convertPropertyFunction(featureFunctionParameters[_z], propertySpec, featureFunctionStops[_z]);\n\n        appendStopPair(_expression11, _z, _output, true);\n      }\n    } catch (err) {\n      _iterator42.e(err);\n    } finally {\n      _iterator42.f();\n    }\n\n    fixupDegenerateStepCurve(_expression11);\n    return _expression11;\n  }\n}\n\nfunction coalesce$1(a, b) {\n  if (a !== undefined) return a;\n  if (b !== undefined) return b;\n}\n\nfunction getFallback(parameters, propertySpec) {\n  var defaultValue = convertLiteral(coalesce$1(parameters.default, propertySpec.default));\n\n  if (defaultValue === undefined && propertySpec.type === \'resolvedImage\') {\n    return \'\';\n  }\n\n  return defaultValue;\n}\n\nfunction convertPropertyFunction(parameters, propertySpec, stops) {\n  var type = getFunctionType(parameters, propertySpec);\n  var get = [\'get\', parameters.property];\n\n  if (type === \'categorical\' && typeof stops[0][0] === \'boolean\') {\n    var _expression12 = [\'case\'];\n\n    var _iterator43 = _createForOfIteratorHelper(stops),\n        _step43;\n\n    try {\n      for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n        var stop = _step43.value;\n\n        _expression12.push([\'==\', get, stop[0]], stop[1]);\n      }\n    } catch (err) {\n      _iterator43.e(err);\n    } finally {\n      _iterator43.f();\n    }\n\n    _expression12.push(getFallback(parameters, propertySpec));\n\n    return _expression12;\n  } else if (type === \'categorical\') {\n    var _expression13 = [\'match\', get];\n\n    var _iterator44 = _createForOfIteratorHelper(stops),\n        _step44;\n\n    try {\n      for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n        var _stop2 = _step44.value;\n        appendStopPair(_expression13, _stop2[0], _stop2[1], false);\n      }\n    } catch (err) {\n      _iterator44.e(err);\n    } finally {\n      _iterator44.f();\n    }\n\n    _expression13.push(getFallback(parameters, propertySpec));\n\n    return _expression13;\n  } else if (type === \'interval\') {\n    var _expression14 = [\'step\', [\'number\', get]];\n\n    var _iterator45 = _createForOfIteratorHelper(stops),\n        _step45;\n\n    try {\n      for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n        var _stop3 = _step45.value;\n        appendStopPair(_expression14, _stop3[0], _stop3[1], true);\n      }\n    } catch (err) {\n      _iterator45.e(err);\n    } finally {\n      _iterator45.f();\n    }\n\n    fixupDegenerateStepCurve(_expression14);\n    return parameters.default === undefined ? _expression14 : [\'case\', [\'==\', [\'typeof\', get], \'number\'], _expression14, convertLiteral(parameters.default)];\n  } else if (type === \'exponential\') {\n    var base = parameters.base !== undefined ? parameters.base : 1;\n    var _expression15 = [getInterpolateOperator(parameters), base === 1 ? [\'linear\'] : [\'exponential\', base], [\'number\', get]];\n\n    var _iterator46 = _createForOfIteratorHelper(stops),\n        _step46;\n\n    try {\n      for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {\n        var _stop4 = _step46.value;\n        appendStopPair(_expression15, _stop4[0], _stop4[1], false);\n      }\n    } catch (err) {\n      _iterator46.e(err);\n    } finally {\n      _iterator46.f();\n    }\n\n    return parameters.default === undefined ? _expression15 : [\'case\', [\'==\', [\'typeof\', get], \'number\'], _expression15, convertLiteral(parameters.default)];\n  } else {\n    throw new Error("Unknown property function type ".concat(type));\n  }\n}\n\nfunction convertZoomFunction(parameters, propertySpec, stops) {\n  var input = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [\'zoom\'];\n  var type = getFunctionType(parameters, propertySpec);\n  var expression;\n  var isStep = false;\n\n  if (type === \'interval\') {\n    expression = [\'step\', input];\n    isStep = true;\n  } else if (type === \'exponential\') {\n    var base = parameters.base !== undefined ? parameters.base : 1;\n    expression = [getInterpolateOperator(parameters), base === 1 ? [\'linear\'] : [\'exponential\', base], input];\n  } else {\n    throw new Error("Unknown zoom function type \\"".concat(type, "\\""));\n  }\n\n  var _iterator47 = _createForOfIteratorHelper(stops),\n      _step47;\n\n  try {\n    for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {\n      var stop = _step47.value;\n      appendStopPair(expression, stop[0], stop[1], isStep);\n    }\n  } catch (err) {\n    _iterator47.e(err);\n  } finally {\n    _iterator47.f();\n  }\n\n  fixupDegenerateStepCurve(expression);\n  return expression;\n}\n\nfunction fixupDegenerateStepCurve(expression) {\n  if (expression[0] === \'step\' && expression.length === 3) {\n    expression.push(0);\n    expression.push(expression[3]);\n  }\n}\n\nfunction appendStopPair(curve, input, output, isStep) {\n  if (curve.length > 3 && input === curve[curve.length - 2]) {\n    return;\n  }\n\n  if (!(isStep && curve.length === 2)) {\n    curve.push(input);\n  }\n\n  curve.push(output);\n}\n\nfunction getFunctionType(parameters, propertySpec) {\n  if (parameters.type) {\n    return parameters.type;\n  } else {\n    return propertySpec.expression.interpolated ? \'exponential\' : \'interval\';\n  }\n}\n\nfunction convertTokenString(s) {\n  var result = [\'concat\'];\n  var re = /{([^{}]+)}/g;\n  var pos = 0;\n\n  for (var match = re.exec(s); match !== null; match = re.exec(s)) {\n    var literal = s.slice(pos, re.lastIndex - match[0].length);\n    pos = re.lastIndex;\n    if (literal.length > 0) result.push(literal);\n    result.push([\'get\', match[1]]);\n  }\n\n  if (result.length === 1) {\n    return s;\n  }\n\n  if (pos < s.length) {\n    result.push(s.slice(pos));\n  } else if (result.length === 2) {\n    return [\'to-string\', result[1]];\n  }\n\n  return result;\n}\n\nfunction isExpressionFilter(filter) {\n  if (filter === true || filter === false) {\n    return true;\n  }\n\n  if (!Array.isArray(filter) || filter.length === 0) {\n    return false;\n  }\n\n  switch (filter[0]) {\n    case \'has\':\n      return filter.length >= 2 && filter[1] !== \'$id\' && filter[1] !== \'$type\';\n\n    case \'in\':\n      return filter.length >= 3 && (typeof filter[1] !== \'string\' || Array.isArray(filter[2]));\n\n    case \'!in\':\n    case \'!has\':\n    case \'none\':\n      return false;\n\n    case \'==\':\n    case \'!=\':\n    case \'>\':\n    case \'>=\':\n    case \'<\':\n    case \'<=\':\n      return filter.length !== 3 || Array.isArray(filter[1]) || Array.isArray(filter[2]);\n\n    case \'any\':\n    case \'all\':\n      var _iterator48 = _createForOfIteratorHelper(filter.slice(1)),\n          _step48;\n\n      try {\n        for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {\n          var f = _step48.value;\n\n          if (!isExpressionFilter(f) && typeof f !== \'boolean\') {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator48.e(err);\n      } finally {\n        _iterator48.f();\n      }\n\n      return true;\n\n    default:\n      return true;\n  }\n}\n\nvar filterSpec = {\n  \'type\': \'boolean\',\n  \'default\': false,\n  \'transition\': false,\n  \'property-type\': \'data-driven\',\n  \'expression\': {\n    \'interpolated\': false,\n    \'parameters\': [\'zoom\', \'feature\']\n  }\n};\n\nfunction createFilter(filter) {\n  if (filter === null || filter === undefined) {\n    return {\n      filter: function filter() {\n        return true;\n      },\n      needGeometry: false\n    };\n  }\n\n  if (!isExpressionFilter(filter)) {\n    filter = convertFilter(filter);\n  }\n\n  var compiled = createExpression(filter, filterSpec);\n\n  if (compiled.result === \'error\') {\n    throw new Error(compiled.value.map(function (err) {\n      return "".concat(err.key, ": ").concat(err.message);\n    }).join(\', \'));\n  } else {\n    var needGeometry = geometryNeeded(filter);\n    return {\n      filter: function filter(globalProperties, feature, canonical) {\n        return compiled.value.evaluate(globalProperties, feature, {}, canonical);\n      },\n      needGeometry: needGeometry\n    };\n  }\n}\n\nfunction compare(a, b) {\n  return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction geometryNeeded(filter) {\n  if (!Array.isArray(filter)) return false;\n  if (filter[0] === \'within\') return true;\n\n  for (var index = 1; index < filter.length; index++) {\n    if (geometryNeeded(filter[index])) return true;\n  }\n\n  return false;\n}\n\nfunction convertFilter(filter) {\n  if (!filter) return true;\n  var op = filter[0];\n  if (filter.length <= 1) return op !== \'any\';\n  var converted = op === \'==\' ? convertComparisonOp(filter[1], filter[2], \'==\') : op === \'!=\' ? convertNegation(convertComparisonOp(filter[1], filter[2], \'==\')) : op === \'<\' || op === \'>\' || op === \'<=\' || op === \'>=\' ? convertComparisonOp(filter[1], filter[2], op) : op === \'any\' ? convertDisjunctionOp(filter.slice(1)) : op === \'all\' ? [\'all\'].concat(filter.slice(1).map(convertFilter)) : op === \'none\' ? [\'all\'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) : op === \'in\' ? convertInOp(filter[1], filter.slice(2)) : op === \'!in\' ? convertNegation(convertInOp(filter[1], filter.slice(2))) : op === \'has\' ? convertHasOp(filter[1]) : op === \'!has\' ? convertNegation(convertHasOp(filter[1])) : op === \'within\' ? filter : true;\n  return converted;\n}\n\nfunction convertComparisonOp(property, value, op) {\n  switch (property) {\n    case \'$type\':\n      return ["filter-type-".concat(op), value];\n\n    case \'$id\':\n      return ["filter-id-".concat(op), value];\n\n    default:\n      return ["filter-".concat(op), property, value];\n  }\n}\n\nfunction convertDisjunctionOp(filters) {\n  return [\'any\'].concat(filters.map(convertFilter));\n}\n\nfunction convertInOp(property, values) {\n  if (values.length === 0) {\n    return false;\n  }\n\n  switch (property) {\n    case \'$type\':\n      return ["filter-type-in", [\'literal\', values]];\n\n    case \'$id\':\n      return ["filter-id-in", [\'literal\', values]];\n\n    default:\n      if (values.length > 200 && !values.some(function (v) {\n        return typeof v !== typeof values[0];\n      })) {\n        return [\'filter-in-large\', property, [\'literal\', values.sort(compare)]];\n      } else {\n        return [\'filter-in-small\', property, [\'literal\', values]];\n      }\n\n  }\n}\n\nfunction convertHasOp(property) {\n  switch (property) {\n    case \'$type\':\n      return true;\n\n    case \'$id\':\n      return ["filter-has-id"];\n\n    default:\n      return ["filter-has", property];\n  }\n}\n\nfunction convertNegation(filter) {\n  return [\'!\', filter];\n}\n\nfunction convertFilter$1(filter) {\n  return _convertFilter(filter, {});\n}\n\nfunction _convertFilter(filter, expectedTypes) {\n  if (isExpressionFilter(filter)) {\n    return filter;\n  }\n\n  if (!filter) return true;\n  var op = filter[0];\n  if (filter.length <= 1) return op !== \'any\';\n  var converted;\n\n  if (op === \'==\' || op === \'!=\' || op === \'<\' || op === \'>\' || op === \'<=\' || op === \'>=\') {\n    var _filter = _slicedToArray(filter, 3),\n        property = _filter[1],\n        value = _filter[2];\n\n    converted = convertComparisonOp$1(property, value, op, expectedTypes);\n  } else if (op === \'any\') {\n    var children = filter.slice(1).map(function (f) {\n      var types = {};\n\n      var child = _convertFilter(f, types);\n\n      var typechecks = runtimeTypeChecks(types);\n      return typechecks === true ? child : [\'case\', typechecks, child, false];\n    });\n    return [\'any\'].concat(children);\n  } else if (op === \'all\') {\n    var _ref111;\n\n    var _children = filter.slice(1).map(function (f) {\n      return _convertFilter(f, expectedTypes);\n    });\n\n    return _children.length > 1 ? [\'all\'].concat(_children) : (_ref111 = []).concat.apply(_ref111, _toConsumableArray(_children));\n  } else if (op === \'none\') {\n    return [\'!\', _convertFilter([\'any\'].concat(filter.slice(1)), {})];\n  } else if (op === \'in\') {\n    converted = convertInOp$1(filter[1], filter.slice(2));\n  } else if (op === \'!in\') {\n    converted = convertInOp$1(filter[1], filter.slice(2), true);\n  } else if (op === \'has\') {\n    converted = convertHasOp$1(filter[1]);\n  } else if (op === \'!has\') {\n    converted = [\'!\', convertHasOp$1(filter[1])];\n  } else {\n    converted = true;\n  }\n\n  return converted;\n}\n\nfunction runtimeTypeChecks(expectedTypes) {\n  var conditions = [];\n\n  for (var property in expectedTypes) {\n    var _get = property === \'$id\' ? [\'id\'] : [\'get\', property];\n\n    conditions.push([\'==\', [\'typeof\', _get], expectedTypes[property]]);\n  }\n\n  if (conditions.length === 0) return true;\n  if (conditions.length === 1) return conditions[0];\n  return [\'all\'].concat(conditions);\n}\n\nfunction convertComparisonOp$1(property, value, op, expectedTypes) {\n  var get;\n\n  if (property === \'$type\') {\n    return [op, [\'geometry-type\'], value];\n  } else if (property === \'$id\') {\n    get = [\'id\'];\n  } else {\n    get = [\'get\', property];\n  }\n\n  if (expectedTypes && value !== null) {\n    var type = typeof value;\n    expectedTypes[property] = type;\n  }\n\n  if (op === \'==\' && property !== \'$id\' && value === null) {\n    return [\'all\', [\'has\', property], [\'==\', get, null]];\n  } else if (op === \'!=\' && property !== \'$id\' && value === null) {\n    return [\'any\', [\'!\', [\'has\', property]], [\'!=\', get, null]];\n  }\n\n  return [op, get, value];\n}\n\nfunction convertInOp$1(property, values) {\n  var negate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (values.length === 0) return negate;\n  var get;\n\n  if (property === \'$type\') {\n    get = [\'geometry-type\'];\n  } else if (property === \'$id\') {\n    get = [\'id\'];\n  } else {\n    get = [\'get\', property];\n  }\n\n  var uniformTypes = true;\n  var type = typeof values[0];\n\n  var _iterator49 = _createForOfIteratorHelper(values),\n      _step49;\n\n  try {\n    for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {\n      var value = _step49.value;\n\n      if (typeof value !== type) {\n        uniformTypes = false;\n        break;\n      }\n    }\n  } catch (err) {\n    _iterator49.e(err);\n  } finally {\n    _iterator49.f();\n  }\n\n  if (uniformTypes && (type === \'string\' || type === \'number\')) {\n    var uniqueValues = values.sort().filter(function (v, i) {\n      return i === 0 || values[i - 1] !== v;\n    });\n    return [\'match\', get, uniqueValues, !negate, negate];\n  }\n\n  return [negate ? \'all\' : \'any\'].concat(values.map(function (v) {\n    return [negate ? \'!=\' : \'==\', get, v];\n  }));\n}\n\nfunction convertHasOp$1(property) {\n  if (property === \'$type\') {\n    return true;\n  } else if (property === \'$id\') {\n    return [\'!=\', [\'id\'], null];\n  } else {\n    return [\'has\', property];\n  }\n}\n\nfunction migrateToExpressions(style) {\n  var converted = [];\n  eachLayer(style, function (layer) {\n    if (layer.filter) {\n      layer.filter = convertFilter$1(layer.filter);\n    }\n  });\n  eachProperty(style, {\n    paint: true,\n    layout: true\n  }, function (_ref112) {\n    var path = _ref112.path,\n        value = _ref112.value,\n        reference = _ref112.reference,\n        set = _ref112.set;\n    if (isExpression(value)) return;\n\n    if (typeof value === \'object\' && !Array.isArray(value)) {\n      set(convertFunction(value, reference));\n      converted.push(path.join(\'.\'));\n    } else if (reference.tokens && typeof value === \'string\') {\n      set(convertTokenString(value));\n    }\n  });\n  return style;\n}\n\nfunction migrate(style) {\n  var migrated = false;\n\n  if (style.version === 7) {\n    style = migrateToV8(style);\n    migrated = true;\n  }\n\n  if (style.version === 8) {\n    migrated = migrateToExpressions(style);\n    migrated = true;\n  }\n\n  if (!migrated) {\n    throw new Error(\'cannot migrate from\', style.version);\n  }\n\n  return style;\n}\n\nfunction composite(style) {\n  var styleIDs = [];\n  var sourceIDs = [];\n  var compositedSourceLayers = [];\n\n  for (var id in style.sources) {\n    var _source = style.sources[id];\n    if (_source.type !== \'vector\') continue;\n    var match = /^mapbox:\\/\\/(.*)/.exec(_source.url);\n    if (!match) continue;\n    styleIDs.push(id);\n    sourceIDs.push(match[1]);\n  }\n\n  if (styleIDs.length < 2) return style;\n  styleIDs.forEach(function (id) {\n    delete style.sources[id];\n  });\n  var compositeID = sourceIDs.join(\',\');\n  style.sources[compositeID] = {\n    \'type\': \'vector\',\n    \'url\': "mapbox://".concat(compositeID)\n  };\n  style.layers.forEach(function (layer) {\n    if (styleIDs.indexOf(layer.source) >= 0) {\n      layer.source = compositeID;\n\n      if (\'source-layer\' in layer) {\n        if (compositedSourceLayers.indexOf(layer[\'source-layer\']) >= 0) {\n          throw new Error(\'Conflicting source layer names\');\n        } else {\n          compositedSourceLayers.push(layer[\'source-layer\']);\n        }\n      }\n    }\n  });\n  return style;\n}\n\nvar refProperties = [\'type\', \'source\', \'source-layer\', \'minzoom\', \'maxzoom\', \'filter\', \'layout\'];\n\nfunction deref(layer, parent) {\n  var result = {};\n\n  for (var k in layer) {\n    if (k !== \'ref\') {\n      result[k] = layer[k];\n    }\n  }\n\n  refProperties.forEach(function (k) {\n    if (k in parent) {\n      result[k] = parent[k];\n    }\n  });\n  return result;\n}\n\nfunction derefLayers(layers) {\n  layers = layers.slice();\n  var map = Object.create(null);\n\n  for (var i = 0; i < layers.length; i++) {\n    map[layers[i].id] = layers[i];\n  }\n\n  for (var _i8 = 0; _i8 < layers.length; _i8++) {\n    if (\'ref\' in layers[_i8]) {\n      layers[_i8] = deref(layers[_i8], map[layers[_i8].ref]);\n    }\n  }\n\n  return layers;\n}\n\nfunction deepEqual(a, b) {\n  if (Array.isArray(a)) {\n    if (!Array.isArray(b) || a.length !== b.length) return false;\n\n    for (var i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) return false;\n    }\n\n    return true;\n  }\n\n  if (typeof a === \'object\' && a !== null && b !== null) {\n    if (!(typeof b === \'object\')) return false;\n    var keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length) return false;\n\n    for (var key in a) {\n      if (!deepEqual(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  return a === b;\n}\n\nvar operations = {\n  setStyle: \'setStyle\',\n  addLayer: \'addLayer\',\n  removeLayer: \'removeLayer\',\n  setPaintProperty: \'setPaintProperty\',\n  setLayoutProperty: \'setLayoutProperty\',\n  setFilter: \'setFilter\',\n  addSource: \'addSource\',\n  removeSource: \'removeSource\',\n  setGeoJSONSourceData: \'setGeoJSONSourceData\',\n  setLayerZoomRange: \'setLayerZoomRange\',\n  setLayerProperty: \'setLayerProperty\',\n  setCenter: \'setCenter\',\n  setZoom: \'setZoom\',\n  setBearing: \'setBearing\',\n  setPitch: \'setPitch\',\n  setSprite: \'setSprite\',\n  setGlyphs: \'setGlyphs\',\n  setTransition: \'setTransition\',\n  setLight: \'setLight\',\n  setTerrain: \'setTerrain\',\n  setFog: \'setFog\'\n};\n\nfunction addSource(sourceId, after, commands) {\n  commands.push({\n    command: operations.addSource,\n    args: [sourceId, after[sourceId]]\n  });\n}\n\nfunction removeSource(sourceId, commands, sourcesRemoved) {\n  commands.push({\n    command: operations.removeSource,\n    args: [sourceId]\n  });\n  sourcesRemoved[sourceId] = true;\n}\n\nfunction updateSource(sourceId, after, commands, sourcesRemoved) {\n  removeSource(sourceId, commands, sourcesRemoved);\n  addSource(sourceId, after, commands);\n}\n\nfunction canUpdateGeoJSON(before, after, sourceId) {\n  var prop;\n\n  for (prop in before[sourceId]) {\n    if (!before[sourceId].hasOwnProperty(prop)) continue;\n\n    if (prop !== \'data\' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {\n      return false;\n    }\n  }\n\n  for (prop in after[sourceId]) {\n    if (!after[sourceId].hasOwnProperty(prop)) continue;\n\n    if (prop !== \'data\' && !deepEqual(before[sourceId][prop], after[sourceId][prop])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction diffSources(before, after, commands, sourcesRemoved) {\n  before = before || {};\n  after = after || {};\n  var sourceId;\n\n  for (sourceId in before) {\n    if (!before.hasOwnProperty(sourceId)) continue;\n\n    if (!after.hasOwnProperty(sourceId)) {\n      removeSource(sourceId, commands, sourcesRemoved);\n    }\n  }\n\n  for (sourceId in after) {\n    if (!after.hasOwnProperty(sourceId)) continue;\n\n    if (!before.hasOwnProperty(sourceId)) {\n      addSource(sourceId, after, commands);\n    } else if (!deepEqual(before[sourceId], after[sourceId])) {\n      if (before[sourceId].type === \'geojson\' && after[sourceId].type === \'geojson\' && canUpdateGeoJSON(before, after, sourceId)) {\n        commands.push({\n          command: operations.setGeoJSONSourceData,\n          args: [sourceId, after[sourceId].data]\n        });\n      } else {\n        updateSource(sourceId, after, commands, sourcesRemoved);\n      }\n    }\n  }\n}\n\nfunction diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {\n  before = before || {};\n  after = after || {};\n  var prop;\n\n  for (prop in before) {\n    if (!before.hasOwnProperty(prop)) continue;\n\n    if (!deepEqual(before[prop], after[prop])) {\n      commands.push({\n        command: command,\n        args: [layerId, prop, after[prop], klass]\n      });\n    }\n  }\n\n  for (prop in after) {\n    if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) continue;\n\n    if (!deepEqual(before[prop], after[prop])) {\n      commands.push({\n        command: command,\n        args: [layerId, prop, after[prop], klass]\n      });\n    }\n  }\n}\n\nfunction pluckId(layer) {\n  return layer.id;\n}\n\nfunction indexById(group, layer) {\n  group[layer.id] = layer;\n  return group;\n}\n\nfunction diffLayers(before, after, commands) {\n  before = before || [];\n  after = after || [];\n  var beforeOrder = before.map(pluckId);\n  var afterOrder = after.map(pluckId);\n  var beforeIndex = before.reduce(indexById, {});\n  var afterIndex = after.reduce(indexById, {});\n  var tracker = beforeOrder.slice();\n  var clean = Object.create(null);\n  var i, d, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;\n\n  for (i = 0, d = 0; i < beforeOrder.length; i++) {\n    layerId = beforeOrder[i];\n\n    if (!afterIndex.hasOwnProperty(layerId)) {\n      commands.push({\n        command: operations.removeLayer,\n        args: [layerId]\n      });\n      tracker.splice(tracker.indexOf(layerId, d), 1);\n    } else {\n      d++;\n    }\n  }\n\n  for (i = 0, d = 0; i < afterOrder.length; i++) {\n    layerId = afterOrder[afterOrder.length - 1 - i];\n    if (tracker[tracker.length - 1 - i] === layerId) continue;\n\n    if (beforeIndex.hasOwnProperty(layerId)) {\n      commands.push({\n        command: operations.removeLayer,\n        args: [layerId]\n      });\n      tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);\n    } else {\n      d++;\n    }\n\n    insertBeforeLayerId = tracker[tracker.length - i];\n    commands.push({\n      command: operations.addLayer,\n      args: [afterIndex[layerId], insertBeforeLayerId]\n    });\n    tracker.splice(tracker.length - i, 0, layerId);\n    clean[layerId] = true;\n  }\n\n  for (i = 0; i < afterOrder.length; i++) {\n    layerId = afterOrder[i];\n    beforeLayer = beforeIndex[layerId];\n    afterLayer = afterIndex[layerId];\n    if (clean[layerId] || deepEqual(beforeLayer, afterLayer)) continue;\n\n    if (!deepEqual(beforeLayer.source, afterLayer.source) || !deepEqual(beforeLayer[\'source-layer\'], afterLayer[\'source-layer\']) || !deepEqual(beforeLayer.type, afterLayer.type)) {\n      commands.push({\n        command: operations.removeLayer,\n        args: [layerId]\n      });\n      insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];\n      commands.push({\n        command: operations.addLayer,\n        args: [afterLayer, insertBeforeLayerId]\n      });\n      continue;\n    }\n\n    diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);\n    diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);\n\n    if (!deepEqual(beforeLayer.filter, afterLayer.filter)) {\n      commands.push({\n        command: operations.setFilter,\n        args: [layerId, afterLayer.filter]\n      });\n    }\n\n    if (!deepEqual(beforeLayer.minzoom, afterLayer.minzoom) || !deepEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {\n      commands.push({\n        command: operations.setLayerZoomRange,\n        args: [layerId, afterLayer.minzoom, afterLayer.maxzoom]\n      });\n    }\n\n    for (prop in beforeLayer) {\n      if (!beforeLayer.hasOwnProperty(prop)) continue;\n      if (prop === \'layout\' || prop === \'paint\' || prop === \'filter\' || prop === \'metadata\' || prop === \'minzoom\' || prop === \'maxzoom\') continue;\n\n      if (prop.indexOf(\'paint.\') === 0) {\n        diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);\n      } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {\n        commands.push({\n          command: operations.setLayerProperty,\n          args: [layerId, prop, afterLayer[prop]]\n        });\n      }\n    }\n\n    for (prop in afterLayer) {\n      if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) continue;\n      if (prop === \'layout\' || prop === \'paint\' || prop === \'filter\' || prop === \'metadata\' || prop === \'minzoom\' || prop === \'maxzoom\') continue;\n\n      if (prop.indexOf(\'paint.\') === 0) {\n        diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);\n      } else if (!deepEqual(beforeLayer[prop], afterLayer[prop])) {\n        commands.push({\n          command: operations.setLayerProperty,\n          args: [layerId, prop, afterLayer[prop]]\n        });\n      }\n    }\n  }\n}\n\nfunction diffStyles(before, after) {\n  if (!before) return [{\n    command: operations.setStyle,\n    args: [after]\n  }];\n  var commands = [];\n\n  try {\n    if (!deepEqual(before.version, after.version)) {\n      return [{\n        command: operations.setStyle,\n        args: [after]\n      }];\n    }\n\n    if (!deepEqual(before.center, after.center)) {\n      commands.push({\n        command: operations.setCenter,\n        args: [after.center]\n      });\n    }\n\n    if (!deepEqual(before.zoom, after.zoom)) {\n      commands.push({\n        command: operations.setZoom,\n        args: [after.zoom]\n      });\n    }\n\n    if (!deepEqual(before.bearing, after.bearing)) {\n      commands.push({\n        command: operations.setBearing,\n        args: [after.bearing]\n      });\n    }\n\n    if (!deepEqual(before.pitch, after.pitch)) {\n      commands.push({\n        command: operations.setPitch,\n        args: [after.pitch]\n      });\n    }\n\n    if (!deepEqual(before.sprite, after.sprite)) {\n      commands.push({\n        command: operations.setSprite,\n        args: [after.sprite]\n      });\n    }\n\n    if (!deepEqual(before.glyphs, after.glyphs)) {\n      commands.push({\n        command: operations.setGlyphs,\n        args: [after.glyphs]\n      });\n    }\n\n    if (!deepEqual(before.transition, after.transition)) {\n      commands.push({\n        command: operations.setTransition,\n        args: [after.transition]\n      });\n    }\n\n    if (!deepEqual(before.light, after.light)) {\n      commands.push({\n        command: operations.setLight,\n        args: [after.light]\n      });\n    }\n\n    if (!deepEqual(before.fog, after.fog)) {\n      commands.push({\n        command: operations.setFog,\n        args: [after.fog]\n      });\n    }\n\n    var sourcesRemoved = {};\n    var removeOrAddSourceCommands = [];\n    diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);\n    var beforeLayers = [];\n\n    if (before.layers) {\n      before.layers.forEach(function (layer) {\n        if (sourcesRemoved[layer.source]) {\n          commands.push({\n            command: operations.removeLayer,\n            args: [layer.id]\n          });\n        } else {\n          beforeLayers.push(layer);\n        }\n      });\n    }\n\n    var beforeTerrain = before.terrain;\n\n    if (beforeTerrain) {\n      if (sourcesRemoved[beforeTerrain.source]) {\n        commands.push({\n          command: operations.setTerrain,\n          args: [undefined]\n        });\n        beforeTerrain = undefined;\n      }\n    }\n\n    commands = commands.concat(removeOrAddSourceCommands);\n\n    if (!deepEqual(beforeTerrain, after.terrain)) {\n      commands.push({\n        command: operations.setTerrain,\n        args: [after.terrain]\n      });\n    }\n\n    diffLayers(beforeLayers, after.layers, commands);\n  } catch (e) {\n    console.warn(\'Unable to compute style diff:\', e);\n    commands = [{\n      command: operations.setStyle,\n      args: [after]\n    }];\n  }\n\n  return commands;\n}\n\nvar ValidationError = function ValidationError(key, value, message, identifier) {\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ValidationError);\n\n  this.message = (key ? "".concat(key, ": ") : \'\') + message;\n  if (identifier) this.identifier = identifier;\n\n  if (value !== null && value !== undefined && value.__line__) {\n    this.line = value.__line__;\n  }\n};\n\nvar ParsingError$1 = function ParsingError$1(error) {\n  (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(this, ParsingError$1);\n\n  this.error = error;\n  this.message = error.message;\n  var match = error.message.match(/line (\\d+)/);\n  this.line = match ? parseInt(match[1], 10) : 0;\n};\n\nfunction validateConstants(options) {\n  var key = options.key;\n  var constants = options.value;\n\n  if (constants) {\n    return [new ValidationError(key, constants, \'constants have been deprecated as of v8\')];\n  } else {\n    return [];\n  }\n}\n\nfunction unbundle(value) {\n  if (value instanceof Number || value instanceof String || value instanceof Boolean) {\n    return value.valueOf();\n  } else {\n    return value;\n  }\n}\n\nfunction deepUnbundle(value) {\n  if (Array.isArray(value)) {\n    return value.map(deepUnbundle);\n  } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {\n    var unbundledValue = {};\n\n    for (var key in value) {\n      unbundledValue[key] = deepUnbundle(value[key]);\n    }\n\n    return unbundledValue;\n  }\n\n  return unbundle(value);\n}\n\nfunction validateObject(options) {\n  var key = options.key;\n  var object = options.value;\n  var elementSpecs = options.valueSpec || {};\n  var elementValidators = options.objectElementValidators || {};\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n  var errors = [];\n  var type = getType(object);\n\n  if (type !== \'object\') {\n    return [new ValidationError(key, object, "object expected, ".concat(type, " found"))];\n  }\n\n  for (var objectKey in object) {\n    var elementSpecKey = objectKey.split(\'.\')[0];\n    var elementSpec = elementSpecs[elementSpecKey] || elementSpecs[\'*\'];\n    var validateElement = void 0;\n\n    if (elementValidators[elementSpecKey]) {\n      validateElement = elementValidators[elementSpecKey];\n    } else if (elementSpecs[elementSpecKey]) {\n      validateElement = validate;\n    } else if (elementValidators[\'*\']) {\n      validateElement = elementValidators[\'*\'];\n    } else if (elementSpecs[\'*\']) {\n      validateElement = validate;\n    } else {\n      errors.push(new ValidationError(key, object[objectKey], "unknown property \\"".concat(objectKey, "\\"")));\n      continue;\n    }\n\n    errors = errors.concat(validateElement({\n      key: (key ? "".concat(key, ".") : key) + objectKey,\n      value: object[objectKey],\n      valueSpec: elementSpec,\n      style: style,\n      styleSpec: styleSpec,\n      object: object,\n      objectKey: objectKey\n    }, object));\n  }\n\n  for (var _elementSpecKey in elementSpecs) {\n    if (elementValidators[_elementSpecKey]) {\n      continue;\n    }\n\n    if (elementSpecs[_elementSpecKey].required && elementSpecs[_elementSpecKey][\'default\'] === undefined && object[_elementSpecKey] === undefined) {\n      errors.push(new ValidationError(key, object, "missing required property \\"".concat(_elementSpecKey, "\\"")));\n    }\n  }\n\n  return errors;\n}\n\nfunction validateArray(options) {\n  var array = options.value;\n  var arraySpec = options.valueSpec;\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n  var key = options.key;\n  var validateArrayElement = options.arrayElementValidator || validate;\n\n  if (getType(array) !== \'array\') {\n    return [new ValidationError(key, array, "array expected, ".concat(getType(array), " found"))];\n  }\n\n  if (arraySpec.length && array.length !== arraySpec.length) {\n    return [new ValidationError(key, array, "array length ".concat(arraySpec.length, " expected, length ").concat(array.length, " found"))];\n  }\n\n  if (arraySpec[\'min-length\'] && array.length < arraySpec[\'min-length\']) {\n    return [new ValidationError(key, array, "array length at least ".concat(arraySpec[\'min-length\'], " expected, length ").concat(array.length, " found"))];\n  }\n\n  var arrayElementSpec = {\n    \'type\': arraySpec.value,\n    \'values\': arraySpec.values,\n    \'minimum\': arraySpec.minimum,\n    \'maximum\': arraySpec.maximum\n  };\n\n  if (styleSpec.$version < 7) {\n    arrayElementSpec.function = arraySpec.function;\n  }\n\n  if (getType(arraySpec.value) === \'object\') {\n    arrayElementSpec = arraySpec.value;\n  }\n\n  var errors = [];\n\n  for (var i = 0; i < array.length; i++) {\n    errors = errors.concat(validateArrayElement({\n      array: array,\n      arrayIndex: i,\n      value: array[i],\n      valueSpec: arrayElementSpec,\n      style: style,\n      styleSpec: styleSpec,\n      key: "".concat(key, "[").concat(i, "]")\n    }));\n  }\n\n  return errors;\n}\n\nfunction validateNumber(options) {\n  var key = options.key;\n  var value = options.value;\n  var valueSpec = options.valueSpec;\n  var type = getType(value);\n\n  if (type === \'number\' && value !== value) {\n    type = \'NaN\';\n  }\n\n  if (type !== \'number\') {\n    return [new ValidationError(key, value, "number expected, ".concat(type, " found"))];\n  }\n\n  if (\'minimum\' in valueSpec) {\n    var specMin = valueSpec.minimum;\n\n    if (getType(valueSpec.minimum) === \'array\') {\n      var i = options.arrayIndex;\n      specMin = valueSpec.minimum[i];\n    }\n\n    if (value < specMin) {\n      return [new ValidationError(key, value, "".concat(value, " is less than the minimum value ").concat(specMin))];\n    }\n  }\n\n  if (\'maximum\' in valueSpec) {\n    var specMax = valueSpec.maximum;\n\n    if (getType(valueSpec.maximum) === \'array\') {\n      var _i9 = options.arrayIndex;\n      specMax = valueSpec.maximum[_i9];\n    }\n\n    if (value > specMax) {\n      return [new ValidationError(key, value, "".concat(value, " is greater than the maximum value ").concat(specMax))];\n    }\n  }\n\n  return [];\n}\n\nfunction validateFunction(options) {\n  var functionValueSpec = options.valueSpec;\n  var functionType = unbundle(options.value.type);\n  var stopKeyType;\n  var stopDomainValues = {};\n  var previousStopDomainValue;\n  var previousStopDomainZoom;\n  var isZoomFunction = functionType !== \'categorical\' && options.value.property === undefined;\n  var isPropertyFunction = !isZoomFunction;\n  var isZoomAndPropertyFunction = getType(options.value.stops) === \'array\' && getType(options.value.stops[0]) === \'array\' && getType(options.value.stops[0][0]) === \'object\';\n  var errors = validateObject({\n    key: options.key,\n    value: options.value,\n    valueSpec: options.styleSpec.function,\n    style: options.style,\n    styleSpec: options.styleSpec,\n    objectElementValidators: {\n      stops: validateFunctionStops,\n      default: validateFunctionDefault\n    }\n  });\n\n  if (functionType === \'identity\' && isZoomFunction) {\n    errors.push(new ValidationError(options.key, options.value, \'missing required property "property"\'));\n  }\n\n  if (functionType !== \'identity\' && !options.value.stops) {\n    errors.push(new ValidationError(options.key, options.value, \'missing required property "stops"\'));\n  }\n\n  if (functionType === \'exponential\' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {\n    errors.push(new ValidationError(options.key, options.value, \'exponential functions not supported\'));\n  }\n\n  if (options.styleSpec.$version >= 8) {\n    if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {\n      errors.push(new ValidationError(options.key, options.value, \'property functions not supported\'));\n    } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {\n      errors.push(new ValidationError(options.key, options.value, \'zoom functions not supported\'));\n    }\n  }\n\n  if ((functionType === \'categorical\' || isZoomAndPropertyFunction) && options.value.property === undefined) {\n    errors.push(new ValidationError(options.key, options.value, \'"property" property is required\'));\n  }\n\n  return errors;\n\n  function validateFunctionStops(options) {\n    if (functionType === \'identity\') {\n      return [new ValidationError(options.key, options.value, \'identity function may not have a "stops" property\')];\n    }\n\n    var errors = [];\n    var value = options.value;\n    errors = errors.concat(validateArray({\n      key: options.key,\n      value: value,\n      valueSpec: options.valueSpec,\n      style: options.style,\n      styleSpec: options.styleSpec,\n      arrayElementValidator: validateFunctionStop\n    }));\n\n    if (getType(value) === \'array\' && value.length === 0) {\n      errors.push(new ValidationError(options.key, value, \'array must have at least one stop\'));\n    }\n\n    return errors;\n  }\n\n  function validateFunctionStop(options) {\n    var errors = [];\n    var value = options.value;\n    var key = options.key;\n\n    if (getType(value) !== \'array\') {\n      return [new ValidationError(key, value, "array expected, ".concat(getType(value), " found"))];\n    }\n\n    if (value.length !== 2) {\n      return [new ValidationError(key, value, "array length 2 expected, length ".concat(value.length, " found"))];\n    }\n\n    if (isZoomAndPropertyFunction) {\n      if (getType(value[0]) !== \'object\') {\n        return [new ValidationError(key, value, "object expected, ".concat(getType(value[0]), " found"))];\n      }\n\n      if (value[0].zoom === undefined) {\n        return [new ValidationError(key, value, \'object stop key must have zoom\')];\n      }\n\n      if (value[0].value === undefined) {\n        return [new ValidationError(key, value, \'object stop key must have value\')];\n      }\n\n      if (previousStopDomainZoom && previousStopDomainZoom > unbundle(value[0].zoom)) {\n        return [new ValidationError(key, value[0].zoom, \'stop zoom values must appear in ascending order\')];\n      }\n\n      if (unbundle(value[0].zoom) !== previousStopDomainZoom) {\n        previousStopDomainZoom = unbundle(value[0].zoom);\n        previousStopDomainValue = undefined;\n        stopDomainValues = {};\n      }\n\n      errors = errors.concat(validateObject({\n        key: "".concat(key, "[0]"),\n        value: value[0],\n        valueSpec: {\n          zoom: {}\n        },\n        style: options.style,\n        styleSpec: options.styleSpec,\n        objectElementValidators: {\n          zoom: validateNumber,\n          value: validateStopDomainValue\n        }\n      }));\n    } else {\n      errors = errors.concat(validateStopDomainValue({\n        key: "".concat(key, "[0]"),\n        value: value[0],\n        valueSpec: {},\n        style: options.style,\n        styleSpec: options.styleSpec\n      }, value));\n    }\n\n    if (isExpression(deepUnbundle(value[1]))) {\n      return errors.concat([new ValidationError("".concat(key, "[1]"), value[1], \'expressions are not allowed in function stops.\')]);\n    }\n\n    return errors.concat(validate({\n      key: "".concat(key, "[1]"),\n      value: value[1],\n      valueSpec: functionValueSpec,\n      style: options.style,\n      styleSpec: options.styleSpec\n    }));\n  }\n\n  function validateStopDomainValue(options, stop) {\n    var type = getType(options.value);\n    var value = unbundle(options.value);\n    var reportValue = options.value !== null ? options.value : stop;\n\n    if (!stopKeyType) {\n      stopKeyType = type;\n    } else if (type !== stopKeyType) {\n      return [new ValidationError(options.key, reportValue, "".concat(type, " stop domain type must match previous stop domain type ").concat(stopKeyType))];\n    }\n\n    if (type !== \'number\' && type !== \'string\' && type !== \'boolean\') {\n      return [new ValidationError(options.key, reportValue, \'stop domain value must be a number, string, or boolean\')];\n    }\n\n    if (type !== \'number\' && functionType !== \'categorical\') {\n      var message = "number expected, ".concat(type, " found");\n\n      if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {\n        message += \'\\nIf you intended to use a categorical function, specify `"type": "categorical"`.\';\n      }\n\n      return [new ValidationError(options.key, reportValue, message)];\n    }\n\n    if (functionType === \'categorical\' && type === \'number\' && (!isFinite(value) || Math.floor(value) !== value)) {\n      return [new ValidationError(options.key, reportValue, "integer expected, found ".concat(value))];\n    }\n\n    if (functionType !== \'categorical\' && type === \'number\' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {\n      return [new ValidationError(options.key, reportValue, \'stop domain values must appear in ascending order\')];\n    } else {\n      previousStopDomainValue = value;\n    }\n\n    if (functionType === \'categorical\' && value in stopDomainValues) {\n      return [new ValidationError(options.key, reportValue, \'stop domain values must be unique\')];\n    } else {\n      stopDomainValues[value] = true;\n    }\n\n    return [];\n  }\n\n  function validateFunctionDefault(options) {\n    return validate({\n      key: options.key,\n      value: options.value,\n      valueSpec: functionValueSpec,\n      style: options.style,\n      styleSpec: options.styleSpec\n    });\n  }\n}\n\nfunction validateExpression(options) {\n  var expression = (options.expressionContext === \'property\' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);\n\n  if (expression.result === \'error\') {\n    return expression.value.map(function (error) {\n      return new ValidationError("".concat(options.key).concat(error.key), options.value, error.message);\n    });\n  }\n\n  var expressionObj = expression.value.expression || expression.value._styleExpression.expression;\n\n  if (options.expressionContext === \'property\' && options.propertyKey === \'text-font\' && !expressionObj.outputDefined()) {\n    return [new ValidationError(options.key, options.value, "Invalid data expression for \\"".concat(options.propertyKey, "\\". Output values must be contained as literals within the expression."))];\n  }\n\n  if (options.expressionContext === \'property\' && options.propertyType === \'layout\' && !isStateConstant(expressionObj)) {\n    return [new ValidationError(options.key, options.value, \'"feature-state" data expressions are not supported with layout properties.\')];\n  }\n\n  if (options.expressionContext === \'filter\' && !isStateConstant(expressionObj)) {\n    return [new ValidationError(options.key, options.value, \'"feature-state" data expressions are not supported with filters.\')];\n  }\n\n  if (options.expressionContext && options.expressionContext.indexOf(\'cluster\') === 0) {\n    if (!isGlobalPropertyConstant(expressionObj, [\'zoom\', \'feature-state\'])) {\n      return [new ValidationError(options.key, options.value, \'"zoom" and "feature-state" expressions are not supported with cluster properties.\')];\n    }\n\n    if (options.expressionContext === \'cluster-initial\' && !isFeatureConstant(expressionObj)) {\n      return [new ValidationError(options.key, options.value, \'Feature data expressions are not supported with initial expression part of cluster properties.\')];\n    }\n  }\n\n  return [];\n}\n\nfunction validateBoolean(options) {\n  var value = options.value;\n  var key = options.key;\n  var type = getType(value);\n\n  if (type !== \'boolean\') {\n    return [new ValidationError(key, value, "boolean expected, ".concat(type, " found"))];\n  }\n\n  return [];\n}\n\nfunction validateColor(options) {\n  var key = options.key;\n  var value = options.value;\n  var type = getType(value);\n\n  if (type !== \'string\') {\n    return [new ValidationError(key, value, "color expected, ".concat(type, " found"))];\n  }\n\n  if (csscolorparser.parseCSSColor(value) === null) {\n    return [new ValidationError(key, value, "color expected, \\"".concat(value, "\\" found"))];\n  }\n\n  return [];\n}\n\nfunction validateEnum(options) {\n  var key = options.key;\n  var value = options.value;\n  var valueSpec = options.valueSpec;\n  var errors = [];\n\n  if (Array.isArray(valueSpec.values)) {\n    if (valueSpec.values.indexOf(unbundle(value)) === -1) {\n      errors.push(new ValidationError(key, value, "expected one of [".concat(valueSpec.values.join(\', \'), "], ").concat(JSON.stringify(value), " found")));\n    }\n  } else {\n    if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {\n      errors.push(new ValidationError(key, value, "expected one of [".concat(Object.keys(valueSpec.values).join(\', \'), "], ").concat(JSON.stringify(value), " found")));\n    }\n  }\n\n  return errors;\n}\n\nfunction validateFilter(options) {\n  if (isExpressionFilter(deepUnbundle(options.value))) {\n    return validateExpression(extend({}, options, {\n      expressionContext: \'filter\',\n      valueSpec: {\n        value: \'boolean\'\n      }\n    }));\n  } else {\n    return validateNonExpressionFilter(options);\n  }\n}\n\nfunction validateNonExpressionFilter(options) {\n  var value = options.value;\n  var key = options.key;\n\n  if (getType(value) !== \'array\') {\n    return [new ValidationError(key, value, "array expected, ".concat(getType(value), " found"))];\n  }\n\n  var styleSpec = options.styleSpec;\n  var type;\n  var errors = [];\n\n  if (value.length < 1) {\n    return [new ValidationError(key, value, \'filter array must have at least 1 element\')];\n  }\n\n  errors = errors.concat(validateEnum({\n    key: "".concat(key, "[0]"),\n    value: value[0],\n    valueSpec: styleSpec.filter_operator,\n    style: options.style,\n    styleSpec: options.styleSpec\n  }));\n\n  switch (unbundle(value[0])) {\n    case \'<\':\n    case \'<=\':\n    case \'>\':\n    case \'>=\':\n      if (value.length >= 2 && unbundle(value[1]) === \'$type\') {\n        errors.push(new ValidationError(key, value, "\\"$type\\" cannot be use with operator \\"".concat(value[0], "\\"")));\n      }\n\n    case \'==\':\n    case \'!=\':\n      if (value.length !== 3) {\n        errors.push(new ValidationError(key, value, "filter array for operator \\"".concat(value[0], "\\" must have 3 elements")));\n      }\n\n    case \'in\':\n    case \'!in\':\n      if (value.length >= 2) {\n        type = getType(value[1]);\n\n        if (type !== \'string\') {\n          errors.push(new ValidationError("".concat(key, "[1]"), value[1], "string expected, ".concat(type, " found")));\n        }\n      }\n\n      for (var i = 2; i < value.length; i++) {\n        type = getType(value[i]);\n\n        if (unbundle(value[1]) === \'$type\') {\n          errors = errors.concat(validateEnum({\n            key: "".concat(key, "[").concat(i, "]"),\n            value: value[i],\n            valueSpec: styleSpec.geometry_type,\n            style: options.style,\n            styleSpec: options.styleSpec\n          }));\n        } else if (type !== \'string\' && type !== \'number\' && type !== \'boolean\') {\n          errors.push(new ValidationError("".concat(key, "[").concat(i, "]"), value[i], "string, number, or boolean expected, ".concat(type, " found")));\n        }\n      }\n\n      break;\n\n    case \'any\':\n    case \'all\':\n    case \'none\':\n      for (var _i10 = 1; _i10 < value.length; _i10++) {\n        errors = errors.concat(validateNonExpressionFilter({\n          key: "".concat(key, "[").concat(_i10, "]"),\n          value: value[_i10],\n          style: options.style,\n          styleSpec: options.styleSpec\n        }));\n      }\n\n      break;\n\n    case \'has\':\n    case \'!has\':\n      type = getType(value[1]);\n\n      if (value.length !== 2) {\n        errors.push(new ValidationError(key, value, "filter array for \\"".concat(value[0], "\\" operator must have 2 elements")));\n      } else if (type !== \'string\') {\n        errors.push(new ValidationError("".concat(key, "[1]"), value[1], "string expected, ".concat(type, " found")));\n      }\n\n      break;\n\n    case \'within\':\n      type = getType(value[1]);\n\n      if (value.length !== 2) {\n        errors.push(new ValidationError(key, value, "filter array for \\"".concat(value[0], "\\" operator must have 2 elements")));\n      } else if (type !== \'object\') {\n        errors.push(new ValidationError("".concat(key, "[1]"), value[1], "object expected, ".concat(type, " found")));\n      }\n\n      break;\n  }\n\n  return errors;\n}\n\nfunction validateProperty(options, propertyType) {\n  var key = options.key;\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n  var value = options.value;\n  var propertyKey = options.objectKey;\n  var layerSpec = styleSpec["".concat(propertyType, "_").concat(options.layerType)];\n  if (!layerSpec) return [];\n  var transitionMatch = propertyKey.match(/^(.*)-transition$/);\n\n  if (propertyType === \'paint\' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {\n    return validate({\n      key: key,\n      value: value,\n      valueSpec: styleSpec.transition,\n      style: style,\n      styleSpec: styleSpec\n    });\n  }\n\n  var valueSpec = options.valueSpec || layerSpec[propertyKey];\n\n  if (!valueSpec) {\n    return [new ValidationError(key, value, "unknown property \\"".concat(propertyKey, "\\""))];\n  }\n\n  var tokenMatch;\n\n  if (getType(value) === \'string\' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {\n    return [new ValidationError(key, value, "\\"".concat(propertyKey, "\\" does not support interpolation syntax\\n") + "Use an identity property function instead: `{ \\"type\\": \\"identity\\", \\"property\\": ".concat(JSON.stringify(tokenMatch[1]), " }`."))];\n  }\n\n  var errors = [];\n\n  if (options.layerType === \'symbol\') {\n    if (propertyKey === \'text-field\' && style && !style.glyphs) {\n      errors.push(new ValidationError(key, value, \'use of "text-field" requires a style "glyphs" property\'));\n    }\n\n    if (propertyKey === \'text-font\' && isFunction$1(deepUnbundle(value)) && unbundle(value.type) === \'identity\') {\n      errors.push(new ValidationError(key, value, \'"text-font" does not support identity functions\'));\n    }\n  }\n\n  return errors.concat(validate({\n    key: options.key,\n    value: value,\n    valueSpec: valueSpec,\n    style: style,\n    styleSpec: styleSpec,\n    expressionContext: \'property\',\n    propertyType: propertyType,\n    propertyKey: propertyKey\n  }));\n}\n\nfunction validatePaintProperty(options) {\n  return validateProperty(options, \'paint\');\n}\n\nfunction validateLayoutProperty(options) {\n  return validateProperty(options, \'layout\');\n}\n\nfunction validateLayer(options) {\n  var errors = [];\n  var layer = options.value;\n  var key = options.key;\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n\n  if (!layer.type && !layer.ref) {\n    errors.push(new ValidationError(key, layer, \'either "type" or "ref" is required\'));\n  }\n\n  var type = unbundle(layer.type);\n  var ref = unbundle(layer.ref);\n\n  if (layer.id) {\n    var layerId = unbundle(layer.id);\n\n    for (var i = 0; i < options.arrayIndex; i++) {\n      var otherLayer = style.layers[i];\n\n      if (unbundle(otherLayer.id) === layerId) {\n        errors.push(new ValidationError(key, layer.id, "duplicate layer id \\"".concat(layer.id, "\\", previously used at line ").concat(otherLayer.id.__line__)));\n      }\n    }\n  }\n\n  if (\'ref\' in layer) {\n    [\'type\', \'source\', \'source-layer\', \'filter\', \'layout\'].forEach(function (p) {\n      if (p in layer) {\n        errors.push(new ValidationError(key, layer[p], "\\"".concat(p, "\\" is prohibited for ref layers")));\n      }\n    });\n    var parent;\n    style.layers.forEach(function (layer) {\n      if (unbundle(layer.id) === ref) parent = layer;\n    });\n\n    if (!parent) {\n      errors.push(new ValidationError(key, layer.ref, "ref layer \\"".concat(ref, "\\" not found")));\n    } else if (parent.ref) {\n      errors.push(new ValidationError(key, layer.ref, \'ref cannot reference another ref layer\'));\n    } else {\n      type = unbundle(parent.type);\n    }\n  } else if (!(type === \'background\' || type === \'sky\')) {\n    if (!layer.source) {\n      errors.push(new ValidationError(key, layer, \'missing required property "source"\'));\n    } else {\n      var _source2 = style.sources && style.sources[layer.source];\n\n      var sourceType = _source2 && unbundle(_source2.type);\n\n      if (!_source2) {\n        errors.push(new ValidationError(key, layer.source, "source \\"".concat(layer.source, "\\" not found")));\n      } else if (sourceType === \'vector\' && type === \'raster\') {\n        errors.push(new ValidationError(key, layer.source, "layer \\"".concat(layer.id, "\\" requires a raster source")));\n      } else if (sourceType === \'raster\' && type !== \'raster\') {\n        errors.push(new ValidationError(key, layer.source, "layer \\"".concat(layer.id, "\\" requires a vector source")));\n      } else if (sourceType === \'vector\' && !layer[\'source-layer\']) {\n        errors.push(new ValidationError(key, layer, "layer \\"".concat(layer.id, "\\" must specify a \\"source-layer\\"")));\n      } else if (sourceType === \'raster-dem\' && type !== \'hillshade\') {\n        errors.push(new ValidationError(key, layer.source, \'raster-dem source can only be used with layer type \\\'hillshade\\\'.\'));\n      } else if (type === \'line\' && layer.paint && layer.paint[\'line-gradient\'] && (sourceType !== \'geojson\' || !_source2.lineMetrics)) {\n        errors.push(new ValidationError(key, layer, "layer \\"".concat(layer.id, "\\" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.")));\n      }\n    }\n  }\n\n  errors = errors.concat(validateObject({\n    key: key,\n    value: layer,\n    valueSpec: styleSpec.layer,\n    style: options.style,\n    styleSpec: options.styleSpec,\n    objectElementValidators: {\n      \'*\': function _() {\n        return [];\n      },\n      type: function type() {\n        return validate({\n          key: "".concat(key, ".type"),\n          value: layer.type,\n          valueSpec: styleSpec.layer.type,\n          style: options.style,\n          styleSpec: options.styleSpec,\n          object: layer,\n          objectKey: \'type\'\n        });\n      },\n      filter: validateFilter,\n      layout: function layout(options) {\n        return validateObject({\n          layer: layer,\n          key: options.key,\n          value: options.value,\n          style: options.style,\n          styleSpec: options.styleSpec,\n          objectElementValidators: {\n            \'*\': function _(options) {\n              return validateLayoutProperty(extend({\n                layerType: type\n              }, options));\n            }\n          }\n        });\n      },\n      paint: function paint(options) {\n        return validateObject({\n          layer: layer,\n          key: options.key,\n          value: options.value,\n          style: options.style,\n          styleSpec: options.styleSpec,\n          objectElementValidators: {\n            \'*\': function _(options) {\n              return validatePaintProperty(extend({\n                layerType: type\n              }, options));\n            }\n          }\n        });\n      }\n    }\n  }));\n  return errors;\n}\n\nfunction validateString(options) {\n  var value = options.value;\n  var key = options.key;\n  var type = getType(value);\n\n  if (type !== \'string\') {\n    return [new ValidationError(key, value, "string expected, ".concat(type, " found"))];\n  }\n\n  return [];\n}\n\nvar objectElementValidators = {\n  promoteId: validatePromoteId\n};\n\nfunction validateSource(options) {\n  var value = options.value;\n  var key = options.key;\n  var styleSpec = options.styleSpec;\n  var style = options.style;\n\n  if (!value.type) {\n    return [new ValidationError(key, value, \'"type" is required\')];\n  }\n\n  var type = unbundle(value.type);\n  var errors;\n\n  switch (type) {\n    case \'vector\':\n    case \'raster\':\n    case \'raster-dem\':\n      errors = validateObject({\n        key: key,\n        value: value,\n        valueSpec: styleSpec["source_".concat(type.replace(\'-\', \'_\'))],\n        style: options.style,\n        styleSpec: styleSpec,\n        objectElementValidators: objectElementValidators\n      });\n      return errors;\n\n    case \'geojson\':\n      errors = validateObject({\n        key: key,\n        value: value,\n        valueSpec: styleSpec.source_geojson,\n        style: style,\n        styleSpec: styleSpec,\n        objectElementValidators: objectElementValidators\n      });\n\n      if (value.cluster) {\n        for (var prop in value.clusterProperties) {\n          var _errors, _errors2;\n\n          var _value$clusterPropert = (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_5__/* .default */ .Z)(value.clusterProperties[prop], 2),\n              operator = _value$clusterPropert[0],\n              mapExpr = _value$clusterPropert[1];\n\n          var reduceExpr = typeof operator === \'string\' ? [operator, [\'accumulated\'], [\'get\', prop]] : operator;\n\n          (_errors = errors).push.apply(_errors, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(validateExpression({\n            key: "".concat(key, ".").concat(prop, ".map"),\n            value: mapExpr,\n            expressionContext: \'cluster-map\'\n          })));\n\n          (_errors2 = errors).push.apply(_errors2, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(validateExpression({\n            key: "".concat(key, ".").concat(prop, ".reduce"),\n            value: reduceExpr,\n            expressionContext: \'cluster-reduce\'\n          })));\n        }\n      }\n\n      return errors;\n\n    case \'video\':\n      return validateObject({\n        key: key,\n        value: value,\n        valueSpec: styleSpec.source_video,\n        style: style,\n        styleSpec: styleSpec\n      });\n\n    case \'image\':\n      return validateObject({\n        key: key,\n        value: value,\n        valueSpec: styleSpec.source_image,\n        style: style,\n        styleSpec: styleSpec\n      });\n\n    case \'canvas\':\n      return [new ValidationError(key, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", \'source.canvas\')];\n\n    default:\n      return validateEnum({\n        key: "".concat(key, ".type"),\n        value: value.type,\n        valueSpec: {\n          values: [\'vector\', \'raster\', \'raster-dem\', \'geojson\', \'video\', \'image\']\n        },\n        style: style,\n        styleSpec: styleSpec\n      });\n  }\n}\n\nfunction validatePromoteId(_ref113) {\n  var key = _ref113.key,\n      value = _ref113.value;\n\n  if (getType(value) === \'string\') {\n    return validateString({\n      key: key,\n      value: value\n    });\n  } else {\n    var errors = [];\n\n    for (var prop in value) {\n      errors.push.apply(errors, (0,_home_runner_work_justice40_tool_justice40_tool_client_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_7__/* .default */ .Z)(validateString({\n        key: "".concat(key, ".").concat(prop),\n        value: value[prop]\n      })));\n    }\n\n    return errors;\n  }\n}\n\nfunction validateLight(options) {\n  var light = options.value;\n  var styleSpec = options.styleSpec;\n  var lightSpec = styleSpec.light;\n  var style = options.style;\n  var errors = [];\n  var rootType = getType(light);\n\n  if (light === undefined) {\n    return errors;\n  } else if (rootType !== \'object\') {\n    errors = errors.concat([new ValidationError(\'light\', light, "object expected, ".concat(rootType, " found"))]);\n    return errors;\n  }\n\n  for (var key in light) {\n    var transitionMatch = key.match(/^(.*)-transition$/);\n\n    if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {\n      errors = errors.concat(validate({\n        key: key,\n        value: light[key],\n        valueSpec: styleSpec.transition,\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else if (lightSpec[key]) {\n      errors = errors.concat(validate({\n        key: key,\n        value: light[key],\n        valueSpec: lightSpec[key],\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else {\n      errors = errors.concat([new ValidationError(key, light[key], "unknown property \\"".concat(key, "\\""))]);\n    }\n  }\n\n  return errors;\n}\n\nfunction validateTerrain(options) {\n  var terrain = options.value;\n  var key = options.key;\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n  var terrainSpec = styleSpec.terrain;\n  var errors = [];\n  var rootType = getType(terrain);\n\n  if (terrain === undefined) {\n    return errors;\n  } else if (rootType !== \'object\') {\n    errors = errors.concat([new ValidationError(\'terrain\', terrain, "object expected, ".concat(rootType, " found"))]);\n    return errors;\n  }\n\n  for (var _key6 in terrain) {\n    var transitionMatch = _key6.match(/^(.*)-transition$/);\n\n    if (transitionMatch && terrainSpec[transitionMatch[1]] && terrainSpec[transitionMatch[1]].transition) {\n      errors = errors.concat(validate({\n        key: _key6,\n        value: terrain[_key6],\n        valueSpec: styleSpec.transition,\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else if (terrainSpec[_key6]) {\n      errors = errors.concat(validate({\n        key: _key6,\n        value: terrain[_key6],\n        valueSpec: terrainSpec[_key6],\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else {\n      errors = errors.concat([new ValidationError(_key6, terrain[_key6], "unknown property \\"".concat(_key6, "\\""))]);\n    }\n  }\n\n  if (!terrain.source) {\n    errors.push(new ValidationError(key, terrain, "terrain is missing required property \\"source\\""));\n  } else {\n    var _source3 = style.sources && style.sources[terrain.source];\n\n    var sourceType = _source3 && unbundle(_source3.type);\n\n    if (!_source3) {\n      errors.push(new ValidationError(key, terrain.source, "source \\"".concat(terrain.source, "\\" not found")));\n    } else if (sourceType !== \'raster-dem\') {\n      errors.push(new ValidationError(key, terrain.source, "terrain cannot be used with a source of type ".concat(sourceType, ", it only be used with a \\"raster-dem\\" source type")));\n    }\n  }\n\n  return errors;\n}\n\nfunction validateFog(options) {\n  var fog = options.value;\n  var style = options.style;\n  var styleSpec = options.styleSpec;\n  var fogSpec = styleSpec.fog;\n  var errors = [];\n  var rootType = getType(fog);\n\n  if (fog === undefined) {\n    return errors;\n  } else if (rootType !== \'object\') {\n    errors = errors.concat([new ValidationError(\'fog\', fog, "object expected, ".concat(rootType, " found"))]);\n    return errors;\n  }\n\n  if (fog.range && !isExpression(deepUnbundle(fog.range)) && fog.range[0] >= fog.range[1]) {\n    errors = errors.concat([new ValidationError(\'fog\', fog, \'fog.range[0] can\\\'t be greater than or equal to fog.range[1]\')]);\n  }\n\n  for (var key in fog) {\n    var transitionMatch = key.match(/^(.*)-transition$/);\n\n    if (transitionMatch && fogSpec[transitionMatch[1]] && fogSpec[transitionMatch[1]].transition) {\n      errors = errors.concat(validate({\n        key: key,\n        value: fog[key],\n        valueSpec: styleSpec.transition,\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else if (fogSpec[key]) {\n      errors = errors.concat(validate({\n        key: key,\n        value: fog[key],\n        valueSpec: fogSpec[key],\n        style: style,\n        styleSpec: styleSpec\n      }));\n    } else {\n      errors = errors.concat([new ValidationError(key, fog[key], "unknown property \\"".concat(key, "\\""))]);\n    }\n  }\n\n  return errors;\n}\n\nfunction validateFormatted(options) {\n  if (validateString(options).length === 0) {\n    return [];\n  }\n\n  return validateExpression(options);\n}\n\nfunction validateImage(options) {\n  if (validateString(options).length === 0) {\n    return [];\n  }\n\n  return validateExpression(options);\n}\n\nvar VALIDATORS = {\n  \'*\': function _() {\n    return [];\n  },\n  \'array\': validateArray,\n  \'boolean\': validateBoolean,\n  \'number\': validateNumber,\n  \'color\': validateColor,\n  \'constants\': validateConstants,\n  \'enum\': validateEnum,\n  \'filter\': validateFilter,\n  \'function\': validateFunction,\n  \'layer\': validateLayer,\n  \'object\': validateObject,\n  \'source\': validateSource,\n  \'light\': validateLight,\n  \'terrain\': validateTerrain,\n  \'fog\': validateFog,\n  \'string\': validateString,\n  \'formatted\': validateFormatted,\n  \'resolvedImage\': validateImage\n};\n\nfunction validate(options) {\n  var value = options.value;\n  var valueSpec = options.valueSpec;\n  var styleSpec = options.styleSpec;\n\n  if (valueSpec.expression && isFunction$1(unbundle(value))) {\n    return validateFunction(options);\n  } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {\n    return validateExpression(options);\n  } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {\n    return VALIDATORS[valueSpec.type](options);\n  } else {\n    var valid = validateObject(extend({}, options, {\n      valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec\n    }));\n    return valid;\n  }\n}\n\nfunction validateGlyphsURL(options) {\n  var value = options.value;\n  var key = options.key;\n  var errors = validateString(options);\n  if (errors.length) return errors;\n\n  if (value.indexOf(\'{fontstack}\') === -1) {\n    errors.push(new ValidationError(key, value, \'"glyphs" url must include a "{fontstack}" token\'));\n  }\n\n  if (value.indexOf(\'{range}\') === -1) {\n    errors.push(new ValidationError(key, value, \'"glyphs" url must include a "{range}" token\'));\n  }\n\n  return errors;\n}\n\nfunction validateStyleMin(style) {\n  var styleSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v8;\n  var errors = [];\n  errors = errors.concat(validate({\n    key: \'\',\n    value: style,\n    valueSpec: styleSpec.$root,\n    styleSpec: styleSpec,\n    style: style,\n    objectElementValidators: {\n      glyphs: validateGlyphsURL,\n      \'*\': function _() {\n        return [];\n      }\n    }\n  }));\n\n  if (style.constants) {\n    errors = errors.concat(validateConstants({\n      key: \'constants\',\n      value: style.constants,\n      style: style,\n      styleSpec: styleSpec\n    }));\n  }\n\n  return sortErrors(errors);\n}\n\nvalidateStyleMin.source = wrapCleanErrors(validateSource);\nvalidateStyleMin.light = wrapCleanErrors(validateLight);\nvalidateStyleMin.terrain = wrapCleanErrors(validateTerrain);\nvalidateStyleMin.fog = wrapCleanErrors(validateFog);\nvalidateStyleMin.layer = wrapCleanErrors(validateLayer);\nvalidateStyleMin.filter = wrapCleanErrors(validateFilter);\nvalidateStyleMin.paintProperty = wrapCleanErrors(validatePaintProperty);\nvalidateStyleMin.layoutProperty = wrapCleanErrors(validateLayoutProperty);\n\nfunction sortErrors(errors) {\n  return [].concat(errors).sort(function (a, b) {\n    return a.line - b.line;\n  });\n}\n\nfunction wrapCleanErrors(inner) {\n  return function () {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key7 = 0; _key7 < _len4; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    return sortErrors(inner.apply(this, args));\n  };\n}\n/* parser generated by jison 0.4.15 */\n\n\nvar jsonlint = createCommonjsModule(function (module, exports) {\n  /*\n    Returns a Parser object of the following structure:\n  \n    Parser: {\n      yy: {}\n    }\n  \n    Parser.prototype: {\n      yy: {},\n      trace: function(),\n      symbols_: {associative list: name ==> number},\n      terminals_: {associative list: number ==> name},\n      productions_: [...],\n      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n      table: [...],\n      defaultActions: {...},\n      parseError: function(str, hash),\n      parse: function(input),\n  \n      lexer: {\n          EOF: 1,\n          parseError: function(str, hash),\n          setInput: function(input),\n          input: function(),\n          unput: function(str),\n          more: function(),\n          less: function(n),\n          pastInput: function(),\n          upcomingInput: function(),\n          showPosition: function(),\n          test_match: function(regex_match_array, rule_index),\n          next: function(),\n          lex: function(),\n          begin: function(condition),\n          popState: function(),\n          _currentRules: function(),\n          topState: function(),\n          pushState: function(condition),\n  \n          options: {\n              ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n          },\n  \n          performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n          rules: [...],\n          conditions: {associative list: name ==> set},\n      }\n    }\n  \n  \n    token location info (@$, _$, etc.): {\n      first_line: n,\n      last_line: n,\n      first_column: n,\n      last_column: n,\n      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n    }\n  \n  \n    the parseError function receives a \'hash\' object with these members for lexer and parser errors: {\n      text:        (matched text)\n      token:       (the produced terminal token, if any)\n      line:        (yylineno)\n    }\n    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n      loc:         (yylloc)\n      expected:    (string describing the set of expected tokens)\n      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n    }\n  */\n  var parser = function () {\n    var o = function o(k, v, _o, l) {\n      for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {\n        ;\n      }\n\n      return _o;\n    },\n        $V0 = [1, 12],\n        $V1 = [1, 13],\n        $V2 = [1, 9],\n        $V3 = [1, 10],\n        $V4 = [1, 11],\n        $V5 = [1, 14],\n        $V6 = [1, 15],\n        $V7 = [14, 18, 22, 24],\n        $V8 = [18, 22],\n        $V9 = [22, 24];\n\n    var parser = {\n      trace: function trace() {},\n      yy: {},\n      symbols_: {\n        "error": 2,\n        "JSONString": 3,\n        "STRING": 4,\n        "JSONNumber": 5,\n        "NUMBER": 6,\n        "JSONNullLiteral": 7,\n        "NULL": 8,\n        "JSONBooleanLiteral": 9,\n        "TRUE": 10,\n        "FALSE": 11,\n        "JSONText": 12,\n        "JSONValue": 13,\n        "EOF": 14,\n        "JSONObject": 15,\n        "JSONArray": 16,\n        "{": 17,\n        "}": 18,\n        "JSONMemberList": 19,\n        "JSONMember": 20,\n        ":": 21,\n        ",": 22,\n        "[": 23,\n        "]": 24,\n        "JSONElementList": 25,\n        "$accept": 0,\n        "$end": 1\n      },\n      terminals_: {\n        2: "error",\n        4: "STRING",\n        6: "NUMBER",\n        8: "NULL",\n        10: "TRUE",\n        11: "FALSE",\n        14: "EOF",\n        17: "{",\n        18: "}",\n        21: ":",\n        22: ",",\n        23: "[",\n        24: "]"\n      },\n      productions_: [0, [3, 1], [5, 1], [7, 1], [9, 1], [9, 1], [12, 2], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [13, 1], [15, 2], [15, 3], [20, 3], [19, 1], [19, 3], [16, 2], [16, 3], [25, 1], [25, 3]],\n      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate\n      /* action[1] */\n      , $$\n      /* vstack */\n      , _$\n      /* lstack */\n      ) {\n        /* this == yyval */\n        var $0 = $$.length - 1;\n\n        switch (yystate) {\n          case 1:\n            // replace escaped characters with actual character\n            this.$ = new String(yytext.replace(/\\\\(\\\\|")/g, "$" + "1").replace(/\\\\n/g, \'\\n\').replace(/\\\\r/g, \'\\r\').replace(/\\\\t/g, \'\\t\').replace(/\\\\v/g, \'\\v\').replace(/\\\\f/g, \'\\f\').replace(/\\\\b/g, \'\\b\'));\n            this.$.__line__ = this._$.first_line;\n            break;\n\n          case 2:\n            this.$ = new Number(yytext);\n            this.$.__line__ = this._$.first_line;\n            break;\n\n          case 3:\n            this.$ = null;\n            break;\n\n          case 4:\n            this.$ = new Boolean(true);\n            this.$.__line__ = this._$.first_line;\n            break;\n\n          case 5:\n            this.$ = new Boolean(false);\n            this.$.__line__ = this._$.first_line;\n            break;\n\n          case 6:\n            return this.$ = $$[$0 - 1];\n\n          case 13:\n            this.$ = {};\n            Object.defineProperty(this.$, \'__line__\', {\n              value: this._$.first_line,\n              enumerable: false\n            });\n            break;\n\n          case 14:\n          case 19:\n            this.$ = $$[$0 - 1];\n            Object.defineProperty(this.$, \'__line__\', {\n              value: this._$.first_line,\n              enumerable: false\n            });\n            break;\n\n          case 15:\n            this.$ = [$$[$0 - 2], $$[$0]];\n            break;\n\n          case 16:\n            this.$ = {};\n            this.$[$$[$0][0]] = $$[$0][1];\n            break;\n\n          case 17:\n            this.$ = $$[$0 - 2];\n            $$[$0 - 2][$$[$0][0]] = $$[$0][1];\n            break;\n\n          case 18:\n            this.$ = [];\n            Object.defineProperty(this.$, \'__line__\', {\n              value: this._$.first_line,\n              enumerable: false\n            });\n            break;\n\n          case 20:\n            this.$ = [$$[$0]];\n            break;\n\n          case 21:\n            this.$ = $$[$0 - 2];\n            $$[$0 - 2].push($$[$0]);\n            break;\n        }\n      },\n      table: [{\n        3: 5,\n        4: $V0,\n        5: 6,\n        6: $V1,\n        7: 3,\n        8: $V2,\n        9: 4,\n        10: $V3,\n        11: $V4,\n        12: 1,\n        13: 2,\n        15: 7,\n        16: 8,\n        17: $V5,\n        23: $V6\n      }, {\n        1: [3]\n      }, {\n        14: [1, 16]\n      }, o($V7, [2, 7]), o($V7, [2, 8]), o($V7, [2, 9]), o($V7, [2, 10]), o($V7, [2, 11]), o($V7, [2, 12]), o($V7, [2, 3]), o($V7, [2, 4]), o($V7, [2, 5]), o([14, 18, 21, 22, 24], [2, 1]), o($V7, [2, 2]), {\n        3: 20,\n        4: $V0,\n        18: [1, 17],\n        19: 18,\n        20: 19\n      }, {\n        3: 5,\n        4: $V0,\n        5: 6,\n        6: $V1,\n        7: 3,\n        8: $V2,\n        9: 4,\n        10: $V3,\n        11: $V4,\n        13: 23,\n        15: 7,\n        16: 8,\n        17: $V5,\n        23: $V6,\n        24: [1, 21],\n        25: 22\n      }, {\n        1: [2, 6]\n      }, o($V7, [2, 13]), {\n        18: [1, 24],\n        22: [1, 25]\n      }, o($V8, [2, 16]), {\n        21: [1, 26]\n      }, o($V7, [2, 18]), {\n        22: [1, 28],\n        24: [1, 27]\n      }, o($V9, [2, 20]), o($V7, [2, 14]), {\n        3: 20,\n        4: $V0,\n        20: 29\n      }, {\n        3: 5,\n        4: $V0,\n        5: 6,\n        6: $V1,\n        7: 3,\n        8: $V2,\n        9: 4,\n        10: $V3,\n        11: $V4,\n        13: 30,\n        15: 7,\n        16: 8,\n        17: $V5,\n        23: $V6\n      }, o($V7, [2, 19]), {\n        3: 5,\n        4: $V0,\n        5: 6,\n        6: $V1,\n        7: 3,\n        8: $V2,\n        9: 4,\n        10: $V3,\n        11: $V4,\n        13: 31,\n        15: 7,\n        16: 8,\n        17: $V5,\n        23: $V6\n      }, o($V8, [2, 17]), o($V8, [2, 15]), o($V9, [2, 21])],\n      defaultActions: {\n        16: [2, 6]\n      },\n      parseError: function parseError(str, hash) {\n        if (hash.recoverable) {\n          this.trace(str);\n        } else {\n          throw new Error(str);\n        }\n      },\n      parse: function parse(input) {\n        var self = this,\n            stack = [0],\n            vstack = [null],\n            lstack = [],\n            table = this.table,\n            yytext = \'\',\n            yylineno = 0,\n            yyleng = 0,\n            TERROR = 2,\n            EOF = 1;\n        var args = lstack.slice.call(arguments, 1);\n        var lexer = Object.create(this.lexer);\n        var sharedState = {\n          yy: {}\n        };\n\n        for (var k in this.yy) {\n          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n          }\n        }\n\n        lexer.setInput(input, sharedState.yy);\n        sharedState.yy.lexer = lexer;\n        sharedState.yy.parser = this;\n\n        if (typeof lexer.yylloc == \'undefined\') {\n          lexer.yylloc = {};\n        }\n\n        var yyloc = lexer.yylloc;\n        lstack.push(yyloc);\n        var ranges = lexer.options && lexer.options.ranges;\n\n        if (typeof sharedState.yy.parseError === \'function\') {\n          this.parseError = sharedState.yy.parseError;\n        } else {\n          this.parseError = Object.getPrototypeOf(this).parseError;\n        }\n\n        function lex() {\n          var token;\n          token = lexer.lex() || EOF;\n\n          if (typeof token !== \'number\') {\n            token = self.symbols_[token] || token;\n          }\n\n          return token;\n        }\n\n        var symbol,\n            state,\n            action,\n            r,\n            yyval = {},\n            p,\n            len,\n            newState,\n            expected;\n\n        while (true) {\n          state = stack[stack.length - 1];\n\n          if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n          } else {\n            if (symbol === null || typeof symbol == \'undefined\') {\n              symbol = lex();\n            }\n\n            action = table[state] && table[state][symbol];\n          }\n\n          if (typeof action === \'undefined\' || !action.length || !action[0]) {\n            var errStr = \'\';\n            expected = [];\n\n            for (p in table[state]) {\n              if (this.terminals_[p] && p > TERROR) {\n                expected.push(\'\\\'\' + this.terminals_[p] + \'\\\'\');\n              }\n            }\n\n            if (lexer.showPosition) {\n              errStr = \'Parse error on line \' + (yylineno + 1) + \':\\n\' + lexer.showPosition() + \'\\nExpecting \' + expected.join(\', \') + \', got \\\'\' + (this.terminals_[symbol] || symbol) + \'\\\'\';\n            } else {\n              errStr = \'Parse error on line \' + (yylineno + 1) + \': Unexpected \' + (symbol == EOF ? \'end of input\' : \'\\\'\' + (this.terminals_[symbol] || symbol) + \'\\\'\');\n            }\n\n            this.parseError(errStr, {\n              text: lexer.match,\n              token: this.terminals_[symbol] || symbol,\n              line: lexer.yylineno,\n              loc: yyloc,\n              expected: expected\n            });\n          }\n\n          if (action[0] instanceof Array && action.length > 1) {\n            throw new Error(\'Parse Error: multiple actions possible at state: \' + state + \', token: \' + symbol);\n          }\n\n          switch (action[0]) {\n            case 1:\n              stack.push(symbol);\n              vstack.push(lexer.yytext);\n              lstack.push(lexer.yylloc);\n              stack.push(action[1]);\n              symbol = null;\n              {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n              }\n              break;\n\n            case 2:\n              len = this.productions_[action[1]][1];\n              yyval.$ = vstack[vstack.length - len];\n              yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n              };\n\n              if (ranges) {\n                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];\n              }\n\n              r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));\n\n              if (typeof r !== \'undefined\') {\n                return r;\n              }\n\n              if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n              }\n\n              stack.push(this.productions_[action[1]][0]);\n              vstack.push(yyval.$);\n              lstack.push(yyval._$);\n              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n              stack.push(newState);\n              break;\n\n            case 3:\n              return true;\n          }\n        }\n\n        return true;\n      }\n    };\n    /* generated by jison-lex 0.3.4 */\n\n    var lexer = function () {\n      var lexer = {\n        EOF: 1,\n        parseError: function parseError(str, hash) {\n          if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n          } else {\n            throw new Error(str);\n          }\n        },\n        // resets the lexer, sets new input\n        setInput: function setInput(input, yy) {\n          this.yy = yy || this.yy || {};\n          this._input = input;\n          this._more = this._backtrack = this.done = false;\n          this.yylineno = this.yyleng = 0;\n          this.yytext = this.matched = this.match = \'\';\n          this.conditionStack = [\'INITIAL\'];\n          this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n          };\n\n          if (this.options.ranges) {\n            this.yylloc.range = [0, 0];\n          }\n\n          this.offset = 0;\n          return this;\n        },\n        // consumes and returns one char from the input\n        input: function input() {\n          var ch = this._input[0];\n          this.yytext += ch;\n          this.yyleng++;\n          this.offset++;\n          this.match += ch;\n          this.matched += ch;\n          var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n\n          if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n          } else {\n            this.yylloc.last_column++;\n          }\n\n          if (this.options.ranges) {\n            this.yylloc.range[1]++;\n          }\n\n          this._input = this._input.slice(1);\n          return ch;\n        },\n        // unshifts one char (or a string) into the input\n        unput: function unput(ch) {\n          var len = ch.length;\n          var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n          this._input = ch + this._input;\n          this.yytext = this.yytext.substr(0, this.yytext.length - len); //this.yyleng -= len;\n\n          this.offset -= len;\n          var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n          this.match = this.match.substr(0, this.match.length - 1);\n          this.matched = this.matched.substr(0, this.matched.length - 1);\n\n          if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n          }\n\n          var r = this.yylloc.range;\n          this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len\n          };\n\n          if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n          }\n\n          this.yyleng = this.yytext.length;\n          return this;\n        },\n        // When called from action, caches matched text and appends it on next action\n        more: function more() {\n          this._more = true;\n          return this;\n        },\n        // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\n        reject: function reject() {\n          if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n          } else {\n            return this.parseError(\'Lexical error on line \' + (this.yylineno + 1) + \'. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n\' + this.showPosition(), {\n              text: "",\n              token: null,\n              line: this.yylineno\n            });\n          }\n\n          return this;\n        },\n        // retain first n characters of the match\n        less: function less(n) {\n          this.unput(this.match.slice(n));\n        },\n        // displays already matched input, i.e. for error messages\n        pastInput: function pastInput() {\n          var past = this.matched.substr(0, this.matched.length - this.match.length);\n          return (past.length > 20 ? \'...\' : \'\') + past.substr(-20).replace(/\\n/g, "");\n        },\n        // displays upcoming input, i.e. for error messages\n        upcomingInput: function upcomingInput() {\n          var next = this.match;\n\n          if (next.length < 20) {\n            next += this._input.substr(0, 20 - next.length);\n          }\n\n          return (next.substr(0, 20) + (next.length > 20 ? \'...\' : \'\')).replace(/\\n/g, "");\n        },\n        // displays the character position where the lexing error occurred, i.e. for error messages\n        showPosition: function showPosition() {\n          var pre = this.pastInput();\n          var c = new Array(pre.length + 1).join("-");\n          return pre + this.upcomingInput() + "\\n" + c + "^";\n        },\n        // test the lexed token: return FALSE when not a match, otherwise return token\n        test_match: function test_match(match, indexed_rule) {\n          var token, lines, backup;\n\n          if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n              yylineno: this.yylineno,\n              yylloc: {\n                first_line: this.yylloc.first_line,\n                last_line: this.last_line,\n                first_column: this.yylloc.first_column,\n                last_column: this.yylloc.last_column\n              },\n              yytext: this.yytext,\n              match: this.match,\n              matches: this.matches,\n              matched: this.matched,\n              yyleng: this.yyleng,\n              offset: this.offset,\n              _more: this._more,\n              _input: this._input,\n              yy: this.yy,\n              conditionStack: this.conditionStack.slice(0),\n              done: this.done\n            };\n\n            if (this.options.ranges) {\n              backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n          }\n\n          lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n\n          if (lines) {\n            this.yylineno += lines.length;\n          }\n\n          this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length : this.yylloc.last_column + match[0].length\n          };\n          this.yytext += match[0];\n          this.match += match[0];\n          this.matches = match;\n          this.yyleng = this.yytext.length;\n\n          if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n          }\n\n          this._more = false;\n          this._backtrack = false;\n          this._input = this._input.slice(match[0].length);\n          this.matched += match[0];\n          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n\n          if (this.done && this._input) {\n            this.done = false;\n          }\n\n          if (token) {\n            return token;\n          } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n              this[k] = backup[k];\n            }\n\n            return false; // rule action called reject() implying the next rule should be tested instead.\n          }\n\n          return false;\n        },\n        // return next match in input\n        next: function next() {\n          if (this.done) {\n            return this.EOF;\n          }\n\n          if (!this._input) {\n            this.done = true;\n          }\n\n          var token, match, tempMatch, index;\n\n          if (!this._more) {\n            this.yytext = \'\';\n            this.match = \'\';\n          }\n\n          var rules = this._currentRules();\n\n          for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n              match = tempMatch;\n              index = i;\n\n              if (this.options.backtrack_lexer) {\n                token = this.test_match(tempMatch, rules[i]);\n\n                if (token !== false) {\n                  return token;\n                } else if (this._backtrack) {\n                  match = false;\n                  continue; // rule action called reject() implying a rule MISmatch.\n                } else {\n                  // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                  return false;\n                }\n              } else if (!this.options.flex) {\n                break;\n              }\n            }\n          }\n\n          if (match) {\n            token = this.test_match(match, rules[index]);\n\n            if (token !== false) {\n              return token;\n            } // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n\n\n            return false;\n          }\n\n          if (this._input === "") {\n            return this.EOF;\n          } else {\n            return this.parseError(\'Lexical error on line \' + (this.yylineno + 1) + \'. Unrecognized text.\\n\' + this.showPosition(), {\n              text: "",\n              token: null,\n              line: this.yylineno\n            });\n          }\n        },\n        // return next match that has a token\n        lex: function lex() {\n          var r = this.next();\n\n          if (r) {\n            return r;\n          } else {\n            return this.lex();\n          }\n        },\n        // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\n        begin: function begin(condition) {\n          this.conditionStack.push(condition);\n        },\n        // pop the previously active lexer condition state off the condition stack\n        popState: function popState() {\n          var n = this.conditionStack.length - 1;\n\n          if (n > 0) {\n            return this.conditionStack.pop();\n          } else {\n            return this.conditionStack[0];\n          }\n        },\n        // produce the lexer rule set which is active for the currently active lexer condition state\n        _currentRules: function _currentRules() {\n          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n          } else {\n            return this.conditions["INITIAL"].rules;\n          }\n        },\n        // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\n        topState: function topState(n) {\n          n = this.conditionStack.length - 1 - Math.abs(n || 0);\n\n          if (n >= 0) {\n            return this.conditionStack[n];\n          } else {\n            return "INITIAL";\n          }\n        },\n        // alias for begin(condition)\n        pushState: function pushState(condition) {\n          this.begin(condition);\n        },\n        // return the number of states currently on the stack\n        stateStackSize: function stateStackSize() {\n          return this.conditionStack.length;\n        },\n        options: {},\n        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {\n          switch ($avoiding_name_collisions) {\n            case 0:\n              /* skip whitespace */\n              break;\n\n            case 1:\n              return 6;\n\n            case 2:\n              yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);\n              return 4;\n\n            case 3:\n              return 17;\n\n            case 4:\n              return 18;\n\n            case 5:\n              return 23;\n\n            case 6:\n              return 24;\n\n            case 7:\n              return 22;\n\n            case 8:\n              return 21;\n\n            case 9:\n              return 10;\n\n            case 10:\n              return 11;\n\n            case 11:\n              return 8;\n\n            case 12:\n              return 14;\n\n            case 13:\n              return \'INVALID\';\n          }\n        },\n        rules: [/^(?:\\s+)/, /^(?:(-?([0-9]|[1-9][0-9]+))(\\.[0-9]+)?([eE][-+]?[0-9]+)?\\b)/, /^(?:"(?:\\\\[\\\\"bfnrt/]|\\\\u[a-fA-F0-9]{4}|[^\\\\\\0-\\x09\\x0a-\\x1f"])*")/, /^(?:\\{)/, /^(?:\\})/, /^(?:\\[)/, /^(?:\\])/, /^(?:,)/, /^(?::)/, /^(?:true\\b)/, /^(?:false\\b)/, /^(?:null\\b)/, /^(?:$)/, /^(?:.)/],\n        conditions: {\n          "INITIAL": {\n            "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],\n            "inclusive": true\n          }\n        }\n      };\n      return lexer;\n    }();\n\n    parser.lexer = lexer;\n\n    function Parser() {\n      this.yy = {};\n    }\n\n    Parser.prototype = parser;\n    parser.Parser = Parser;\n    return new Parser();\n  }();\n\n  if (typeof commonjsRequire !== \'undefined\' && \'object\' !== \'undefined\') {\n    exports.parser = parser;\n    exports.Parser = parser.Parser;\n\n    exports.parse = function () {\n      return parser.parse.apply(parser, arguments);\n    };\n  }\n});\n\nfunction readStyle(style) {\n  if (style instanceof String || typeof style === \'string\' || style instanceof Buffer) {\n    try {\n      return jsonlint.parse(style.toString());\n    } catch (e) {\n      throw new ParsingError$1(e);\n    }\n  }\n\n  return style;\n}\n\nfunction validateStyle(style) {\n  var styleSpec = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v8;\n  var s = style;\n\n  try {\n    s = readStyle(s);\n  } catch (e) {\n    return [e];\n  }\n\n  return validateStyleMin(s, styleSpec);\n}\n\nvar SUPPORTED_SPEC_VERSION = 8;\nvar MAX_SOURCES_IN_STYLE = 15;\n\nfunction isValid(value, regex) {\n  if (!value || getType(value) !== \'string\') return true;\n  return !!value.match(regex);\n}\n\nfunction getSourceCount(source) {\n  if (source.url) {\n    return source.url.split(\',\').length;\n  } else {\n    return 0;\n  }\n}\n\nfunction getAllowedKeyErrors(obj, keys, path) {\n  var allowed = new Set(keys);\n  var errors = [];\n  Object.keys(obj).forEach(function (k) {\n    if (!allowed.has(k)) {\n      var prop = path ? "".concat(path, ".").concat(k) : null;\n      errors.push(new ValidationError(prop, obj[k], "Unsupported property \\"".concat(k, "\\"")));\n    }\n  });\n  return errors;\n}\n\nfunction getSourceErrors(source, i) {\n  var errors = [];\n  var sourceKeys = [\'type\', \'url\', \'tileSize\'];\n  errors.push.apply(errors, _toConsumableArray(getAllowedKeyErrors(source, sourceKeys, \'source\')));\n  var sourceUrlPattern = /^mapbox:\\/\\/([^/]*)$/;\n\n  if (!isValid(source.url, sourceUrlPattern)) {\n    errors.push(new ValidationError("sources[".concat(i, "]"), source.url, \'Source url must be a valid Mapbox tileset url\'));\n  }\n\n  return errors;\n}\n\nfunction getSourcesErrors(sources) {\n  var errors = [];\n  var count = 0;\n  Object.keys(sources).forEach(function (s, i) {\n    var sourceErrors = getSourceErrors(sources[s], i);\n\n    if (!sourceErrors.length) {\n      count = count + getSourceCount(sources[s]);\n    }\n\n    errors.push.apply(errors, _toConsumableArray(sourceErrors));\n  });\n\n  if (count > MAX_SOURCES_IN_STYLE) {\n    errors.push(new ValidationError(\'sources\', null, "Styles must contain ".concat(MAX_SOURCES_IN_STYLE, " or fewer sources")));\n  }\n\n  return errors;\n}\n\nfunction getRootErrors(style, specKeys) {\n  var errors = [];\n  var optionalRootProperties = [\'owner\', \'id\', \'cacheControl\', \'draft\', \'created\', \'modified\', \'visibility\'];\n  var allowedKeyErrors = getAllowedKeyErrors(style, [].concat(_toConsumableArray(specKeys), optionalRootProperties));\n  errors.push.apply(errors, _toConsumableArray(allowedKeyErrors));\n\n  if (style.version > SUPPORTED_SPEC_VERSION || style.version < SUPPORTED_SPEC_VERSION) {\n    errors.push(new ValidationError(\'version\', style.version, "Style version must be ".concat(SUPPORTED_SPEC_VERSION)));\n  }\n\n  var glyphUrlPattern = /^mapbox:\\/\\/fonts\\/([^/]*)\\/{fontstack}\\/{range}.pbf$/;\n\n  if (!isValid(style.glyphs, glyphUrlPattern)) {\n    errors.push(new ValidationError(\'glyphs\', style.glyphs, \'Styles must reference glyphs hosted by Mapbox\'));\n  }\n\n  var spriteUrlPattern = /^mapbox:\\/\\/sprites\\/([^/]*)\\/([^/]*)\\/?([^/]*)?$/;\n\n  if (!isValid(style.sprite, spriteUrlPattern)) {\n    errors.push(new ValidationError(\'sprite\', style.sprite, \'Styles must reference sprites hosted by Mapbox\'));\n  }\n\n  var visibilityPattern = /^(public|private)$/;\n\n  if (!isValid(style.visibility, visibilityPattern)) {\n    errors.push(new ValidationError(\'visibility\', style.visibility, \'Style visibility must be public or private\'));\n  }\n\n  return errors;\n}\n\nfunction validateMapboxApiSupported(style) {\n  var s = style;\n\n  try {\n    s = readStyle(s);\n  } catch (e) {\n    return [e];\n  }\n\n  var errors = validateStyleMin(s, v8).concat(getRootErrors(s, Object.keys(v8.$root)));\n\n  if (s.sources) {\n    errors = errors.concat(getSourcesErrors(s.sources));\n  }\n\n  return errors;\n}\n\nvar expression$1 = {\n  StyleExpression: StyleExpression,\n  isExpression: isExpression,\n  isExpressionFilter: isExpressionFilter,\n  createExpression: createExpression,\n  createPropertyExpression: createPropertyExpression,\n  normalizePropertyExpression: normalizePropertyExpression,\n  ZoomConstantExpression: ZoomConstantExpression,\n  ZoomDependentExpression: ZoomDependentExpression,\n  StylePropertyFunction: StylePropertyFunction\n};\nvar styleFunction = {\n  convertFunction: convertFunction,\n  createFunction: createFunction,\n  isFunction: isFunction$1\n};\nvar visit = {\n  eachSource: eachSource,\n  eachLayer: eachLayer,\n  eachProperty: eachProperty\n};\nvalidateStyle.parsed = validateStyle;\nvalidateStyle.latest = validateStyle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9qdXN0aWNlNDAtdG9vbC8uL25vZGVfbW9kdWxlcy9AbWFwYm94L21hcGJveC1nbC1zdHlsZS1zcGVjL2Rpc3QvaW5kZXguZXMuanM/MjMwYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEg7QUFDb0I7QUFDUjtBQUNKO0FBQ007QUFDWjtBQUNrQztBQUN0QjtBQUNFOztBQUU5SSxnQ0FBZ0MsNkRBQTZELHlDQUF5QyxhQUFhLDhKQUFlLGtCQUFrQixpQ0FBaUMsaUJBQWlCLDhKQUFlLG1CQUFtQix5REFBeUQsRUFBRSxPQUFPLHVDQUF1QyxFQUFFLFFBQVEseUtBQTBCLGVBQWUsR0FBRzs7QUFFdmEsc0NBQXNDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sNkVBQTZFLEdBQUcsYUFBYSxFQUFFLFlBQVksY0FBYyxFQUFFOztBQUV2VSx3REFBd0QsaUZBQWlGLFdBQVcsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLDhCQUE4QixFQUFFLHFCQUFxQixVQUFVLEVBQUUsU0FBUyxFQUFFLDhKQUE4SixFQUFFLGtEQUFrRCxTQUFTLGtCQUFrQixpQkFBaUIsRUFBRSxtQkFBbUIsc0JBQXNCLDhCQUE4QixhQUFhLEVBQUUsc0JBQXNCLGVBQWUsV0FBVyxFQUFFLG1CQUFtQixNQUFNLHlEQUF5RCxFQUFFLFVBQVUsdUJBQXVCLEVBQUUsRUFBRSxHQUFHOztBQUVwK0IsaURBQWlELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Qsa0hBQWtIOztBQUU5WixzQ0FBc0MsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sa0JBQWtCLEVBQUUsYUFBYTs7QUFFckw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRHQUE0RyxVQUFVLFFBQVEsTUFBTTtBQUNwSSxxQ0FBcUMsVUFBVSxFQUFFLE1BQU07QUFDdkQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0hBQW9ILDhCQUE4QjtBQUNsSixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0SkFBNEosOENBQThDLG9MQUFvTCxzRUFBc0UsMkNBQTJDLGdLQUFnSyxvRkFBb0Y7QUFDbnVCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0hBQW9ILDhCQUE4QjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUxBQXlMO0FBQ3pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5RUFBeUUsWUFBWTtBQUNyRixLQUFLO0FBQ0w7QUFDQSwwRUFBMEUsWUFBWTtBQUN0RixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1UkFBdVI7QUFDdlI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDBJQUEwSTtBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyS0FBMks7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3S0FBd0s7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4S0FBOEs7QUFDOUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyS0FBMks7QUFDM0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwwUUFBMFE7QUFDMVE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUNBQXFDLFVBQVUsRUFBRSxNQUFNO0FBQ3ZELEtBQUs7QUFDTCxnRUFBZ0UsVUFBVSxFQUFFLE1BQU07QUFDbEYsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBLHVDQUF1QyxRQUFRO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJGQUEyRixjQUFjO0FBQ3pHO0FBQ0E7O0FBRUEscUNBQXFDLHNCQUFzQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSx3SkFBUzs7QUFFWDs7QUFFQTtBQUNBOztBQUVBLElBQUksOEpBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLGVBQWUsK0pBQWdCOztBQUVoQztBQUNBO0FBQ0E7O0FBRUEsSUFBSSw4SkFBZTs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRCwyQkFBMkIsNkpBQWM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLDJKQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLElBQUksOEpBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLG1DQUFtQztBQUM5RCw0QkFBNEIsNkpBQWM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEVBQUUsMkpBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FB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Q0EsaUJBQWlCLDZKQUFjO0FBQy9COztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLDZKQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLDZKQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLDZKQUFjO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQiw2SkFBYztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQiw2SkFBYztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLDZKQUFjO0FBQy9COztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQkFBaUIsNkpBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQiw2SkFBYztBQUMvQjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FB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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixtQ0FBbUM7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0gsbUVBQW1FO0FBQ25FLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixtQ0FBbUM7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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Q0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDhKQUFlOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSw4SkFBZTs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QixrQkFBa0I7QUFDM0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDJCQUEyQjtBQUMzQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNkRBQTZEO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUlBQWlJLEVBQUUscUNBQXFDLFdBQVc7QUFDbkw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsVUFBVSxHQUFHLE1BQU07O0FBRXpFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzMDIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF90b0FycmF5IGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQXJyYXlcIjtcbmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXlcIjtcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvanVzdGljZTQwLXRvb2wvanVzdGljZTQwLXRvb2wvY2xpZW50L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5XCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCIvaG9tZS9ydW5uZXIvd29yay9qdXN0aWNlNDAtdG9vbC9qdXN0aWNlNDAtdG9vbC9jbGllbnQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiO1xuaW1wb3J0IF9nZXRQcm90b3R5cGVPZiBmcm9tIFwiL2hvbWUvcnVubmVyL3dvcmsvanVzdGljZTQwLXRvb2wvanVzdGljZTQwLXRvb2wvY2xpZW50L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF93cmFwTmF0aXZlU3VwZXIgZnJvbSBcIi9ob21lL3J1bm5lci93b3JrL2p1c3RpY2U0MC10b29sL2p1c3RpY2U0MC10b29sL2NsaWVudC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vd3JhcE5hdGl2ZVN1cGVyXCI7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbnZhciAkdmVyc2lvbiA9IDg7XG52YXIgJHJvb3QgPSB7XG4gIHZlcnNpb246IHtcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IFs4XSxcbiAgICBkb2M6IFwiU3R5bGUgc3BlY2lmaWNhdGlvbiB2ZXJzaW9uIG51bWJlci4gTXVzdCBiZSA4LlwiLFxuICAgIGV4YW1wbGU6IDhcbiAgfSxcbiAgbmFtZToge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkEgaHVtYW4tcmVhZGFibGUgbmFtZSBmb3IgdGhlIHN0eWxlLlwiLFxuICAgIGV4YW1wbGU6IFwiQnJpZ2h0XCJcbiAgfSxcbiAgbWV0YWRhdGE6IHtcbiAgICB0eXBlOiBcIipcIixcbiAgICBkb2M6IFwiQXJiaXRyYXJ5IHByb3BlcnRpZXMgdXNlZnVsIHRvIHRyYWNrIHdpdGggdGhlIHN0eWxlc2hlZXQsIGJ1dCBkbyBub3QgaW5mbHVlbmNlIHJlbmRlcmluZy4gUHJvcGVydGllcyBzaG91bGQgYmUgcHJlZml4ZWQgdG8gYXZvaWQgY29sbGlzaW9ucywgbGlrZSAnbWFwYm94OicuXCJcbiAgfSxcbiAgY2VudGVyOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJEZWZhdWx0IG1hcCBjZW50ZXIgaW4gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZS4gIFRoZSBzdHlsZSBjZW50ZXIgd2lsbCBiZSB1c2VkIG9ubHkgaWYgdGhlIG1hcCBoYXMgbm90IGJlZW4gcG9zaXRpb25lZCBieSBvdGhlciBtZWFucyAoZS5nLiBtYXAgb3B0aW9ucyBvciB1c2VyIGludGVyYWN0aW9uKS5cIixcbiAgICBleGFtcGxlOiBbLTczLjk3NDksIDQwLjc3MzZdXG4gIH0sXG4gIHpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJEZWZhdWx0IHpvb20gbGV2ZWwuICBUaGUgc3R5bGUgem9vbSB3aWxsIGJlIHVzZWQgb25seSBpZiB0aGUgbWFwIGhhcyBub3QgYmVlbiBwb3NpdGlvbmVkIGJ5IG90aGVyIG1lYW5zIChlLmcuIG1hcCBvcHRpb25zIG9yIHVzZXIgaW50ZXJhY3Rpb24pLlwiLFxuICAgIGV4YW1wbGU6IDEyLjVcbiAgfSxcbiAgYmVhcmluZzoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgcGVyaW9kOiAzNjAsXG4gICAgdW5pdHM6IFwiZGVncmVlc1wiLFxuICAgIGRvYzogXCJEZWZhdWx0IGJlYXJpbmcsIGluIGRlZ3JlZXMuIFRoZSBiZWFyaW5nIGlzIHRoZSBjb21wYXNzIGRpcmVjdGlvbiB0aGF0IGlzIFxcXCJ1cFxcXCI7IGZvciBleGFtcGxlLCBhIGJlYXJpbmcgb2YgOTDCsCBvcmllbnRzIHRoZSBtYXAgc28gdGhhdCBlYXN0IGlzIHVwLiBUaGlzIHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG4gICAgZXhhbXBsZTogMjlcbiAgfSxcbiAgcGl0Y2g6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIHVuaXRzOiBcImRlZ3JlZXNcIixcbiAgICBkb2M6IFwiRGVmYXVsdCBwaXRjaCwgaW4gZGVncmVlcy4gWmVybyBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBzdXJmYWNlLCBmb3IgYSBsb29rIHN0cmFpZ2h0IGRvd24gYXQgdGhlIG1hcCwgd2hpbGUgYSBncmVhdGVyIHZhbHVlIGxpa2UgNjAgbG9va3MgYWhlYWQgdG93YXJkcyB0aGUgaG9yaXpvbi4gVGhlIHN0eWxlIHBpdGNoIHdpbGwgYmUgdXNlZCBvbmx5IGlmIHRoZSBtYXAgaGFzIG5vdCBiZWVuIHBvc2l0aW9uZWQgYnkgb3RoZXIgbWVhbnMgKGUuZy4gbWFwIG9wdGlvbnMgb3IgdXNlciBpbnRlcmFjdGlvbikuXCIsXG4gICAgZXhhbXBsZTogNTBcbiAgfSxcbiAgbGlnaHQ6IHtcbiAgICB0eXBlOiBcImxpZ2h0XCIsXG4gICAgZG9jOiBcIlRoZSBnbG9iYWwgbGlnaHQgc291cmNlLlwiLFxuICAgIGV4YW1wbGU6IHtcbiAgICAgIGFuY2hvcjogXCJ2aWV3cG9ydFwiLFxuICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgIGludGVuc2l0eTogMC40XG4gICAgfVxuICB9LFxuICB0ZXJyYWluOiB7XG4gICAgdHlwZTogXCJ0ZXJyYWluXCIsXG4gICAgZG9jOiBcIkEgZ2xvYmFsIG1vZGlmaWVyIHRoYXQgZWxldmF0ZXMgbGF5ZXJzIGFuZCBtYXJrZXJzIGJhc2VkIG9uIGEgREVNIGRhdGEgc291cmNlLlwiXG4gIH0sXG4gIGZvZzoge1xuICAgIHR5cGU6IFwiZm9nXCIsXG4gICAgZG9jOiBcIkEgZ2xvYmFsIGVmZmVjdCB0aGF0IGZhZGVzIGxheWVycyBhbmQgbWFya2VycyBiYXNlZCBvbiB0aGVpciBkaXN0YW5jZSB0byB0aGUgY2FtZXJhLiBUaGUgZm9nIGNhbiBiZSB1c2VkIHRvIGFwcHJveGltYXRlIHRoZSBlZmZlY3Qgb2YgYXRtb3NwaGVyZSBvbiBkaXN0YW50IG9iamVjdHMgYW5kIGVuaGFuY2UgdGhlIGRlcHRoIHBlcmNlcHRpb24gb2YgdGhlIG1hcCB3aGVuIHVzZWQgd2l0aCB0ZXJyYWluIG9yIDNEIGZlYXR1cmVzLlwiXG4gIH0sXG4gIHNvdXJjZXM6IHtcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB0eXBlOiBcInNvdXJjZXNcIixcbiAgICBkb2M6IFwiRGF0YSBzb3VyY2Ugc3BlY2lmaWNhdGlvbnMuXCIsXG4gICAgZXhhbXBsZToge1xuICAgICAgXCJtYXBib3gtc3RyZWV0c1wiOiB7XG4gICAgICAgIHR5cGU6IFwidmVjdG9yXCIsXG4gICAgICAgIHVybDogXCJtYXBib3g6Ly9tYXBib3gubWFwYm94LXN0cmVldHMtdjZcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc3ByaXRlOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkb2M6IFwiQSBiYXNlIFVSTCBmb3IgcmV0cmlldmluZyB0aGUgc3ByaXRlIGltYWdlIGFuZCBtZXRhZGF0YS4gVGhlIGV4dGVuc2lvbnMgYC5wbmdgLCBgLmpzb25gIGFuZCBzY2FsZSBmYWN0b3IgYEAyeC5wbmdgIHdpbGwgYmUgYXV0b21hdGljYWxseSBhcHBlbmRlZC4gVGhpcyBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpZiBhbnkgbGF5ZXIgdXNlcyB0aGUgYGJhY2tncm91bmQtcGF0dGVybmAsIGBmaWxsLXBhdHRlcm5gLCBgbGluZS1wYXR0ZXJuYCwgYGZpbGwtZXh0cnVzaW9uLXBhdHRlcm5gLCBvciBgaWNvbi1pbWFnZWAgcHJvcGVydGllcy4gVGhlIFVSTCBtdXN0IGJlIGFic29sdXRlLCBjb250YWluaW5nIHRoZSBbc2NoZW1lLCBhdXRob3JpdHkgYW5kIHBhdGggY29tcG9uZW50c10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVJMI1N5bnRheCkuXCIsXG4gICAgZXhhbXBsZTogXCJtYXBib3g6Ly9zcHJpdGVzL21hcGJveC9icmlnaHQtdjhcIlxuICB9LFxuICBnbHlwaHM6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJBIFVSTCB0ZW1wbGF0ZSBmb3IgbG9hZGluZyBzaWduZWQtZGlzdGFuY2UtZmllbGQgZ2x5cGggc2V0cyBpbiBQQkYgZm9ybWF0LiBUaGUgVVJMIG11c3QgaW5jbHVkZSBge2ZvbnRzdGFja31gIGFuZCBge3JhbmdlfWAgdG9rZW5zLiBUaGlzIHByb3BlcnR5IGlzIHJlcXVpcmVkIGlmIGFueSBsYXllciB1c2VzIHRoZSBgdGV4dC1maWVsZGAgbGF5b3V0IHByb3BlcnR5LiBUaGUgVVJMIG11c3QgYmUgYWJzb2x1dGUsIGNvbnRhaW5pbmcgdGhlIFtzY2hlbWUsIGF1dGhvcml0eSBhbmQgcGF0aCBjb21wb25lbnRzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VUkwjU3ludGF4KS5cIixcbiAgICBleGFtcGxlOiBcIm1hcGJveDovL2ZvbnRzL21hcGJveC97Zm9udHN0YWNrfS97cmFuZ2V9LnBiZlwiXG4gIH0sXG4gIHRyYW5zaXRpb246IHtcbiAgICB0eXBlOiBcInRyYW5zaXRpb25cIixcbiAgICBkb2M6IFwiQSBnbG9iYWwgdHJhbnNpdGlvbiBkZWZpbml0aW9uIHRvIHVzZSBhcyBhIGRlZmF1bHQgYWNyb3NzIHByb3BlcnRpZXMsIHRvIGJlIHVzZWQgZm9yIHRpbWluZyB0cmFuc2l0aW9ucyBiZXR3ZWVuIG9uZSB2YWx1ZSBhbmQgdGhlIG5leHQgd2hlbiBubyBwcm9wZXJ0eS1zcGVjaWZpYyB0cmFuc2l0aW9uIGlzIHNldC4gQ29sbGlzaW9uLWJhc2VkIHN5bWJvbCBmYWRpbmcgaXMgY29udHJvbGxlZCBpbmRlcGVuZGVudGx5IG9mIHRoZSBzdHlsZSdzIGB0cmFuc2l0aW9uYCBwcm9wZXJ0eS5cIixcbiAgICBleGFtcGxlOiB7XG4gICAgICBkdXJhdGlvbjogMzAwLFxuICAgICAgZGVsYXk6IDBcbiAgICB9XG4gIH0sXG4gIGxheWVyczoge1xuICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJsYXllclwiLFxuICAgIGRvYzogXCJMYXllcnMgd2lsbCBiZSBkcmF3biBpbiB0aGUgb3JkZXIgb2YgdGhpcyBhcnJheS5cIixcbiAgICBleGFtcGxlOiBbe1xuICAgICAgaWQ6IFwid2F0ZXJcIixcbiAgICAgIHNvdXJjZTogXCJtYXBib3gtc3RyZWV0c1wiLFxuICAgICAgXCJzb3VyY2UtbGF5ZXJcIjogXCJ3YXRlclwiLFxuICAgICAgdHlwZTogXCJmaWxsXCIsXG4gICAgICBwYWludDoge1xuICAgICAgICBcImZpbGwtY29sb3JcIjogXCIjMDBmZmZmXCJcbiAgICAgIH1cbiAgICB9XVxuICB9XG59O1xudmFyIHNvdXJjZXMgPSB7XG4gIFwiKlwiOiB7XG4gICAgdHlwZTogXCJzb3VyY2VcIixcbiAgICBkb2M6IFwiU3BlY2lmaWNhdGlvbiBvZiBhIGRhdGEgc291cmNlLiBGb3IgdmVjdG9yIGFuZCByYXN0ZXIgc291cmNlcywgZWl0aGVyIFRpbGVKU09OIG9yIGEgVVJMIHRvIGEgVGlsZUpTT04gbXVzdCBiZSBwcm92aWRlZC4gRm9yIGltYWdlIGFuZCB2aWRlbyBzb3VyY2VzLCBhIFVSTCBtdXN0IGJlIHByb3ZpZGVkLiBGb3IgR2VvSlNPTiBzb3VyY2VzLCBhIFVSTCBvciBpbmxpbmUgR2VvSlNPTiBtdXN0IGJlIHByb3ZpZGVkLlwiXG4gIH1cbn07XG52YXIgc291cmNlID0gW1wic291cmNlX3ZlY3RvclwiLCBcInNvdXJjZV9yYXN0ZXJcIiwgXCJzb3VyY2VfcmFzdGVyX2RlbVwiLCBcInNvdXJjZV9nZW9qc29uXCIsIFwic291cmNlX3ZpZGVvXCIsIFwic291cmNlX2ltYWdlXCJdO1xudmFyIHNvdXJjZV92ZWN0b3IgPSB7XG4gIHR5cGU6IHtcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZlY3Rvcjoge1xuICAgICAgICBkb2M6IFwiQSB2ZWN0b3IgdGlsZSBzb3VyY2UuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvYzogXCJUaGUgdHlwZSBvZiB0aGUgc291cmNlLlwiXG4gIH0sXG4gIHVybDoge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkEgVVJMIHRvIGEgVGlsZUpTT04gcmVzb3VyY2UuIFN1cHBvcnRlZCBwcm90b2NvbHMgYXJlIGBodHRwOmAsIGBodHRwczpgLCBhbmQgYG1hcGJveDovLzxUaWxlc2V0IElEPmAuXCJcbiAgfSxcbiAgdGlsZXM6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkFuIGFycmF5IG9mIG9uZSBvciBtb3JlIHRpbGUgc291cmNlIFVSTHMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG4gIH0sXG4gIGJvdW5kczoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDQsXG4gICAgXCJkZWZhdWx0XCI6IFstMTgwLCAtODUuMDUxMTI5LCAxODAsIDg1LjA1MTEyOV0sXG4gICAgZG9jOiBcIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC5cIlxuICB9LFxuICBzY2hlbWU6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHh5ejoge1xuICAgICAgICBkb2M6IFwiU2xpcHB5IG1hcCB0aWxlbmFtZXMgc2NoZW1lLlwiXG4gICAgICB9LFxuICAgICAgdG1zOiB7XG4gICAgICAgIGRvYzogXCJPU0dlbyBzcGVjIHNjaGVtZS5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwieHl6XCIsXG4gICAgZG9jOiBcIkluZmx1ZW5jZXMgdGhlIHkgZGlyZWN0aW9uIG9mIHRoZSB0aWxlIGNvb3JkaW5hdGVzLiBUaGUgZ2xvYmFsLW1lcmNhdG9yIChha2EgU3BoZXJpY2FsIE1lcmNhdG9yKSBwcm9maWxlIGlzIGFzc3VtZWQuXCJcbiAgfSxcbiAgbWluem9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgZG9jOiBcIk1pbmltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuXCJcbiAgfSxcbiAgbWF4em9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDIyLFxuICAgIGRvYzogXCJNYXhpbXVtIHpvb20gbGV2ZWwgZm9yIHdoaWNoIHRpbGVzIGFyZSBhdmFpbGFibGUsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLiBEYXRhIGZyb20gdGlsZXMgYXQgdGhlIG1heHpvb20gYXJlIHVzZWQgd2hlbiBkaXNwbGF5aW5nIHRoZSBtYXAgYXQgaGlnaGVyIHpvb20gbGV2ZWxzLlwiXG4gIH0sXG4gIGF0dHJpYnV0aW9uOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkb2M6IFwiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuXCJcbiAgfSxcbiAgcHJvbW90ZUlkOiB7XG4gICAgdHlwZTogXCJwcm9tb3RlSWRcIixcbiAgICBkb2M6IFwiQSBwcm9wZXJ0eSB0byB1c2UgYXMgYSBmZWF0dXJlIGlkIChmb3IgZmVhdHVyZSBzdGF0ZSkuIEVpdGhlciBhIHByb3BlcnR5IG5hbWUsIG9yIGFuIG9iamVjdCBvZiB0aGUgZm9ybSBgezxzb3VyY2VMYXllcj46IDxwcm9wZXJ0eU5hbWU+fWAuIElmIHNwZWNpZmllZCBhcyBhIHN0cmluZyBmb3IgYSB2ZWN0b3IgdGlsZSBzb3VyY2UsIHRoZSBzYW1lIHByb3BlcnR5IGlzIHVzZWQgYWNyb3NzIGFsbCBpdHMgc291cmNlIGxheWVycy5cIlxuICB9LFxuICB2b2xhdGlsZToge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICBkb2M6IFwiQSBzZXR0aW5nIHRvIGRldGVybWluZSB3aGV0aGVyIGEgc291cmNlJ3MgdGlsZXMgYXJlIGNhY2hlZCBsb2NhbGx5LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgYW5kcm9pZDogXCI5LjMuMFwiLFxuICAgICAgICBpb3M6IFwiNS4xMC4wXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiKlwiOiB7XG4gICAgdHlwZTogXCIqXCIsXG4gICAgZG9jOiBcIk90aGVyIGtleXMgdG8gY29uZmlndXJlIHRoZSBkYXRhIHNvdXJjZS5cIlxuICB9XG59O1xudmFyIHNvdXJjZV9yYXN0ZXIgPSB7XG4gIHR5cGU6IHtcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHJhc3Rlcjoge1xuICAgICAgICBkb2M6IFwiQSByYXN0ZXIgdGlsZSBzb3VyY2UuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvYzogXCJUaGUgdHlwZSBvZiB0aGUgc291cmNlLlwiXG4gIH0sXG4gIHVybDoge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkEgVVJMIHRvIGEgVGlsZUpTT04gcmVzb3VyY2UuIFN1cHBvcnRlZCBwcm90b2NvbHMgYXJlIGBodHRwOmAsIGBodHRwczpgLCBhbmQgYG1hcGJveDovLzxUaWxlc2V0IElEPmAuXCJcbiAgfSxcbiAgdGlsZXM6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkFuIGFycmF5IG9mIG9uZSBvciBtb3JlIHRpbGUgc291cmNlIFVSTHMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG4gIH0sXG4gIGJvdW5kczoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDQsXG4gICAgXCJkZWZhdWx0XCI6IFstMTgwLCAtODUuMDUxMTI5LCAxODAsIDg1LjA1MTEyOV0sXG4gICAgZG9jOiBcIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC5cIlxuICB9LFxuICBtaW56b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBkb2M6IFwiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuICB9LFxuICBtYXh6b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMjIsXG4gICAgZG9jOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcbiAgfSxcbiAgdGlsZVNpemU6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiA1MTIsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG4gIH0sXG4gIHNjaGVtZToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgeHl6OiB7XG4gICAgICAgIGRvYzogXCJTbGlwcHkgbWFwIHRpbGVuYW1lcyBzY2hlbWUuXCJcbiAgICAgIH0sXG4gICAgICB0bXM6IHtcbiAgICAgICAgZG9jOiBcIk9TR2VvIHNwZWMgc2NoZW1lLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJ4eXpcIixcbiAgICBkb2M6IFwiSW5mbHVlbmNlcyB0aGUgeSBkaXJlY3Rpb24gb2YgdGhlIHRpbGUgY29vcmRpbmF0ZXMuIFRoZSBnbG9iYWwtbWVyY2F0b3IgKGFrYSBTcGhlcmljYWwgTWVyY2F0b3IpIHByb2ZpbGUgaXMgYXNzdW1lZC5cIlxuICB9LFxuICBhdHRyaWJ1dGlvbjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkNvbnRhaW5zIGFuIGF0dHJpYnV0aW9uIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZSBtYXAgaXMgc2hvd24gdG8gYSB1c2VyLlwiXG4gIH0sXG4gIHZvbGF0aWxlOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgIGRvYzogXCJBIHNldHRpbmcgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBzb3VyY2UncyB0aWxlcyBhcmUgY2FjaGVkIGxvY2FsbHkuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBhbmRyb2lkOiBcIjkuMy4wXCIsXG4gICAgICAgIGlvczogXCI1LjEwLjBcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCIqXCI6IHtcbiAgICB0eXBlOiBcIipcIixcbiAgICBkb2M6IFwiT3RoZXIga2V5cyB0byBjb25maWd1cmUgdGhlIGRhdGEgc291cmNlLlwiXG4gIH1cbn07XG52YXIgc291cmNlX3Jhc3Rlcl9kZW0gPSB7XG4gIHR5cGU6IHtcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIFwicmFzdGVyLWRlbVwiOiB7XG4gICAgICAgIGRvYzogXCJBIFJHQi1lbmNvZGVkIHJhc3RlciBERU0gc291cmNlXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGRvYzogXCJUaGUgdHlwZSBvZiB0aGUgc291cmNlLlwiXG4gIH0sXG4gIHVybDoge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkEgVVJMIHRvIGEgVGlsZUpTT04gcmVzb3VyY2UuIFN1cHBvcnRlZCBwcm90b2NvbHMgYXJlIGBodHRwOmAsIGBodHRwczpgLCBhbmQgYG1hcGJveDovLzxUaWxlc2V0IElEPmAuXCJcbiAgfSxcbiAgdGlsZXM6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkFuIGFycmF5IG9mIG9uZSBvciBtb3JlIHRpbGUgc291cmNlIFVSTHMsIGFzIGluIHRoZSBUaWxlSlNPTiBzcGVjLlwiXG4gIH0sXG4gIGJvdW5kczoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDQsXG4gICAgXCJkZWZhdWx0XCI6IFstMTgwLCAtODUuMDUxMTI5LCAxODAsIDg1LjA1MTEyOV0sXG4gICAgZG9jOiBcIkFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgb2YgdGhlIHNvdXRod2VzdCBhbmQgbm9ydGhlYXN0IGNvcm5lcnMgb2YgdGhlIHNvdXJjZSdzIGJvdW5kaW5nIGJveCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBgW3N3LmxuZywgc3cubGF0LCBuZS5sbmcsIG5lLmxhdF1gLiBXaGVuIHRoaXMgcHJvcGVydHkgaXMgaW5jbHVkZWQgaW4gYSBzb3VyY2UsIG5vIHRpbGVzIG91dHNpZGUgb2YgdGhlIGdpdmVuIGJvdW5kcyBhcmUgcmVxdWVzdGVkIGJ5IE1hcGJveCBHTC5cIlxuICB9LFxuICBtaW56b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBkb2M6IFwiTWluaW11bSB6b29tIGxldmVsIGZvciB3aGljaCB0aWxlcyBhcmUgYXZhaWxhYmxlLCBhcyBpbiB0aGUgVGlsZUpTT04gc3BlYy5cIlxuICB9LFxuICBtYXh6b29tOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMjIsXG4gICAgZG9jOiBcIk1heGltdW0gem9vbSBsZXZlbCBmb3Igd2hpY2ggdGlsZXMgYXJlIGF2YWlsYWJsZSwgYXMgaW4gdGhlIFRpbGVKU09OIHNwZWMuIERhdGEgZnJvbSB0aWxlcyBhdCB0aGUgbWF4em9vbSBhcmUgdXNlZCB3aGVuIGRpc3BsYXlpbmcgdGhlIG1hcCBhdCBoaWdoZXIgem9vbSBsZXZlbHMuXCJcbiAgfSxcbiAgdGlsZVNpemU6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiA1MTIsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIlRoZSBtaW5pbXVtIHZpc3VhbCBzaXplIHRvIGRpc3BsYXkgdGlsZXMgZm9yIHRoaXMgbGF5ZXIuIE9ubHkgY29uZmlndXJhYmxlIGZvciByYXN0ZXIgbGF5ZXJzLlwiXG4gIH0sXG4gIGF0dHJpYnV0aW9uOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkb2M6IFwiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuXCJcbiAgfSxcbiAgZW5jb2Rpbmc6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHRlcnJhcml1bToge1xuICAgICAgICBkb2M6IFwiVGVycmFyaXVtIGZvcm1hdCBQTkcgdGlsZXMuIFNlZSBodHRwczovL2F3cy5hbWF6b24uY29tL2VzL3B1YmxpYy1kYXRhc2V0cy90ZXJyYWluLyBmb3IgbW9yZSBpbmZvLlwiXG4gICAgICB9LFxuICAgICAgbWFwYm94OiB7XG4gICAgICAgIGRvYzogXCJNYXBib3ggVGVycmFpbiBSR0IgdGlsZXMuIFNlZSBodHRwczovL3d3dy5tYXBib3guY29tL2hlbHAvYWNjZXNzLWVsZXZhdGlvbi1kYXRhLyNtYXBib3gtdGVycmFpbi1yZ2IgZm9yIG1vcmUgaW5mby5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwibWFwYm94XCIsXG4gICAgZG9jOiBcIlRoZSBlbmNvZGluZyB1c2VkIGJ5IHRoaXMgc291cmNlLiBNYXBib3ggVGVycmFpbiBSR0IgaXMgdXNlZCBieSBkZWZhdWx0XCJcbiAgfSxcbiAgdm9sYXRpbGU6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgZG9jOiBcIkEgc2V0dGluZyB0byBkZXRlcm1pbmUgd2hldGhlciBhIHNvdXJjZSdzIHRpbGVzIGFyZSBjYWNoZWQgbG9jYWxseS5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGFuZHJvaWQ6IFwiOS4zLjBcIixcbiAgICAgICAgaW9zOiBcIjUuMTAuMFwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcIipcIjoge1xuICAgIHR5cGU6IFwiKlwiLFxuICAgIGRvYzogXCJPdGhlciBrZXlzIHRvIGNvbmZpZ3VyZSB0aGUgZGF0YSBzb3VyY2UuXCJcbiAgfVxufTtcbnZhciBzb3VyY2VfZ2VvanNvbiA9IHtcbiAgdHlwZToge1xuICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgZ2VvanNvbjoge1xuICAgICAgICBkb2M6IFwiQSBHZW9KU09OIGRhdGEgc291cmNlLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBkb2M6IFwiVGhlIGRhdGEgdHlwZSBvZiB0aGUgR2VvSlNPTiBzb3VyY2UuXCJcbiAgfSxcbiAgZGF0YToge1xuICAgIHR5cGU6IFwiKlwiLFxuICAgIGRvYzogXCJBIFVSTCB0byBhIEdlb0pTT04gZmlsZSwgb3IgaW5saW5lIEdlb0pTT04uXCJcbiAgfSxcbiAgbWF4em9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDE4LFxuICAgIGRvYzogXCJNYXhpbXVtIHpvb20gbGV2ZWwgYXQgd2hpY2ggdG8gY3JlYXRlIHZlY3RvciB0aWxlcyAoaGlnaGVyIG1lYW5zIGdyZWF0ZXIgZGV0YWlsIGF0IGhpZ2ggem9vbSBsZXZlbHMpLlwiXG4gIH0sXG4gIGF0dHJpYnV0aW9uOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkb2M6IFwiQ29udGFpbnMgYW4gYXR0cmlidXRpb24gdG8gYmUgZGlzcGxheWVkIHdoZW4gdGhlIG1hcCBpcyBzaG93biB0byBhIHVzZXIuXCJcbiAgfSxcbiAgYnVmZmVyOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMTI4LFxuICAgIG1heGltdW06IDUxMixcbiAgICBtaW5pbXVtOiAwLFxuICAgIGRvYzogXCJTaXplIG9mIHRoZSB0aWxlIGJ1ZmZlciBvbiBlYWNoIHNpZGUuIEEgdmFsdWUgb2YgMCBwcm9kdWNlcyBubyBidWZmZXIuIEEgdmFsdWUgb2YgNTEyIHByb2R1Y2VzIGEgYnVmZmVyIGFzIHdpZGUgYXMgdGhlIHRpbGUgaXRzZWxmLiBMYXJnZXIgdmFsdWVzIHByb2R1Y2UgZmV3ZXIgcmVuZGVyaW5nIGFydGlmYWN0cyBuZWFyIHRpbGUgZWRnZXMgYW5kIHNsb3dlciBwZXJmb3JtYW5jZS5cIlxuICB9LFxuICBmaWx0ZXI6IHtcbiAgICB0eXBlOiBcIipcIixcbiAgICBkb2M6IFwiQW4gZXhwcmVzc2lvbiBmb3IgZmlsdGVyaW5nIGZlYXR1cmVzIHByaW9yIHRvIHByb2Nlc3NpbmcgdGhlbSBmb3IgcmVuZGVyaW5nLlwiXG4gIH0sXG4gIHRvbGVyYW5jZToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAuMzc1LFxuICAgIGRvYzogXCJEb3VnbGFzLVBldWNrZXIgc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlIChoaWdoZXIgbWVhbnMgc2ltcGxlciBnZW9tZXRyaWVzIGFuZCBmYXN0ZXIgcGVyZm9ybWFuY2UpLlwiXG4gIH0sXG4gIGNsdXN0ZXI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgZG9jOiBcIklmIHRoZSBkYXRhIGlzIGEgY29sbGVjdGlvbiBvZiBwb2ludCBmZWF0dXJlcywgc2V0dGluZyB0aGlzIHRvIHRydWUgY2x1c3RlcnMgdGhlIHBvaW50cyBieSByYWRpdXMgaW50byBncm91cHMuIENsdXN0ZXIgZ3JvdXBzIGJlY29tZSBuZXcgYFBvaW50YCBmZWF0dXJlcyBpbiB0aGUgc291cmNlIHdpdGggYWRkaXRpb25hbCBwcm9wZXJ0aWVzOlxcbiAqIGBjbHVzdGVyYCBJcyBgdHJ1ZWAgaWYgdGhlIHBvaW50IGlzIGEgY2x1c3RlciBcXG4gKiBgY2x1c3Rlcl9pZGAgQSB1bnFpdWUgaWQgZm9yIHRoZSBjbHVzdGVyIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgW2NsdXN0ZXIgaW5zcGVjdGlvbiBtZXRob2RzXShodHRwczovL3d3dy5tYXBib3guY29tL21hcGJveC1nbC1qcy9hcGkvI2dlb2pzb25zb3VyY2UjZ2V0Y2x1c3RlcmV4cGFuc2lvbnpvb20pXFxuICogYHBvaW50X2NvdW50YCBOdW1iZXIgb2Ygb3JpZ2luYWwgcG9pbnRzIGdyb3VwZWQgaW50byB0aGlzIGNsdXN0ZXJcXG4gKiBgcG9pbnRfY291bnRfYWJicmV2aWF0ZWRgIEFuIGFiYnJldmlhdGVkIHBvaW50IGNvdW50XCJcbiAgfSxcbiAgY2x1c3RlclJhZGl1czoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDUwLFxuICAgIG1pbmltdW06IDAsXG4gICAgZG9jOiBcIlJhZGl1cyBvZiBlYWNoIGNsdXN0ZXIgaWYgY2x1c3RlcmluZyBpcyBlbmFibGVkLiBBIHZhbHVlIG9mIDUxMiBpbmRpY2F0ZXMgYSByYWRpdXMgZXF1YWwgdG8gdGhlIHdpZHRoIG9mIGEgdGlsZS5cIlxuICB9LFxuICBjbHVzdGVyTWF4Wm9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZG9jOiBcIk1heCB6b29tIG9uIHdoaWNoIHRvIGNsdXN0ZXIgcG9pbnRzIGlmIGNsdXN0ZXJpbmcgaXMgZW5hYmxlZC4gRGVmYXVsdHMgdG8gb25lIHpvb20gbGVzcyB0aGFuIG1heHpvb20gKHNvIHRoYXQgbGFzdCB6b29tIGZlYXR1cmVzIGFyZSBub3QgY2x1c3RlcmVkKS4gQ2x1c3RlcnMgYXJlIHJlLWV2YWx1YXRlZCBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzIHNvIHNldHRpbmcgY2x1c3Rlck1heFpvb20gdG8gMTQgbWVhbnMgdGhlIGNsdXN0ZXJzIHdpbGwgYmUgZGlzcGxheWVkIHVudGlsIHoxNS5cIlxuICB9LFxuICBjbHVzdGVyTWluUG9pbnRzOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiTWluaW11bSBudW1iZXIgb2YgcG9pbnRzIG5lY2Vzc2FyeSB0byBmb3JtIGEgY2x1c3RlciBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQuIERlZmF1bHRzIHRvIGAyYC5cIlxuICB9LFxuICBjbHVzdGVyUHJvcGVydGllczoge1xuICAgIHR5cGU6IFwiKlwiLFxuICAgIGRvYzogXCJBbiBvYmplY3QgZGVmaW5pbmcgY3VzdG9tIHByb3BlcnRpZXMgb24gdGhlIGdlbmVyYXRlZCBjbHVzdGVycyBpZiBjbHVzdGVyaW5nIGlzIGVuYWJsZWQsIGFnZ3JlZ2F0aW5nIHZhbHVlcyBmcm9tIGNsdXN0ZXJlZCBwb2ludHMuIEhhcyB0aGUgZm9ybSBge1xcXCJwcm9wZXJ0eV9uYW1lXFxcIjogW29wZXJhdG9yLCBtYXBfZXhwcmVzc2lvbl19YC4gYG9wZXJhdG9yYCBpcyBhbnkgZXhwcmVzc2lvbiBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXQgbGVhc3QgMiBvcGVyYW5kcyAoZS5nLiBgXFxcIitcXFwiYCBvciBgXFxcIm1heFxcXCJgKSDigJQgaXQgYWNjdW11bGF0ZXMgdGhlIHByb3BlcnR5IHZhbHVlIGZyb20gY2x1c3RlcnMvcG9pbnRzIHRoZSBjbHVzdGVyIGNvbnRhaW5zOyBgbWFwX2V4cHJlc3Npb25gIHByb2R1Y2VzIHRoZSB2YWx1ZSBvZiBhIHNpbmdsZSBwb2ludC5cXG5cXG5FeGFtcGxlOiBge1xcXCJzdW1cXFwiOiBbXFxcIitcXFwiLCBbXFxcImdldFxcXCIsIFxcXCJzY2FsZXJhbmtcXFwiXV19YC5cXG5cXG5Gb3IgbW9yZSBhZHZhbmNlZCB1c2UgY2FzZXMsIGluIHBsYWNlIG9mIGBvcGVyYXRvcmAsIHlvdSBjYW4gdXNlIGEgY3VzdG9tIHJlZHVjZSBleHByZXNzaW9uIHRoYXQgcmVmZXJlbmNlcyBhIHNwZWNpYWwgYFtcXFwiYWNjdW11bGF0ZWRcXFwiXWAgdmFsdWUsIGUuZy46XFxuYHtcXFwic3VtXFxcIjogW1tcXFwiK1xcXCIsIFtcXFwiYWNjdW11bGF0ZWRcXFwiXSwgW1xcXCJnZXRcXFwiLCBcXFwic3VtXFxcIl1dLCBbXFxcImdldFxcXCIsIFxcXCJzY2FsZXJhbmtcXFwiXV19YFwiXG4gIH0sXG4gIGxpbmVNZXRyaWNzOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgIGRvYzogXCJXaGV0aGVyIHRvIGNhbGN1bGF0ZSBsaW5lIGRpc3RhbmNlIG1ldHJpY3MuIFRoaXMgaXMgcmVxdWlyZWQgZm9yIGxpbmUgbGF5ZXJzIHRoYXQgc3BlY2lmeSBgbGluZS1ncmFkaWVudGAgdmFsdWVzLlwiXG4gIH0sXG4gIGdlbmVyYXRlSWQ6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgZG9jOiBcIldoZXRoZXIgdG8gZ2VuZXJhdGUgaWRzIGZvciB0aGUgZ2VvanNvbiBmZWF0dXJlcy4gV2hlbiBlbmFibGVkLCB0aGUgYGZlYXR1cmUuaWRgIHByb3BlcnR5IHdpbGwgYmUgYXV0byBhc3NpZ25lZCBiYXNlZCBvbiBpdHMgaW5kZXggaW4gdGhlIGBmZWF0dXJlc2AgYXJyYXksIG92ZXItd3JpdGluZyBhbnkgcHJldmlvdXMgdmFsdWVzLlwiXG4gIH0sXG4gIHByb21vdGVJZDoge1xuICAgIHR5cGU6IFwicHJvbW90ZUlkXCIsXG4gICAgZG9jOiBcIkEgcHJvcGVydHkgdG8gdXNlIGFzIGEgZmVhdHVyZSBpZCAoZm9yIGZlYXR1cmUgc3RhdGUpLiBFaXRoZXIgYSBwcm9wZXJ0eSBuYW1lLCBvciBhbiBvYmplY3Qgb2YgdGhlIGZvcm0gYHs8c291cmNlTGF5ZXI+OiA8cHJvcGVydHlOYW1lPn1gLlwiXG4gIH1cbn07XG52YXIgc291cmNlX3ZpZGVvID0ge1xuICB0eXBlOiB7XG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aWRlbzoge1xuICAgICAgICBkb2M6IFwiQSB2aWRlbyBkYXRhIHNvdXJjZS5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgZG9jOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIHZpZGVvIHNvdXJjZS5cIlxuICB9LFxuICB1cmxzOiB7XG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJVUkxzIHRvIHZpZGVvIGNvbnRlbnQgaW4gb3JkZXIgb2YgcHJlZmVycmVkIGZvcm1hdC5cIlxuICB9LFxuICBjb29yZGluYXRlczoge1xuICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgIGRvYzogXCJDb3JuZXJzIG9mIHZpZGVvIHNwZWNpZmllZCBpbiBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXJzLlwiLFxuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBsZW5ndGg6IDQsXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGxlbmd0aDogMixcbiAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgZG9jOiBcIkEgc2luZ2xlIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcGFpci5cIlxuICAgIH1cbiAgfVxufTtcbnZhciBzb3VyY2VfaW1hZ2UgPSB7XG4gIHR5cGU6IHtcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGltYWdlOiB7XG4gICAgICAgIGRvYzogXCJBbiBpbWFnZSBkYXRhIHNvdXJjZS5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgZG9jOiBcIlRoZSBkYXRhIHR5cGUgb2YgdGhlIGltYWdlIHNvdXJjZS5cIlxuICB9LFxuICB1cmw6IHtcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJVUkwgdGhhdCBwb2ludHMgdG8gYW4gaW1hZ2UuXCJcbiAgfSxcbiAgY29vcmRpbmF0ZXM6IHtcbiAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICBkb2M6IFwiQ29ybmVycyBvZiBpbWFnZSBzcGVjaWZpZWQgaW4gbG9uZ2l0dWRlLCBsYXRpdHVkZSBwYWlycy5cIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgbGVuZ3RoOiA0LFxuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBsZW5ndGg6IDIsXG4gICAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICAgIGRvYzogXCJBIHNpbmdsZSBsb25naXR1ZGUsIGxhdGl0dWRlIHBhaXIuXCJcbiAgICB9XG4gIH1cbn07XG52YXIgbGF5ZXIgPSB7XG4gIGlkOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkb2M6IFwiVW5pcXVlIGxheWVyIG5hbWUuXCIsXG4gICAgcmVxdWlyZWQ6IHRydWVcbiAgfSxcbiAgdHlwZToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgZmlsbDoge1xuICAgICAgICBkb2M6IFwiQSBmaWxsZWQgcG9seWdvbiB3aXRoIGFuIG9wdGlvbmFsIHN0cm9rZWQgYm9yZGVyLlwiLFxuICAgICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaW5lOiB7XG4gICAgICAgIGRvYzogXCJBIHN0cm9rZWQgbGluZS5cIixcbiAgICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3ltYm9sOiB7XG4gICAgICAgIGRvYzogXCJBbiBpY29uIG9yIGEgdGV4dCBsYWJlbC5cIixcbiAgICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2lyY2xlOiB7XG4gICAgICAgIGRvYzogXCJBIGZpbGxlZCBjaXJjbGUuXCIsXG4gICAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhlYXRtYXA6IHtcbiAgICAgICAgZG9jOiBcIkEgaGVhdG1hcC5cIixcbiAgICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJmaWxsLWV4dHJ1c2lvblwiOiB7XG4gICAgICAgIGRvYzogXCJBbiBleHRydWRlZCAoM0QpIHBvbHlnb24uXCIsXG4gICAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgICAgIGFuZHJvaWQ6IFwiNS4xLjBcIixcbiAgICAgICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJhc3Rlcjoge1xuICAgICAgICBkb2M6IFwiUmFzdGVyIG1hcCB0ZXh0dXJlcyBzdWNoIGFzIHNhdGVsbGl0ZSBpbWFnZXJ5LlwiLFxuICAgICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoaWxsc2hhZGU6IHtcbiAgICAgICAgZG9jOiBcIkNsaWVudC1zaWRlIGhpbGxzaGFkaW5nIHZpc3VhbGl6YXRpb24gYmFzZWQgb24gREVNIGRhdGEuIEN1cnJlbnRseSwgdGhlIGltcGxlbWVudGF0aW9uIG9ubHkgc3VwcG9ydHMgTWFwYm94IFRlcnJhaW4gUkdCIGFuZCBNYXB6ZW4gVGVycmFyaXVtIHRpbGVzLlwiLFxuICAgICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgICAganM6IFwiMC40My4wXCIsXG4gICAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICAgIGRvYzogXCJUaGUgYmFja2dyb3VuZCBjb2xvciBvciBwYXR0ZXJuIG9mIHRoZSBtYXAuXCIsXG4gICAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNreToge1xuICAgICAgICBkb2M6IFwiQSBzcGhlcmljYWwgZG9tZSBhcm91bmQgdGhlIG1hcCB0aGF0IGlzIGFsd2F5cyByZW5kZXJlZCBiZWhpbmQgYWxsIG90aGVyIGxheWVycy5cIixcbiAgICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICAgIGpzOiBcIjIuMC4wXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRvYzogXCJSZW5kZXJpbmcgdHlwZSBvZiB0aGlzIGxheWVyLlwiLFxuICAgIHJlcXVpcmVkOiB0cnVlXG4gIH0sXG4gIG1ldGFkYXRhOiB7XG4gICAgdHlwZTogXCIqXCIsXG4gICAgZG9jOiBcIkFyYml0cmFyeSBwcm9wZXJ0aWVzIHVzZWZ1bCB0byB0cmFjayB3aXRoIHRoZSBsYXllciwgYnV0IGRvIG5vdCBpbmZsdWVuY2UgcmVuZGVyaW5nLiBQcm9wZXJ0aWVzIHNob3VsZCBiZSBwcmVmaXhlZCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlICdtYXBib3g6Jy5cIlxuICB9LFxuICBzb3VyY2U6IHtcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIGRvYzogXCJOYW1lIG9mIGEgc291cmNlIGRlc2NyaXB0aW9uIHRvIGJlIHVzZWQgZm9yIHRoaXMgbGF5ZXIuIFJlcXVpcmVkIGZvciBhbGwgbGF5ZXIgdHlwZXMgZXhjZXB0IGBiYWNrZ3JvdW5kYC5cIlxuICB9LFxuICBcInNvdXJjZS1sYXllclwiOiB7XG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICBkb2M6IFwiTGF5ZXIgdG8gdXNlIGZyb20gYSB2ZWN0b3IgdGlsZSBzb3VyY2UuIFJlcXVpcmVkIGZvciB2ZWN0b3IgdGlsZSBzb3VyY2VzOyBwcm9oaWJpdGVkIGZvciBhbGwgb3RoZXIgc291cmNlIHR5cGVzLCBpbmNsdWRpbmcgR2VvSlNPTiBzb3VyY2VzLlwiXG4gIH0sXG4gIG1pbnpvb206IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMjQsXG4gICAgZG9jOiBcIlRoZSBtaW5pbXVtIHpvb20gbGV2ZWwgZm9yIHRoZSBsYXllci4gQXQgem9vbSBsZXZlbHMgbGVzcyB0aGFuIHRoZSBtaW56b29tLCB0aGUgbGF5ZXIgd2lsbCBiZSBoaWRkZW4uXCJcbiAgfSxcbiAgbWF4em9vbToge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAyNCxcbiAgICBkb2M6IFwiVGhlIG1heGltdW0gem9vbSBsZXZlbCBmb3IgdGhlIGxheWVyLiBBdCB6b29tIGxldmVscyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gdGhlIG1heHpvb20sIHRoZSBsYXllciB3aWxsIGJlIGhpZGRlbi5cIlxuICB9LFxuICBmaWx0ZXI6IHtcbiAgICB0eXBlOiBcImZpbHRlclwiLFxuICAgIGRvYzogXCJBIGV4cHJlc3Npb24gc3BlY2lmeWluZyBjb25kaXRpb25zIG9uIHNvdXJjZSBmZWF0dXJlcy4gT25seSBmZWF0dXJlcyB0aGF0IG1hdGNoIHRoZSBmaWx0ZXIgYXJlIGRpc3BsYXllZC4gWm9vbSBleHByZXNzaW9ucyBpbiBmaWx0ZXJzIGFyZSBvbmx5IGV2YWx1YXRlZCBhdCBpbnRlZ2VyIHpvb20gbGV2ZWxzLiBUaGUgYGZlYXR1cmUtc3RhdGVgIGV4cHJlc3Npb24gaXMgbm90IHN1cHBvcnRlZCBpbiBmaWx0ZXIgZXhwcmVzc2lvbnMuXCJcbiAgfSxcbiAgbGF5b3V0OiB7XG4gICAgdHlwZTogXCJsYXlvdXRcIixcbiAgICBkb2M6IFwiTGF5b3V0IHByb3BlcnRpZXMgZm9yIHRoZSBsYXllci5cIlxuICB9LFxuICBwYWludDoge1xuICAgIHR5cGU6IFwicGFpbnRcIixcbiAgICBkb2M6IFwiRGVmYXVsdCBwYWludCBwcm9wZXJ0aWVzIGZvciB0aGlzIGxheWVyLlwiXG4gIH1cbn07XG52YXIgbGF5b3V0ID0gW1wibGF5b3V0X2ZpbGxcIiwgXCJsYXlvdXRfbGluZVwiLCBcImxheW91dF9jaXJjbGVcIiwgXCJsYXlvdXRfaGVhdG1hcFwiLCBcImxheW91dF9maWxsLWV4dHJ1c2lvblwiLCBcImxheW91dF9zeW1ib2xcIiwgXCJsYXlvdXRfcmFzdGVyXCIsIFwibGF5b3V0X2hpbGxzaGFkZVwiLCBcImxheW91dF9iYWNrZ3JvdW5kXCIsIFwibGF5b3V0X3NreVwiXTtcbnZhciBsYXlvdXRfYmFja2dyb3VuZCA9IHtcbiAgdmlzaWJpbGl0eToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmlzaWJsZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICB9LFxuICAgICAgbm9uZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgIGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgfVxufTtcbnZhciBsYXlvdXRfc2t5ID0ge1xuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcbiAgICAgIH0sXG4gICAgICBub25lOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIyLjAuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn07XG52YXIgbGF5b3V0X2ZpbGwgPSB7XG4gIFwiZmlsbC1zb3J0LWtleVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiU29ydHMgZmVhdHVyZXMgaW4gYXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoaXMgdmFsdWUuIEZlYXR1cmVzIHdpdGggYSBoaWdoZXIgc29ydCBrZXkgd2lsbCBhcHBlYXIgYWJvdmUgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMS4yLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI5LjEuMFwiLFxuICAgICAgICBpb3M6IFwiNS44LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xNS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIxLjIuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjkuMS4wXCIsXG4gICAgICAgIGlvczogXCI1LjguMFwiLFxuICAgICAgICBtYWNvczogXCIwLjE1LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIHZpc2liaWxpdHk6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuICAgICAgfSxcbiAgICAgIG5vbmU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICBkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn07XG52YXIgbGF5b3V0X2NpcmNsZSA9IHtcbiAgXCJjaXJjbGUtc29ydC1rZXlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZG9jOiBcIlNvcnRzIGZlYXR1cmVzIGluIGFzY2VuZGluZyBvcmRlciBiYXNlZCBvbiB0aGlzIHZhbHVlLiBGZWF0dXJlcyB3aXRoIGEgaGlnaGVyIHNvcnQga2V5IHdpbGwgYXBwZWFyIGFib3ZlIGZlYXR1cmVzIHdpdGggYSBsb3dlciBzb3J0IGtleS5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjEuMi4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiOS4yLjBcIixcbiAgICAgICAgaW9zOiBcIjUuOS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTYuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMS4yLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI5LjIuMFwiLFxuICAgICAgICBpb3M6IFwiNS45LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xNi4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcbiAgICAgIH0sXG4gICAgICBub25lOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICB9XG59O1xudmFyIGxheW91dF9oZWF0bWFwID0ge1xuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcbiAgICAgIH0sXG4gICAgICBub25lOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICB9XG59O1xudmFyIGxheW91dF9saW5lID0ge1xuICBcImxpbmUtY2FwXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGJ1dHQ6IHtcbiAgICAgICAgZG9jOiBcIkEgY2FwIHdpdGggYSBzcXVhcmVkLW9mZiBlbmQgd2hpY2ggaXMgZHJhd24gdG8gdGhlIGV4YWN0IGVuZHBvaW50IG9mIHRoZSBsaW5lLlwiXG4gICAgICB9LFxuICAgICAgcm91bmQ6IHtcbiAgICAgICAgZG9jOiBcIkEgY2FwIHdpdGggYSByb3VuZGVkIGVuZCB3aGljaCBpcyBkcmF3biBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIGF0IGEgcmFkaXVzIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGggYW5kIGNlbnRlcmVkIG9uIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZS5cIlxuICAgICAgfSxcbiAgICAgIHNxdWFyZToge1xuICAgICAgICBkb2M6IFwiQSBjYXAgd2l0aCBhIHNxdWFyZWQtb2ZmIGVuZCB3aGljaCBpcyBkcmF3biBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIGF0IGEgZGlzdGFuY2Ugb2Ygb25lLWhhbGYgb2YgdGhlIGxpbmUncyB3aWR0aC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwiYnV0dFwiLFxuICAgIGRvYzogXCJUaGUgZGlzcGxheSBvZiBsaW5lIGVuZGluZ3MuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjIuMy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtam9pblwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBiZXZlbDoge1xuICAgICAgICBkb2M6IFwiQSBqb2luIHdpdGggYSBzcXVhcmVkLW9mZiBlbmQgd2hpY2ggaXMgZHJhd24gYmV5b25kIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZSBhdCBhIGRpc3RhbmNlIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGguXCJcbiAgICAgIH0sXG4gICAgICByb3VuZDoge1xuICAgICAgICBkb2M6IFwiQSBqb2luIHdpdGggYSByb3VuZGVkIGVuZCB3aGljaCBpcyBkcmF3biBiZXlvbmQgdGhlIGVuZHBvaW50IG9mIHRoZSBsaW5lIGF0IGEgcmFkaXVzIG9mIG9uZS1oYWxmIG9mIHRoZSBsaW5lJ3Mgd2lkdGggYW5kIGNlbnRlcmVkIG9uIHRoZSBlbmRwb2ludCBvZiB0aGUgbGluZS5cIlxuICAgICAgfSxcbiAgICAgIG1pdGVyOiB7XG4gICAgICAgIGRvYzogXCJBIGpvaW4gd2l0aCBhIHNoYXJwLCBhbmdsZWQgY29ybmVyIHdoaWNoIGlzIGRyYXduIHdpdGggdGhlIG91dGVyIHNpZGVzIGJleW9uZCB0aGUgZW5kcG9pbnQgb2YgdGhlIHBhdGggdW50aWwgdGhleSBtZWV0LlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJtaXRlclwiLFxuICAgIGRvYzogXCJUaGUgZGlzcGxheSBvZiBsaW5lcyB3aGVuIGpvaW5pbmcuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuNDAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMi4wXCIsXG4gICAgICAgIGlvczogXCIzLjcuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjYuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLW1pdGVyLWxpbWl0XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAyLFxuICAgIGRvYzogXCJVc2VkIHRvIGF1dG9tYXRpY2FsbHkgY29udmVydCBtaXRlciBqb2lucyB0byBiZXZlbCBqb2lucyBmb3Igc2hhcnAgYW5nbGVzLlwiLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCJsaW5lLWpvaW5cIjogXCJtaXRlclwiXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwibGluZS1yb3VuZC1saW1pdFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMS4wNSxcbiAgICBkb2M6IFwiVXNlZCB0byBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgcm91bmQgam9pbnMgdG8gbWl0ZXIgam9pbnMgZm9yIHNoYWxsb3cgYW5nbGVzLlwiLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCJsaW5lLWpvaW5cIjogXCJyb3VuZFwiXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwibGluZS1zb3J0LWtleVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiU29ydHMgZmVhdHVyZXMgaW4gYXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoaXMgdmFsdWUuIEZlYXR1cmVzIHdpdGggYSBoaWdoZXIgc29ydCBrZXkgd2lsbCBhcHBlYXIgYWJvdmUgZmVhdHVyZXMgd2l0aCBhIGxvd2VyIHNvcnQga2V5LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMS4yLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI5LjEuMFwiLFxuICAgICAgICBpb3M6IFwiNS44LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xNS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIxLjIuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjkuMS4wXCIsXG4gICAgICAgIGlvczogXCI1LjguMFwiLFxuICAgICAgICBtYWNvczogXCIwLjE1LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIHZpc2liaWxpdHk6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuICAgICAgfSxcbiAgICAgIG5vbmU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICBkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn07XG52YXIgbGF5b3V0X3N5bWJvbCA9IHtcbiAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHBvaW50OiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGFiZWwgaXMgcGxhY2VkIGF0IHRoZSBwb2ludCB3aGVyZSB0aGUgZ2VvbWV0cnkgaXMgbG9jYXRlZC5cIlxuICAgICAgfSxcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYWJlbCBpcyBwbGFjZWQgYWxvbmcgdGhlIGxpbmUgb2YgdGhlIGdlb21ldHJ5LiBDYW4gb25seSBiZSB1c2VkIG9uIGBMaW5lU3RyaW5nYCBhbmQgYFBvbHlnb25gIGdlb21ldHJpZXMuXCJcbiAgICAgIH0sXG4gICAgICBcImxpbmUtY2VudGVyXCI6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYWJlbCBpcyBwbGFjZWQgYXQgdGhlIGNlbnRlciBvZiB0aGUgbGluZSBvZiB0aGUgZ2VvbWV0cnkuIENhbiBvbmx5IGJlIHVzZWQgb24gYExpbmVTdHJpbmdgIGFuZCBgUG9seWdvbmAgZ2VvbWV0cmllcy4gTm90ZSB0aGF0IGEgc2luZ2xlIGZlYXR1cmUgaW4gYSB2ZWN0b3IgdGlsZSBtYXkgY29udGFpbiBtdWx0aXBsZSBsaW5lIGdlb21ldHJpZXMuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcInBvaW50XCIsXG4gICAgZG9jOiBcIkxhYmVsIHBsYWNlbWVudCByZWxhdGl2ZSB0byBpdHMgZ2VvbWV0cnkuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiYGxpbmUtY2VudGVyYCB2YWx1ZVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDcuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuNC4wXCIsXG4gICAgICAgIGlvczogXCI0LjMuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEwLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInN5bWJvbC1zcGFjaW5nXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAyNTAsXG4gICAgbWluaW11bTogMSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiRGlzdGFuY2UgYmV0d2VlbiB0d28gc3ltYm9sIGFuY2hvcnMuXCIsXG4gICAgcmVxdWlyZXM6IFt7XG4gICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJsaW5lXCJcbiAgICB9XSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJzeW1ib2wtYXZvaWQtZWRnZXNcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICBkb2M6IFwiSWYgdHJ1ZSwgdGhlIHN5bWJvbHMgd2lsbCBub3QgY3Jvc3MgdGlsZSBlZGdlcyB0byBhdm9pZCBtdXR1YWwgY29sbGlzaW9ucy4gUmVjb21tZW5kZWQgaW4gbGF5ZXJzIHRoYXQgZG9uJ3QgaGF2ZSBlbm91Z2ggcGFkZGluZyBpbiB0aGUgdmVjdG9yIHRpbGUgdG8gcHJldmVudCBjb2xsaXNpb25zLCBvciBpZiBpdCBpcyBhIHBvaW50IHN5bWJvbCBsYXllciBwbGFjZWQgYWZ0ZXIgYSBsaW5lIHN5bWJvbCBsYXllci4gV2hlbiB1c2luZyBhIGNsaWVudCB0aGF0IHN1cHBvcnRzIGdsb2JhbCBjb2xsaXNpb24gZGV0ZWN0aW9uLCBsaWtlIE1hcGJveCBHTCBKUyB2ZXJzaW9uIDAuNDIuMCBvciBncmVhdGVyLCBlbmFibGluZyB0aGlzIHByb3BlcnR5IGlzIG5vdCBuZWVkZWQgdG8gcHJldmVudCBjbGlwcGVkIGxhYmVscyBhdCB0aWxlIGJvdW5kYXJpZXMuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInN5bWJvbC1zb3J0LWtleVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBkb2M6IFwiU29ydHMgZmVhdHVyZXMgaW4gYXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoaXMgdmFsdWUuIEZlYXR1cmVzIHdpdGggbG93ZXIgc29ydCBrZXlzIGFyZSBkcmF3biBhbmQgcGxhY2VkIGZpcnN0LiAgV2hlbiBgaWNvbi1hbGxvdy1vdmVybGFwYCBvciBgdGV4dC1hbGxvdy1vdmVybGFwYCBpcyBgZmFsc2VgLCBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkgd2lsbCBoYXZlIHByaW9yaXR5IGR1cmluZyBwbGFjZW1lbnQuIFdoZW4gYGljb24tYWxsb3ctb3ZlcmxhcGAgb3IgYHRleHQtYWxsb3ctb3ZlcmxhcGAgaXMgc2V0IHRvIGB0cnVlYCwgZmVhdHVyZXMgd2l0aCBhIGhpZ2hlciBzb3J0IGtleSB3aWxsIG92ZXJsYXAgb3ZlciBmZWF0dXJlcyB3aXRoIGEgbG93ZXIgc29ydCBrZXkuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjUzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI3LjQuMFwiLFxuICAgICAgICBpb3M6IFwiNC4xMS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTQuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC41My4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNy40LjBcIixcbiAgICAgICAgaW9zOiBcIjQuMTEuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjE0LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwic3ltYm9sLXotb3JkZXJcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgYXV0bzoge1xuICAgICAgICBkb2M6IFwiU29ydHMgc3ltYm9scyBieSBgc3ltYm9sLXNvcnQta2V5YCBpZiBzZXQuIE90aGVyd2lzZSwgc29ydHMgc3ltYm9scyBieSB0aGVpciB5LXBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCBpZiBgaWNvbi1hbGxvdy1vdmVybGFwYCBvciBgdGV4dC1hbGxvdy1vdmVybGFwYCBpcyBzZXQgdG8gYHRydWVgIG9yIGBpY29uLWlnbm9yZS1wbGFjZW1lbnRgIG9yIGB0ZXh0LWlnbm9yZS1wbGFjZW1lbnRgIGlzIGBmYWxzZWAuXCJcbiAgICAgIH0sXG4gICAgICBcInZpZXdwb3J0LXlcIjoge1xuICAgICAgICBkb2M6IFwiU29ydHMgc3ltYm9scyBieSB0aGVpciB5LXBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCBpZiBgaWNvbi1hbGxvdy1vdmVybGFwYCBvciBgdGV4dC1hbGxvdy1vdmVybGFwYCBpcyBzZXQgdG8gYHRydWVgIG9yIGBpY29uLWlnbm9yZS1wbGFjZW1lbnRgIG9yIGB0ZXh0LWlnbm9yZS1wbGFjZW1lbnRgIGlzIGBmYWxzZWAuXCJcbiAgICAgIH0sXG4gICAgICBzb3VyY2U6IHtcbiAgICAgICAgZG9jOiBcIlNvcnRzIHN5bWJvbHMgYnkgYHN5bWJvbC1zb3J0LWtleWAgaWYgc2V0LiBPdGhlcndpc2UsIG5vIHNvcnRpbmcgaXMgYXBwbGllZDsgc3ltYm9scyBhcmUgcmVuZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHNvdXJjZSBkYXRhLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJhdXRvXCIsXG4gICAgZG9jOiBcIkRldGVybWluZXMgd2hldGhlciBvdmVybGFwcGluZyBzeW1ib2xzIGluIHRoZSBzYW1lIGxheWVyIGFyZSByZW5kZXJlZCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFwcGVhciBpbiB0aGUgZGF0YSBzb3VyY2Ugb3IgYnkgdGhlaXIgeS1wb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuIFRvIGNvbnRyb2wgdGhlIG9yZGVyIGFuZCBwcmlvcml0aXphdGlvbiBvZiBzeW1ib2xzIG90aGVyd2lzZSwgdXNlIGBzeW1ib2wtc29ydC1rZXlgLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40OS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi42LjBcIixcbiAgICAgICAgaW9zOiBcIjQuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTIuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi1hbGxvdy1vdmVybGFwXCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgZG9jOiBcIklmIHRydWUsIHRoZSBpY29uIHdpbGwgYmUgdmlzaWJsZSBldmVuIGlmIGl0IGNvbGxpZGVzIHdpdGggb3RoZXIgcHJldmlvdXNseSBkcmF3biBzeW1ib2xzLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLWlnbm9yZS1wbGFjZW1lbnRcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICBkb2M6IFwiSWYgdHJ1ZSwgb3RoZXIgc3ltYm9scyBjYW4gYmUgdmlzaWJsZSBldmVuIGlmIHRoZXkgY29sbGlkZSB3aXRoIHRoZSBpY29uLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLW9wdGlvbmFsXCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgZG9jOiBcIklmIHRydWUsIHRleHQgd2lsbCBkaXNwbGF5IHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyBpY29ucyB3aGVuIHRoZSBpY29uIGNvbGxpZGVzIHdpdGggb3RoZXIgc3ltYm9scyBhbmQgdGhlIHRleHQgZG9lcyBub3QuXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIiwgXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLXJvdGF0aW9uLWFsaWdubWVudFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHtcbiAgICAgICAgZG9jOiBcIldoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgcG9pbnRgLCBhbGlnbnMgaWNvbnMgZWFzdC13ZXN0LiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIGFsaWducyBpY29uIHgtYXhlcyB3aXRoIHRoZSBsaW5lLlwiXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgZG9jOiBcIlByb2R1Y2VzIGljb25zIHdob3NlIHgtYXhlcyBhcmUgYWxpZ25lZCB3aXRoIHRoZSB4LWF4aXMgb2YgdGhlIHZpZXdwb3J0LCByZWdhcmRsZXNzIG9mIHRoZSB2YWx1ZSBvZiBgc3ltYm9sLXBsYWNlbWVudGAuXCJcbiAgICAgIH0sXG4gICAgICBhdXRvOiB7XG4gICAgICAgIGRvYzogXCJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgdGhpcyBpcyBlcXVpdmFsZW50IHRvIGB2aWV3cG9ydGAuIFdoZW4gYHN5bWJvbC1wbGFjZW1lbnRgIGlzIHNldCB0byBgbGluZWAgb3IgYGxpbmUtY2VudGVyYCwgdGhpcyBpcyBlcXVpdmFsZW50IHRvIGBtYXBgLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJhdXRvXCIsXG4gICAgZG9jOiBcIkluIGNvbWJpbmF0aW9uIHdpdGggYHN5bWJvbC1wbGFjZW1lbnRgLCBkZXRlcm1pbmVzIHRoZSByb3RhdGlvbiBiZWhhdmlvciBvZiBpY29ucy5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJgYXV0b2AgdmFsdWVcIjoge1xuICAgICAgICBqczogXCIwLjI1LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI0LjIuMFwiLFxuICAgICAgICBpb3M6IFwiMy40LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4zLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24tc2l6ZVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHVuaXRzOiBcImZhY3RvciBvZiB0aGUgb3JpZ2luYWwgaWNvbiBzaXplXCIsXG4gICAgZG9jOiBcIlNjYWxlcyB0aGUgb3JpZ2luYWwgc2l6ZSBvZiB0aGUgaWNvbiBieSB0aGUgcHJvdmlkZWQgZmFjdG9yLiBUaGUgbmV3IHBpeGVsIHNpemUgb2YgdGhlIGltYWdlIHdpbGwgYmUgdGhlIG9yaWdpbmFsIHBpeGVsIHNpemUgbXVsdGlwbGllZCBieSBgaWNvbi1zaXplYC4gMSBpcyB0aGUgb3JpZ2luYWwgc2l6ZTsgMyB0cmlwbGVzIHRoZSBzaXplIG9mIHRoZSBpbWFnZS5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zNS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4xLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi10ZXh0LWZpdFwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBub25lOiB7XG4gICAgICAgIGRvYzogXCJUaGUgaWNvbiBpcyBkaXNwbGF5ZWQgYXQgaXRzIGludHJpbnNpYyBhc3BlY3QgcmF0aW8uXCJcbiAgICAgIH0sXG4gICAgICB3aWR0aDoge1xuICAgICAgICBkb2M6IFwiVGhlIGljb24gaXMgc2NhbGVkIGluIHRoZSB4LWRpbWVuc2lvbiB0byBmaXQgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0LlwiXG4gICAgICB9LFxuICAgICAgaGVpZ2h0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgaWNvbiBpcyBzY2FsZWQgaW4gdGhlIHktZGltZW5zaW9uIHRvIGZpdCB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0LlwiXG4gICAgICB9LFxuICAgICAgYm90aDoge1xuICAgICAgICBkb2M6IFwiVGhlIGljb24gaXMgc2NhbGVkIGluIGJvdGggeC0gYW5kIHktZGltZW5zaW9ucy5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwibm9uZVwiLFxuICAgIGRvYzogXCJTY2FsZXMgdGhlIGljb24gdG8gZml0IGFyb3VuZCB0aGUgYXNzb2NpYXRlZCB0ZXh0LlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCIsIFwidGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMjEuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjQuMi4wXCIsXG4gICAgICAgIGlvczogXCIzLjQuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjIuMVwiXG4gICAgICB9LFxuICAgICAgXCJzdHJldGNoYWJsZSBpY29uc1wiOiB7XG4gICAgICAgIGpzOiBcIjEuNi4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiOS4yLjBcIixcbiAgICAgICAgaW9zOiBcIjUuOC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTUuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaWNvbi10ZXh0LWZpdC1wYWRkaW5nXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiA0LFxuICAgIFwiZGVmYXVsdFwiOiBbMCwgMCwgMCwgMF0sXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIlNpemUgb2YgdGhlIGFkZGl0aW9uYWwgYXJlYSBhZGRlZCB0byBkaW1lbnNpb25zIGRldGVybWluZWQgYnkgYGljb24tdGV4dC1maXRgLCBpbiBjbG9ja3dpc2Ugb3JkZXI6IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdC5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiLCBcInRleHQtZmllbGRcIiwge1xuICAgICAgXCJpY29uLXRleHQtZml0XCI6IFtcImJvdGhcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXVxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4yMS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNC4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMi4xXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24taW1hZ2VcIjoge1xuICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgIGRvYzogXCJOYW1lIG9mIGltYWdlIGluIHNwcml0ZSB0byB1c2UgZm9yIGRyYXdpbmcgYW4gaW1hZ2UgYmFja2dyb3VuZC5cIixcbiAgICB0b2tlbnM6IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMzUuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLXJvdGF0ZVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBwZXJpb2Q6IDM2MCxcbiAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgZG9jOiBcIlJvdGF0ZXMgdGhlIGljb24gY2xvY2t3aXNlLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjIxLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLXBhZGRpbmdcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDIsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiU2l6ZSBvZiB0aGUgYWRkaXRpb25hbCBhcmVhIGFyb3VuZCB0aGUgaWNvbiBib3VuZGluZyBib3ggdXNlZCBmb3IgZGV0ZWN0aW5nIHN5bWJvbCBjb2xsaXNpb25zLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24ta2VlcC11cHJpZ2h0XCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogZmFsc2UsXG4gICAgZG9jOiBcIklmIHRydWUsIHRoZSBpY29uIG1heSBiZSBmbGlwcGVkIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93bi5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiLCB7XG4gICAgICBcImljb24tcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcbiAgICB9LCB7XG4gICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1wibGluZVwiLCBcImxpbmUtY2VudGVyXCJdXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImljb24tb2Zmc2V0XCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiAyLFxuICAgIFwiZGVmYXVsdFwiOiBbMCwgMF0sXG4gICAgZG9jOiBcIk9mZnNldCBkaXN0YW5jZSBvZiBpY29uIGZyb20gaXRzIGFuY2hvci4gUG9zaXRpdmUgdmFsdWVzIGluZGljYXRlIHJpZ2h0IGFuZCBkb3duLCB3aGlsZSBuZWdhdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgbGVmdCBhbmQgdXAuIEVhY2ggY29tcG9uZW50IGlzIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlIG9mIGBpY29uLXNpemVgIHRvIG9idGFpbiB0aGUgZmluYWwgb2Zmc2V0IGluIHBpeGVscy4gV2hlbiBjb21iaW5lZCB3aXRoIGBpY29uLXJvdGF0ZWAgdGhlIG9mZnNldCB3aWxsIGJlIGFzIGlmIHRoZSByb3RhdGVkIGRpcmVjdGlvbiB3YXMgdXAuXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMjkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImljb24tYW5jaG9yXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGNlbnRlcjoge1xuICAgICAgICBkb2M6IFwiVGhlIGNlbnRlciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgbGVmdDoge1xuICAgICAgICBkb2M6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgcmlnaHQ6IHtcbiAgICAgICAgZG9jOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICB0b3A6IHtcbiAgICAgICAgZG9jOiBcIlRoZSB0b3Agb2YgdGhlIGljb24gaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIGJvdHRvbToge1xuICAgICAgICBkb2M6IFwiVGhlIGJvdHRvbSBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgXCJ0b3AtbGVmdFwiOiB7XG4gICAgICAgIGRvYzogXCJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICBcInRvcC1yaWdodFwiOiB7XG4gICAgICAgIGRvYzogXCJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgXCJib3R0b20tbGVmdFwiOiB7XG4gICAgICAgIGRvYzogXCJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSBpY29uIGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICBcImJvdHRvbS1yaWdodFwiOiB7XG4gICAgICAgIGRvYzogXCJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgaWNvbiBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJjZW50ZXJcIixcbiAgICBkb2M6IFwiUGFydCBvZiB0aGUgaWNvbiBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40MC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNy4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNi4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjQwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjIuMFwiLFxuICAgICAgICBpb3M6IFwiMy43LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC42LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi1waXRjaC1hbGlnbm1lbnRcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7XG4gICAgICAgIGRvYzogXCJUaGUgaWNvbiBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgbWFwLlwiXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBpY29uIGlzIGFsaWduZWQgdG8gdGhlIHBsYW5lIG9mIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgfSxcbiAgICAgIGF1dG86IHtcbiAgICAgICAgZG9jOiBcIkF1dG9tYXRpY2FsbHkgbWF0Y2hlcyB0aGUgdmFsdWUgb2YgYGljb24tcm90YXRpb24tYWxpZ25tZW50YC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwiYXV0b1wiLFxuICAgIGRvYzogXCJPcmllbnRhdGlvbiBvZiBpY29uIHdoZW4gbWFwIGlzIHBpdGNoZWQuXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjM5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjIuMFwiLFxuICAgICAgICBpb3M6IFwiMy43LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC42LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtcGl0Y2gtYWxpZ25tZW50XCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge1xuICAgICAgICBkb2M6IFwiVGhlIHRleHQgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIG1hcC5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgdmlld3BvcnQuXCJcbiAgICAgIH0sXG4gICAgICBhdXRvOiB7XG4gICAgICAgIGRvYzogXCJBdXRvbWF0aWNhbGx5IG1hdGNoZXMgdGhlIHZhbHVlIG9mIGB0ZXh0LXJvdGF0aW9uLWFsaWdubWVudGAuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcImF1dG9cIixcbiAgICBkb2M6IFwiT3JpZW50YXRpb24gb2YgdGV4dCB3aGVuIG1hcCBpcyBwaXRjaGVkLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4yMS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNC4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMi4xXCJcbiAgICAgIH0sXG4gICAgICBcImBhdXRvYCB2YWx1ZVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMjUuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjQuMi4wXCIsXG4gICAgICAgIGlvczogXCIzLjQuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjMuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC1yb3RhdGlvbi1hbGlnbm1lbnRcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7XG4gICAgICAgIGRvYzogXCJXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYHBvaW50YCwgYWxpZ25zIHRleHQgZWFzdC13ZXN0LiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIGFsaWducyB0ZXh0IHgtYXhlcyB3aXRoIHRoZSBsaW5lLlwiXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgZG9jOiBcIlByb2R1Y2VzIGdseXBocyB3aG9zZSB4LWF4ZXMgYXJlIGFsaWduZWQgd2l0aCB0aGUgeC1heGlzIG9mIHRoZSB2aWV3cG9ydCwgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYHN5bWJvbC1wbGFjZW1lbnRgLlwiXG4gICAgICB9LFxuICAgICAgYXV0bzoge1xuICAgICAgICBkb2M6IFwiV2hlbiBgc3ltYm9sLXBsYWNlbWVudGAgaXMgc2V0IHRvIGBwb2ludGAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgdmlld3BvcnRgLiBXaGVuIGBzeW1ib2wtcGxhY2VtZW50YCBpcyBzZXQgdG8gYGxpbmVgIG9yIGBsaW5lLWNlbnRlcmAsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBgbWFwYC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwiYXV0b1wiLFxuICAgIGRvYzogXCJJbiBjb21iaW5hdGlvbiB3aXRoIGBzeW1ib2wtcGxhY2VtZW50YCwgZGV0ZXJtaW5lcyB0aGUgcm90YXRpb24gYmVoYXZpb3Igb2YgdGhlIGluZGl2aWR1YWwgZ2x5cGhzIGZvcm1pbmcgdGhlIHRleHQuXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiYGF1dG9gIHZhbHVlXCI6IHtcbiAgICAgICAganM6IFwiMC4yNS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNC4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LWZpZWxkXCI6IHtcbiAgICB0eXBlOiBcImZvcm1hdHRlZFwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIlwiLFxuICAgIHRva2VuczogdHJ1ZSxcbiAgICBkb2M6IFwiVmFsdWUgdG8gdXNlIGZvciBhIHRleHQgbGFiZWwuIElmIGEgcGxhaW4gYHN0cmluZ2AgaXMgcHJvdmlkZWQsIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIGBmb3JtYXR0ZWRgIHdpdGggZGVmYXVsdC9pbmhlcml0ZWQgZm9ybWF0dGluZyBvcHRpb25zLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjMzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1mb250XCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwic3RyaW5nXCIsXG4gICAgXCJkZWZhdWx0XCI6IFtcIk9wZW4gU2FucyBSZWd1bGFyXCIsIFwiQXJpYWwgVW5pY29kZSBNUyBSZWd1bGFyXCJdLFxuICAgIGRvYzogXCJGb250IHN0YWNrIHRvIHVzZSBmb3IgZGlzcGxheWluZyB0ZXh0LlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjQzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1zaXplXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAxNixcbiAgICBtaW5pbXVtOiAwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJGb250IHNpemUuXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMzUuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtbWF4LXdpZHRoXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAxMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHVuaXRzOiBcImVtc1wiLFxuICAgIGRvYzogXCJUaGUgbWF4aW11bSBsaW5lIHdpZHRoIGZvciB0ZXh0IHdyYXBwaW5nLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjQwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjIuMFwiLFxuICAgICAgICBpb3M6IFwiMy43LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC42LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LWxpbmUtaGVpZ2h0XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAxLjIsXG4gICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgZG9jOiBcIlRleHQgbGVhZGluZyB2YWx1ZSBmb3IgbXVsdGktbGluZSB0ZXh0LlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIyLjMuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtbGV0dGVyLXNwYWNpbmdcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgdW5pdHM6IFwiZW1zXCIsXG4gICAgZG9jOiBcIlRleHQgdHJhY2tpbmcgYW1vdW50LlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjQwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjIuMFwiLFxuICAgICAgICBpb3M6IFwiMy43LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC42LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LWp1c3RpZnlcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgYXV0bzoge1xuICAgICAgICBkb2M6IFwiVGhlIHRleHQgaXMgYWxpZ25lZCB0b3dhcmRzIHRoZSBhbmNob3IgcG9zaXRpb24uXCJcbiAgICAgIH0sXG4gICAgICBsZWZ0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSBsZWZ0LlwiXG4gICAgICB9LFxuICAgICAgY2VudGVyOiB7XG4gICAgICAgIGRvYzogXCJUaGUgdGV4dCBpcyBjZW50ZXJlZC5cIlxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgdGV4dCBpcyBhbGlnbmVkIHRvIHRoZSByaWdodC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG4gICAgZG9jOiBcIlRleHQganVzdGlmaWNhdGlvbiBvcHRpb25zLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjM5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjIuMFwiLFxuICAgICAgICBpb3M6IFwiMy43LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC42LjBcIlxuICAgICAgfSxcbiAgICAgIGF1dG86IHtcbiAgICAgICAganM6IFwiMC41NC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNy40LjBcIixcbiAgICAgICAgaW9zOiBcIjQuMTAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjE0LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1yYWRpYWwtb2Zmc2V0XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIHVuaXRzOiBcImVtc1wiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIGRvYzogXCJSYWRpYWwgb2Zmc2V0IG9mIHRleHQsIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHN5bWJvbCdzIGFuY2hvci4gVXNlZnVsIGluIGNvbWJpbmF0aW9uIHdpdGggYHRleHQtdmFyaWFibGUtYW5jaG9yYCwgd2hpY2ggZGVmYXVsdHMgdG8gdXNpbmcgdGhlIHR3by1kaW1lbnNpb25hbCBgdGV4dC1vZmZzZXRgIGlmIHByZXNlbnQuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjU0LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI3LjQuMFwiLFxuICAgICAgICBpb3M6IFwiNC4xMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTQuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC41NC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNy40LjBcIixcbiAgICAgICAgaW9zOiBcIjQuMTAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjE0LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIixcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH1cbiAgfSxcbiAgXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIGNlbnRlcjoge1xuICAgICAgICBkb2M6IFwiVGhlIGNlbnRlciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgbGVmdDoge1xuICAgICAgICBkb2M6IFwiVGhlIGxlZnQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgcmlnaHQ6IHtcbiAgICAgICAgZG9jOiBcIlRoZSByaWdodCBzaWRlIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICB0b3A6IHtcbiAgICAgICAgZG9jOiBcIlRoZSB0b3Agb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIGJvdHRvbToge1xuICAgICAgICBkb2M6IFwiVGhlIGJvdHRvbSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgXCJ0b3AtbGVmdFwiOiB7XG4gICAgICAgIGRvYzogXCJUaGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICBcInRvcC1yaWdodFwiOiB7XG4gICAgICAgIGRvYzogXCJUaGUgdG9wIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgXCJib3R0b20tbGVmdFwiOiB7XG4gICAgICAgIGRvYzogXCJUaGUgYm90dG9tIGxlZnQgY29ybmVyIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICBcImJvdHRvbS1yaWdodFwiOiB7XG4gICAgICAgIGRvYzogXCJUaGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCB7XG4gICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1wicG9pbnRcIl1cbiAgICB9XSxcbiAgICBkb2M6IFwiVG8gaW5jcmVhc2UgdGhlIGNoYW5jZSBvZiBwbGFjaW5nIGhpZ2gtcHJpb3JpdHkgbGFiZWxzIG9uIHRoZSBtYXAsIHlvdSBjYW4gcHJvdmlkZSBhbiBhcnJheSBvZiBgdGV4dC1hbmNob3JgIGxvY2F0aW9uczogdGhlIHJlbmRlcmVyIHdpbGwgYXR0ZW1wdCB0byBwbGFjZSB0aGUgbGFiZWwgYXQgZWFjaCBsb2NhdGlvbiwgaW4gb3JkZXIsIGJlZm9yZSBtb3Zpbmcgb250byB0aGUgbmV4dCBsYWJlbC4gVXNlIGB0ZXh0LWp1c3RpZnk6IGF1dG9gIHRvIGNob29zZSBqdXN0aWZpY2F0aW9uIGJhc2VkIG9uIGFuY2hvciBwb3NpdGlvbi4gVG8gYXBwbHkgYW4gb2Zmc2V0LCB1c2UgdGhlIGB0ZXh0LXJhZGlhbC1vZmZzZXRgIG9yIHRoZSB0d28tZGltZW5zaW9uYWwgYHRleHQtb2Zmc2V0YC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNTQuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjcuNC4wXCIsXG4gICAgICAgIGlvczogXCI0LjEwLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJ0ZXh0LWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBjZW50ZXI6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBjZW50ZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIGxlZnQ6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsZWZ0IHNpZGUgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgcmlnaHQgc2lkZSBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgdG9wOiB7XG4gICAgICAgIGRvYzogXCJUaGUgdG9wIG9mIHRoZSB0ZXh0IGlzIHBsYWNlZCBjbG9zZXN0IHRvIHRoZSBhbmNob3IuXCJcbiAgICAgIH0sXG4gICAgICBib3R0b206IHtcbiAgICAgICAgZG9jOiBcIlRoZSBib3R0b20gb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIFwidG9wLWxlZnRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgXCJ0b3AtcmlnaHRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIHRvcCByaWdodCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfSxcbiAgICAgIFwiYm90dG9tLWxlZnRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBvZiB0aGUgdGV4dCBpcyBwbGFjZWQgY2xvc2VzdCB0byB0aGUgYW5jaG9yLlwiXG4gICAgICB9LFxuICAgICAgXCJib3R0b20tcmlnaHRcIjoge1xuICAgICAgICBkb2M6IFwiVGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHRleHQgaXMgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwiY2VudGVyXCIsXG4gICAgZG9jOiBcIlBhcnQgb2YgdGhlIHRleHQgcGxhY2VkIGNsb3Nlc3QgdG8gdGhlIGFuY2hvci5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCB7XG4gICAgICBcIiFcIjogXCJ0ZXh0LXZhcmlhYmxlLWFuY2hvclwiXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMzkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMi4wXCIsXG4gICAgICAgIGlvczogXCIzLjcuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjYuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LW1heC1hbmdsZVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogNDUsXG4gICAgdW5pdHM6IFwiZGVncmVlc1wiLFxuICAgIGRvYzogXCJNYXhpbXVtIGFuZ2xlIGNoYW5nZSBiZXR3ZWVuIGFkamFjZW50IGNoYXJhY3RlcnMuXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcImxpbmVcIiwgXCJsaW5lLWNlbnRlclwiXVxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtd3JpdGluZy1tb2RlXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgaG9yaXpvbnRhbDoge1xuICAgICAgICBkb2M6IFwiSWYgYSB0ZXh0J3MgbGFuZ3VhZ2Ugc3VwcG9ydHMgaG9yaXpvbnRhbCB3cml0aW5nIG1vZGUsIHN5bWJvbHMgd2l0aCBwb2ludCBwbGFjZW1lbnQgd291bGQgYmUgbGFpZCBvdXQgaG9yaXpvbnRhbGx5LlwiXG4gICAgICB9LFxuICAgICAgdmVydGljYWw6IHtcbiAgICAgICAgZG9jOiBcIklmIGEgdGV4dCdzIGxhbmd1YWdlIHN1cHBvcnRzIHZlcnRpY2FsIHdyaXRpbmcgbW9kZSwgc3ltYm9scyB3aXRoIHBvaW50IHBsYWNlbWVudCB3b3VsZCBiZSBsYWlkIG91dCB2ZXJ0aWNhbGx5LlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBkb2M6IFwiVGhlIHByb3BlcnR5IGFsbG93cyBjb250cm9sIG92ZXIgYSBzeW1ib2wncyBvcmllbnRhdGlvbi4gTm90ZSB0aGF0IHRoZSBwcm9wZXJ0eSB2YWx1ZXMgYWN0IGFzIGEgaGludCwgc28gdGhhdCBhIHN5bWJvbCB3aG9zZSBsYW5ndWFnZSBkb2VzbuKAmXQgc3VwcG9ydCB0aGUgcHJvdmlkZWQgb3JpZW50YXRpb24gd2lsbCBiZSBsYWlkIG91dCBpbiBpdHMgbmF0dXJhbCBvcmllbnRhdGlvbi4gRXhhbXBsZTogRW5nbGlzaCBwb2ludCBzeW1ib2wgd2lsbCBiZSByZW5kZXJlZCBob3Jpem9udGFsbHkgZXZlbiBpZiBhcnJheSB2YWx1ZSBjb250YWlucyBzaW5nbGUgJ3ZlcnRpY2FsJyBlbnVtIHZhbHVlLiBUaGUgb3JkZXIgb2YgZWxlbWVudHMgaW4gYW4gYXJyYXkgZGVmaW5lIHByaW9yaXR5IG9yZGVyIGZvciB0aGUgcGxhY2VtZW50IG9mIGFuIG9yaWVudGF0aW9uIHZhcmlhbnQuXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwge1xuICAgICAgXCJzeW1ib2wtcGxhY2VtZW50XCI6IFtcInBvaW50XCJdXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIxLjMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjguMy4wXCIsXG4gICAgICAgIGlvczogXCI1LjMuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjE1LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtcm90YXRlXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIHBlcmlvZDogMzYwLFxuICAgIHVuaXRzOiBcImRlZ3JlZXNcIixcbiAgICBkb2M6IFwiUm90YXRlcyB0aGUgdGV4dCBjbG9ja3dpc2UuXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMzUuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtcGFkZGluZ1wiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMixcbiAgICBtaW5pbXVtOiAwLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJTaXplIG9mIHRoZSBhZGRpdGlvbmFsIGFyZWEgYXJvdW5kIHRoZSB0ZXh0IGJvdW5kaW5nIGJveCB1c2VkIGZvciBkZXRlY3Rpbmcgc3ltYm9sIGNvbGxpc2lvbnMuXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC1rZWVwLXVwcmlnaHRcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgIGRvYzogXCJJZiB0cnVlLCB0aGUgdGV4dCBtYXkgYmUgZmxpcHBlZCB2ZXJ0aWNhbGx5IHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByZW5kZXJlZCB1cHNpZGUtZG93bi5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCB7XG4gICAgICBcInRleHQtcm90YXRpb24tYWxpZ25tZW50XCI6IFwibWFwXCJcbiAgICB9LCB7XG4gICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogW1wibGluZVwiLCBcImxpbmUtY2VudGVyXCJdXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtdHJhbnNmb3JtXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG5vbmU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSB0ZXh0IGlzIG5vdCBhbHRlcmVkLlwiXG4gICAgICB9LFxuICAgICAgdXBwZXJjYXNlOiB7XG4gICAgICAgIGRvYzogXCJGb3JjZXMgYWxsIGxldHRlcnMgdG8gYmUgZGlzcGxheWVkIGluIHVwcGVyY2FzZS5cIlxuICAgICAgfSxcbiAgICAgIGxvd2VyY2FzZToge1xuICAgICAgICBkb2M6IFwiRm9yY2VzIGFsbCBsZXR0ZXJzIHRvIGJlIGRpc3BsYXllZCBpbiBsb3dlcmNhc2UuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcIm5vbmVcIixcbiAgICBkb2M6IFwiU3BlY2lmaWVzIGhvdyB0byBjYXBpdGFsaXplIHRleHQsIHNpbWlsYXIgdG8gdGhlIENTUyBgdGV4dC10cmFuc2Zvcm1gIHByb3BlcnR5LlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjMzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1vZmZzZXRcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBkb2M6IFwiT2Zmc2V0IGRpc3RhbmNlIG9mIHRleHQgZnJvbSBpdHMgYW5jaG9yLiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC4gSWYgdXNlZCB3aXRoIHRleHQtdmFyaWFibGUtYW5jaG9yLCBpbnB1dCB2YWx1ZXMgd2lsbCBiZSB0YWtlbiBhcyBhYnNvbHV0ZSB2YWx1ZXMuIE9mZnNldHMgYWxvbmcgdGhlIHgtIGFuZCB5LWF4aXMgd2lsbCBiZSBhcHBsaWVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhlIGFuY2hvciBwb3NpdGlvbi5cIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICB1bml0czogXCJlbXNcIixcbiAgICBsZW5ndGg6IDIsXG4gICAgXCJkZWZhdWx0XCI6IFswLCAwXSxcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCB7XG4gICAgICBcIiFcIjogXCJ0ZXh0LXJhZGlhbC1vZmZzZXRcIlxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjM1LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJ0ZXh0LWFsbG93LW92ZXJsYXBcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICBkb2M6IFwiSWYgdHJ1ZSwgdGhlIHRleHQgd2lsbCBiZSB2aXNpYmxlIGV2ZW4gaWYgaXQgY29sbGlkZXMgd2l0aCBvdGhlciBwcmV2aW91c2x5IGRyYXduIHN5bWJvbHMuXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtaWdub3JlLXBsYWNlbWVudFwiOiB7XG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgXCJkZWZhdWx0XCI6IGZhbHNlLFxuICAgIGRvYzogXCJJZiB0cnVlLCBvdGhlciBzeW1ib2xzIGNhbiBiZSB2aXNpYmxlIGV2ZW4gaWYgdGhleSBjb2xsaWRlIHdpdGggdGhlIHRleHQuXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtb3B0aW9uYWxcIjoge1xuICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgIFwiZGVmYXVsdFwiOiBmYWxzZSxcbiAgICBkb2M6IFwiSWYgdHJ1ZSwgaWNvbnMgd2lsbCBkaXNwbGF5IHdpdGhvdXQgdGhlaXIgY29ycmVzcG9uZGluZyB0ZXh0IHdoZW4gdGhlIHRleHQgY29sbGlkZXMgd2l0aCBvdGhlciBzeW1ib2xzIGFuZCB0aGUgaWNvbiBkb2VzIG5vdC5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiLCBcImljb24taW1hZ2VcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICB2aXNpYmlsaXR5OiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgc2hvd24uXCJcbiAgICAgIH0sXG4gICAgICBub25lOiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGF5ZXIgaXMgbm90IHNob3duLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJ2aXNpYmxlXCIsXG4gICAgZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICB9XG59O1xudmFyIGxheW91dF9yYXN0ZXIgPSB7XG4gIHZpc2liaWxpdHk6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBzaG93bi5cIlxuICAgICAgfSxcbiAgICAgIG5vbmU6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsYXllciBpcyBub3Qgc2hvd24uXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcInZpc2libGVcIixcbiAgICBkb2M6IFwiV2hldGhlciB0aGlzIGxheWVyIGlzIGRpc3BsYXllZC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb25zdGFudFwiXG4gIH1cbn07XG52YXIgbGF5b3V0X2hpbGxzaGFkZSA9IHtcbiAgdmlzaWJpbGl0eToge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgdmlzaWJsZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICB9LFxuICAgICAgbm9uZToge1xuICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgIGRvYzogXCJXaGV0aGVyIHRoaXMgbGF5ZXIgaXMgZGlzcGxheWVkLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40My4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNvbnN0YW50XCJcbiAgfVxufTtcbnZhciBmaWx0ZXIgPSB7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgdmFsdWU6IFwiKlwiLFxuICBkb2M6IFwiQSBmaWx0ZXIgc2VsZWN0cyBzcGVjaWZpYyBmZWF0dXJlcyBmcm9tIGEgbGF5ZXIuXCJcbn07XG52YXIgZmlsdGVyX29wZXJhdG9yID0ge1xuICB0eXBlOiBcImVudW1cIixcbiAgdmFsdWVzOiB7XG4gICAgXCI9PVwiOiB7XG4gICAgICBkb2M6IFwiYFtcXFwiPT1cXFwiLCBrZXksIHZhbHVlXWAgZXF1YWxpdHk6IGBmZWF0dXJlW2tleV0gPSB2YWx1ZWBcIlxuICAgIH0sXG4gICAgXCIhPVwiOiB7XG4gICAgICBkb2M6IFwiYFtcXFwiIT1cXFwiLCBrZXksIHZhbHVlXWAgaW5lcXVhbGl0eTogYGZlYXR1cmVba2V5XSDiiaAgdmFsdWVgXCJcbiAgICB9LFxuICAgIFwiPlwiOiB7XG4gICAgICBkb2M6IFwiYFtcXFwiPlxcXCIsIGtleSwgdmFsdWVdYCBncmVhdGVyIHRoYW46IGBmZWF0dXJlW2tleV0gPiB2YWx1ZWBcIlxuICAgIH0sXG4gICAgXCI+PVwiOiB7XG4gICAgICBkb2M6IFwiYFtcXFwiPj1cXFwiLCBrZXksIHZhbHVlXWAgZ3JlYXRlciB0aGFuIG9yIGVxdWFsOiBgZmVhdHVyZVtrZXldIOKJpSB2YWx1ZWBcIlxuICAgIH0sXG4gICAgXCI8XCI6IHtcbiAgICAgIGRvYzogXCJgW1xcXCI8XFxcIiwga2V5LCB2YWx1ZV1gIGxlc3MgdGhhbjogYGZlYXR1cmVba2V5XSA8IHZhbHVlYFwiXG4gICAgfSxcbiAgICBcIjw9XCI6IHtcbiAgICAgIGRvYzogXCJgW1xcXCI8PVxcXCIsIGtleSwgdmFsdWVdYCBsZXNzIHRoYW4gb3IgZXF1YWw6IGBmZWF0dXJlW2tleV0g4omkIHZhbHVlYFwiXG4gICAgfSxcbiAgICBcImluXCI6IHtcbiAgICAgIGRvYzogXCJgW1xcXCJpblxcXCIsIGtleSwgdjAsIC4uLiwgdm5dYCBzZXQgaW5jbHVzaW9uOiBgZmVhdHVyZVtrZXldIOKIiCB7djAsIC4uLiwgdm59YFwiXG4gICAgfSxcbiAgICBcIiFpblwiOiB7XG4gICAgICBkb2M6IFwiYFtcXFwiIWluXFxcIiwga2V5LCB2MCwgLi4uLCB2bl1gIHNldCBleGNsdXNpb246IGBmZWF0dXJlW2tleV0g4oiJIHt2MCwgLi4uLCB2bn1gXCJcbiAgICB9LFxuICAgIGFsbDoge1xuICAgICAgZG9jOiBcImBbXFxcImFsbFxcXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgQU5EYDogYGYwIOKIpyAuLi4g4oinIGZuYFwiXG4gICAgfSxcbiAgICBhbnk6IHtcbiAgICAgIGRvYzogXCJgW1xcXCJhbnlcXFwiLCBmMCwgLi4uLCBmbl1gIGxvZ2ljYWwgYE9SYDogYGYwIOKIqCAuLi4g4oioIGZuYFwiXG4gICAgfSxcbiAgICBub25lOiB7XG4gICAgICBkb2M6IFwiYFtcXFwibm9uZVxcXCIsIGYwLCAuLi4sIGZuXWAgbG9naWNhbCBgTk9SYDogYMKsZjAg4oinIC4uLiDiiKcgwqxmbmBcIlxuICAgIH0sXG4gICAgaGFzOiB7XG4gICAgICBkb2M6IFwiYFtcXFwiaGFzXFxcIiwga2V5XWAgYGZlYXR1cmVba2V5XWAgZXhpc3RzXCJcbiAgICB9LFxuICAgIFwiIWhhc1wiOiB7XG4gICAgICBkb2M6IFwiYFtcXFwiIWhhc1xcXCIsIGtleV1gIGBmZWF0dXJlW2tleV1gIGRvZXMgbm90IGV4aXN0XCJcbiAgICB9LFxuICAgIHdpdGhpbjoge1xuICAgICAgZG9jOiBcImBbXFxcIndpdGhpblxcXCIsIG9iamVjdF1gIGZlYXR1cmUgZ2VvbWV0cnkgaXMgd2l0aGluIG9iamVjdCBnZW9tZXRyeVwiXG4gICAgfVxuICB9LFxuICBkb2M6IFwiVGhlIGZpbHRlciBvcGVyYXRvci5cIlxufTtcbnZhciBnZW9tZXRyeV90eXBlID0ge1xuICB0eXBlOiBcImVudW1cIixcbiAgdmFsdWVzOiB7XG4gICAgUG9pbnQ6IHtcbiAgICAgIGRvYzogXCJGaWx0ZXIgdG8gcG9pbnQgZ2VvbWV0cmllcy5cIlxuICAgIH0sXG4gICAgTGluZVN0cmluZzoge1xuICAgICAgZG9jOiBcIkZpbHRlciB0byBsaW5lIGdlb21ldHJpZXMuXCJcbiAgICB9LFxuICAgIFBvbHlnb246IHtcbiAgICAgIGRvYzogXCJGaWx0ZXIgdG8gcG9seWdvbiBnZW9tZXRyaWVzLlwiXG4gICAgfVxuICB9LFxuICBkb2M6IFwiVGhlIGdlb21ldHJ5IHR5cGUgZm9yIHRoZSBmaWx0ZXIgdG8gc2VsZWN0LlwiXG59O1xudmFyIGZ1bmN0aW9uX3N0b3AgPSB7XG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgbWluaW11bTogMCxcbiAgbWF4aW11bTogMjQsXG4gIHZhbHVlOiBbXCJudW1iZXJcIiwgXCJjb2xvclwiXSxcbiAgbGVuZ3RoOiAyLFxuICBkb2M6IFwiWm9vbSBsZXZlbCBhbmQgdmFsdWUgcGFpci5cIlxufTtcbnZhciBleHByZXNzaW9uID0ge1xuICB0eXBlOiBcImFycmF5XCIsXG4gIHZhbHVlOiBcIipcIixcbiAgbWluaW11bTogMSxcbiAgZG9jOiBcIkFuIGV4cHJlc3Npb24gZGVmaW5lcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgZm9yIGRhdGEtZHJpdmVuIHN0eWxlIHByb3BlcnRpZXMgb3IgZmVhdHVyZSBmaWx0ZXJzLlwiXG59O1xudmFyIGV4cHJlc3Npb25fbmFtZSA9IHtcbiAgZG9jOiBcIlwiLFxuICB0eXBlOiBcImVudW1cIixcbiAgdmFsdWVzOiB7XG4gICAgXCJsZXRcIjoge1xuICAgICAgZG9jOiBcIkJpbmRzIGV4cHJlc3Npb25zIHRvIG5hbWVkIHZhcmlhYmxlcywgd2hpY2ggY2FuIHRoZW4gYmUgcmVmZXJlbmNlZCBpbiB0aGUgcmVzdWx0IGV4cHJlc3Npb24gdXNpbmcgW1xcXCJ2YXJcXFwiLCBcXFwidmFyaWFibGVfbmFtZVxcXCJdLlwiLFxuICAgICAgZ3JvdXA6IFwiVmFyaWFibGUgYmluZGluZ1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ2YXJcIjoge1xuICAgICAgZG9jOiBcIlJlZmVyZW5jZXMgdmFyaWFibGUgYm91bmQgdXNpbmcgXFxcImxldFxcXCIuXCIsXG4gICAgICBncm91cDogXCJWYXJpYWJsZSBiaW5kaW5nXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsaXRlcmFsOiB7XG4gICAgICBkb2M6IFwiUHJvdmlkZXMgYSBsaXRlcmFsIGFycmF5IG9yIG9iamVjdCB2YWx1ZS5cIixcbiAgICAgIGdyb3VwOiBcIlR5cGVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhcnJheToge1xuICAgICAgZG9jOiBcIkFzc2VydHMgdGhhdCB0aGUgaW5wdXQgaXMgYW4gYXJyYXkgKG9wdGlvbmFsbHkgd2l0aCBhIHNwZWNpZmljIGl0ZW0gdHlwZSBhbmQgbGVuZ3RoKS4gIElmLCB3aGVuIHRoZSBpbnB1dCBleHByZXNzaW9uIGlzIGV2YWx1YXRlZCwgaXQgaXMgbm90IG9mIHRoZSBhc3NlcnRlZCB0eXBlLCB0aGVuIHRoaXMgYXNzZXJ0aW9uIHdpbGwgY2F1c2UgdGhlIHdob2xlIGV4cHJlc3Npb24gdG8gYmUgYWJvcnRlZC5cIixcbiAgICAgIGdyb3VwOiBcIlR5cGVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhdDoge1xuICAgICAgZG9jOiBcIlJldHJpZXZlcyBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXCIsXG4gICAgICBncm91cDogXCJMb29rdXBcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaW5cIjoge1xuICAgICAgZG9jOiBcIkRldGVybWluZXMgd2hldGhlciBhbiBpdGVtIGV4aXN0cyBpbiBhbiBhcnJheSBvciBhIHN1YnN0cmluZyBleGlzdHMgaW4gYSBzdHJpbmcuXCIsXG4gICAgICBncm91cDogXCJMb29rdXBcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjEuNi4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI5LjEuMFwiLFxuICAgICAgICAgIGlvczogXCI1LjguMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuMTUuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaW5kZXgtb2ZcIjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIGZpcnN0IHBvc2l0aW9uIGF0IHdoaWNoIGFuIGl0ZW0gY2FuIGJlIGZvdW5kIGluIGFuIGFycmF5IG9yIGEgc3Vic3RyaW5nIGNhbiBiZSBmb3VuZCBpbiBhIHN0cmluZywgb3IgYC0xYCBpZiB0aGUgaW5wdXQgY2Fubm90IGJlIGZvdW5kLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGluZGV4IGZyb20gd2hlcmUgdG8gYmVnaW4gdGhlIHNlYXJjaC5cIixcbiAgICAgIGdyb3VwOiBcIkxvb2t1cFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMS4xMC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2xpY2U6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIGFuIGl0ZW0gZnJvbSBhbiBhcnJheSBvciBhIHN1YnN0cmluZyBmcm9tIGEgc3RyaW5nIGZyb20gYSBzcGVjaWZpZWQgc3RhcnQgaW5kZXgsIG9yIGJldHdlZW4gYSBzdGFydCBpbmRleCBhbmQgYW4gZW5kIGluZGV4IGlmIHNldC4gVGhlIHJldHVybiB2YWx1ZSBpcyBpbmNsdXNpdmUgb2YgdGhlIHN0YXJ0IGluZGV4IGJ1dCBub3Qgb2YgdGhlIGVuZCBpbmRleC5cIixcbiAgICAgIGdyb3VwOiBcIkxvb2t1cFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMS4xMC4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJjYXNlXCI6IHtcbiAgICAgIGRvYzogXCJTZWxlY3RzIHRoZSBmaXJzdCBvdXRwdXQgd2hvc2UgY29ycmVzcG9uZGluZyB0ZXN0IGNvbmRpdGlvbiBldmFsdWF0ZXMgdG8gdHJ1ZSwgb3IgdGhlIGZhbGxiYWNrIHZhbHVlIG90aGVyd2lzZS5cIixcbiAgICAgIGdyb3VwOiBcIkRlY2lzaW9uXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXRjaDoge1xuICAgICAgZG9jOiBcIlNlbGVjdHMgdGhlIG91dHB1dCBmb3Igd2hpY2ggdGhlIGxhYmVsIHZhbHVlIG1hdGNoZXMgdGhlIGlucHV0IHZhbHVlLCBvciB0aGUgZmFsbGJhY2sgdmFsdWUgaWYgbm8gbWF0Y2ggaXMgZm91bmQuIFRoZSBpbnB1dCBjYW4gYmUgYW55IGV4cHJlc3Npb24gKGZvciBleGFtcGxlLCBgW1xcXCJnZXRcXFwiLCBcXFwiYnVpbGRpbmdfdHlwZVxcXCJdYCkuIEVhY2ggbGFiZWwgbXVzdCBiZSB1bmlxdWUsIGFuZCBtdXN0IGJlIGVpdGhlcjpcXG4gLSBhIHNpbmdsZSBsaXRlcmFsIHZhbHVlOyBvclxcbiAtIGFuIGFycmF5IG9mIGxpdGVyYWwgdmFsdWVzLCB0aGUgdmFsdWVzIG9mIHdoaWNoIG11c3QgYmUgYWxsIHN0cmluZ3Mgb3IgYWxsIG51bWJlcnMgKGZvciBleGFtcGxlIGBbMTAwLCAxMDFdYCBvciBgW1xcXCJjXFxcIiwgXFxcImJcXFwiXWApLlxcblxcblRoZSBpbnB1dCBtYXRjaGVzIGlmIGFueSBvZiB0aGUgdmFsdWVzIGluIHRoZSBhcnJheSBtYXRjaGVzIHVzaW5nIHN0cmljdCBlcXVhbGl0eSwgc2ltaWxhciB0byB0aGUgYFxcXCJpblxcXCJgIG9wZXJhdG9yLlxcbklmIHRoZSBpbnB1dCB0eXBlIGRvZXMgbm90IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBsYWJlbHMsIHRoZSByZXN1bHQgd2lsbCBiZSB0aGUgZmFsbGJhY2sgdmFsdWUuXCIsXG4gICAgICBncm91cDogXCJEZWNpc2lvblwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29hbGVzY2U6IHtcbiAgICAgIGRvYzogXCJFdmFsdWF0ZXMgZWFjaCBleHByZXNzaW9uIGluIHR1cm4gdW50aWwgdGhlIGZpcnN0IG5vbi1udWxsIHZhbHVlIGlzIG9idGFpbmVkLCBhbmQgcmV0dXJucyB0aGF0IHZhbHVlLlwiLFxuICAgICAgZ3JvdXA6IFwiRGVjaXNpb25cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHN0ZXA6IHtcbiAgICAgIGRvYzogXCJQcm9kdWNlcyBkaXNjcmV0ZSwgc3RlcHBlZCByZXN1bHRzIGJ5IGV2YWx1YXRpbmcgYSBwaWVjZXdpc2UtY29uc3RhbnQgZnVuY3Rpb24gZGVmaW5lZCBieSBwYWlycyBvZiBpbnB1dCBhbmQgb3V0cHV0IHZhbHVlcyAoXFxcInN0b3BzXFxcIikuIFRoZSBgaW5wdXRgIG1heSBiZSBhbnkgbnVtZXJpYyBleHByZXNzaW9uIChlLmcuLCBgW1xcXCJnZXRcXFwiLCBcXFwicG9wdWxhdGlvblxcXCJdYCkuIFN0b3AgaW5wdXRzIG11c3QgYmUgbnVtZXJpYyBsaXRlcmFscyBpbiBzdHJpY3RseSBhc2NlbmRpbmcgb3JkZXIuIFJldHVybnMgdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGUgc3RvcCBqdXN0IGxlc3MgdGhhbiB0aGUgaW5wdXQsIG9yIHRoZSBmaXJzdCBvdXRwdXQgaWYgdGhlIGlucHV0IGlzIGxlc3MgdGhhbiB0aGUgZmlyc3Qgc3RvcC5cIixcbiAgICAgIGdyb3VwOiBcIlJhbXBzLCBzY2FsZXMsIGN1cnZlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40Mi4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaW50ZXJwb2xhdGU6IHtcbiAgICAgIGRvYzogXCJQcm9kdWNlcyBjb250aW51b3VzLCBzbW9vdGggcmVzdWx0cyBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gcGFpcnMgb2YgaW5wdXQgYW5kIG91dHB1dCB2YWx1ZXMgKFxcXCJzdG9wc1xcXCIpLiBUaGUgYGlucHV0YCBtYXkgYmUgYW55IG51bWVyaWMgZXhwcmVzc2lvbiAoZS5nLiwgYFtcXFwiZ2V0XFxcIiwgXFxcInBvcHVsYXRpb25cXFwiXWApLiBTdG9wIGlucHV0cyBtdXN0IGJlIG51bWVyaWMgbGl0ZXJhbHMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLiBUaGUgb3V0cHV0IHR5cGUgbXVzdCBiZSBgbnVtYmVyYCwgYGFycmF5PG51bWJlcj5gLCBvciBgY29sb3JgLlxcblxcbkludGVycG9sYXRpb24gdHlwZXM6XFxuLSBgW1xcXCJsaW5lYXJcXFwiXWA6IEludGVycG9sYXRlcyBsaW5lYXJseSBiZXR3ZWVuIHRoZSBwYWlyIG9mIHN0b3BzIGp1c3QgbGVzcyB0aGFuIGFuZCBqdXN0IGdyZWF0ZXIgdGhhbiB0aGUgaW5wdXQuXFxuLSBgW1xcXCJleHBvbmVudGlhbFxcXCIsIGJhc2VdYDogSW50ZXJwb2xhdGVzIGV4cG9uZW50aWFsbHkgYmV0d2VlbiB0aGUgc3RvcHMganVzdCBsZXNzIHRoYW4gYW5kIGp1c3QgZ3JlYXRlciB0aGFuIHRoZSBpbnB1dC4gYGJhc2VgIGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSBvdXRwdXQgaW5jcmVhc2VzOiBoaWdoZXIgdmFsdWVzIG1ha2UgdGhlIG91dHB1dCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCB2YWx1ZXMgY2xvc2UgdG8gMSB0aGUgb3V0cHV0IGluY3JlYXNlcyBsaW5lYXJseS5cXG4tIGBbXFxcImN1YmljLWJlemllclxcXCIsIHgxLCB5MSwgeDIsIHkyXWA6IEludGVycG9sYXRlcyB1c2luZyB0aGUgY3ViaWMgYmV6aWVyIGN1cnZlIGRlZmluZWQgYnkgdGhlIGdpdmVuIGNvbnRyb2wgcG9pbnRzLlwiLFxuICAgICAgZ3JvdXA6IFwiUmFtcHMsIHNjYWxlcywgY3VydmVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQyLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImludGVycG9sYXRlLWhjbFwiOiB7XG4gICAgICBkb2M6IFwiUHJvZHVjZXMgY29udGludW91cywgc21vb3RoIHJlc3VsdHMgYnkgaW50ZXJwb2xhdGluZyBiZXR3ZWVuIHBhaXJzIG9mIGlucHV0IGFuZCBvdXRwdXQgdmFsdWVzIChcXFwic3RvcHNcXFwiKS4gV29ya3MgbGlrZSBgaW50ZXJwb2xhdGVgLCBidXQgdGhlIG91dHB1dCB0eXBlIG11c3QgYmUgYGNvbG9yYCwgYW5kIHRoZSBpbnRlcnBvbGF0aW9uIGlzIHBlcmZvcm1lZCBpbiB0aGUgSHVlLUNocm9tYS1MdW1pbmFuY2UgY29sb3Igc3BhY2UuXCIsXG4gICAgICBncm91cDogXCJSYW1wcywgc2NhbGVzLCBjdXJ2ZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDkuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaW50ZXJwb2xhdGUtbGFiXCI6IHtcbiAgICAgIGRvYzogXCJQcm9kdWNlcyBjb250aW51b3VzLCBzbW9vdGggcmVzdWx0cyBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gcGFpcnMgb2YgaW5wdXQgYW5kIG91dHB1dCB2YWx1ZXMgKFxcXCJzdG9wc1xcXCIpLiBXb3JrcyBsaWtlIGBpbnRlcnBvbGF0ZWAsIGJ1dCB0aGUgb3V0cHV0IHR5cGUgbXVzdCBiZSBgY29sb3JgLCBhbmQgdGhlIGludGVycG9sYXRpb24gaXMgcGVyZm9ybWVkIGluIHRoZSBDSUVMQUIgY29sb3Igc3BhY2UuXCIsXG4gICAgICBncm91cDogXCJSYW1wcywgc2NhbGVzLCBjdXJ2ZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDkuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxuMjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgbWF0aGVtYXRpY2FsIGNvbnN0YW50IGxuKDIpLlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcGk6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBtYXRoZW1hdGljYWwgY29uc3RhbnQgcGkuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBlOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgbWF0aGVtYXRpY2FsIGNvbnN0YW50IGUuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInR5cGVvZlwiOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBhIHN0cmluZyBkZXNjcmliaW5nIHRoZSB0eXBlIG9mIHRoZSBnaXZlbiB2YWx1ZS5cIixcbiAgICAgIGdyb3VwOiBcIlR5cGVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzdHJpbmc6IHtcbiAgICAgIGRvYzogXCJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IHZhbHVlIGlzIGEgc3RyaW5nLiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgYSBzdHJpbmcgaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgc3RyaW5ncywgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG4gICAgICBncm91cDogXCJUeXBlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbnVtYmVyOiB7XG4gICAgICBkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhIG51bWJlci4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGEgbnVtYmVyIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgYXJlIG51bWJlcnMsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuICAgICAgZ3JvdXA6IFwiVHlwZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGJvb2xlYW46IHtcbiAgICAgIGRvYzogXCJBc3NlcnRzIHRoYXQgdGhlIGlucHV0IHZhbHVlIGlzIGEgYm9vbGVhbi4gSWYgbXVsdGlwbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgZWFjaCBvbmUgaXMgZXZhbHVhdGVkIGluIG9yZGVyIHVudGlsIGEgYm9vbGVhbiBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGFyZSBib29sZWFucywgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG4gICAgICBncm91cDogXCJUeXBlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb2JqZWN0OiB7XG4gICAgICBkb2M6IFwiQXNzZXJ0cyB0aGF0IHRoZSBpbnB1dCB2YWx1ZSBpcyBhbiBvYmplY3QuIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCBhbiBvYmplY3QgaXMgb2J0YWluZWQuIElmIG5vbmUgb2YgdGhlIGlucHV0cyBhcmUgb2JqZWN0cywgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG4gICAgICBncm91cDogXCJUeXBlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29sbGF0b3I6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIGEgYGNvbGxhdG9yYCBmb3IgdXNlIGluIGxvY2FsZS1kZXBlbmRlbnQgY29tcGFyaXNvbiBvcGVyYXRpb25zLiBUaGUgYGNhc2Utc2Vuc2l0aXZlYCBhbmQgYGRpYWNyaXRpYy1zZW5zaXRpdmVgIG9wdGlvbnMgZGVmYXVsdCB0byBgZmFsc2VgLiBUaGUgYGxvY2FsZWAgYXJndW1lbnQgc3BlY2lmaWVzIHRoZSBJRVRGIGxhbmd1YWdlIHRhZyBvZiB0aGUgbG9jYWxlIHRvIHVzZS4gSWYgbm9uZSBpcyBwcm92aWRlZCwgdGhlIGRlZmF1bHQgbG9jYWxlIGlzIHVzZWQuIElmIHRoZSByZXF1ZXN0ZWQgbG9jYWxlIGlzIG5vdCBhdmFpbGFibGUsIHRoZSBgY29sbGF0b3JgIHdpbGwgdXNlIGEgc3lzdGVtLWRlZmluZWQgZmFsbGJhY2sgbG9jYWxlLiBVc2UgYHJlc29sdmVkLWxvY2FsZWAgdG8gdGVzdCB0aGUgcmVzdWx0cyBvZiBsb2NhbGUgZmFsbGJhY2sgYmVoYXZpb3IuXCIsXG4gICAgICBncm91cDogXCJUeXBlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjUuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjIuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuOS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZm9ybWF0OiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBhIGBmb3JtYXR0ZWRgIHN0cmluZyBmb3IgZGlzcGxheWluZyBtaXhlZC1mb3JtYXQgdGV4dCBpbiB0aGUgYHRleHQtZmllbGRgIHByb3BlcnR5LiBUaGUgaW5wdXQgbWF5IGNvbnRhaW4gYSBzdHJpbmcgbGl0ZXJhbCBvciBleHByZXNzaW9uLCBpbmNsdWRpbmcgYW4gW2AnaW1hZ2UnYF0oI3R5cGVzLWltYWdlKSBleHByZXNzaW9uLiBTdHJpbmdzIG1heSBiZSBmb2xsb3dlZCBieSBhIHN0eWxlIG92ZXJyaWRlIG9iamVjdCB0aGF0IHN1cHBvcnRzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcXG4tIGBcXFwidGV4dC1mb250XFxcImA6IE92ZXJyaWRlcyB0aGUgZm9udCBzdGFjayBzcGVjaWZpZWQgYnkgdGhlIHJvb3QgbGF5b3V0IHByb3BlcnR5Llxcbi0gYFxcXCJ0ZXh0LWNvbG9yXFxcImA6IE92ZXJyaWRlcyB0aGUgY29sb3Igc3BlY2lmaWVkIGJ5IHRoZSByb290IHBhaW50IHByb3BlcnR5Llxcbi0gYFxcXCJmb250LXNjYWxlXFxcImA6IEFwcGxpZXMgYSBzY2FsaW5nIGZhY3RvciBvbiBgdGV4dC1zaXplYCBhcyBzcGVjaWZpZWQgYnkgdGhlIHJvb3QgbGF5b3V0IHByb3BlcnR5LlwiLFxuICAgICAgZ3JvdXA6IFwiVHlwZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDguMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi43LjBcIixcbiAgICAgICAgICBpb3M6IFwiNC42LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjEyLjBcIlxuICAgICAgICB9LFxuICAgICAgICBcInRleHQtZm9udFwiOiB7XG4gICAgICAgICAganM6IFwiMC40OC4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjcuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjYuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuMTIuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZm9udC1zY2FsZVwiOiB7XG4gICAgICAgICAganM6IFwiMC40OC4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjcuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjYuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuMTIuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGV4dC1jb2xvclwiOiB7XG4gICAgICAgICAganM6IFwiMS4zLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjcuMy4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMTAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuMTQuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlOiB7XG4gICAgICAgICAganM6IFwiMS42LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjguNi4wXCIsXG4gICAgICAgICAgaW9zOiBcIjUuNy4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC4xNS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaW1hZ2U6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIGFuIGBpbWFnZWAgdHlwZSBmb3IgdXNlIGluIGBpY29uLWltYWdlYCwgYCotcGF0dGVybmAgZW50cmllcyBhbmQgYXMgYSBzZWN0aW9uIGluIHRoZSBgZm9ybWF0YCBleHByZXNzaW9uLiBJZiBzZXQsIHRoZSBgaW1hZ2VgIGFyZ3VtZW50IHdpbGwgY2hlY2sgdGhhdCB0aGUgcmVxdWVzdGVkIGltYWdlIGV4aXN0cyBpbiB0aGUgc3R5bGUgYW5kIHdpbGwgcmV0dXJuIGVpdGhlciB0aGUgcmVzb2x2ZWQgaW1hZ2UgbmFtZSBvciBgbnVsbGAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9yIG5vdCB0aGUgaW1hZ2UgaXMgY3VycmVudGx5IGluIHRoZSBzdHlsZS4gVGhpcyB2YWxpZGF0aW9uIHByb2Nlc3MgaXMgc3luY2hyb25vdXMgYW5kIHJlcXVpcmVzIHRoZSBpbWFnZSB0byBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIHN0eWxlIGJlZm9yZSByZXF1ZXN0aW5nIGl0IGluIHRoZSBgaW1hZ2VgIGFyZ3VtZW50LlwiLFxuICAgICAgZ3JvdXA6IFwiVHlwZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjEuNC4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI4LjYuMFwiLFxuICAgICAgICAgIGlvczogXCI1LjcuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuMTUuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwibnVtYmVyLWZvcm1hdFwiOiB7XG4gICAgICBkb2M6IFwiQ29udmVydHMgdGhlIGlucHV0IG51bWJlciBpbnRvIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIHVzaW5nIHRoZSBwcm92aWRpbmcgZm9ybWF0dGluZyBydWxlcy4gSWYgc2V0LCB0aGUgYGxvY2FsZWAgYXJndW1lbnQgc3BlY2lmaWVzIHRoZSBsb2NhbGUgdG8gdXNlLCBhcyBhIEJDUCA0NyBsYW5ndWFnZSB0YWcuIElmIHNldCwgdGhlIGBjdXJyZW5jeWAgYXJndW1lbnQgc3BlY2lmaWVzIGFuIElTTyA0MjE3IGNvZGUgdG8gdXNlIGZvciBjdXJyZW5jeS1zdHlsZSBmb3JtYXR0aW5nLiBJZiBzZXQsIHRoZSBgbWluLWZyYWN0aW9uLWRpZ2l0c2AgYW5kIGBtYXgtZnJhY3Rpb24tZGlnaXRzYCBhcmd1bWVudHMgc3BlY2lmeSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBudW1iZXIgb2YgZnJhY3Rpb25hbCBkaWdpdHMgdG8gaW5jbHVkZS5cIixcbiAgICAgIGdyb3VwOiBcIlR5cGVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjU0LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRvLXN0cmluZ1wiOiB7XG4gICAgICBkb2M6IFwiQ29udmVydHMgdGhlIGlucHV0IHZhbHVlIHRvIGEgc3RyaW5nLiBJZiB0aGUgaW5wdXQgaXMgYG51bGxgLCB0aGUgcmVzdWx0IGlzIGBcXFwiXFxcImAuIElmIHRoZSBpbnB1dCBpcyBhIGJvb2xlYW4sIHRoZSByZXN1bHQgaXMgYFxcXCJ0cnVlXFxcImAgb3IgYFxcXCJmYWxzZVxcXCJgLiBJZiB0aGUgaW5wdXQgaXMgYSBudW1iZXIsIGl0IGlzIGNvbnZlcnRlZCB0byBhIHN0cmluZyBhcyBzcGVjaWZpZWQgYnkgdGhlIFtcXFwiTnVtYmVyVG9TdHJpbmdcXFwiIGFsZ29yaXRobV0oaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9zdHJpbmctYXBwbGllZC10by10aGUtbnVtYmVyLXR5cGUpIG9mIHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb24uIElmIHRoZSBpbnB1dCBpcyBhIGNvbG9yLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgb2YgdGhlIGZvcm0gYFxcXCJyZ2JhKHIsZyxiLGEpXFxcImAsIHdoZXJlIGByYCwgYGdgLCBhbmQgYGJgIGFyZSBudW1lcmFscyByYW5naW5nIGZyb20gMCB0byAyNTUsIGFuZCBgYWAgcmFuZ2VzIGZyb20gMCB0byAxLiBPdGhlcndpc2UsIHRoZSBpbnB1dCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgaW4gdGhlIGZvcm1hdCBzcGVjaWZpZWQgYnkgdGhlIFtgSlNPTi5zdHJpbmdpZnlgXShodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1qc29uLnN0cmluZ2lmeSkgZnVuY3Rpb24gb2YgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgU3BlY2lmaWNhdGlvbi5cIixcbiAgICAgIGdyb3VwOiBcIlR5cGVzXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInRvLW51bWJlclwiOiB7XG4gICAgICBkb2M6IFwiQ29udmVydHMgdGhlIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyLCBpZiBwb3NzaWJsZS4gSWYgdGhlIGlucHV0IGlzIGBudWxsYCBvciBgZmFsc2VgLCB0aGUgcmVzdWx0IGlzIDAuIElmIHRoZSBpbnB1dCBpcyBgdHJ1ZWAsIHRoZSByZXN1bHQgaXMgMS4gSWYgdGhlIGlucHV0IGlzIGEgc3RyaW5nLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgYXMgc3BlY2lmaWVkIGJ5IHRoZSBbXFxcIlRvTnVtYmVyIEFwcGxpZWQgdG8gdGhlIFN0cmluZyBUeXBlXFxcIiBhbGdvcml0aG1dKGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbnVtYmVyLWFwcGxpZWQtdG8tdGhlLXN0cmluZy10eXBlKSBvZiB0aGUgRUNNQVNjcmlwdCBMYW5ndWFnZSBTcGVjaWZpY2F0aW9uLiBJZiBtdWx0aXBsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCBlYWNoIG9uZSBpcyBldmFsdWF0ZWQgaW4gb3JkZXIgdW50aWwgdGhlIGZpcnN0IHN1Y2Nlc3NmdWwgY29udmVyc2lvbiBpcyBvYnRhaW5lZC4gSWYgbm9uZSBvZiB0aGUgaW5wdXRzIGNhbiBiZSBjb252ZXJ0ZWQsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuICAgICAgZ3JvdXA6IFwiVHlwZXNcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwidG8tYm9vbGVhblwiOiB7XG4gICAgICBkb2M6IFwiQ29udmVydHMgdGhlIGlucHV0IHZhbHVlIHRvIGEgYm9vbGVhbi4gVGhlIHJlc3VsdCBpcyBgZmFsc2VgIHdoZW4gdGhlbiBpbnB1dCBpcyBhbiBlbXB0eSBzdHJpbmcsIDAsIGBmYWxzZWAsIGBudWxsYCwgb3IgYE5hTmA7IG90aGVyd2lzZSBpdCBpcyBgdHJ1ZWAuXCIsXG4gICAgICBncm91cDogXCJUeXBlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ0by1yZ2JhXCI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIGEgZm91ci1lbGVtZW50IGFycmF5IGNvbnRhaW5pbmcgdGhlIGlucHV0IGNvbG9yJ3MgcmVkLCBncmVlbiwgYmx1ZSwgYW5kIGFscGhhIGNvbXBvbmVudHMsIGluIHRoYXQgb3JkZXIuXCIsXG4gICAgICBncm91cDogXCJDb2xvclwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJ0by1jb2xvclwiOiB7XG4gICAgICBkb2M6IFwiQ29udmVydHMgdGhlIGlucHV0IHZhbHVlIHRvIGEgY29sb3IuIElmIG11bHRpcGxlIHZhbHVlcyBhcmUgcHJvdmlkZWQsIGVhY2ggb25lIGlzIGV2YWx1YXRlZCBpbiBvcmRlciB1bnRpbCB0aGUgZmlyc3Qgc3VjY2Vzc2Z1bCBjb252ZXJzaW9uIGlzIG9idGFpbmVkLiBJZiBub25lIG9mIHRoZSBpbnB1dHMgY2FuIGJlIGNvbnZlcnRlZCwgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG4gICAgICBncm91cDogXCJUeXBlc1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmdiOiB7XG4gICAgICBkb2M6IFwiQ3JlYXRlcyBhIGNvbG9yIHZhbHVlIGZyb20gcmVkLCBncmVlbiwgYW5kIGJsdWUgY29tcG9uZW50cywgd2hpY2ggbXVzdCByYW5nZSBiZXR3ZWVuIDAgYW5kIDI1NSwgYW5kIGFuIGFscGhhIGNvbXBvbmVudCBvZiAxLiBJZiBhbnkgY29tcG9uZW50IGlzIG91dCBvZiByYW5nZSwgdGhlIGV4cHJlc3Npb24gaXMgYW4gZXJyb3IuXCIsXG4gICAgICBncm91cDogXCJDb2xvclwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmdiYToge1xuICAgICAgZG9jOiBcIkNyZWF0ZXMgYSBjb2xvciB2YWx1ZSBmcm9tIHJlZCwgZ3JlZW4sIGJsdWUgY29tcG9uZW50cywgd2hpY2ggbXVzdCByYW5nZSBiZXR3ZWVuIDAgYW5kIDI1NSwgYW5kIGFuIGFscGhhIGNvbXBvbmVudCB3aGljaCBtdXN0IHJhbmdlIGJldHdlZW4gMCBhbmQgMS4gSWYgYW55IGNvbXBvbmVudCBpcyBvdXQgb2YgcmFuZ2UsIHRoZSBleHByZXNzaW9uIGlzIGFuIGVycm9yLlwiLFxuICAgICAgZ3JvdXA6IFwiQ29sb3JcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDoge1xuICAgICAgZG9jOiBcIlJldHJpZXZlcyBhIHByb3BlcnR5IHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgZmVhdHVyZSdzIHByb3BlcnRpZXMsIG9yIGZyb20gYW5vdGhlciBvYmplY3QgaWYgYSBzZWNvbmQgYXJndW1lbnQgaXMgcHJvdmlkZWQuIFJldHVybnMgbnVsbCBpZiB0aGUgcmVxdWVzdGVkIHByb3BlcnR5IGlzIG1pc3NpbmcuXCIsXG4gICAgICBncm91cDogXCJMb29rdXBcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhczoge1xuICAgICAgZG9jOiBcIlRlc3RzIGZvciB0aGUgcHJlc2VuY2Ugb2YgYW4gcHJvcGVydHkgdmFsdWUgaW4gdGhlIGN1cnJlbnQgZmVhdHVyZSdzIHByb3BlcnRpZXMsIG9yIGZyb20gYW5vdGhlciBvYmplY3QgaWYgYSBzZWNvbmQgYXJndW1lbnQgaXMgcHJvdmlkZWQuXCIsXG4gICAgICBncm91cDogXCJMb29rdXBcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxlbmd0aDoge1xuICAgICAgZG9jOiBcIkdldHMgdGhlIGxlbmd0aCBvZiBhbiBhcnJheSBvciBzdHJpbmcuXCIsXG4gICAgICBncm91cDogXCJMb29rdXBcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGRvYzogXCJHZXRzIHRoZSBmZWF0dXJlIHByb3BlcnRpZXMgb2JqZWN0LiAgTm90ZSB0aGF0IGluIHNvbWUgY2FzZXMsIGl0IG1heSBiZSBtb3JlIGVmZmljaWVudCB0byB1c2UgW1xcXCJnZXRcXFwiLCBcXFwicHJvcGVydHlfbmFtZVxcXCJdIGRpcmVjdGx5LlwiLFxuICAgICAgZ3JvdXA6IFwiRmVhdHVyZSBkYXRhXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImZlYXR1cmUtc3RhdGVcIjoge1xuICAgICAgZG9jOiBcIlJldHJpZXZlcyBhIHByb3BlcnR5IHZhbHVlIGZyb20gdGhlIGN1cnJlbnQgZmVhdHVyZSdzIHN0YXRlLiBSZXR1cm5zIG51bGwgaWYgdGhlIHJlcXVlc3RlZCBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCBvbiB0aGUgZmVhdHVyZSdzIHN0YXRlLiBBIGZlYXR1cmUncyBzdGF0ZSBpcyBub3QgcGFydCBvZiB0aGUgR2VvSlNPTiBvciB2ZWN0b3IgdGlsZSBkYXRhLCBhbmQgbXVzdCBiZSBzZXQgcHJvZ3JhbW1hdGljYWxseSBvbiBlYWNoIGZlYXR1cmUuIEZlYXR1cmVzIGFyZSBpZGVudGlmaWVkIGJ5IHRoZWlyIGBpZGAgYXR0cmlidXRlLCB3aGljaCBtdXN0IGJlIGFuIGludGVnZXIgb3IgYSBzdHJpbmcgdGhhdCBjYW4gYmUgY2FzdCB0byBhbiBpbnRlZ2VyLiBOb3RlIHRoYXQgW1xcXCJmZWF0dXJlLXN0YXRlXFxcIl0gY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHBhaW50IHByb3BlcnRpZXMgdGhhdCBzdXBwb3J0IGRhdGEtZHJpdmVuIHN0eWxpbmcuXCIsXG4gICAgICBncm91cDogXCJGZWF0dXJlIGRhdGFcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDYuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZ2VvbWV0cnktdHlwZVwiOiB7XG4gICAgICBkb2M6IFwiR2V0cyB0aGUgZmVhdHVyZSdzIGdlb21ldHJ5IHR5cGU6IGBQb2ludGAsIGBNdWx0aVBvaW50YCwgYExpbmVTdHJpbmdgLCBgTXVsdGlMaW5lU3RyaW5nYCwgYFBvbHlnb25gLCBgTXVsdGlQb2x5Z29uYC5cIixcbiAgICAgIGdyb3VwOiBcIkZlYXR1cmUgZGF0YVwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaWQ6IHtcbiAgICAgIGRvYzogXCJHZXRzIHRoZSBmZWF0dXJlJ3MgaWQsIGlmIGl0IGhhcyBvbmUuXCIsXG4gICAgICBncm91cDogXCJGZWF0dXJlIGRhdGFcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHpvb206IHtcbiAgICAgIGRvYzogXCJHZXRzIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwuICBOb3RlIHRoYXQgaW4gc3R5bGUgbGF5b3V0IGFuZCBwYWludCBwcm9wZXJ0aWVzLCBbXFxcInpvb21cXFwiXSBtYXkgb25seSBhcHBlYXIgYXMgdGhlIGlucHV0IHRvIGEgdG9wLWxldmVsIFxcXCJzdGVwXFxcIiBvciBcXFwiaW50ZXJwb2xhdGVcXFwiIGV4cHJlc3Npb24uXCIsXG4gICAgICBncm91cDogXCJab29tXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImhlYXRtYXAtZGVuc2l0eVwiOiB7XG4gICAgICBkb2M6IFwiR2V0cyB0aGUga2VybmVsIGRlbnNpdHkgZXN0aW1hdGlvbiBvZiBhIHBpeGVsIGluIGEgaGVhdG1hcCBsYXllciwgd2hpY2ggaXMgYSByZWxhdGl2ZSBtZWFzdXJlIG9mIGhvdyBtYW55IGRhdGEgcG9pbnRzIGFyZSBjcm93ZGVkIGFyb3VuZCBhIHBhcnRpY3VsYXIgcGl4ZWwuIENhbiBvbmx5IGJlIHVzZWQgaW4gdGhlIGBoZWF0bWFwLWNvbG9yYCBwcm9wZXJ0eS5cIixcbiAgICAgIGdyb3VwOiBcIkhlYXRtYXBcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwibGluZS1wcm9ncmVzc1wiOiB7XG4gICAgICBkb2M6IFwiR2V0cyB0aGUgcHJvZ3Jlc3MgYWxvbmcgYSBncmFkaWVudCBsaW5lLiBDYW4gb25seSBiZSB1c2VkIGluIHRoZSBgbGluZS1ncmFkaWVudGAgcHJvcGVydHkuXCIsXG4gICAgICBncm91cDogXCJGZWF0dXJlIGRhdGFcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDUuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi41LjBcIixcbiAgICAgICAgICBpb3M6IFwiNC42LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjEyLjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcInNreS1yYWRpYWwtcHJvZ3Jlc3NcIjoge1xuICAgICAgZG9jOiBcIkdldHMgdGhlIGRpc3RhbmNlIG9mIGEgcG9pbnQgb24gdGhlIHNreSBmcm9tIHRoZSBzdW4gcG9zaXRpb24uIFJldHVybnMgMCBhdCBzdW4gcG9zaXRpb24gYW5kIDEgd2hlbiB0aGUgZGlzdGFuY2UgcmVhY2hlcyBgc2t5LWdyYWRpZW50LXJhZGl1c2AuIENhbiBvbmx5IGJlIHVzZWQgaW4gdGhlIGBza3ktZ3JhZGllbnRgIHByb3BlcnR5LlwiLFxuICAgICAgZ3JvdXA6IFwic2t5XCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIyLjAuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFjY3VtdWxhdGVkOiB7XG4gICAgICBkb2M6IFwiR2V0cyB0aGUgdmFsdWUgb2YgYSBjbHVzdGVyIHByb3BlcnR5IGFjY3VtdWxhdGVkIHNvIGZhci4gQ2FuIG9ubHkgYmUgdXNlZCBpbiB0aGUgYGNsdXN0ZXJQcm9wZXJ0aWVzYCBvcHRpb24gb2YgYSBjbHVzdGVyZWQgR2VvSlNPTiBzb3VyY2UuXCIsXG4gICAgICBncm91cDogXCJGZWF0dXJlIGRhdGFcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNTMuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiK1wiOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgc3VtIG9mIHRoZSBpbnB1dHMuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIipcIjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhlIGlucHV0cy5cIixcbiAgICAgIGdyb3VwOiBcIk1hdGhcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiLVwiOiB7XG4gICAgICBkb2M6IFwiRm9yIHR3byBpbnB1dHMsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGluZyB0aGUgc2Vjb25kIGlucHV0IGZyb20gdGhlIGZpcnN0LiBGb3IgYSBzaW5nbGUgaW5wdXQsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGluZyBpdCBmcm9tIDAuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIi9cIjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIHJlc3VsdCBvZiBmbG9hdGluZyBwb2ludCBkaXZpc2lvbiBvZiB0aGUgZmlyc3QgaW5wdXQgYnkgdGhlIHNlY29uZC5cIixcbiAgICAgIGdyb3VwOiBcIk1hdGhcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiJVwiOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgcmVtYWluZGVyIGFmdGVyIGludGVnZXIgZGl2aXNpb24gb2YgdGhlIGZpcnN0IGlucHV0IGJ5IHRoZSBzZWNvbmQuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIl5cIjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIHJlc3VsdCBvZiByYWlzaW5nIHRoZSBmaXJzdCBpbnB1dCB0byB0aGUgcG93ZXIgc3BlY2lmaWVkIGJ5IHRoZSBzZWNvbmQuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzcXJ0OiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIGlucHV0LlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40Mi4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbG9nMTA6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBiYXNlLXRlbiBsb2dhcml0aG0gb2YgdGhlIGlucHV0LlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbG46IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiB0aGUgaW5wdXQuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsb2cyOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgYmFzZS10d28gbG9nYXJpdGhtIG9mIHRoZSBpbnB1dC5cIixcbiAgICAgIGdyb3VwOiBcIk1hdGhcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNpbjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIHNpbmUgb2YgdGhlIGlucHV0LlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29zOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgY29zaW5lIG9mIHRoZSBpbnB1dC5cIixcbiAgICAgIGdyb3VwOiBcIk1hdGhcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHRhbjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIHRhbmdlbnQgb2YgdGhlIGlucHV0LlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYXNpbjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIGFyY3NpbmUgb2YgdGhlIGlucHV0LlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWNvczoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIGFyY2Nvc2luZSBvZiB0aGUgaW5wdXQuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhdGFuOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgYXJjdGFuZ2VudCBvZiB0aGUgaW5wdXQuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtaW46IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlIG9mIHRoZSBpbnB1dHMuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtYXg6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBpbnB1dHMuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByb3VuZDoge1xuICAgICAgZG9jOiBcIlJvdW5kcyB0aGUgaW5wdXQgdG8gdGhlIG5lYXJlc3QgaW50ZWdlci4gSGFsZndheSB2YWx1ZXMgYXJlIHJvdW5kZWQgYXdheSBmcm9tIHplcm8uIEZvciBleGFtcGxlLCBgW1xcXCJyb3VuZFxcXCIsIC0xLjVdYCBldmFsdWF0ZXMgdG8gLTIuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhYnM6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGUgaW5wdXQuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjZWlsOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgc21hbGxlc3QgaW50ZWdlciB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgaW5wdXQuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmbG9vcjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIGxhcmdlc3QgaW50ZWdlciB0aGF0IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgaW5wdXQuXCIsXG4gICAgICBncm91cDogXCJNYXRoXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaXN0YW5jZToge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIHNob3J0ZXN0IGRpc3RhbmNlIGluIG1ldGVycyBiZXR3ZWVuIHRoZSBldmFsdWF0ZWQgZmVhdHVyZSBhbmQgdGhlIGlucHV0IGdlb21ldHJ5LiBUaGUgaW5wdXQgdmFsdWUgY2FuIGJlIGEgdmFsaWQgR2VvSlNPTiBvZiB0eXBlIGBQb2ludGAsIGBNdWx0aVBvaW50YCwgYExpbmVTdHJpbmdgLCBgTXVsdGlMaW5lU3RyaW5nYCwgYFBvbHlnb25gLCBgTXVsdGlQb2x5Z29uYCwgYEZlYXR1cmVgLCBvciBgRmVhdHVyZUNvbGxlY3Rpb25gLiBEaXN0YW5jZSB2YWx1ZXMgcmV0dXJuZWQgbWF5IHZhcnkgaW4gcHJlY2lzaW9uIGR1ZSB0byBsb3NzIGluIHByZWNpc2lvbiBmcm9tIGVuY29kaW5nIGdlb21ldHJpZXMsIHBhcnRpY3VsYXJseSBiZWxvdyB6b29tIGxldmVsIDEzLlwiLFxuICAgICAgZ3JvdXA6IFwiTWF0aFwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAgYW5kcm9pZDogXCI5LjIuMFwiLFxuICAgICAgICAgIGlvczogXCI1LjkuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuMTYuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiPT1cIjoge1xuICAgICAgZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCB2YWx1ZXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGNvbXBhcmlzb24gaXMgc3RyaWN0bHkgdHlwZWQ6IHZhbHVlcyBvZiBkaWZmZXJlbnQgcnVudGltZSB0eXBlcyBhcmUgYWx3YXlzIGNvbnNpZGVyZWQgdW5lcXVhbC4gQ2FzZXMgd2hlcmUgdGhlIHR5cGVzIGFyZSBrbm93biB0byBiZSBkaWZmZXJlbnQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbnZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG4gICAgICBncm91cDogXCJEZWNpc2lvblwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgY29sbGF0b3I6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuNS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC45LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIiE9XCI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaW5wdXQgdmFsdWVzIGFyZSBub3QgZXF1YWwsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgY29tcGFyaXNvbiBpcyBzdHJpY3RseSB0eXBlZDogdmFsdWVzIG9mIGRpZmZlcmVudCBydW50aW1lIHR5cGVzIGFyZSBhbHdheXMgY29uc2lkZXJlZCB1bmVxdWFsLiBDYXNlcyB3aGVyZSB0aGUgdHlwZXMgYXJlIGtub3duIHRvIGJlIGRpZmZlcmVudCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGludmFsaWQgYW5kIHdpbGwgcHJvZHVjZSBhIHBhcnNlIGVycm9yLiBBY2NlcHRzIGFuIG9wdGlvbmFsIGBjb2xsYXRvcmAgYXJndW1lbnQgdG8gY29udHJvbCBsb2NhbGUtZGVwZW5kZW50IHN0cmluZyBjb21wYXJpc29ucy5cIixcbiAgICAgIGdyb3VwOiBcIkRlY2lzaW9uXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9LFxuICAgICAgICBjb2xsYXRvcjoge1xuICAgICAgICAgIGpzOiBcIjAuNDUuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi41LjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4yLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjkuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiPlwiOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGlucHV0IGlzIHN0cmljdGx5IGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGFyZ3VtZW50cyBhcmUgcmVxdWlyZWQgdG8gYmUgZWl0aGVyIGJvdGggc3RyaW5ncyBvciBib3RoIG51bWJlcnM7IGlmIGR1cmluZyBldmFsdWF0aW9uIHRoZXkgYXJlIG5vdCwgZXhwcmVzc2lvbiBldmFsdWF0aW9uIHByb2R1Y2VzIGFuIGVycm9yLiBDYXNlcyB3aGVyZSB0aGlzIGNvbnN0cmFpbnQgaXMga25vd24gbm90IHRvIGhvbGQgYXQgcGFyc2UgdGltZSBhcmUgY29uc2lkZXJlZCBpbiB2YWxpZCBhbmQgd2lsbCBwcm9kdWNlIGEgcGFyc2UgZXJyb3IuIEFjY2VwdHMgYW4gb3B0aW9uYWwgYGNvbGxhdG9yYCBhcmd1bWVudCB0byBjb250cm9sIGxvY2FsZS1kZXBlbmRlbnQgc3RyaW5nIGNvbXBhcmlzb25zLlwiLFxuICAgICAgZ3JvdXA6IFwiRGVjaXNpb25cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIGNvbGxhdG9yOiB7XG4gICAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjUuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjIuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuOS4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXCI8XCI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgc3RyaWN0bHkgbGVzcyB0aGFuIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG4gICAgICBncm91cDogXCJEZWNpc2lvblwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgY29sbGF0b3I6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuNS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC45LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIj49XCI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG4gICAgICBncm91cDogXCJEZWNpc2lvblwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgY29sbGF0b3I6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuNS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC45LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIjw9XCI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgaW5wdXQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgYXJndW1lbnRzIGFyZSByZXF1aXJlZCB0byBiZSBlaXRoZXIgYm90aCBzdHJpbmdzIG9yIGJvdGggbnVtYmVyczsgaWYgZHVyaW5nIGV2YWx1YXRpb24gdGhleSBhcmUgbm90LCBleHByZXNzaW9uIGV2YWx1YXRpb24gcHJvZHVjZXMgYW4gZXJyb3IuIENhc2VzIHdoZXJlIHRoaXMgY29uc3RyYWludCBpcyBrbm93biBub3QgdG8gaG9sZCBhdCBwYXJzZSB0aW1lIGFyZSBjb25zaWRlcmVkIGluIHZhbGlkIGFuZCB3aWxsIHByb2R1Y2UgYSBwYXJzZSBlcnJvci4gQWNjZXB0cyBhbiBvcHRpb25hbCBgY29sbGF0b3JgIGFyZ3VtZW50IHRvIGNvbnRyb2wgbG9jYWxlLWRlcGVuZGVudCBzdHJpbmcgY29tcGFyaXNvbnMuXCIsXG4gICAgICBncm91cDogXCJEZWNpc2lvblwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgY29sbGF0b3I6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuNS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC45LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhbGw6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIGB0cnVlYCBpZiBhbGwgdGhlIGlucHV0cyBhcmUgYHRydWVgLCBgZmFsc2VgIG90aGVyd2lzZS4gVGhlIGlucHV0cyBhcmUgZXZhbHVhdGVkIGluIG9yZGVyLCBhbmQgZXZhbHVhdGlvbiBpcyBzaG9ydC1jaXJjdWl0aW5nOiBvbmNlIGFuIGlucHV0IGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIGBmYWxzZWAsIHRoZSByZXN1bHQgaXMgYGZhbHNlYCBhbmQgbm8gZnVydGhlciBpbnB1dCBleHByZXNzaW9ucyBhcmUgZXZhbHVhdGVkLlwiLFxuICAgICAgZ3JvdXA6IFwiRGVjaXNpb25cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFueToge1xuICAgICAgZG9jOiBcIlJldHVybnMgYHRydWVgIGlmIGFueSBvZiB0aGUgaW5wdXRzIGFyZSBgdHJ1ZWAsIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgaW5wdXRzIGFyZSBldmFsdWF0ZWQgaW4gb3JkZXIsIGFuZCBldmFsdWF0aW9uIGlzIHNob3J0LWNpcmN1aXRpbmc6IG9uY2UgYW4gaW5wdXQgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gYHRydWVgLCB0aGUgcmVzdWx0IGlzIGB0cnVlYCBhbmQgbm8gZnVydGhlciBpbnB1dCBleHByZXNzaW9ucyBhcmUgZXZhbHVhdGVkLlwiLFxuICAgICAgZ3JvdXA6IFwiRGVjaXNpb25cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiIVwiOiB7XG4gICAgICBkb2M6IFwiTG9naWNhbCBuZWdhdGlvbi4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IGlzIGBmYWxzZWAsIGFuZCBgZmFsc2VgIGlmIHRoZSBpbnB1dCBpcyBgdHJ1ZWAuXCIsXG4gICAgICBncm91cDogXCJEZWNpc2lvblwiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgd2l0aGluOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGV2YWx1YXRlZCBmZWF0dXJlIGlzIGZ1bGx5IGNvbnRhaW5lZCBpbnNpZGUgYSBib3VuZGFyeSBvZiB0aGUgaW5wdXQgZ2VvbWV0cnksIGBmYWxzZWAgb3RoZXJ3aXNlLiBUaGUgaW5wdXQgdmFsdWUgY2FuIGJlIGEgdmFsaWQgR2VvSlNPTiBvZiB0eXBlIGBQb2x5Z29uYCwgYE11bHRpUG9seWdvbmAsIGBGZWF0dXJlYCwgb3IgYEZlYXR1cmVDb2xsZWN0aW9uYC4gU3VwcG9ydGVkIGZlYXR1cmVzIGZvciBldmFsdWF0aW9uOlxcbi0gYFBvaW50YDogUmV0dXJucyBgZmFsc2VgIGlmIGEgcG9pbnQgaXMgb24gdGhlIGJvdW5kYXJ5IG9yIGZhbGxzIG91dHNpZGUgdGhlIGJvdW5kYXJ5Llxcbi0gYExpbmVTdHJpbmdgOiBSZXR1cm5zIGBmYWxzZWAgaWYgYW55IHBhcnQgb2YgYSBsaW5lIGZhbGxzIG91dHNpZGUgdGhlIGJvdW5kYXJ5LCB0aGUgbGluZSBpbnRlcnNlY3RzIHRoZSBib3VuZGFyeSwgb3IgYSBsaW5lJ3MgZW5kcG9pbnQgaXMgb24gdGhlIGJvdW5kYXJ5LlwiLFxuICAgICAgZ3JvdXA6IFwiRGVjaXNpb25cIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjEuOS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI5LjEuMFwiLFxuICAgICAgICAgIGlvczogXCI1LjguMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuMTUuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiaXMtc3VwcG9ydGVkLXNjcmlwdFwiOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGlucHV0IHN0cmluZyBpcyBleHBlY3RlZCB0byByZW5kZXIgbGVnaWJseS4gUmV0dXJucyBgZmFsc2VgIGlmIHRoZSBpbnB1dCBzdHJpbmcgY29udGFpbnMgc2VjdGlvbnMgdGhhdCBjYW5ub3QgYmUgcmVuZGVyZWQgd2l0aG91dCBwb3RlbnRpYWwgbG9zcyBvZiBtZWFuaW5nIChlLmcuIEluZGljIHNjcmlwdHMgdGhhdCByZXF1aXJlIGNvbXBsZXggdGV4dCBzaGFwaW5nLCBvciByaWdodC10by1sZWZ0IHNjcmlwdHMgaWYgdGhlIHRoZSBgbWFwYm94LWdsLXJ0bC10ZXh0YCBwbHVnaW4gaXMgbm90IGluIHVzZSBpbiBNYXBib3ggR0wgSlMpLlwiLFxuICAgICAgZ3JvdXA6IFwiU3RyaW5nXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQ1LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuNi4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgdXBjYXNlOiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyB0aGUgaW5wdXQgc3RyaW5nIGNvbnZlcnRlZCB0byB1cHBlcmNhc2UuIEZvbGxvd3MgdGhlIFVuaWNvZGUgRGVmYXVsdCBDYXNlIENvbnZlcnNpb24gYWxnb3JpdGhtIGFuZCB0aGUgbG9jYWxlLWluc2Vuc2l0aXZlIGNhc2UgbWFwcGluZ3MgaW4gdGhlIFVuaWNvZGUgQ2hhcmFjdGVyIERhdGFiYXNlLlwiLFxuICAgICAgZ3JvdXA6IFwiU3RyaW5nXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkb3duY2FzZToge1xuICAgICAgZG9jOiBcIlJldHVybnMgdGhlIGlucHV0IHN0cmluZyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlLiBGb2xsb3dzIHRoZSBVbmljb2RlIERlZmF1bHQgQ2FzZSBDb252ZXJzaW9uIGFsZ29yaXRobSBhbmQgdGhlIGxvY2FsZS1pbnNlbnNpdGl2ZSBjYXNlIG1hcHBpbmdzIGluIHRoZSBVbmljb2RlIENoYXJhY3RlciBEYXRhYmFzZS5cIixcbiAgICAgIGdyb3VwOiBcIlN0cmluZ1wiLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY29uY2F0OiB7XG4gICAgICBkb2M6IFwiUmV0dXJucyBhIGBzdHJpbmdgIGNvbnNpc3Rpbmcgb2YgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIGlucHV0cy4gRWFjaCBpbnB1dCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgYXMgaWYgYnkgYHRvLXN0cmluZ2AuXCIsXG4gICAgICBncm91cDogXCJTdHJpbmdcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwicmVzb2x2ZWQtbG9jYWxlXCI6IHtcbiAgICAgIGRvYzogXCJSZXR1cm5zIHRoZSBJRVRGIGxhbmd1YWdlIHRhZyBvZiB0aGUgbG9jYWxlIGJlaW5nIHVzZWQgYnkgdGhlIHByb3ZpZGVkIGBjb2xsYXRvcmAuIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IHN5c3RlbSBsb2NhbGUsIG9yIHRvIGRldGVybWluZSBpZiBhIHJlcXVlc3RlZCBsb2NhbGUgd2FzIHN1Y2Nlc3NmdWxseSBsb2FkZWQuXCIsXG4gICAgICBncm91cDogXCJTdHJpbmdcIixcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDUuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi41LjBcIixcbiAgICAgICAgICBpb3M6IFwiNC4yLjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjkuMFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgZm9nID0ge1xuICByYW5nZToge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBcImRlZmF1bHRcIjogWzAuNSwgMTBdLFxuICAgIG1pbmltdW06IC0yMCxcbiAgICBtYXhpbXVtOiAyMCxcbiAgICBsZW5ndGg6IDIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgZG9jOiBcIlRoZSBzdGFydCBhbmQgZW5kIGRpc3RhbmNlIHJhbmdlIGluIHdoaWNoIGZvZyBmYWRlcyBmcm9tIGZ1bGx5IHRyYW5zcGFyZW50IHRvIGZ1bGx5IG9wYXF1ZS4gVGhlIGRpc3RhbmNlIHRvIHRoZSBwb2ludCBhdCB0aGUgY2VudGVyIG9mIHRoZSBtYXAgaXMgZGVmaW5lZCBhcyB6ZXJvLCBzbyB0aGF0IG5lZ2F0aXZlIHJhbmdlIHZhbHVlcyBhcmUgY2xvc2VyIHRvIHRoZSBjYW1lcmEsIGFuZCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIGZhcnRoZXIgYXdheS5cIixcbiAgICBleGFtcGxlOiBbMC41LCAxMF0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIyLjMuMFwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb2xvcjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiI2ZmZmZmZlwiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgZG9jOiBcIlRoZSBjb2xvciBvZiB0aGUgZm9nLiBVc2luZyBvcGFjaXR5IGlzIHJlY29tbWVuZGVkIG9ubHkgZm9yIHNtb290aGx5IHRyYW5zaXRpb25pbmcgZm9nIG9uL29mZiBhcyBhbnl0aGluZyBsZXNzIHRoYW4gMTAwJSBvcGFjaXR5IHJlc3VsdHMgaW4gbW9yZSB0aWxlcyBsb2FkZWQgYW5kIGRyYXduLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4zLjBcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJob3Jpem9uLWJsZW5kXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICBcImRlZmF1bHRcIjogMC4xLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIGRvYzogXCJIb3Jpem9uIGJsZW5kIGFwcGxpZXMgYSBzbW9vdGggZmFkZSBmcm9tIHRoZSBjb2xvciBvZiB0aGUgZm9nIHRvIHRoZSBjb2xvciBvZiB0aGUgc2t5LiBBIHZhbHVlIG9mIHplcm8gbGVhdmVzIGEgc2hhcnAgdHJhbnNpdGlvbiBmcm9tIGZvZyB0byBza3kuIEluY3JlYXNpbmcgdGhlIHZhbHVlIGJsZW5kcyB0aGUgY29sb3Igb2YgZm9nIGludG8gaW5jcmVhc2luZ2x5IGhpZ2ggYW5nbGVzIG9mIHRoZSBza3kuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIyLjMuMFwiXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIGxpZ2h0ID0ge1xuICBhbmNob3I6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7XG4gICAgICAgIGRvYzogXCJUaGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSBpcyBhbGlnbmVkIHRvIHRoZSByb3RhdGlvbiBvZiB0aGUgbWFwLlwiXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBwb3NpdGlvbiBvZiB0aGUgbGlnaHQgc291cmNlIGlzIGFsaWduZWQgdG8gdGhlIHJvdGF0aW9uIG9mIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiLFxuICAgIHRyYW5zaXRpb246IGZhbHNlLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBkb2M6IFwiV2hldGhlciBleHRydWRlZCBnZW9tZXRyaWVzIGFyZSBsaXQgcmVsYXRpdmUgdG8gdGhlIG1hcCBvciB2aWV3cG9ydC5cIixcbiAgICBleGFtcGxlOiBcIm1hcFwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4yNy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4xLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvc2l0aW9uOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIFwiZGVmYXVsdFwiOiBbMS4xNSwgMjEwLCAzMF0sXG4gICAgbGVuZ3RoOiAzLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIGRvYzogXCJQb3NpdGlvbiBvZiB0aGUgbGlnaHQgc291cmNlIHJlbGF0aXZlIHRvIGxpdCAoZXh0cnVkZWQpIGdlb21ldHJpZXMsIGluIFtyIHJhZGlhbCBjb29yZGluYXRlLCBhIGF6aW11dGhhbCBhbmdsZSwgcCBwb2xhciBhbmdsZV0gd2hlcmUgciBpbmRpY2F0ZXMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgYmFzZSBvZiBhbiBvYmplY3QgdG8gaXRzIGxpZ2h0LCBhIGluZGljYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGxpZ2h0IHJlbGF0aXZlIHRvIDDCsCAoMMKwIHdoZW4gYGxpZ2h0LmFuY2hvcmAgaXMgc2V0IHRvIGB2aWV3cG9ydGAgY29ycmVzcG9uZHMgdG8gdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQsIG9yIDDCsCB3aGVuIGBsaWdodC5hbmNob3JgIGlzIHNldCB0byBgbWFwYCBjb3JyZXNwb25kcyB0byBkdWUgbm9ydGgsIGFuZCBkZWdyZWVzIHByb2NlZWQgY2xvY2t3aXNlKSwgYW5kIHAgaW5kaWNhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGxpZ2h0IChmcm9tIDDCsCwgZGlyZWN0bHkgYWJvdmUsIHRvIDE4MMKwLCBkaXJlY3RseSBiZWxvdykuXCIsXG4gICAgZXhhbXBsZTogWzEuNSwgOTAsIDgwXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMjcuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb2xvcjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiI2ZmZmZmZlwiLFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgZG9jOiBcIkNvbG9yIHRpbnQgZm9yIGxpZ2h0aW5nIGV4dHJ1ZGVkIGdlb21ldHJpZXMuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgaW50ZW5zaXR5OiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCIsXG4gICAgXCJkZWZhdWx0XCI6IDAuNSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBkb2M6IFwiSW50ZW5zaXR5IG9mIGxpZ2h0aW5nIChvbiBhIHNjYWxlIGZyb20gMCB0byAxKS4gSGlnaGVyIG51bWJlcnMgd2lsbCBwcmVzZW50IGFzIG1vcmUgZXh0cmVtZSBjb250cmFzdC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMjcuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIHRlcnJhaW4gPSB7XG4gIHNvdXJjZToge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIk5hbWUgb2YgYSBzb3VyY2Ugb2YgYHJhc3Rlcl9kZW1gIHR5cGUgdG8gYmUgdXNlZCBmb3IgdGVycmFpbiBlbGV2YXRpb24uXCIsXG4gICAgcmVxdWlyZWQ6IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIyLjAuMFwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBleGFnZ2VyYXRpb246IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEwMDAsXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBkb2M6IFwiRXhhZ2dlcmF0ZXMgdGhlIGVsZXZhdGlvbiBvZiB0aGUgdGVycmFpbiBieSBtdWx0aXBseWluZyB0aGUgZGF0YSBmcm9tIHRoZSBERU0gd2l0aCB0aGlzIHZhbHVlLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4wLjBcIlxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnZhciBwYWludCA9IFtcInBhaW50X2ZpbGxcIiwgXCJwYWludF9saW5lXCIsIFwicGFpbnRfY2lyY2xlXCIsIFwicGFpbnRfaGVhdG1hcFwiLCBcInBhaW50X2ZpbGwtZXh0cnVzaW9uXCIsIFwicGFpbnRfc3ltYm9sXCIsIFwicGFpbnRfcmFzdGVyXCIsIFwicGFpbnRfaGlsbHNoYWRlXCIsIFwicGFpbnRfYmFja2dyb3VuZFwiLCBcInBhaW50X3NreVwiXTtcbnZhciBwYWludF9maWxsID0ge1xuICBcImZpbGwtYW50aWFsaWFzXCI6IHtcbiAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICBkb2M6IFwiV2hldGhlciBvciBub3QgdGhlIGZpbGwgc2hvdWxkIGJlIGFudGlhbGlhc2VkLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJmaWxsLW9wYWNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIGRvYzogXCJUaGUgb3BhY2l0eSBvZiB0aGUgZW50aXJlIGZpbGwgbGF5ZXIuIEluIGNvbnRyYXN0IHRvIHRoZSBgZmlsbC1jb2xvcmAsIHRoaXMgdmFsdWUgd2lsbCBhbHNvIGFmZmVjdCB0aGUgMXB4IHN0cm9rZSBhcm91bmQgdGhlIGZpbGwsIGlmIHRoZSBzdHJva2UgaXMgdXNlZC5cIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjIxLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiZmlsbC1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICBkb2M6IFwiVGhlIGNvbG9yIG9mIHRoZSBmaWxsZWQgcGFydCBvZiB0aGlzIGxheWVyLiBUaGlzIGNvbG9yIGNhbiBiZSBzcGVjaWZpZWQgYXMgYHJnYmFgIHdpdGggYW4gYWxwaGEgY29tcG9uZW50IGFuZCB0aGUgY29sb3IncyBvcGFjaXR5IHdpbGwgbm90IGFmZmVjdCB0aGUgb3BhY2l0eSBvZiB0aGUgMXB4IHN0cm9rZSwgaWYgaXQgaXMgdXNlZC5cIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCIhXCI6IFwiZmlsbC1wYXR0ZXJuXCJcbiAgICB9XSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4xOS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImZpbGwtb3V0bGluZS1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIGRvYzogXCJUaGUgb3V0bGluZSBjb2xvciBvZiB0aGUgZmlsbC4gTWF0Y2hlcyB0aGUgdmFsdWUgb2YgYGZpbGwtY29sb3JgIGlmIHVuc3BlY2lmaWVkLlwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgcmVxdWlyZXM6IFt7XG4gICAgICBcIiFcIjogXCJmaWxsLXBhdHRlcm5cIlxuICAgIH0sIHtcbiAgICAgIFwiZmlsbC1hbnRpYWxpYXNcIjogdHJ1ZVxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjE5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiZmlsbC10cmFuc2xhdGVcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDIsXG4gICAgXCJkZWZhdWx0XCI6IFswLCAwXSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImZpbGwtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBmaWxsIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgZmlsbCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBmaWxsLXRyYW5zbGF0ZWAuXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgcmVxdWlyZXM6IFtcImZpbGwtdHJhbnNsYXRlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJmaWxsLXBhdHRlcm5cIjoge1xuICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBpbWFnZSBmaWxscy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuIE5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuNDkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTEuMFwiLFxuICAgICAgICBpb3M6IFwiNC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiXG4gIH1cbn07XG52YXIgcGFpbnRfbGluZSA9IHtcbiAgXCJsaW5lLW9wYWNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZG9jOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBsaW5lIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMjkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgZG9jOiBcIlRoZSBjb2xvciB3aXRoIHdoaWNoIHRoZSBsaW5lIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgcmVxdWlyZXM6IFt7XG4gICAgICBcIiFcIjogXCJsaW5lLXBhdHRlcm5cIlxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjIzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwibGluZS10cmFuc2xhdGVcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDIsXG4gICAgXCJkZWZhdWx0XCI6IFswLCAwXSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImxpbmUtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBsaW5lIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgbGluZSBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBsaW5lLXRyYW5zbGF0ZWAuXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgcmVxdWlyZXM6IFtcImxpbmUtdHJhbnNsYXRlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJsaW5lLXdpZHRoXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiU3Ryb2tlIHRoaWNrbmVzcy5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zOS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNy4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNi4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtZ2FwLXdpZHRoXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgZG9jOiBcIkRyYXdzIGEgbGluZSBjYXNpbmcgb3V0c2lkZSBvZiBhIGxpbmUncyBhY3R1YWwgcGF0aC4gVmFsdWUgaW5kaWNhdGVzIHRoZSB3aWR0aCBvZiB0aGUgaW5uZXIgZ2FwLlwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMjkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLW9mZnNldFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBkb2M6IFwiVGhlIGxpbmUncyBvZmZzZXQuIEZvciBsaW5lYXIgZmVhdHVyZXMsIGEgcG9zaXRpdmUgdmFsdWUgb2Zmc2V0cyB0aGUgbGluZSB0byB0aGUgcmlnaHQsIHJlbGF0aXZlIHRvIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxpbmUsIGFuZCBhIG5lZ2F0aXZlIHZhbHVlIHRvIHRoZSBsZWZ0LiBGb3IgcG9seWdvbiBmZWF0dXJlcywgYSBwb3NpdGl2ZSB2YWx1ZSByZXN1bHRzIGluIGFuIGluc2V0LCBhbmQgYSBuZWdhdGl2ZSB2YWx1ZSByZXN1bHRzIGluIGFuIG91dHNldC5cIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMi4xXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMy4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuMS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjI5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwibGluZS1ibHVyXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiQmx1ciBhcHBsaWVkIHRvIHRoZSBsaW5lLCBpbiBwaXhlbHMuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMjkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJsaW5lLWRhc2hhcnJheVwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJTcGVjaWZpZXMgdGhlIGxlbmd0aHMgb2YgdGhlIGFsdGVybmF0aW5nIGRhc2hlcyBhbmQgZ2FwcyB0aGF0IGZvcm0gdGhlIGRhc2ggcGF0dGVybi4gVGhlIGxlbmd0aHMgYXJlIGxhdGVyIHNjYWxlZCBieSB0aGUgbGluZSB3aWR0aC4gVG8gY29udmVydCBhIGRhc2ggbGVuZ3RoIHRvIHBpeGVscywgbXVsdGlwbHkgdGhlIGxlbmd0aCBieSB0aGUgY3VycmVudCBsaW5lIHdpZHRoLiBOb3RlIHRoYXQgR2VvSlNPTiBzb3VyY2VzIHdpdGggYGxpbmVNZXRyaWNzOiB0cnVlYCBzcGVjaWZpZWQgd29uJ3QgcmVuZGVyIGRhc2hlZCBsaW5lcyB0byB0aGUgZXhwZWN0ZWQgc2NhbGUuIEFsc28gbm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy5cIixcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgdW5pdHM6IFwibGluZSB3aWR0aHNcIixcbiAgICByZXF1aXJlczogW3tcbiAgICAgIFwiIVwiOiBcImxpbmUtcGF0dGVyblwiXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjIuMy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImxpbmUtcGF0dGVyblwiOiB7XG4gICAgdHlwZTogXCJyZXNvbHZlZEltYWdlXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBkb2M6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlIGxpbmVzLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuIE5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuNDkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTEuMFwiLFxuICAgICAgICBpb3M6IFwiNC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjcm9zcy1mYWRlZC1kYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwibGluZS1ncmFkaWVudFwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIGRvYzogXCJEZWZpbmVzIGEgZ3JhZGllbnQgd2l0aCB3aGljaCB0byBjb2xvciBhIGxpbmUgZmVhdHVyZS4gQ2FuIG9ubHkgYmUgdXNlZCB3aXRoIEdlb0pTT04gc291cmNlcyB0aGF0IHNwZWNpZnkgYFxcXCJsaW5lTWV0cmljc1xcXCI6IHRydWVgLlwiLFxuICAgIHRyYW5zaXRpb246IGZhbHNlLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCIhXCI6IFwibGluZS1kYXNoYXJyYXlcIlxuICAgIH0sIHtcbiAgICAgIFwiIVwiOiBcImxpbmUtcGF0dGVyblwiXG4gICAgfSwge1xuICAgICAgc291cmNlOiBcImdlb2pzb25cIixcbiAgICAgIGhhczoge1xuICAgICAgICBsaW5lTWV0cmljczogdHJ1ZVxuICAgICAgfVxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40NS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi41LjBcIixcbiAgICAgICAgaW9zOiBcIjQuNC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMTEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJsaW5lLXByb2dyZXNzXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb2xvci1yYW1wXCJcbiAgfVxufTtcbnZhciBwYWludF9jaXJjbGUgPSB7XG4gIFwiY2lyY2xlLXJhZGl1c1wiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogNSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIkNpcmNsZSByYWRpdXMuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMTguMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJjaXJjbGUtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcImRlZmF1bHRcIjogXCIjMDAwMDAwXCIsXG4gICAgZG9jOiBcIlRoZSBmaWxsIGNvbG9yIG9mIHRoZSBjaXJjbGUuXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4xOC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImNpcmNsZS1ibHVyXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIGRvYzogXCJBbW91bnQgdG8gYmx1ciB0aGUgY2lyY2xlLiAxIGJsdXJzIHRoZSBjaXJjbGUgc3VjaCB0aGF0IG9ubHkgdGhlIGNlbnRlcnBvaW50IGlzIGZ1bGwgb3BhY2l0eS5cIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjIwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiY2lyY2xlLW9wYWNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZG9jOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBjaXJjbGUgd2lsbCBiZSBkcmF3bi5cIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4yMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImNpcmNsZS10cmFuc2xhdGVcIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDIsXG4gICAgXCJkZWZhdWx0XCI6IFswLCAwXSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCwgcmVzcGVjdGl2ZWx5LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImNpcmNsZS10cmFuc2xhdGUtYW5jaG9yXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge1xuICAgICAgICBkb2M6IFwiVGhlIGNpcmNsZSBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSBtYXAuXCJcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBkb2M6IFwiVGhlIGNpcmNsZSBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBjaXJjbGUtdHJhbnNsYXRlYC5cIixcbiAgICBcImRlZmF1bHRcIjogXCJtYXBcIixcbiAgICByZXF1aXJlczogW1wiY2lyY2xlLXRyYW5zbGF0ZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiY2lyY2xlLXBpdGNoLXNjYWxlXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge1xuICAgICAgICBkb2M6IFwiQ2lyY2xlcyBhcmUgc2NhbGVkIGFjY29yZGluZyB0byB0aGVpciBhcHBhcmVudCBkaXN0YW5jZSB0byB0aGUgY2FtZXJhLlwiXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgZG9jOiBcIkNpcmNsZXMgYXJlIG5vdCBzY2FsZWQuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgIGRvYzogXCJDb250cm9scyB0aGUgc2NhbGluZyBiZWhhdmlvciBvZiB0aGUgY2lyY2xlIHdoZW4gdGhlIG1hcCBpcyBwaXRjaGVkLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4yMS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNC4yLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMi4xXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJjaXJjbGUtcGl0Y2gtYWxpZ25tZW50XCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge1xuICAgICAgICBkb2M6IFwiVGhlIGNpcmNsZSBpcyBhbGlnbmVkIHRvIHRoZSBwbGFuZSBvZiB0aGUgbWFwLlwiXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgZG9jOiBcIlRoZSBjaXJjbGUgaXMgYWxpZ25lZCB0byB0aGUgcGxhbmUgb2YgdGhlIHZpZXdwb3J0LlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJ2aWV3cG9ydFwiLFxuICAgIGRvYzogXCJPcmllbnRhdGlvbiBvZiBjaXJjbGUgd2hlbiBtYXAgaXMgcGl0Y2hlZC5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMzkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMi4wXCIsXG4gICAgICAgIGlvczogXCIzLjcuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjYuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiY2lyY2xlLXN0cm9rZS13aWR0aFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIlRoZSB3aWR0aCBvZiB0aGUgY2lyY2xlJ3Mgc3Ryb2tlLiBTdHJva2VzIGFyZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgYGNpcmNsZS1yYWRpdXNgLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4yOS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjI5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiY2lyY2xlLXN0cm9rZS1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICBkb2M6IFwiVGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgY2lyY2xlLlwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjI5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMjkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJjaXJjbGUtc3Ryb2tlLW9wYWNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZG9jOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBjaXJjbGUncyBzdHJva2UuXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjI5LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMjkuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfVxufTtcbnZhciBwYWludF9oZWF0bWFwID0ge1xuICBcImhlYXRtYXAtcmFkaXVzXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAzMCxcbiAgICBtaW5pbXVtOiAxLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIlJhZGl1cyBvZiBpbmZsdWVuY2Ugb2Ygb25lIGhlYXRtYXAgcG9pbnQgaW4gcGl4ZWxzLiBJbmNyZWFzaW5nIHRoZSB2YWx1ZSBtYWtlcyB0aGUgaGVhdG1hcCBzbW9vdGhlciwgYnV0IGxlc3MgZGV0YWlsZWQuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuNDMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJoZWF0bWFwLXdlaWdodFwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246IGZhbHNlLFxuICAgIGRvYzogXCJBIG1lYXN1cmUgb2YgaG93IG11Y2ggYW4gaW5kaXZpZHVhbCBwb2ludCBjb250cmlidXRlcyB0byB0aGUgaGVhdG1hcC4gQSB2YWx1ZSBvZiAxMCB3b3VsZCBiZSBlcXVpdmFsZW50IHRvIGhhdmluZyAxMCBwb2ludHMgb2Ygd2VpZ2h0IDEgaW4gdGhlIHNhbWUgc3BvdC4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiBjb21iaW5lZCB3aXRoIGNsdXN0ZXJpbmcuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjQxLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJoZWF0bWFwLWludGVuc2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgZG9jOiBcIlNpbWlsYXIgdG8gYGhlYXRtYXAtd2VpZ2h0YCBidXQgY29udHJvbHMgdGhlIGludGVuc2l0eSBvZiB0aGUgaGVhdG1hcCBnbG9iYWxseS4gUHJpbWFyaWx5IHVzZWQgZm9yIGFkanVzdGluZyB0aGUgaGVhdG1hcCBiYXNlZCBvbiB6b29tIGxldmVsLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImhlYXRtYXAtY29sb3JcIjoge1xuICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICBcImRlZmF1bHRcIjogW1wiaW50ZXJwb2xhdGVcIiwgW1wibGluZWFyXCJdLCBbXCJoZWF0bWFwLWRlbnNpdHlcIl0sIDAsIFwicmdiYSgwLCAwLCAyNTUsIDApXCIsIDAuMSwgXCJyb3lhbGJsdWVcIiwgMC4zLCBcImN5YW5cIiwgMC41LCBcImxpbWVcIiwgMC43LCBcInllbGxvd1wiLCAxLCBcInJlZFwiXSxcbiAgICBkb2M6IFwiRGVmaW5lcyB0aGUgY29sb3Igb2YgZWFjaCBwaXhlbCBiYXNlZCBvbiBpdHMgZGVuc2l0eSB2YWx1ZSBpbiBhIGhlYXRtYXAuICBTaG91bGQgYmUgYW4gZXhwcmVzc2lvbiB0aGF0IHVzZXMgYFtcXFwiaGVhdG1hcC1kZW5zaXR5XFxcIl1gIGFzIGlucHV0LlwiLFxuICAgIHRyYW5zaXRpb246IGZhbHNlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40MS4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge31cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcImhlYXRtYXAtZGVuc2l0eVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29sb3ItcmFtcFwiXG4gIH0sXG4gIFwiaGVhdG1hcC1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJUaGUgZ2xvYmFsIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGhlYXRtYXAgbGF5ZXIgd2lsbCBiZSBkcmF3bi5cIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDEuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfVxufTtcbnZhciBwYWludF9zeW1ib2wgPSB7XG4gIFwiaWNvbi1vcGFjaXR5XCI6IHtcbiAgICBkb2M6IFwiVGhlIG9wYWNpdHkgYXQgd2hpY2ggdGhlIGljb24gd2lsbCBiZSBkcmF3bi5cIixcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHJlcXVpcmVzOiBbXCJpY29uLWltYWdlXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjMzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwiaWNvbi1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIGRvYzogXCJUaGUgY29sb3Igb2YgdGhlIGljb24uIFRoaXMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHNkZiBpY29ucy5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zMy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcImljb24taGFsby1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIGRvYzogXCJUaGUgY29sb3Igb2YgdGhlIGljb24ncyBoYWxvLiBJY29uIGhhbG9zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBTREYgaWNvbnMuXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMzMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLWhhbG8td2lkdGhcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJEaXN0YW5jZSBvZiBoYWxvIHRvIHRoZSBpY29uIG91dGxpbmUuXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMzMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLWhhbG8tYmx1clwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIkZhZGUgb3V0IHRoZSBoYWxvIHRvd2FyZHMgdGhlIG91dHNpZGUuXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIl0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfSxcbiAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgIGpzOiBcIjAuMzMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjUuMC4wXCIsXG4gICAgICAgIGlvczogXCIzLjUuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjQuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgfSxcbiAgXCJpY29uLXRyYW5zbGF0ZVwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgIGxlbmd0aDogMixcbiAgICBcImRlZmF1bHRcIjogWzAsIDBdLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgdW5pdHM6IFwicGl4ZWxzXCIsXG4gICAgZG9jOiBcIkRpc3RhbmNlIHRoYXQgdGhlIGljb24ncyBhbmNob3IgaXMgbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgcGxhY2VtZW50LiBQb3NpdGl2ZSB2YWx1ZXMgaW5kaWNhdGUgcmlnaHQgYW5kIGRvd24sIHdoaWxlIG5lZ2F0aXZlIHZhbHVlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cC5cIixcbiAgICByZXF1aXJlczogW1wiaWNvbi1pbWFnZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJpY29uLXRyYW5zbGF0ZS1hbmNob3JcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbWFwOiB7XG4gICAgICAgIGRvYzogXCJJY29ucyBhcmUgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgbWFwLlwiXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgZG9jOiBcIkljb25zIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGBpY29uLXRyYW5zbGF0ZWAuXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgcmVxdWlyZXM6IFtcImljb24taW1hZ2VcIiwgXCJpY29uLXRyYW5zbGF0ZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwidGV4dC1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjMzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIGRvYzogXCJUaGUgY29sb3Igd2l0aCB3aGljaCB0aGUgdGV4dCB3aWxsIGJlIGRyYXduLlwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIG92ZXJyaWRhYmxlOiB0cnVlLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjMzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1oYWxvLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgZG9jOiBcIlRoZSBjb2xvciBvZiB0aGUgdGV4dCdzIGhhbG8sIHdoaWNoIGhlbHBzIGl0IHN0YW5kIG91dCBmcm9tIGJhY2tncm91bmRzLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjMzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1oYWxvLXdpZHRoXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiRGlzdGFuY2Ugb2YgaGFsbyB0byB0aGUgZm9udCBvdXRsaW5lLiBNYXggdGV4dCBoYWxvIHdpZHRoIGlzIDEvNCBvZiB0aGUgZm9udC1zaXplLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH0sXG4gICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICBqczogXCIwLjMzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI1LjAuMFwiLFxuICAgICAgICBpb3M6IFwiMy41LjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC40LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gIH0sXG4gIFwidGV4dC1oYWxvLWJsdXJcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDAsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcInBpeGVsc1wiLFxuICAgIGRvYzogXCJUaGUgaGFsbydzIGZhZGVvdXQgZGlzdGFuY2UgdG93YXJkcyB0aGUgb3V0c2lkZS5cIixcbiAgICByZXF1aXJlczogW1widGV4dC1maWVsZFwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAganM6IFwiMC4zMy4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNS4wLjBcIixcbiAgICAgICAgaW9zOiBcIjMuNS4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICB9LFxuICBcInRleHQtdHJhbnNsYXRlXCI6IHtcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgdmFsdWU6IFwibnVtYmVyXCIsXG4gICAgbGVuZ3RoOiAyLFxuICAgIFwiZGVmYXVsdFwiOiBbMCwgMF0sXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICBkb2M6IFwiRGlzdGFuY2UgdGhhdCB0aGUgdGV4dCdzIGFuY2hvciBpcyBtb3ZlZCBmcm9tIGl0cyBvcmlnaW5hbCBwbGFjZW1lbnQuIFBvc2l0aXZlIHZhbHVlcyBpbmRpY2F0ZSByaWdodCBhbmQgZG93biwgd2hpbGUgbmVnYXRpdmUgdmFsdWVzIGluZGljYXRlIGxlZnQgYW5kIHVwLlwiLFxuICAgIHJlcXVpcmVzOiBbXCJ0ZXh0LWZpZWxkXCJdLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInRleHQtdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgdmFsdWVzOiB7XG4gICAgICBtYXA6IHtcbiAgICAgICAgZG9jOiBcIlRoZSB0ZXh0IGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgdGV4dCBpcyB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgZG9jOiBcIkNvbnRyb2xzIHRoZSBmcmFtZSBvZiByZWZlcmVuY2UgZm9yIGB0ZXh0LXRyYW5zbGF0ZWAuXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwibWFwXCIsXG4gICAgcmVxdWlyZXM6IFtcInRleHQtZmllbGRcIiwgXCJ0ZXh0LXRyYW5zbGF0ZVwiXSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH1cbn07XG52YXIgcGFpbnRfcmFzdGVyID0ge1xuICBcInJhc3Rlci1vcGFjaXR5XCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJUaGUgb3BhY2l0eSBhdCB3aGljaCB0aGUgaW1hZ2Ugd2lsbCBiZSBkcmF3bi5cIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJyYXN0ZXItaHVlLXJvdGF0ZVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBwZXJpb2Q6IDM2MCxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHVuaXRzOiBcImRlZ3JlZXNcIixcbiAgICBkb2M6IFwiUm90YXRlcyBodWVzIGFyb3VuZCB0aGUgY29sb3Igd2hlZWwuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwicmFzdGVyLWJyaWdodG5lc3MtbWluXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIGJyaWdodG5lc3Mgb2YgdGhlIGltYWdlLiBUaGUgdmFsdWUgaXMgdGhlIG1pbmltdW0gYnJpZ2h0bmVzcy5cIixcbiAgICBcImRlZmF1bHRcIjogMCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJyYXN0ZXItYnJpZ2h0bmVzcy1tYXhcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZG9jOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgYnJpZ2h0bmVzcyBvZiB0aGUgaW1hZ2UuIFRoZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBicmlnaHRuZXNzLlwiLFxuICAgIFwiZGVmYXVsdFwiOiAxLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMSxcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC4xMC4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiMi4wLjFcIixcbiAgICAgICAgaW9zOiBcIjIuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuMS4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInJhc3Rlci1zYXR1cmF0aW9uXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJJbmNyZWFzZSBvciByZWR1Y2UgdGhlIHNhdHVyYXRpb24gb2YgdGhlIGltYWdlLlwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIG1pbmltdW06IC0xLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJyYXN0ZXItY29udHJhc3RcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgZG9jOiBcIkluY3JlYXNlIG9yIHJlZHVjZSB0aGUgY29udHJhc3Qgb2YgdGhlIGltYWdlLlwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIG1pbmltdW06IC0xLFxuICAgIG1heGltdW06IDEsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJyYXN0ZXItcmVzYW1wbGluZ1wiOiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgZG9jOiBcIlRoZSByZXNhbXBsaW5nL2ludGVycG9sYXRpb24gbWV0aG9kIHRvIHVzZSBmb3Igb3ZlcnNjYWxpbmcsIGFsc28ga25vd24gYXMgdGV4dHVyZSBtYWduaWZpY2F0aW9uIGZpbHRlclwiLFxuICAgIHZhbHVlczoge1xuICAgICAgbGluZWFyOiB7XG4gICAgICAgIGRvYzogXCIoQmkpbGluZWFyIGZpbHRlcmluZyBpbnRlcnBvbGF0ZXMgcGl4ZWwgdmFsdWVzIHVzaW5nIHRoZSB3ZWlnaHRlZCBhdmVyYWdlIG9mIHRoZSBmb3VyIGNsb3Nlc3Qgb3JpZ2luYWwgc291cmNlIHBpeGVscyBjcmVhdGluZyBhIHNtb290aCBidXQgYmx1cnJ5IGxvb2sgd2hlbiBvdmVyc2NhbGVkXCJcbiAgICAgIH0sXG4gICAgICBuZWFyZXN0OiB7XG4gICAgICAgIGRvYzogXCJOZWFyZXN0IG5laWdoYm9yIGZpbHRlcmluZyBpbnRlcnBvbGF0ZXMgcGl4ZWwgdmFsdWVzIHVzaW5nIHRoZSBuZWFyZXN0IG9yaWdpbmFsIHNvdXJjZSBwaXhlbCBjcmVhdGluZyBhIHNoYXJwIGJ1dCBwaXhlbGF0ZWQgbG9vayB3aGVuIG92ZXJzY2FsZWRcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwibGluZWFyXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjQ3LjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjMuMFwiLFxuICAgICAgICBpb3M6IFwiNC4yLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC45LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInJhc3Rlci1mYWRlLWR1cmF0aW9uXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAzMDAsXG4gICAgbWluaW11bTogMCxcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICB1bml0czogXCJtaWxsaXNlY29uZHNcIixcbiAgICBkb2M6IFwiRmFkZSBkdXJhdGlvbiB3aGVuIGEgbmV3IHRpbGUgaXMgYWRkZWQuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjEwLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCIyLjAuMVwiLFxuICAgICAgICBpb3M6IFwiMi4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC4xLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH1cbn07XG52YXIgcGFpbnRfaGlsbHNoYWRlID0ge1xuICBcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tZGlyZWN0aW9uXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAzMzUsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAzNTksXG4gICAgZG9jOiBcIlRoZSBkaXJlY3Rpb24gb2YgdGhlIGxpZ2h0IHNvdXJjZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBoaWxsc2hhZGluZyB3aXRoIDAgYXMgdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQgaWYgYGhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yYCBpcyBzZXQgdG8gYHZpZXdwb3J0YCBhbmQgZHVlIG5vcnRoIGlmIGBoaWxsc2hhZGUtaWxsdW1pbmF0aW9uLWFuY2hvcmAgaXMgc2V0IHRvIGBtYXBgLlwiLFxuICAgIHRyYW5zaXRpb246IGZhbHNlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40My4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcImhpbGxzaGFkZS1pbGx1bWluYXRpb24tYW5jaG9yXCI6IHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICB2YWx1ZXM6IHtcbiAgICAgIG1hcDoge1xuICAgICAgICBkb2M6IFwiVGhlIGhpbGxzaGFkZSBpbGx1bWluYXRpb24gaXMgcmVsYXRpdmUgdG8gdGhlIG5vcnRoIGRpcmVjdGlvbi5cIlxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIGRvYzogXCJUaGUgaGlsbHNoYWRlIGlsbHVtaW5hdGlvbiBpcyByZWxhdGl2ZSB0byB0aGUgdG9wIG9mIHRoZSB2aWV3cG9ydC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IFwidmlld3BvcnRcIixcbiAgICBkb2M6IFwiRGlyZWN0aW9uIG9mIGxpZ2h0IHNvdXJjZSB3aGVuIG1hcCBpcyByb3RhdGVkLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40My4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJoaWxsc2hhZGUtZXhhZ2dlcmF0aW9uXCI6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIGRvYzogXCJJbnRlbnNpdHkgb2YgdGhlIGhpbGxzaGFkZVwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLjUsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjQzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaGlsbHNoYWRlLXNoYWRvdy1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICBkb2M6IFwiVGhlIHNoYWRpbmcgY29sb3Igb2YgYXJlYXMgdGhhdCBmYWNlIGF3YXkgZnJvbSB0aGUgbGlnaHQgc291cmNlLlwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIwLjQzLjBcIixcbiAgICAgICAgYW5kcm9pZDogXCI2LjAuMFwiLFxuICAgICAgICBpb3M6IFwiNC4wLjBcIixcbiAgICAgICAgbWFjb3M6IFwiMC43LjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwiaGlsbHNoYWRlLWhpZ2hsaWdodC1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIiNGRkZGRkZcIixcbiAgICBkb2M6IFwiVGhlIHNoYWRpbmcgY29sb3Igb2YgYXJlYXMgdGhhdCBmYWNlcyB0b3dhcmRzIHRoZSBsaWdodCBzb3VyY2UuXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuNDMuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjYuMC4wXCIsXG4gICAgICAgIGlvczogXCI0LjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjcuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJoaWxsc2hhZGUtYWNjZW50LWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwiIzAwMDAwMFwiLFxuICAgIGRvYzogXCJUaGUgc2hhZGluZyBjb2xvciB1c2VkIHRvIGFjY2VudHVhdGUgcnVnZ2VkIHRlcnJhaW4gbGlrZSBzaGFycCBjbGlmZnMgYW5kIGdvcmdlcy5cIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMC40My4wXCIsXG4gICAgICAgIGFuZHJvaWQ6IFwiNi4wLjBcIixcbiAgICAgICAgaW9zOiBcIjQuMC4wXCIsXG4gICAgICAgIG1hY29zOiBcIjAuNy4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9XG59O1xudmFyIHBhaW50X2JhY2tncm91bmQgPSB7XG4gIFwiYmFja2dyb3VuZC1jb2xvclwiOiB7XG4gICAgdHlwZTogXCJjb2xvclwiLFxuICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICBkb2M6IFwiVGhlIGNvbG9yIHdpdGggd2hpY2ggdGhlIGJhY2tncm91bmQgd2lsbCBiZSBkcmF3bi5cIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCIhXCI6IFwiYmFja2dyb3VuZC1wYXR0ZXJuXCJcbiAgICB9XSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJiYWNrZ3JvdW5kLXBhdHRlcm5cIjoge1xuICAgIHR5cGU6IFwicmVzb2x2ZWRJbWFnZVwiLFxuICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgZG9jOiBcIk5hbWUgb2YgaW1hZ2UgaW4gc3ByaXRlIHRvIHVzZSBmb3IgZHJhd2luZyBhbiBpbWFnZSBiYWNrZ3JvdW5kLiBGb3Igc2VhbWxlc3MgcGF0dGVybnMsIGltYWdlIHdpZHRoIGFuZCBoZWlnaHQgbXVzdCBiZSBhIGZhY3RvciBvZiB0d28gKDIsIDQsIDgsIC4uLiwgNTEyKS4gTm90ZSB0aGF0IHpvb20tZGVwZW5kZW50IGV4cHJlc3Npb25zIHdpbGwgYmUgZXZhbHVhdGVkIG9ubHkgYXQgaW50ZWdlciB6b29tIGxldmVscy5cIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY3Jvc3MtZmFkZWRcIlxuICB9LFxuICBcImJhY2tncm91bmQtb3BhY2l0eVwiOiB7XG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogMSxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDEsXG4gICAgZG9jOiBcIlRoZSBvcGFjaXR5IGF0IHdoaWNoIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgZHJhd24uXCIsXG4gICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjAuMTAuMFwiLFxuICAgICAgICBhbmRyb2lkOiBcIjIuMC4xXCIsXG4gICAgICAgIGlvczogXCIyLjAuMFwiLFxuICAgICAgICBtYWNvczogXCIwLjEuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfVxufTtcbnZhciBwYWludF9za3kgPSB7XG4gIFwic2t5LXR5cGVcIjoge1xuICAgIHR5cGU6IFwiZW51bVwiLFxuICAgIHZhbHVlczoge1xuICAgICAgZ3JhZGllbnQ6IHtcbiAgICAgICAgZG9jOiBcIlJlbmRlcnMgdGhlIHNreSB3aXRoIGEgZ3JhZGllbnQgdGhhdCBjYW4gYmUgY29uZmlndXJlZCB3aXRoIGBza3ktZ3JhZGllbnQtcmFkaXVzYCBhbmQgYHNreS1ncmFkaWVudGAuXCJcbiAgICAgIH0sXG4gICAgICBhdG1vc3BoZXJlOiB7XG4gICAgICAgIGRvYzogXCJSZW5kZXJzIHRoZSBza3kgd2l0aCBhIHNpbXVsYXRlZCBhdG1vc3BoZXJpYyBzY2F0dGVyaW5nIGFsZ29yaXRobSwgdGhlIHN1biBkaXJlY3Rpb24gY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBsaWdodCBwb3NpdGlvbiBvciBleHBsaWNpdGx5IHNldCB0aHJvdWdoIGBza3ktYXRtb3NwaGVyZS1zdW5gLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogXCJhdG1vc3BoZXJlXCIsXG4gICAgZG9jOiBcIlRoZSB0eXBlIG9mIHRoZSBza3lcIixcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjIuMC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgfSxcbiAgXCJza3ktYXRtb3NwaGVyZS1zdW5cIjoge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBsZW5ndGg6IDIsXG4gICAgdW5pdHM6IFwiZGVncmVlc1wiLFxuICAgIG1pbmltdW06IFswLCAwXSxcbiAgICBtYXhpbXVtOiBbMzYwLCAxODBdLFxuICAgIHRyYW5zaXRpb246IGZhbHNlLFxuICAgIGRvYzogXCJQb3NpdGlvbiBvZiB0aGUgc3VuIGNlbnRlciBbYSBhemltdXRoYWwgYW5nbGUsIHAgcG9sYXIgYW5nbGVdLiBUaGUgYXppbXV0aGFsIGFuZ2xlIGluZGljYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHN1biByZWxhdGl2ZSB0byAwwrAgbm9ydGgsIHdoZXJlIGRlZ3JlZXMgcHJvY2VlZCBjbG9ja3dpc2UuIFRoZSBwb2xhciBhbmdsZSBpbmRpY2F0ZXMgdGhlIGhlaWdodCBvZiB0aGUgc3VuLCB3aGVyZSAwwrAgaXMgZGlyZWN0bHkgYWJvdmUsIGF0IHplbml0aCwgYW5kIDkwwrAgYXQgdGhlIGhvcml6b24uIFdoZW4gdGhpcyBwcm9wZXJ0eSBpcyBvbW1pdHRlZCwgdGhlIHN1biBjZW50ZXIgaXMgZGlyZWN0bHkgaW5oZXJpdGVkIGZyb20gdGhlIGxpZ2h0IHBvc2l0aW9uLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4wLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgcmVxdWlyZXM6IFt7XG4gICAgICBcInNreS10eXBlXCI6IFwiYXRtb3NwaGVyZVwiXG4gICAgfV0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInNreS1hdG1vc3BoZXJlLXN1bi1pbnRlbnNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgcmVxdWlyZXM6IFt7XG4gICAgICBcInNreS10eXBlXCI6IFwiYXRtb3NwaGVyZVwiXG4gICAgfV0sXG4gICAgXCJkZWZhdWx0XCI6IDEwLFxuICAgIG1pbmltdW06IDAsXG4gICAgbWF4aW11bTogMTAwLFxuICAgIHRyYW5zaXRpb246IGZhbHNlLFxuICAgIGRvYzogXCJJbnRlbnNpdHkgb2YgdGhlIHN1biBhcyBhIGxpZ2h0IHNvdXJjZSBpbiB0aGUgYXRtb3NwaGVyZSAob24gYSBzY2FsZSBmcm9tIDAgdG8gYSAxMDApLiBTZXR0aW5nIGhpZ2hlciB2YWx1ZXMgd2lsbCBicmlnaHRlbiB1cCB0aGUgc2t5LlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4wLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwic2t5LWdyYWRpZW50LWNlbnRlclwiOiB7XG4gICAgdHlwZTogXCJhcnJheVwiLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCJza3ktdHlwZVwiOiBcImdyYWRpZW50XCJcbiAgICB9XSxcbiAgICB2YWx1ZTogXCJudW1iZXJcIixcbiAgICBcImRlZmF1bHRcIjogWzAsIDBdLFxuICAgIGxlbmd0aDogMixcbiAgICB1bml0czogXCJkZWdyZWVzXCIsXG4gICAgbWluaW11bTogWzAsIDBdLFxuICAgIG1heGltdW06IFszNjAsIDE4MF0sXG4gICAgdHJhbnNpdGlvbjogZmFsc2UsXG4gICAgZG9jOiBcIlBvc2l0aW9uIG9mIHRoZSBncmFkaWVudCBjZW50ZXIgW2EgYXppbXV0aGFsIGFuZ2xlLCBwIHBvbGFyIGFuZ2xlXS4gVGhlIGF6aW11dGhhbCBhbmdsZSBpbmRpY2F0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBncmFkaWVudCBjZW50ZXIgcmVsYXRpdmUgdG8gMMKwIG5vcnRoLCB3aGVyZSBkZWdyZWVzIHByb2NlZWQgY2xvY2t3aXNlLiBUaGUgcG9sYXIgYW5nbGUgaW5kaWNhdGVzIHRoZSBoZWlnaHQgb2YgdGhlIGdyYWRpZW50IGNlbnRlciwgd2hlcmUgMMKwIGlzIGRpcmVjdGx5IGFib3ZlLCBhdCB6ZW5pdGgsIGFuZCA5MMKwIGF0IHRoZSBob3Jpem9uLlwiLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4wLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInNreS1ncmFkaWVudC1yYWRpdXNcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgcmVxdWlyZXM6IFt7XG4gICAgICBcInNreS10eXBlXCI6IFwiZ3JhZGllbnRcIlxuICAgIH1dLFxuICAgIFwiZGVmYXVsdFwiOiA5MCxcbiAgICBtaW5pbXVtOiAwLFxuICAgIG1heGltdW06IDE4MCxcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICBkb2M6IFwiVGhlIGFuZ3VsYXIgZGlzdGFuY2UgKG1lYXN1cmVkIGluIGRlZ3JlZXMpIGZyb20gYHNreS1ncmFkaWVudC1jZW50ZXJgIHVwIHRvIHdoaWNoIHRoZSBncmFkaWVudCBleHRlbmRzLiBBIHZhbHVlIG9mIDE4MCBjYXVzZXMgdGhlIGdyYWRpZW50IHRvIHdyYXAgYXJvdW5kIHRvIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gZnJvbSBgc2t5LWdyYWRpZW50LWNlbnRlcmAuXCIsXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIyLjAuMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwic2t5LWdyYWRpZW50XCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJkZWZhdWx0XCI6IFtcImludGVycG9sYXRlXCIsIFtcImxpbmVhclwiXSwgW1wic2t5LXJhZGlhbC1wcm9ncmVzc1wiXSwgMC44LCBcIiM4N2NlZWJcIiwgMSwgXCJ3aGl0ZVwiXSxcbiAgICBkb2M6IFwiRGVmaW5lcyBhIHJhZGlhbCBjb2xvciBncmFkaWVudCB3aXRoIHdoaWNoIHRvIGNvbG9yIHRoZSBza3kuIFRoZSBjb2xvciB2YWx1ZXMgY2FuIGJlIGludGVycG9sYXRlZCB3aXRoIGFuIGV4cHJlc3Npb24gdXNpbmcgYHNreS1yYWRpYWwtcHJvZ3Jlc3NgLiBUaGUgcmFuZ2UgWzAsIDFdIGZvciB0aGUgaW50ZXJwb2xhbnQgY292ZXJzIGEgcmFkaWFsIGRpc3RhbmNlIChpbiBkZWdyZWVzKSBvZiBbMCwgYHNreS1ncmFkaWVudC1yYWRpdXNgXSBjZW50ZXJlZCBhdCB0aGUgcG9zaXRpb24gc3BlY2lmaWVkIGJ5IGBza3ktZ3JhZGllbnQtY2VudGVyYC5cIixcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICByZXF1aXJlczogW3tcbiAgICAgIFwic2t5LXR5cGVcIjogXCJncmFkaWVudFwiXG4gICAgfV0sXG4gICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICBqczogXCIyLjAuMFwiXG4gICAgICB9LFxuICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHt9XG4gICAgfSxcbiAgICBleHByZXNzaW9uOiB7XG4gICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICBwYXJhbWV0ZXJzOiBbXCJza3ktcmFkaWFsLXByb2dyZXNzXCJdXG4gICAgfSxcbiAgICBcInByb3BlcnR5LXR5cGVcIjogXCJjb2xvci1yYW1wXCJcbiAgfSxcbiAgXCJza3ktYXRtb3NwaGVyZS1oYWxvLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwid2hpdGVcIixcbiAgICBkb2M6IFwiQSBjb2xvciBhcHBsaWVkIHRvIHRoZSBhdG1vc3BoZXJlIHN1biBoYWxvLiBUaGUgYWxwaGEgY2hhbm5lbCBkZXNjcmliZXMgaG93IHN0cm9uZ2x5IHRoZSBzdW4gaGFsbyBpcyByZXByZXNlbnRlZCBpbiBhbiBhdG1vc3BoZXJlIHNreSBsYXllci5cIixcbiAgICB0cmFuc2l0aW9uOiBmYWxzZSxcbiAgICByZXF1aXJlczogW3tcbiAgICAgIFwic2t5LXR5cGVcIjogXCJhdG1vc3BoZXJlXCJcbiAgICB9XSxcbiAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgIGpzOiBcIjIuMC4wXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICB9LFxuICBcInNreS1hdG1vc3BoZXJlLWNvbG9yXCI6IHtcbiAgICB0eXBlOiBcImNvbG9yXCIsXG4gICAgXCJkZWZhdWx0XCI6IFwid2hpdGVcIixcbiAgICBkb2M6IFwiQSBjb2xvciB1c2VkIHRvIHR3ZWFrIHRoZSBtYWluIGF0bW9zcGhlcmljIHNjYXR0ZXJpbmcgY29lZmZpY2llbnRzLiBVc2luZyB3aGl0ZSBhcHBsaWVzIHRoZSBkZWZhdWx0IGNvZWZmaWNpZW50cyBnaXZpbmcgdGhlIG5hdHVyYWwgYmx1ZSBjb2xvciB0byB0aGUgYXRtb3NwaGVyZS4gVGhpcyBjb2xvciBhZmZlY3RzIGhvdyBoZWF2aWx5IHRoZSBjb3JyZXNwb25kaW5nIHdhdmVsZW5ndGggaXMgcmVwcmVzZW50ZWQgZHVyaW5nIHNjYXR0ZXJpbmcuIFRoZSBhbHBoYSBjaGFubmVsIGRlc2NyaWJlcyB0aGUgZGVuc2l0eSBvZiB0aGUgYXRtb3NwaGVyZSwgd2l0aCAxIG1heGltdW0gZGVuc2l0eSBhbmQgMCBubyBkZW5zaXR5LlwiLFxuICAgIHRyYW5zaXRpb246IGZhbHNlLFxuICAgIHJlcXVpcmVzOiBbe1xuICAgICAgXCJza3ktdHlwZVwiOiBcImF0bW9zcGhlcmVcIlxuICAgIH1dLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4wLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH0sXG4gIFwic2t5LW9wYWNpdHlcIjoge1xuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgXCJkZWZhdWx0XCI6IDEsXG4gICAgbWluaW11bTogMCxcbiAgICBtYXhpbXVtOiAxLFxuICAgIGRvYzogXCJUaGUgb3BhY2l0eSBvZiB0aGUgZW50aXJlIHNreSBsYXllci5cIixcbiAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAganM6IFwiMi4wLjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gIH1cbn07XG52YXIgdHJhbnNpdGlvbiA9IHtcbiAgZHVyYXRpb246IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAzMDAsXG4gICAgbWluaW11bTogMCxcbiAgICB1bml0czogXCJtaWxsaXNlY29uZHNcIixcbiAgICBkb2M6IFwiVGltZSBhbGxvdHRlZCBmb3IgdHJhbnNpdGlvbnMgdG8gY29tcGxldGUuXCJcbiAgfSxcbiAgZGVsYXk6IHtcbiAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgIG1pbmltdW06IDAsXG4gICAgdW5pdHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgZG9jOiBcIkxlbmd0aCBvZiB0aW1lIGJlZm9yZSBhIHRyYW5zaXRpb24gYmVnaW5zLlwiXG4gIH1cbn07XG52YXIgcHJvbW90ZUlkID0ge1xuICBcIipcIjoge1xuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgZG9jOiBcIkEgbmFtZSBvZiBhIGZlYXR1cmUgcHJvcGVydHkgdG8gdXNlIGFzIElEIGZvciBmZWF0dXJlIHN0YXRlLlwiXG4gIH1cbn07XG52YXIgdjggPSB7XG4gICR2ZXJzaW9uOiAkdmVyc2lvbixcbiAgJHJvb3Q6ICRyb290LFxuICBzb3VyY2VzOiBzb3VyY2VzLFxuICBzb3VyY2U6IHNvdXJjZSxcbiAgc291cmNlX3ZlY3Rvcjogc291cmNlX3ZlY3RvcixcbiAgc291cmNlX3Jhc3Rlcjogc291cmNlX3Jhc3RlcixcbiAgc291cmNlX3Jhc3Rlcl9kZW06IHNvdXJjZV9yYXN0ZXJfZGVtLFxuICBzb3VyY2VfZ2VvanNvbjogc291cmNlX2dlb2pzb24sXG4gIHNvdXJjZV92aWRlbzogc291cmNlX3ZpZGVvLFxuICBzb3VyY2VfaW1hZ2U6IHNvdXJjZV9pbWFnZSxcbiAgbGF5ZXI6IGxheWVyLFxuICBsYXlvdXQ6IGxheW91dCxcbiAgbGF5b3V0X2JhY2tncm91bmQ6IGxheW91dF9iYWNrZ3JvdW5kLFxuICBsYXlvdXRfc2t5OiBsYXlvdXRfc2t5LFxuICBsYXlvdXRfZmlsbDogbGF5b3V0X2ZpbGwsXG4gIGxheW91dF9jaXJjbGU6IGxheW91dF9jaXJjbGUsXG4gIGxheW91dF9oZWF0bWFwOiBsYXlvdXRfaGVhdG1hcCxcbiAgXCJsYXlvdXRfZmlsbC1leHRydXNpb25cIjoge1xuICAgIHZpc2liaWxpdHk6IHtcbiAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgdmFsdWVzOiB7XG4gICAgICAgIHZpc2libGU6IHtcbiAgICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIHNob3duLlwiXG4gICAgICAgIH0sXG4gICAgICAgIG5vbmU6IHtcbiAgICAgICAgICBkb2M6IFwiVGhlIGxheWVyIGlzIG5vdCBzaG93bi5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJkZWZhdWx0XCI6IFwidmlzaWJsZVwiLFxuICAgICAgZG9jOiBcIldoZXRoZXIgdGhpcyBsYXllciBpcyBkaXNwbGF5ZWQuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiY29uc3RhbnRcIlxuICAgIH1cbiAgfSxcbiAgbGF5b3V0X2xpbmU6IGxheW91dF9saW5lLFxuICBsYXlvdXRfc3ltYm9sOiBsYXlvdXRfc3ltYm9sLFxuICBsYXlvdXRfcmFzdGVyOiBsYXlvdXRfcmFzdGVyLFxuICBsYXlvdXRfaGlsbHNoYWRlOiBsYXlvdXRfaGlsbHNoYWRlLFxuICBmaWx0ZXI6IGZpbHRlcixcbiAgZmlsdGVyX29wZXJhdG9yOiBmaWx0ZXJfb3BlcmF0b3IsXG4gIGdlb21ldHJ5X3R5cGU6IGdlb21ldHJ5X3R5cGUsXG4gIFwiZnVuY3Rpb25cIjoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHR5cGU6IFwiZXhwcmVzc2lvblwiLFxuICAgICAgZG9jOiBcIkFuIGV4cHJlc3Npb24uXCJcbiAgICB9LFxuICAgIHN0b3BzOiB7XG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBkb2M6IFwiQW4gYXJyYXkgb2Ygc3RvcHMuXCIsXG4gICAgICB2YWx1ZTogXCJmdW5jdGlvbl9zdG9wXCJcbiAgICB9LFxuICAgIGJhc2U6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkb2M6IFwiVGhlIGV4cG9uZW50aWFsIGJhc2Ugb2YgdGhlIGludGVycG9sYXRpb24gY3VydmUuIEl0IGNvbnRyb2xzIHRoZSByYXRlIGF0IHdoaWNoIHRoZSByZXN1bHQgaW5jcmVhc2VzLiBIaWdoZXIgdmFsdWVzIG1ha2UgdGhlIHJlc3VsdCBpbmNyZWFzZSBtb3JlIHRvd2FyZHMgdGhlIGhpZ2ggZW5kIG9mIHRoZSByYW5nZS4gV2l0aCBgMWAgdGhlIHN0b3BzIGFyZSBpbnRlcnBvbGF0ZWQgbGluZWFybHkuXCJcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgZG9jOiBcIlRoZSBuYW1lIG9mIGEgZmVhdHVyZSBwcm9wZXJ0eSB0byB1c2UgYXMgdGhlIGZ1bmN0aW9uIGlucHV0LlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwiJHpvb21cIlxuICAgIH0sXG4gICAgdHlwZToge1xuICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICB2YWx1ZXM6IHtcbiAgICAgICAgaWRlbnRpdHk6IHtcbiAgICAgICAgICBkb2M6IFwiUmV0dXJuIHRoZSBpbnB1dCB2YWx1ZSBhcyB0aGUgb3V0cHV0IHZhbHVlLlwiXG4gICAgICAgIH0sXG4gICAgICAgIGV4cG9uZW50aWFsOiB7XG4gICAgICAgICAgZG9jOiBcIkdlbmVyYXRlIGFuIG91dHB1dCBieSBpbnRlcnBvbGF0aW5nIGJldHdlZW4gc3RvcHMganVzdCBsZXNzIHRoYW4gYW5kIGp1c3QgZ3JlYXRlciB0aGFuIHRoZSBmdW5jdGlvbiBpbnB1dC5cIlxuICAgICAgICB9LFxuICAgICAgICBpbnRlcnZhbDoge1xuICAgICAgICAgIGRvYzogXCJSZXR1cm4gdGhlIG91dHB1dCB2YWx1ZSBvZiB0aGUgc3RvcCBqdXN0IGxlc3MgdGhhbiB0aGUgZnVuY3Rpb24gaW5wdXQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgY2F0ZWdvcmljYWw6IHtcbiAgICAgICAgICBkb2M6IFwiUmV0dXJuIHRoZSBvdXRwdXQgdmFsdWUgb2YgdGhlIHN0b3AgZXF1YWwgdG8gdGhlIGZ1bmN0aW9uIGlucHV0LlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkb2M6IFwiVGhlIGludGVycG9sYXRpb24gc3RyYXRlZ3kgdG8gdXNlIGluIGZ1bmN0aW9uIGV2YWx1YXRpb24uXCIsXG4gICAgICBcImRlZmF1bHRcIjogXCJleHBvbmVudGlhbFwiXG4gICAgfSxcbiAgICBjb2xvclNwYWNlOiB7XG4gICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgIHZhbHVlczoge1xuICAgICAgICByZ2I6IHtcbiAgICAgICAgICBkb2M6IFwiVXNlIHRoZSBSR0IgY29sb3Igc3BhY2UgdG8gaW50ZXJwb2xhdGUgY29sb3IgdmFsdWVzXCJcbiAgICAgICAgfSxcbiAgICAgICAgbGFiOiB7XG4gICAgICAgICAgZG9jOiBcIlVzZSB0aGUgTEFCIGNvbG9yIHNwYWNlIHRvIGludGVycG9sYXRlIGNvbG9yIHZhbHVlcy5cIlxuICAgICAgICB9LFxuICAgICAgICBoY2w6IHtcbiAgICAgICAgICBkb2M6IFwiVXNlIHRoZSBIQ0wgY29sb3Igc3BhY2UgdG8gaW50ZXJwb2xhdGUgY29sb3IgdmFsdWVzLCBpbnRlcnBvbGF0aW5nIHRoZSBIdWUsIENocm9tYSwgYW5kIEx1bWluYW5jZSBjaGFubmVscyBpbmRpdmlkdWFsbHkuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRvYzogXCJUaGUgY29sb3Igc3BhY2UgaW4gd2hpY2ggY29sb3JzIGludGVycG9sYXRlZC4gSW50ZXJwb2xhdGluZyBjb2xvcnMgaW4gcGVyY2VwdHVhbCBjb2xvciBzcGFjZXMgbGlrZSBMQUIgYW5kIEhDTCB0ZW5kIHRvIHByb2R1Y2UgY29sb3IgcmFtcHMgdGhhdCBsb29rIG1vcmUgY29uc2lzdGVudCBhbmQgcHJvZHVjZSBjb2xvcnMgdGhhdCBjYW4gYmUgZGlmZmVyZW50aWF0ZWQgbW9yZSBlYXNpbHkgdGhhbiB0aG9zZSBpbnRlcnBvbGF0ZWQgaW4gUkdCIHNwYWNlLlwiLFxuICAgICAgXCJkZWZhdWx0XCI6IFwicmdiXCJcbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICB0eXBlOiBcIipcIixcbiAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgIGRvYzogXCJBIHZhbHVlIHRvIHNlcnZlIGFzIGEgZmFsbGJhY2sgZnVuY3Rpb24gcmVzdWx0IHdoZW4gYSB2YWx1ZSBpc24ndCBvdGhlcndpc2UgYXZhaWxhYmxlLiBJdCBpcyB1c2VkIGluIHRoZSBmb2xsb3dpbmcgY2lyY3Vtc3RhbmNlczpcXG4qIEluIGNhdGVnb3JpY2FsIGZ1bmN0aW9ucywgd2hlbiB0aGUgZmVhdHVyZSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHN0b3AgZG9tYWluIHZhbHVlcy5cXG4qIEluIHByb3BlcnR5IGFuZCB6b29tLWFuZC1wcm9wZXJ0eSBmdW5jdGlvbnMsIHdoZW4gYSBmZWF0dXJlIGRvZXMgbm90IGNvbnRhaW4gYSB2YWx1ZSBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cXG4qIEluIGlkZW50aXR5IGZ1bmN0aW9ucywgd2hlbiB0aGUgZmVhdHVyZSB2YWx1ZSBpcyBub3QgdmFsaWQgZm9yIHRoZSBzdHlsZSBwcm9wZXJ0eSAoZm9yIGV4YW1wbGUsIGlmIHRoZSBmdW5jdGlvbiBpcyBiZWluZyB1c2VkIGZvciBhIGBjaXJjbGUtY29sb3JgIHByb3BlcnR5IGJ1dCB0aGUgZmVhdHVyZSBwcm9wZXJ0eSB2YWx1ZSBpcyBub3QgYSBzdHJpbmcgb3Igbm90IGEgdmFsaWQgY29sb3IpLlxcbiogSW4gaW50ZXJ2YWwgb3IgZXhwb25lbnRpYWwgcHJvcGVydHkgYW5kIHpvb20tYW5kLXByb3BlcnR5IGZ1bmN0aW9ucywgd2hlbiB0aGUgZmVhdHVyZSB2YWx1ZSBpcyBub3QgbnVtZXJpYy5cXG5JZiBubyBkZWZhdWx0IGlzIHByb3ZpZGVkLCB0aGUgc3R5bGUgcHJvcGVydHkncyBkZWZhdWx0IGlzIHVzZWQgaW4gdGhlc2UgY2lyY3Vtc3RhbmNlcy5cIlxuICAgIH1cbiAgfSxcbiAgZnVuY3Rpb25fc3RvcDogZnVuY3Rpb25fc3RvcCxcbiAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgZXhwcmVzc2lvbl9uYW1lOiBleHByZXNzaW9uX25hbWUsXG4gIGZvZzogZm9nLFxuICBsaWdodDogbGlnaHQsXG4gIHRlcnJhaW46IHRlcnJhaW4sXG4gIHBhaW50OiBwYWludCxcbiAgcGFpbnRfZmlsbDogcGFpbnRfZmlsbCxcbiAgXCJwYWludF9maWxsLWV4dHJ1c2lvblwiOiB7XG4gICAgXCJmaWxsLWV4dHJ1c2lvbi1vcGFjaXR5XCI6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMSxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgZG9jOiBcIlRoZSBvcGFjaXR5IG9mIHRoZSBlbnRpcmUgZmlsbCBleHRydXNpb24gbGF5ZXIuIFRoaXMgaXMgcmVuZGVyZWQgb24gYSBwZXItbGF5ZXIsIG5vdCBwZXItZmVhdHVyZSwgYmFzaXMsIGFuZCBkYXRhLWRyaXZlbiBzdHlsaW5nIGlzIG5vdCBhdmFpbGFibGUuXCIsXG4gICAgICB0cmFuc2l0aW9uOiB0cnVlLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCJdXG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1jb25zdGFudFwiXG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLWNvbG9yXCI6IHtcbiAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIiMwMDAwMDBcIixcbiAgICAgIGRvYzogXCJUaGUgYmFzZSBjb2xvciBvZiB0aGUgZXh0cnVkZWQgZmlsbC4gVGhlIGV4dHJ1c2lvbidzIHN1cmZhY2VzIHdpbGwgYmUgc2hhZGVkIGRpZmZlcmVudGx5IGJhc2VkIG9uIHRoaXMgY29sb3IgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgcm9vdCBgbGlnaHRgIHNldHRpbmdzLiBJZiB0aGlzIGNvbG9yIGlzIHNwZWNpZmllZCBhcyBgcmdiYWAgd2l0aCBhbiBhbHBoYSBjb21wb25lbnQsIHRoZSBhbHBoYSBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkOyB1c2UgYGZpbGwtZXh0cnVzaW9uLW9wYWNpdHlgIHRvIHNldCBsYXllciBvcGFjaXR5LlwiLFxuICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgIHJlcXVpcmVzOiBbe1xuICAgICAgICBcIiFcIjogXCJmaWxsLWV4dHJ1c2lvbi1wYXR0ZXJuXCJcbiAgICAgIH1dLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkYXRhLWRyaXZlbiBzdHlsaW5nXCI6IHtcbiAgICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIiwgXCJmZWF0dXJlXCIsIFwiZmVhdHVyZS1zdGF0ZVwiXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtZHJpdmVuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlXCI6IHtcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIHZhbHVlOiBcIm51bWJlclwiLFxuICAgICAgbGVuZ3RoOiAyLFxuICAgICAgXCJkZWZhdWx0XCI6IFswLCAwXSxcbiAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICB1bml0czogXCJwaXhlbHNcIixcbiAgICAgIGRvYzogXCJUaGUgZ2VvbWV0cnkncyBvZmZzZXQuIFZhbHVlcyBhcmUgW3gsIHldIHdoZXJlIG5lZ2F0aXZlcyBpbmRpY2F0ZSBsZWZ0IGFuZCB1cCAob24gdGhlIGZsYXQgcGxhbmUpLCByZXNwZWN0aXZlbHkuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6IHRydWUsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tdHJhbnNsYXRlLWFuY2hvclwiOiB7XG4gICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgIHZhbHVlczoge1xuICAgICAgICBtYXA6IHtcbiAgICAgICAgICBkb2M6IFwiVGhlIGZpbGwgZXh0cnVzaW9uIGlzIHRyYW5zbGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG1hcC5cIlxuICAgICAgICB9LFxuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgIGRvYzogXCJUaGUgZmlsbCBleHRydXNpb24gaXMgdHJhbnNsYXRlZCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRvYzogXCJDb250cm9scyB0aGUgZnJhbWUgb2YgcmVmZXJlbmNlIGZvciBgZmlsbC1leHRydXNpb24tdHJhbnNsYXRlYC5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIm1hcFwiLFxuICAgICAgcmVxdWlyZXM6IFtcImZpbGwtZXh0cnVzaW9uLXRyYW5zbGF0ZVwiXSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuMjcuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNS4xLjBcIixcbiAgICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogZmFsc2UsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtcInpvb21cIl1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWNvbnN0YW50XCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24tcGF0dGVyblwiOiB7XG4gICAgICB0eXBlOiBcInJlc29sdmVkSW1hZ2VcIixcbiAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICBkb2M6IFwiTmFtZSBvZiBpbWFnZSBpbiBzcHJpdGUgdG8gdXNlIGZvciBkcmF3aW5nIGltYWdlcyBvbiBleHRydWRlZCBmaWxscy4gRm9yIHNlYW1sZXNzIHBhdHRlcm5zLCBpbWFnZSB3aWR0aCBhbmQgaGVpZ2h0IG11c3QgYmUgYSBmYWN0b3Igb2YgdHdvICgyLCA0LCA4LCAuLi4sIDUxMikuIE5vdGUgdGhhdCB6b29tLWRlcGVuZGVudCBleHByZXNzaW9ucyB3aWxsIGJlIGV2YWx1YXRlZCBvbmx5IGF0IGludGVnZXIgem9vbSBsZXZlbHMuXCIsXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIGpzOiBcIjAuNDkuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNi41LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjExLjBcIixcbiAgICAgICAgICBpb3M6IFwiNC40LjBcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXhwcmVzc2lvbjoge1xuICAgICAgICBpbnRlcnBvbGF0ZWQ6IGZhbHNlLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCJcbiAgICB9LFxuICAgIFwiZmlsbC1leHRydXNpb24taGVpZ2h0XCI6IHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICBcImRlZmF1bHRcIjogMCxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICB1bml0czogXCJtZXRlcnNcIixcbiAgICAgIGRvYzogXCJUaGUgaGVpZ2h0IHdpdGggd2hpY2ggdG8gZXh0cnVkZSB0aGlzIGxheWVyLlwiLFxuICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgIFwic2RrLXN1cHBvcnRcIjoge1xuICAgICAgICBcImJhc2ljIGZ1bmN0aW9uYWxpdHlcIjoge1xuICAgICAgICAgIGpzOiBcIjAuMjcuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNS4xLjBcIixcbiAgICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGF0YS1kcml2ZW4gc3R5bGluZ1wiOiB7XG4gICAgICAgICAganM6IFwiMC4yNy4wXCIsXG4gICAgICAgICAgYW5kcm9pZDogXCI1LjEuMFwiLFxuICAgICAgICAgIGlvczogXCIzLjYuMFwiLFxuICAgICAgICAgIG1hY29zOiBcIjAuNS4wXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiB0cnVlLFxuICAgICAgICBwYXJhbWV0ZXJzOiBbXCJ6b29tXCIsIFwiZmVhdHVyZVwiLCBcImZlYXR1cmUtc3RhdGVcIl1cbiAgICAgIH0sXG4gICAgICBcInByb3BlcnR5LXR5cGVcIjogXCJkYXRhLWRyaXZlblwiXG4gICAgfSxcbiAgICBcImZpbGwtZXh0cnVzaW9uLWJhc2VcIjoge1xuICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgIFwiZGVmYXVsdFwiOiAwLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIHVuaXRzOiBcIm1ldGVyc1wiLFxuICAgICAgZG9jOiBcIlRoZSBoZWlnaHQgd2l0aCB3aGljaCB0byBleHRydWRlIHRoZSBiYXNlIG9mIHRoaXMgbGF5ZXIuIE11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBmaWxsLWV4dHJ1c2lvbi1oZWlnaHRgLlwiLFxuICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgIHJlcXVpcmVzOiBbXCJmaWxsLWV4dHJ1c2lvbi1oZWlnaHRcIl0sXG4gICAgICBcInNkay1zdXBwb3J0XCI6IHtcbiAgICAgICAgXCJiYXNpYyBmdW5jdGlvbmFsaXR5XCI6IHtcbiAgICAgICAgICBqczogXCIwLjI3LjBcIixcbiAgICAgICAgICBhbmRyb2lkOiBcIjUuMS4wXCIsXG4gICAgICAgICAgaW9zOiBcIjMuNi4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC41LjBcIlxuICAgICAgICB9LFxuICAgICAgICBcImRhdGEtZHJpdmVuIHN0eWxpbmdcIjoge1xuICAgICAgICAgIGpzOiBcIjAuMjcuMFwiLFxuICAgICAgICAgIGFuZHJvaWQ6IFwiNS4xLjBcIixcbiAgICAgICAgICBpb3M6IFwiMy42LjBcIixcbiAgICAgICAgICBtYWNvczogXCIwLjUuMFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleHByZXNzaW9uOiB7XG4gICAgICAgIGludGVycG9sYXRlZDogdHJ1ZSxcbiAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiLCBcImZlYXR1cmVcIiwgXCJmZWF0dXJlLXN0YXRlXCJdXG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0eS10eXBlXCI6IFwiZGF0YS1kcml2ZW5cIlxuICAgIH0sXG4gICAgXCJmaWxsLWV4dHJ1c2lvbi12ZXJ0aWNhbC1ncmFkaWVudFwiOiB7XG4gICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgICAgZG9jOiBcIldoZXRoZXIgdG8gYXBwbHkgYSB2ZXJ0aWNhbCBncmFkaWVudCB0byB0aGUgc2lkZXMgb2YgYSBmaWxsLWV4dHJ1c2lvbiBsYXllci4gSWYgdHJ1ZSwgc2lkZXMgd2lsbCBiZSBzaGFkZWQgc2xpZ2h0bHkgZGFya2VyIGZhcnRoZXIgZG93bi5cIixcbiAgICAgIHRyYW5zaXRpb246IGZhbHNlLFxuICAgICAgXCJzZGstc3VwcG9ydFwiOiB7XG4gICAgICAgIFwiYmFzaWMgZnVuY3Rpb25hbGl0eVwiOiB7XG4gICAgICAgICAganM6IFwiMC41MC4wXCIsXG4gICAgICAgICAgaW9zOiBcIjQuNy4wXCIsXG4gICAgICAgICAgbWFjb3M6IFwiMC4xMy4wXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgaW50ZXJwb2xhdGVkOiBmYWxzZSxcbiAgICAgICAgcGFyYW1ldGVyczogW1wiem9vbVwiXVxuICAgICAgfSxcbiAgICAgIFwicHJvcGVydHktdHlwZVwiOiBcImRhdGEtY29uc3RhbnRcIlxuICAgIH1cbiAgfSxcbiAgcGFpbnRfbGluZTogcGFpbnRfbGluZSxcbiAgcGFpbnRfY2lyY2xlOiBwYWludF9jaXJjbGUsXG4gIHBhaW50X2hlYXRtYXA6IHBhaW50X2hlYXRtYXAsXG4gIHBhaW50X3N5bWJvbDogcGFpbnRfc3ltYm9sLFxuICBwYWludF9yYXN0ZXI6IHBhaW50X3Jhc3RlcixcbiAgcGFpbnRfaGlsbHNoYWRlOiBwYWludF9oaWxsc2hhZGUsXG4gIHBhaW50X2JhY2tncm91bmQ6IHBhaW50X2JhY2tncm91bmQsXG4gIHBhaW50X3NreTogcGFpbnRfc2t5LFxuICB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uLFxuICBcInByb3BlcnR5LXR5cGVcIjoge1xuICAgIFwiZGF0YS1kcml2ZW5cIjoge1xuICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG4gICAgICBkb2M6IFwiUHJvcGVydHkgaXMgaW50ZXJwb2xhYmxlIGFuZCBjYW4gYmUgcmVwcmVzZW50ZWQgdXNpbmcgYSBwcm9wZXJ0eSBleHByZXNzaW9uLlwiXG4gICAgfSxcbiAgICBcImNyb3NzLWZhZGVkXCI6IHtcbiAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiLFxuICAgICAgZG9jOiBcIlByb3BlcnR5IGlzIG5vbi1pbnRlcnBvbGFibGU7IHJhdGhlciwgaXRzIHZhbHVlcyB3aWxsIGJlIGNyb3NzLWZhZGVkIHRvIHNtb290aGx5IHRyYW5zaXRpb24gYmV0d2VlbiBpbnRlZ2VyIHpvb21zLlwiXG4gICAgfSxcbiAgICBcImNyb3NzLWZhZGVkLWRhdGEtZHJpdmVuXCI6IHtcbiAgICAgIHR5cGU6IFwicHJvcGVydHktdHlwZVwiLFxuICAgICAgZG9jOiBcIlByb3BlcnR5IGlzIG5vbi1pbnRlcnBvbGFibGU7IHJhdGhlciwgaXRzIHZhbHVlcyB3aWxsIGJlIGNyb3NzLWZhZGVkIHRvIHNtb290aGx5IHRyYW5zaXRpb24gYmV0d2VlbiBpbnRlZ2VyIHpvb21zLiBJdCBjYW4gYmUgcmVwcmVzZW50ZWQgdXNpbmcgYSBwcm9wZXJ0eSBleHByZXNzaW9uLlwiXG4gICAgfSxcbiAgICBcImNvbG9yLXJhbXBcIjoge1xuICAgICAgdHlwZTogXCJwcm9wZXJ0eS10eXBlXCIsXG4gICAgICBkb2M6IFwiUHJvcGVydHkgc2hvdWxkIGJlIHNwZWNpZmllZCB1c2luZyBhIGNvbG9yIHJhbXAgZnJvbSB3aGljaCB0aGUgb3V0cHV0IGNvbG9yIGNhbiBiZSBzYW1wbGVkIGJhc2VkIG9uIGEgcHJvcGVydHkgY2FsY3VsYXRpb24uXCJcbiAgICB9LFxuICAgIFwiZGF0YS1jb25zdGFudFwiOiB7XG4gICAgICB0eXBlOiBcInByb3BlcnR5LXR5cGVcIixcbiAgICAgIGRvYzogXCJQcm9wZXJ0eSBpcyBpbnRlcnBvbGFibGUgYnV0IGNhbm5vdCBiZSByZXByZXNlbnRlZCB1c2luZyBhIHByb3BlcnR5IGV4cHJlc3Npb24uXCJcbiAgICB9LFxuICAgIGNvbnN0YW50OiB7XG4gICAgICB0eXBlOiBcInByb3BlcnR5LXR5cGVcIixcbiAgICAgIGRvYzogXCJQcm9wZXJ0eSBpcyBjb25zdGFudCBhY3Jvc3MgYWxsIHpvb20gbGV2ZWxzIGFuZCBwcm9wZXJ0eSB2YWx1ZXMuXCJcbiAgICB9XG4gIH0sXG4gIHByb21vdGVJZDogcHJvbW90ZUlkXG59OyAvLyBOb3RlOiBUaGlzIHJlZ2V4IG1hdGNoZXMgZXZlbiBpbnZhbGlkIEpTT04gc3RyaW5ncywgYnV0IHNpbmNlIHdl4oCZcmVcbi8vIHdvcmtpbmcgb24gdGhlIG91dHB1dCBvZiBgSlNPTi5zdHJpbmdpZnlgIHdlIGtub3cgdGhhdCBvbmx5IHZhbGlkIHN0cmluZ3Ncbi8vIGFyZSBwcmVzZW50ICh1bmxlc3MgdGhlIHVzZXIgc3VwcGxpZWQgYSB3ZWlyZCBgb3B0aW9ucy5pbmRlbnRgIGJ1dCBpblxuLy8gdGhhdCBjYXNlIHdlIGRvbuKAmXQgY2FyZSBzaW5jZSB0aGUgb3V0cHV0IHdvdWxkIGJlIGludmFsaWQgYW55d2F5KS5cblxudmFyIHN0cmluZ09yQ2hhciA9IC8oXCIoPzpbXlxcXFxcIl18XFxcXC4pKlwiKXxbOixdL2c7XG5cbnZhciBqc29uU3RyaW5naWZ5UHJldHR5Q29tcGFjdCA9IGZ1bmN0aW9uIHN0cmluZ2lmeShwYXNzZWRPYmosIG9wdGlvbnMpIHtcbiAgdmFyIGluZGVudCwgbWF4TGVuZ3RoLCByZXBsYWNlcjtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGluZGVudCA9IEpTT04uc3RyaW5naWZ5KFsxXSwgdW5kZWZpbmVkLCBvcHRpb25zLmluZGVudCA9PT0gdW5kZWZpbmVkID8gMiA6IG9wdGlvbnMuaW5kZW50KS5zbGljZSgyLCAtMyk7XG4gIG1heExlbmd0aCA9IGluZGVudCA9PT0gXCJcIiA/IEluZmluaXR5IDogb3B0aW9ucy5tYXhMZW5ndGggPT09IHVuZGVmaW5lZCA/IDgwIDogb3B0aW9ucy5tYXhMZW5ndGg7XG4gIHJlcGxhY2VyID0gb3B0aW9ucy5yZXBsYWNlcjtcbiAgcmV0dXJuIGZ1bmN0aW9uIF9zdHJpbmdpZnkob2JqLCBjdXJyZW50SW5kZW50LCByZXNlcnZlZCkge1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHZhciBlbmQsIGluZGV4LCBpdGVtcywga2V5LCBrZXlQYXJ0LCBrZXlzLCBsZW5ndGgsIG5leHRJbmRlbnQsIHByZXR0aWZpZWQsIHN0YXJ0LCBzdHJpbmcsIHZhbHVlO1xuXG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgfVxuXG4gICAgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkob2JqLCByZXBsYWNlcik7XG5cbiAgICBpZiAoc3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgbGVuZ3RoID0gbWF4TGVuZ3RoIC0gY3VycmVudEluZGVudC5sZW5ndGggLSByZXNlcnZlZDtcblxuICAgIGlmIChzdHJpbmcubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgcHJldHRpZmllZCA9IHN0cmluZy5yZXBsYWNlKHN0cmluZ09yQ2hhciwgZnVuY3Rpb24gKG1hdGNoLCBzdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdMaXRlcmFsIHx8IG1hdGNoICsgXCIgXCI7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHByZXR0aWZpZWQubGVuZ3RoIDw9IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcHJldHRpZmllZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZXIgIT0gbnVsbCkge1xuICAgICAgb2JqID0gSlNPTi5wYXJzZShzdHJpbmcpO1xuICAgICAgcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICBuZXh0SW5kZW50ID0gY3VycmVudEluZGVudCArIGluZGVudDtcbiAgICAgIGl0ZW1zID0gW107XG4gICAgICBpbmRleCA9IDA7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgc3RhcnQgPSBcIltcIjtcbiAgICAgICAgZW5kID0gXCJdXCI7XG4gICAgICAgIGxlbmd0aCA9IG9iai5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaXRlbXMucHVzaChfc3RyaW5naWZ5KG9ialtpbmRleF0sIG5leHRJbmRlbnQsIGluZGV4ID09PSBsZW5ndGggLSAxID8gMCA6IDEpIHx8IFwibnVsbFwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBcIntcIjtcbiAgICAgICAgZW5kID0gXCJ9XCI7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgICBrZXlQYXJ0ID0gSlNPTi5zdHJpbmdpZnkoa2V5KSArIFwiOiBcIjtcbiAgICAgICAgICB2YWx1ZSA9IF9zdHJpbmdpZnkob2JqW2tleV0sIG5leHRJbmRlbnQsIGtleVBhcnQubGVuZ3RoICsgKGluZGV4ID09PSBsZW5ndGggLSAxID8gMCA6IDEpKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKGtleVBhcnQgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBbc3RhcnQsIGluZGVudCArIGl0ZW1zLmpvaW4oXCIsXFxuXCIgKyBuZXh0SW5kZW50KSwgZW5kXS5qb2luKFwiXFxuXCIgKyBjdXJyZW50SW5kZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5nO1xuICB9KHBhc3NlZE9iaiwgXCJcIiwgMCk7XG59O1xuXG5mdW5jdGlvbiBzb3J0S2V5c0J5KG9iaiwgcmVmZXJlbmNlKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gcmVmZXJlbmNlKSB7XG4gICAgaWYgKG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2tleSBpbiBvYmopIHtcbiAgICBpZiAocmVzdWx0W19rZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdFtfa2V5XSA9IG9ialtfa2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JtYXQoc3R5bGUpIHtcbiAgdmFyIHNwYWNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAyO1xuICBzdHlsZSA9IHNvcnRLZXlzQnkoc3R5bGUsIHY4LiRyb290KTtcblxuICBpZiAoc3R5bGUubGF5ZXJzKSB7XG4gICAgc3R5bGUubGF5ZXJzID0gc3R5bGUubGF5ZXJzLm1hcChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIHJldHVybiBzb3J0S2V5c0J5KGxheWVyLCB2OC5sYXllcik7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ganNvblN0cmluZ2lmeVByZXR0eUNvbXBhY3Qoc3R5bGUsIHtcbiAgICBpbmRlbnQ6IHNwYWNlXG4gIH0pO1xufVxuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4pIHtcbiAgdmFyIG1vZHVsZSA9IHtcbiAgICBleHBvcnRzOiB7fVxuICB9O1xuICByZXR1cm4gZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG5mdW5jdGlvbiBjb21tb25qc1JlcXVpcmUodGFyZ2V0KSB7XG4gIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGR5bmFtaWNhbGx5IHJlcXVpcmUgXCInICsgdGFyZ2V0ICsgJ1wiLiBQbGVhc2UgY29uZmlndXJlIHRoZSBkeW5hbWljUmVxdWlyZVRhcmdldHMgb3B0aW9uIG9mIEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzIGFwcHJvcHJpYXRlbHkgZm9yIHRoaXMgcmVxdWlyZSBjYWxsIHRvIGJlaGF2ZSBwcm9wZXJseS4nKTtcbn1cbi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG5cblxudmFyIHB1bnljb2RlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICAoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG4gICAgdmFyIGZyZWVFeHBvcnRzID0gZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuICAgIHZhciBmcmVlTW9kdWxlID0gbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuICAgIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGNvbW1vbmpzR2xvYmFsID09ICdvYmplY3QnICYmIGNvbW1vbmpzR2xvYmFsO1xuXG4gICAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbCkge1xuICAgICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cbiAgICAgKiBAbmFtZSBwdW55Y29kZVxuICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAqL1xuXG5cbiAgICB2YXIgcHVueWNvZGUsXG5cbiAgICAvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG4gICAgbWF4SW50ID0gMjE0NzQ4MzY0NyxcbiAgICAgICAgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG4gICAgLyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuICAgIGJhc2UgPSAzNixcbiAgICAgICAgdE1pbiA9IDEsXG4gICAgICAgIHRNYXggPSAyNixcbiAgICAgICAgc2tldyA9IDM4LFxuICAgICAgICBkYW1wID0gNzAwLFxuICAgICAgICBpbml0aWFsQmlhcyA9IDcyLFxuICAgICAgICBpbml0aWFsTiA9IDEyOCxcbiAgICAgICAgLy8gMHg4MFxuICAgIGRlbGltaXRlciA9ICctJyxcbiAgICAgICAgLy8gJ1xceDJEJ1xuXG4gICAgLyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cbiAgICByZWdleFB1bnljb2RlID0gL154bi0tLyxcbiAgICAgICAgcmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sXG4gICAgICAgIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG4gICAgcmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZyxcbiAgICAgICAgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG4gICAgLyoqIEVycm9yIG1lc3NhZ2VzICovXG4gICAgZXJyb3JzID0ge1xuICAgICAgJ292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcbiAgICAgICdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG4gICAgICAnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuICAgIH0sXG5cbiAgICAvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG4gICAgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuICAgICAgICBmbG9vciA9IE1hdGguZmxvb3IsXG4gICAgICAgIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cbiAgICAvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG4gICAga2V5O1xuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cbiAgICAgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG4gICAgICB0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAgICAgKiBpdGVtLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuICAgICAqIGFkZHJlc3Nlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG4gICAgICogY2hhcmFjdGVyLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gICAgICogZnVuY3Rpb24uXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG4gICAgICB2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcbiAgICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuICAgICAgICAvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuICAgICAgICByZXN1bHQgPSBwYXJ0c1swXSArICdAJztcbiAgICAgICAgc3RyaW5nID0gcGFydHNbMV07XG4gICAgICB9IC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblxuXG4gICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuICAgICAgdmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuICAgICAgdmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuICAgICAgcmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcbiAgICAgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG4gICAgICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAgICAgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcbiAgICAgKiBtYXRjaGluZyBVVEYtMTYuXG4gICAgICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4gICAgICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG4gICAgICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcbiAgICAgKiBAbmFtZSBkZWNvZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcbiAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICBjb3VudGVyID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGV4dHJhO1xuXG4gICAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cbiAgICAgICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblxuICAgICAgICAgIGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkge1xuICAgICAgICAgICAgLy8gbG93IHN1cnJvZ2F0ZVxuICAgICAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcbiAgICAgICAgICAgIC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuICAgICAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG4gICAgICogQG5hbWUgZW5jb2RlXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcbiAgICAgIHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XG5cbiAgICAgICAgaWYgKHZhbHVlID4gMHhGRkZGKSB7XG4gICAgICAgICAgdmFsdWUgLT0gMHgxMDAwMDtcbiAgICAgICAgICBvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcbiAgICAgICAgICB2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG4gICAgICAgIH1cblxuICAgICAgICBvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG4gICAgICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG4gICAgICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuICAgICAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG4gICAgICBpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuICAgICAgICByZXR1cm4gY29kZVBvaW50IC0gMjI7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQgLSA2NTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICAgICAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICAgICAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG4gICAgICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gICAgICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAgICAgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcbiAgICAgIC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG4gICAgICAvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcbiAgICAgIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gICAgICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuICAgICAgdmFyIGsgPSAwO1xuICAgICAgZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcbiAgICAgIGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblxuICAgICAgZm9yICg7XG4gICAgICAvKiBubyBpbml0aWFsaXphdGlvbiAqL1xuICAgICAgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcbiAgICAgICAgZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcbiAgICAgKiBzeW1ib2xzLlxuICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICAgICAgLy8gRG9uJ3QgdXNlIFVDUy0yXG4gICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG4gICAgICAgICAgb3V0LFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIG4gPSBpbml0aWFsTixcbiAgICAgICAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG4gICAgICAgICAgYmFzaWMsXG4gICAgICAgICAgaixcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBvbGRpLFxuICAgICAgICAgIHcsXG4gICAgICAgICAgayxcbiAgICAgICAgICBkaWdpdCxcbiAgICAgICAgICB0LFxuXG4gICAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cbiAgICAgIGJhc2VNaW51c1Q7IC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuICAgICAgLy8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcbiAgICAgIC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG4gICAgICBiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cbiAgICAgIGlmIChiYXNpYyA8IDApIHtcbiAgICAgICAgYmFzaWMgPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuICAgICAgICAvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuICAgICAgICAgIGVycm9yKCdub3QtYmFzaWMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuICAgICAgfSAvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG4gICAgICAvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cbiAgICAgIGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOylcbiAgICAgIC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi9cbiAgICAgIHtcbiAgICAgICAgLy8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuICAgICAgICAvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG4gICAgICAgIC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG4gICAgICAgIC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG4gICAgICAgIC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG4gICAgICAgIGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTs7XG4gICAgICAgIC8qIG5vIGNvbmRpdGlvbiAqL1xuICAgICAgICBrICs9IGJhc2UpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICAgIGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cbiAgICAgICAgICBpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG4gICAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IGRpZ2l0ICogdztcbiAgICAgICAgICB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG5cbiAgICAgICAgICBpZiAoZGlnaXQgPCB0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cbiAgICAgICAgICBpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG4gICAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3ICo9IGJhc2VNaW51c1Q7XG4gICAgICAgIH1cblxuICAgICAgICBvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcbiAgICAgICAgYmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7IC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG4gICAgICAgIC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cbiAgICAgICAgaWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuICAgICAgICAgIGVycm9yKCdvdmVyZmxvdycpO1xuICAgICAgICB9XG5cbiAgICAgICAgbiArPSBmbG9vcihpIC8gb3V0KTtcbiAgICAgICAgaSAlPSBvdXQ7IC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblxuICAgICAgICBvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gICAgICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICAgIHZhciBuLFxuICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgIGhhbmRsZWRDUENvdW50LFxuICAgICAgICAgIGJhc2ljTGVuZ3RoLFxuICAgICAgICAgIGJpYXMsXG4gICAgICAgICAgaixcbiAgICAgICAgICBtLFxuICAgICAgICAgIHEsXG4gICAgICAgICAgayxcbiAgICAgICAgICB0LFxuICAgICAgICAgIGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICBvdXRwdXQgPSBbXSxcblxuICAgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cbiAgICAgIGlucHV0TGVuZ3RoLFxuXG4gICAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cbiAgICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcbiAgICAgICAgICBiYXNlTWludXNULFxuICAgICAgICAgIHFNaW51c1Q7IC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblxuICAgICAgaW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTsgLy8gQ2FjaGUgdGhlIGxlbmd0aFxuXG4gICAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDsgLy8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblxuICAgICAgbiA9IGluaXRpYWxOO1xuICAgICAgZGVsdGEgPSAwO1xuICAgICAgYmlhcyA9IGluaXRpYWxCaWFzOyAvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoOyAvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcbiAgICAgIC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cbiAgICAgIC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXG4gICAgICBpZiAoYmFzaWNMZW5ndGgpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcbiAgICAgIH0gLy8gTWFpbiBlbmNvZGluZyBsb29wOlxuXG5cbiAgICAgIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG4gICAgICAgIC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcbiAgICAgICAgLy8gbGFyZ2VyIG9uZTpcbiAgICAgICAgZm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG4gICAgICAgICAgICBtID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG4gICAgICAgIC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cblxuICAgICAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cbiAgICAgICAgaWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcbiAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG4gICAgICAgIG4gPSBtO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cbiAgICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG4gICAgICAgICAgICBlcnJvcignb3ZlcmZsb3cnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09IG4pIHtcbiAgICAgICAgICAgIC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG4gICAgICAgICAgICBmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7O1xuICAgICAgICAgICAgLyogbm8gY29uZGl0aW9uICovXG4gICAgICAgICAgICBrICs9IGJhc2UpIHtcbiAgICAgICAgICAgICAgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiBrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzO1xuXG4gICAgICAgICAgICAgIGlmIChxIDwgdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcU1pbnVzVCA9IHEgLSB0O1xuICAgICAgICAgICAgICBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG4gICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSkpO1xuICAgICAgICAgICAgICBxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG4gICAgICAgICAgICBiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuICAgICAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICAgICAgKytoYW5kbGVkQ1BDb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICArK2RlbHRhO1xuICAgICAgICArK247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3NcbiAgICAgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG4gICAgICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG4gICAgICogY29udmVydGVkIHRvIFVuaWNvZGUuXG4gICAgICogQG1lbWJlck9mIHB1bnljb2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuICAgICAqIGNvbnZlcnQgdG8gVW5pY29kZS5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcbiAgICAgKiBzdHJpbmcuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuICAgICAgcmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICByZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZykgPyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpIDogc3RyaW5nO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuICAgICAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuICAgICAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuICAgICAqIEFTQ0lJLlxuICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG4gICAgICogVW5pY29kZSBzdHJpbmcuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuICAgICAqIGVtYWlsIGFkZHJlc3MuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcbiAgICAgIHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpID8gJ3huLS0nICsgZW5jb2RlKHN0cmluZykgOiBzdHJpbmc7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cblxuICAgIHB1bnljb2RlID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG4gICAgICAgKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAgICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAgICovXG4gICAgICAndmVyc2lvbic6ICcxLjMuMicsXG5cbiAgICAgIC8qKlxuICAgICAgICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcbiAgICAgICAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG4gICAgICAgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cbiAgICAgICAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgICd1Y3MyJzoge1xuICAgICAgICAnZGVjb2RlJzogdWNzMmRlY29kZSxcbiAgICAgICAgJ2VuY29kZSc6IHVjczJlbmNvZGVcbiAgICAgIH0sXG4gICAgICAnZGVjb2RlJzogZGVjb2RlLFxuICAgICAgJ2VuY29kZSc6IGVuY29kZSxcbiAgICAgICd0b0FTQ0lJJzogdG9BU0NJSSxcbiAgICAgICd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcbiAgICB9O1xuICAgIC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuICAgIC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuICAgIC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblxuICAgIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG4gICAgICBpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcbiAgICAgICAgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcbiAgICAgICAgZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuICAgICAgICBmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuICAgICAgICAgIHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG4gICAgICByb290LnB1bnljb2RlID0gcHVueWNvZGU7XG4gICAgfVxuICB9KShjb21tb25qc0dsb2JhbCk7XG59KTtcbnZhciB1dGlsID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTsgLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbnZhciBkZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDsgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG5cbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0cixcbiAgICAgICAgdnN0cixcbiAgICAgICAgayxcbiAgICAgICAgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59OyAvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cblxuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24gc3RyaW5naWZ5UHJpbWl0aXZlKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuXG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIHF1ZXJ5c3RyaW5nID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuICBleHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSBkZWNvZGU7XG4gIGV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSBlbmNvZGU7XG59KTtcbnZhciBwYXJzZSA9IHVybFBhcnNlO1xudmFyIHJlc29sdmUgPSB1cmxSZXNvbHZlO1xudmFyIHJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xudmFyIGZvcm1hdCQxID0gdXJsRm9ybWF0O1xudmFyIFVybF8xID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59IC8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxuXG5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG5zaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbi8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG5kZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxudW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbmF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4vLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4vLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbi8vIHRoZW0uXG5ub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbnVuc2FmZVByb3RvY29sID0ge1xuICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICdqYXZhc2NyaXB0Oic6IHRydWVcbn0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAnamF2YXNjcmlwdDonOiB0cnVlXG59LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0Llxuc2xhc2hlZFByb3RvY29sID0ge1xuICAnaHR0cCc6IHRydWUsXG4gICdodHRwcyc6IHRydWUsXG4gICdmdHAnOiB0cnVlLFxuICAnZ29waGVyJzogdHJ1ZSxcbiAgJ2ZpbGUnOiB0cnVlLFxuICAnaHR0cDonOiB0cnVlLFxuICAnaHR0cHM6JzogdHJ1ZSxcbiAgJ2Z0cDonOiB0cnVlLFxuICAnZ29waGVyOic6IHRydWUsXG4gICdmaWxlOic6IHRydWVcbn07XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuICB2YXIgdSA9IG5ldyBVcmwoKTtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH0gLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuXG5cbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPSBxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuICB2YXIgcmVzdCA9IHVybDsgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuXG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG5cbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcblxuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuXG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9IC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cblxuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG5cbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmIChzbGFzaGVzIHx8IHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIGhvc3RFbmQgPSBoZWM7XG4gICAgfSAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cblxuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcblxuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9IC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG5cblxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfSAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG5cblxuICAgIGhvc3RFbmQgPSAtMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIGhvc3RFbmQgPSBoZWM7XG4gICAgfSAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG5cblxuICAgIGlmIChob3N0RW5kID09PSAtMSkgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7IC8vIHB1bGwgb3V0IHBvcnQuXG5cbiAgICB0aGlzLnBhcnNlSG9zdCgpOyAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJzsgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cblxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiYgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7IC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuXG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG5cblxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG5cbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7IC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG5cbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG5cblxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSkgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcblxuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cblxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH0gLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cblxuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG5cbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG5cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG5cbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuXG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG5cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cblxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG5cbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJiB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfSAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG5cblxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9IC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuXG5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59OyAvLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5cblxuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcblxuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgPyB0aGlzLmhvc3RuYW1lIDogJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG5cbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJiB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IHF1ZXJ5ICYmICc/JyArIHF1ZXJ5IHx8ICcnO1xuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7IC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuXG4gIGlmICh0aGlzLnNsYXNoZXMgfHwgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24gKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcblxuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfSAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG5cblxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7IC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cblxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuXG5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcblxuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH0gLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cblxuXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcblxuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcblxuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuXG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSkge1xuICAgICAgICA7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuXG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0OyAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuXG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuXG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgICAgaXNSZWxBYnMgPSByZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLFxuICAgICAgbXVzdEVuZEFicyA9IGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8IHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdOyAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cblxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuXG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuXG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcblxuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG5cbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7ZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG5cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cblxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJyA/IHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycgPyByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoOyAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTsgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgPyByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG5cbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5OyAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG5cbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgKyAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsOyAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG5cbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG5cblxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJzsgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuXG4gIHZhciB1cCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuXG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfSAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG5cblxuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJiAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nOyAvLyBwdXQgdGhlIGhvc3QgYmFja1xuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6IHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7IC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID8gcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuXG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgcmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGg7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9IC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcblxuXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgKyAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cblxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcblxuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuXG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuXG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG5cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxudmFyIHVybCA9IHtcbiAgcGFyc2U6IHBhcnNlLFxuICByZXNvbHZlOiByZXNvbHZlLFxuICByZXNvbHZlT2JqZWN0OiByZXNvbHZlT2JqZWN0LFxuICBmb3JtYXQ6IGZvcm1hdCQxLFxuICBVcmw6IFVybF8xXG59O1xuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eVJlZmVyZW5jZShwcm9wZXJ0eU5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2OC5sYXlvdXQubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdjhbdjgubGF5b3V0W2ldXSkge1xuICAgICAgaWYgKGtleSA9PT0gcHJvcGVydHlOYW1lKSByZXR1cm4gdjhbdjgubGF5b3V0W2ldXVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCB2OC5wYWludC5sZW5ndGg7IF9pKyspIHtcbiAgICBmb3IgKHZhciBfa2V5MiBpbiB2OFt2OC5wYWludFtfaV1dKSB7XG4gICAgICBpZiAoX2tleTIgPT09IHByb3BlcnR5TmFtZSkgcmV0dXJuIHY4W3Y4LnBhaW50W19pXV1bX2tleTJdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBlYWNoU291cmNlKHN0eWxlLCBjYWxsYmFjaykge1xuICBmb3IgKHZhciBrIGluIHN0eWxlLnNvdXJjZXMpIHtcbiAgICBjYWxsYmFjayhzdHlsZS5zb3VyY2VzW2tdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlYWNoTGF5ZXIoc3R5bGUsIGNhbGxiYWNrKSB7XG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdHlsZS5sYXllcnMpLFxuICAgICAgX3N0ZXA7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgdmFyIF9sYXllciA9IF9zdGVwLnZhbHVlO1xuICAgICAgY2FsbGJhY2soX2xheWVyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvci5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yLmYoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlYWNoUHJvcGVydHkoc3R5bGUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGlubmVyKGxheWVyLCBwcm9wZXJ0eVR5cGUpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IGxheWVyW3Byb3BlcnR5VHlwZV07XG4gICAgaWYgKCFwcm9wZXJ0aWVzKSByZXR1cm47XG4gICAgT2JqZWN0LmtleXMocHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIHBhdGg6IFtsYXllci5pZCwgcHJvcGVydHlUeXBlLCBrZXldLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IHByb3BlcnRpZXNba2V5XSxcbiAgICAgICAgcmVmZXJlbmNlOiBnZXRQcm9wZXJ0eVJlZmVyZW5jZShrZXkpLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh4KSB7XG4gICAgICAgICAgcHJvcGVydGllc1trZXldID0geDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBlYWNoTGF5ZXIoc3R5bGUsIGZ1bmN0aW9uIChsYXllcikge1xuICAgIGlmIChvcHRpb25zLnBhaW50KSB7XG4gICAgICBpbm5lcihsYXllciwgJ3BhaW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubGF5b3V0KSB7XG4gICAgICBpbm5lcihsYXllciwgJ2xheW91dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVhY2hMYXlvdXQobGF5ZXIsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGsgaW4gbGF5ZXIpIHtcbiAgICBpZiAoay5pbmRleE9mKCdsYXlvdXQnKSA9PT0gMCkge1xuICAgICAgY2FsbGJhY2sobGF5ZXJba10sIGspO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlYWNoUGFpbnQobGF5ZXIsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGsgaW4gbGF5ZXIpIHtcbiAgICBpZiAoay5pbmRleE9mKCdwYWludCcpID09PSAwKSB7XG4gICAgICBjYWxsYmFjayhsYXllcltrXSwgayk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDb25zdGFudChzdHlsZSwgdmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWVbMF0gPT09ICdAJykge1xuICAgIHJldHVybiByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHN0eWxlLmNvbnN0YW50c1t2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlLnN0b3BzKTtcbn1cblxuZnVuY3Rpb24gcmVuYW1lUHJvcGVydHkob2JqLCBmcm9tLCB0bykge1xuICBvYmpbdG9dID0gb2JqW2Zyb21dO1xuICBkZWxldGUgb2JqW2Zyb21dO1xufVxuXG5mdW5jdGlvbiBtaWdyYXRlVG9WOChzdHlsZSkge1xuICBzdHlsZS52ZXJzaW9uID0gODtcbiAgZWFjaFNvdXJjZShzdHlsZSwgZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UudHlwZSA9PT0gJ3ZpZGVvJyAmJiBzb3VyY2UudXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmFtZVByb3BlcnR5KHNvdXJjZSwgJ3VybCcsICd1cmxzJyk7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZS50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICBzb3VyY2UuY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgcmV0dXJuIGNvb3JkLnJldmVyc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgZWFjaExheW91dChsYXllciwgZnVuY3Rpb24gKGxheW91dCkge1xuICAgICAgaWYgKGxheW91dFsnc3ltYm9sLW1pbi1kaXN0YW5jZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVuYW1lUHJvcGVydHkobGF5b3V0LCAnc3ltYm9sLW1pbi1kaXN0YW5jZScsICdzeW1ib2wtc3BhY2luZycpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVhY2hQYWludChsYXllciwgZnVuY3Rpb24gKHBhaW50KSB7XG4gICAgICBpZiAocGFpbnRbJ2JhY2tncm91bmQtaW1hZ2UnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbmFtZVByb3BlcnR5KHBhaW50LCAnYmFja2dyb3VuZC1pbWFnZScsICdiYWNrZ3JvdW5kLXBhdHRlcm4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhaW50WydsaW5lLWltYWdlJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW5hbWVQcm9wZXJ0eShwYWludCwgJ2xpbmUtaW1hZ2UnLCAnbGluZS1wYXR0ZXJuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWludFsnZmlsbC1pbWFnZSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVuYW1lUHJvcGVydHkocGFpbnQsICdmaWxsLWltYWdlJywgJ2ZpbGwtcGF0dGVybicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgZWFjaFByb3BlcnR5KHN0eWxlLCB7XG4gICAgcGFpbnQ6IHRydWUsXG4gICAgbGF5b3V0OiB0cnVlXG4gIH0sIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgIHZhciB2YWx1ZSA9IHJlc29sdmVDb25zdGFudChzdHlsZSwgcHJvcGVydHkudmFsdWUpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YWx1ZS5zdG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgICAgIHN0b3BbMV0gPSByZXNvbHZlQ29uc3RhbnQoc3R5bGUsIHN0b3BbMV0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvcGVydHkuc2V0KHZhbHVlKTtcbiAgfSk7XG4gIGRlbGV0ZSBzdHlsZS5jb25zdGFudHM7XG4gIGVhY2hMYXllcihzdHlsZSwgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgZWFjaExheW91dChsYXllciwgZnVuY3Rpb24gKGxheW91dCkge1xuICAgICAgZGVsZXRlIGxheW91dFsndGV4dC1tYXgtc2l6ZSddO1xuICAgICAgZGVsZXRlIGxheW91dFsnaWNvbi1tYXgtc2l6ZSddO1xuICAgIH0pO1xuICAgIGVhY2hQYWludChsYXllciwgZnVuY3Rpb24gKHBhaW50KSB7XG4gICAgICBpZiAocGFpbnRbJ3RleHQtc2l6ZSddKSB7XG4gICAgICAgIGlmICghbGF5ZXIubGF5b3V0KSBsYXllci5sYXlvdXQgPSB7fTtcbiAgICAgICAgbGF5ZXIubGF5b3V0Wyd0ZXh0LXNpemUnXSA9IHBhaW50Wyd0ZXh0LXNpemUnXTtcbiAgICAgICAgZGVsZXRlIHBhaW50Wyd0ZXh0LXNpemUnXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhaW50WydpY29uLXNpemUnXSkge1xuICAgICAgICBpZiAoIWxheWVyLmxheW91dCkgbGF5ZXIubGF5b3V0ID0ge307XG4gICAgICAgIGxheWVyLmxheW91dFsnaWNvbi1zaXplJ10gPSBwYWludFsnaWNvbi1zaXplJ107XG4gICAgICAgIGRlbGV0ZSBwYWludFsnaWNvbi1zaXplJ107XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIG1pZ3JhdGVGb250c3RhY2tVUkwoaW5wdXQpIHtcbiAgICB2YXIgaW5wdXRQYXJzZWQgPSB1cmwucGFyc2UoaW5wdXQpO1xuICAgIHZhciBpbnB1dFBhdGhuYW1lUGFydHMgPSBpbnB1dFBhcnNlZC5wYXRobmFtZS5zcGxpdCgnLycpO1xuXG4gICAgaWYgKGlucHV0UGFyc2VkLnByb3RvY29sICE9PSAnbWFwYm94OicpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9IGVsc2UgaWYgKGlucHV0UGFyc2VkLmhvc3RuYW1lID09PSAnZm9udHN0YWNrJykge1xuICAgICAgcmV0dXJuICdtYXBib3g6Ly9mb250cy9tYXBib3gve2ZvbnRzdGFja30ve3JhbmdlfS5wYmYnO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRQYXJzZWQuaG9zdG5hbWUgPT09ICdmb250cycpIHtcbiAgICAgIHJldHVybiBcIm1hcGJveDovL2ZvbnRzL1wiLmNvbmNhdChpbnB1dFBhdGhuYW1lUGFydHNbMl0sIFwiL3tmb250c3RhY2t9L3tyYW5nZX0ucGJmXCIpO1xuICAgIH0gZWxzZSA7XG4gIH1cblxuICBpZiAoc3R5bGUuZ2x5cGhzKSB7XG4gICAgc3R5bGUuZ2x5cGhzID0gbWlncmF0ZUZvbnRzdGFja1VSTChzdHlsZS5nbHlwaHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWlncmF0ZUZvbnRTdGFjayhmb250KSB7XG4gICAgZnVuY3Rpb24gc3BsaXRBbmRUcmltKHN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZy5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcy50cmltKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmb250KSkge1xuICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZm9udCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBzcGxpdEFuZFRyaW0oZm9udCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZm9udCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvbnQuc3RvcHMuZm9yRWFjaChmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICBzdG9wWzFdID0gc3BsaXRBbmRUcmltKHN0b3BbMV0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZm9udDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIGZvbnQgdmFsdWUnKTtcbiAgICB9XG4gIH1cblxuICBlYWNoTGF5ZXIoc3R5bGUsIGZ1bmN0aW9uIChsYXllcikge1xuICAgIGVhY2hMYXlvdXQobGF5ZXIsIGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgICAgIGlmIChsYXlvdXRbJ3RleHQtZm9udCddKSB7XG4gICAgICAgIGxheW91dFsndGV4dC1mb250J10gPSBtaWdyYXRlRm9udFN0YWNrKGxheW91dFsndGV4dC1mb250J10pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgdmFyIGZpcnN0U3ltYm9sTGF5ZXIgPSAwO1xuXG4gIGZvciAodmFyIGkgPSBzdHlsZS5sYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgX2xheWVyMiA9IHN0eWxlLmxheWVyc1tpXTtcblxuICAgIGlmIChfbGF5ZXIyLnR5cGUgIT09ICdzeW1ib2wnKSB7XG4gICAgICBmaXJzdFN5bWJvbExheWVyID0gaSArIDE7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgc3ltYm9sTGF5ZXJzID0gc3R5bGUubGF5ZXJzLnNwbGljZShmaXJzdFN5bWJvbExheWVyKTtcbiAgc3ltYm9sTGF5ZXJzLnJldmVyc2UoKTtcbiAgc3R5bGUubGF5ZXJzID0gc3R5bGUubGF5ZXJzLmNvbmNhdChzeW1ib2xMYXllcnMpO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChvdXRwdXQpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGlucHV0cyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkzID0gMTsgX2tleTMgPCBfbGVuOyBfa2V5MysrKSB7XG4gICAgaW5wdXRzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgZm9yICh2YXIgX2kyID0gMCwgX2lucHV0cyA9IGlucHV0czsgX2kyIDwgX2lucHV0cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgdmFyIGlucHV0ID0gX2lucHV0c1tfaTJdO1xuXG4gICAgZm9yICh2YXIgayBpbiBpbnB1dCkge1xuICAgICAgb3V0cHV0W2tdID0gaW5wdXRba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxudmFyIFBhcnNpbmdFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhQYXJzaW5nRXJyb3IsIF9FcnJvcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQYXJzaW5nRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIFBhcnNpbmdFcnJvcihrZXksIG1lc3NhZ2UpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2luZ0Vycm9yKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgX3RoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgX3RoaXMua2V5ID0ga2V5O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBQYXJzaW5nRXJyb3I7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG52YXIgU2NvcGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY29wZShwYXJlbnQpIHtcbiAgICB2YXIgYmluZGluZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNjb3BlKTtcblxuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcblxuICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYmluZGluZ3MpLFxuICAgICAgICBfc3RlcDI7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMi52YWx1ZSwgMiksXG4gICAgICAgICAgICBuYW1lID0gX3N0ZXAyJHZhbHVlWzBdLFxuICAgICAgICAgICAgX2V4cHJlc3Npb24gPSBfc3RlcDIkdmFsdWVbMV07XG5cbiAgICAgICAgdGhpcy5iaW5kaW5nc1tuYW1lXSA9IF9leHByZXNzaW9uO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY29wZSwgW3tcbiAgICBrZXk6IFwiY29uY2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbmNhdChiaW5kaW5ncykge1xuICAgICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLCBiaW5kaW5ncyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgICAgaWYgKHRoaXMuYmluZGluZ3NbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbbmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0KG5hbWUpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQobmFtZSwgXCIgbm90IGZvdW5kIGluIHNjb3BlLlwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKHRoaXMuYmluZGluZ3NbbmFtZV0pIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuaGFzKG5hbWUpIDogZmFsc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNjb3BlO1xufSgpO1xuXG52YXIgTnVsbFR5cGUgPSB7XG4gIGtpbmQ6ICdudWxsJ1xufTtcbnZhciBOdW1iZXJUeXBlID0ge1xuICBraW5kOiAnbnVtYmVyJ1xufTtcbnZhciBTdHJpbmdUeXBlID0ge1xuICBraW5kOiAnc3RyaW5nJ1xufTtcbnZhciBCb29sZWFuVHlwZSA9IHtcbiAga2luZDogJ2Jvb2xlYW4nXG59O1xudmFyIENvbG9yVHlwZSA9IHtcbiAga2luZDogJ2NvbG9yJ1xufTtcbnZhciBPYmplY3RUeXBlID0ge1xuICBraW5kOiAnb2JqZWN0J1xufTtcbnZhciBWYWx1ZVR5cGUgPSB7XG4gIGtpbmQ6ICd2YWx1ZSdcbn07XG52YXIgRXJyb3JUeXBlID0ge1xuICBraW5kOiAnZXJyb3InXG59O1xudmFyIENvbGxhdG9yVHlwZSA9IHtcbiAga2luZDogJ2NvbGxhdG9yJ1xufTtcbnZhciBGb3JtYXR0ZWRUeXBlID0ge1xuICBraW5kOiAnZm9ybWF0dGVkJ1xufTtcbnZhciBSZXNvbHZlZEltYWdlVHlwZSA9IHtcbiAga2luZDogJ3Jlc29sdmVkSW1hZ2UnXG59O1xuXG5mdW5jdGlvbiBhcnJheShpdGVtVHlwZSwgTikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6ICdhcnJheScsXG4gICAgaXRlbVR5cGU6IGl0ZW1UeXBlLFxuICAgIE46IE5cbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcodHlwZSkge1xuICBpZiAodHlwZS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgdmFyIGl0ZW1UeXBlID0gdG9TdHJpbmcodHlwZS5pdGVtVHlwZSk7XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlLk4gPT09ICdudW1iZXInID8gXCJhcnJheTxcIi5jb25jYXQoaXRlbVR5cGUsIFwiLCBcIikuY29uY2F0KHR5cGUuTiwgXCI+XCIpIDogdHlwZS5pdGVtVHlwZS5raW5kID09PSAndmFsdWUnID8gJ2FycmF5JyA6IFwiYXJyYXk8XCIuY29uY2F0KGl0ZW1UeXBlLCBcIj5cIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHR5cGUua2luZDtcbiAgfVxufVxuXG52YXIgdmFsdWVNZW1iZXJUeXBlcyA9IFtOdWxsVHlwZSwgTnVtYmVyVHlwZSwgU3RyaW5nVHlwZSwgQm9vbGVhblR5cGUsIENvbG9yVHlwZSwgRm9ybWF0dGVkVHlwZSwgT2JqZWN0VHlwZSwgYXJyYXkoVmFsdWVUeXBlKSwgUmVzb2x2ZWRJbWFnZVR5cGVdO1xuXG5mdW5jdGlvbiBfY2hlY2tTdWJ0eXBlKGV4cGVjdGVkLCB0KSB7XG4gIGlmICh0LmtpbmQgPT09ICdlcnJvcicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5raW5kID09PSAnYXJyYXknKSB7XG4gICAgaWYgKHQua2luZCA9PT0gJ2FycmF5JyAmJiAodC5OID09PSAwICYmIHQuaXRlbVR5cGUua2luZCA9PT0gJ3ZhbHVlJyB8fCAhX2NoZWNrU3VidHlwZShleHBlY3RlZC5pdGVtVHlwZSwgdC5pdGVtVHlwZSkpICYmICh0eXBlb2YgZXhwZWN0ZWQuTiAhPT0gJ251bWJlcicgfHwgZXhwZWN0ZWQuTiA9PT0gdC5OKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09IHQua2luZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkLmtpbmQgPT09ICd2YWx1ZScpIHtcbiAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHZhbHVlTWVtYmVyVHlwZXMpLFxuICAgICAgICBfc3RlcDM7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIG1lbWJlclR5cGUgPSBfc3RlcDMudmFsdWU7XG5cbiAgICAgICAgaWYgKCFfY2hlY2tTdWJ0eXBlKG1lbWJlclR5cGUsIHQpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gXCJFeHBlY3RlZCBcIi5jb25jYXQodG9TdHJpbmcoZXhwZWN0ZWQpLCBcIiBidXQgZm91bmQgXCIpLmNvbmNhdCh0b1N0cmluZyh0KSwgXCIgaW5zdGVhZC5cIik7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRUeXBlKHByb3ZpZGVkLCBhbGxvd2VkVHlwZXMpIHtcbiAgcmV0dXJuIGFsbG93ZWRUeXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQua2luZCA9PT0gcHJvdmlkZWQua2luZDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWROYXRpdmVUeXBlKHByb3ZpZGVkLCBhbGxvd2VkVHlwZXMpIHtcbiAgcmV0dXJuIGFsbG93ZWRUeXBlcy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKHQgPT09ICdudWxsJykge1xuICAgICAgcmV0dXJuIHByb3ZpZGVkID09PSBudWxsO1xuICAgIH0gZWxzZSBpZiAodCA9PT0gJ2FycmF5Jykge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocHJvdmlkZWQpO1xuICAgIH0gZWxzZSBpZiAodCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBwcm92aWRlZCAmJiAhQXJyYXkuaXNBcnJheShwcm92aWRlZCkgJiYgdHlwZW9mIHByb3ZpZGVkID09PSAnb2JqZWN0JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHQgPT09IHR5cGVvZiBwcm92aWRlZDtcbiAgICB9XG4gIH0pO1xufVxuXG52YXIgY3NzY29sb3JwYXJzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gIC8vIChjKSBEZWFuIE1jTmFtZWUgPGRlYW5AZ21haWwuY29tPiwgMjAxMi5cbiAgLy9cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL2Nzcy1jb2xvci1wYXJzZXItanNcbiAgLy9cbiAgLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICAvLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuICAvLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuICAvLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3JcbiAgLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAgLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAgLy9cbiAgLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAgLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gIC8vXG4gIC8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAgLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gIC8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICAvLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gIC8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gIC8vIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1NcbiAgLy8gSU4gVEhFIFNPRlRXQVJFLlxuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yL1xuICB2YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICAgXCJ0cmFuc3BhcmVudFwiOiBbMCwgMCwgMCwgMF0sXG4gICAgXCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTUsIDFdLFxuICAgIFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1LCAxXSxcbiAgICBcImFxdWFcIjogWzAsIDI1NSwgMjU1LCAxXSxcbiAgICBcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTIsIDFdLFxuICAgIFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTUsIDFdLFxuICAgIFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjAsIDFdLFxuICAgIFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2LCAxXSxcbiAgICBcImJsYWNrXCI6IFswLCAwLCAwLCAxXSxcbiAgICBcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1LCAxXSxcbiAgICBcImJsdWVcIjogWzAsIDAsIDI1NSwgMV0sXG4gICAgXCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjYsIDFdLFxuICAgIFwiYnJvd25cIjogWzE2NSwgNDIsIDQyLCAxXSxcbiAgICBcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNSwgMV0sXG4gICAgXCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MCwgMV0sXG4gICAgXCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMCwgMV0sXG4gICAgXCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMCwgMV0sXG4gICAgXCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwLCAxXSxcbiAgICBcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3LCAxXSxcbiAgICBcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwLCAxXSxcbiAgICBcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwLCAxXSxcbiAgICBcImN5YW5cIjogWzAsIDI1NSwgMjU1LCAxXSxcbiAgICBcImRhcmtibHVlXCI6IFswLCAwLCAxMzksIDFdLFxuICAgIFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5LCAxXSxcbiAgICBcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMSwgMV0sXG4gICAgXCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OSwgMV0sXG4gICAgXCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMCwgMV0sXG4gICAgXCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OSwgMV0sXG4gICAgXCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDcsIDFdLFxuICAgIFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5LCAxXSxcbiAgICBcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0NywgMV0sXG4gICAgXCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMCwgMV0sXG4gICAgXCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDQsIDFdLFxuICAgIFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwLCAxXSxcbiAgICBcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjIsIDFdLFxuICAgIFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzLCAxXSxcbiAgICBcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5LCAxXSxcbiAgICBcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzksIDFdLFxuICAgIFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OSwgMV0sXG4gICAgXCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOSwgMV0sXG4gICAgXCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMSwgMV0sXG4gICAgXCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3LCAxXSxcbiAgICBcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NSwgMV0sXG4gICAgXCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1LCAxXSxcbiAgICBcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDUsIDFdLFxuICAgIFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1LCAxXSxcbiAgICBcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzQsIDFdLFxuICAgIFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDAsIDFdLFxuICAgIFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0LCAxXSxcbiAgICBcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1LCAxXSxcbiAgICBcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMCwgMV0sXG4gICAgXCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1LCAxXSxcbiAgICBcImdvbGRcIjogWzI1NSwgMjE1LCAwLCAxXSxcbiAgICBcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyLCAxXSxcbiAgICBcImdyYXlcIjogWzEyOCwgMTI4LCAxMjgsIDFdLFxuICAgIFwiZ3JlZW5cIjogWzAsIDEyOCwgMCwgMV0sXG4gICAgXCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3LCAxXSxcbiAgICBcImdyZXlcIjogWzEyOCwgMTI4LCAxMjgsIDFdLFxuICAgIFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDAsIDFdLFxuICAgIFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MCwgMV0sXG4gICAgXCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyLCAxXSxcbiAgICBcImluZGlnb1wiOiBbNzUsIDAsIDEzMCwgMV0sXG4gICAgXCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MCwgMV0sXG4gICAgXCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MCwgMV0sXG4gICAgXCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MCwgMV0sXG4gICAgXCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1LCAxXSxcbiAgICBcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDAsIDFdLFxuICAgIFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1LCAxXSxcbiAgICBcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMCwgMV0sXG4gICAgXCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4LCAxXSxcbiAgICBcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NSwgMV0sXG4gICAgXCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMCwgMV0sXG4gICAgXCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTEsIDFdLFxuICAgIFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NCwgMV0sXG4gICAgXCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTEsIDFdLFxuICAgIFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzLCAxXSxcbiAgICBcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyLCAxXSxcbiAgICBcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MCwgMV0sXG4gICAgXCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTAsIDFdLFxuICAgIFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAgIFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAgIFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjIsIDFdLFxuICAgIFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjQsIDFdLFxuICAgIFwibGltZVwiOiBbMCwgMjU1LCAwLCAxXSxcbiAgICBcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTAsIDFdLFxuICAgIFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzAsIDFdLFxuICAgIFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTUsIDFdLFxuICAgIFwibWFyb29uXCI6IFsxMjgsIDAsIDAsIDFdLFxuICAgIFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MCwgMV0sXG4gICAgXCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDUsIDFdLFxuICAgIFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTEsIDFdLFxuICAgIFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5LCAxXSxcbiAgICBcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTMsIDFdLFxuICAgIFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4LCAxXSxcbiAgICBcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NCwgMV0sXG4gICAgXCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNCwgMV0sXG4gICAgXCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzMywgMV0sXG4gICAgXCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyLCAxXSxcbiAgICBcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MCwgMV0sXG4gICAgXCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjUsIDFdLFxuICAgIFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODEsIDFdLFxuICAgIFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzMsIDFdLFxuICAgIFwibmF2eVwiOiBbMCwgMCwgMTI4LCAxXSxcbiAgICBcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzAsIDFdLFxuICAgIFwib2xpdmVcIjogWzEyOCwgMTI4LCAwLCAxXSxcbiAgICBcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1LCAxXSxcbiAgICBcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDAsIDFdLFxuICAgIFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwLCAxXSxcbiAgICBcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNCwgMV0sXG4gICAgXCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwLCAxXSxcbiAgICBcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1MiwgMV0sXG4gICAgXCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4LCAxXSxcbiAgICBcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDcsIDFdLFxuICAgIFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxMywgMV0sXG4gICAgXCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODUsIDFdLFxuICAgIFwicGVydVwiOiBbMjA1LCAxMzMsIDYzLCAxXSxcbiAgICBcInBpbmtcIjogWzI1NSwgMTkyLCAyMDMsIDFdLFxuICAgIFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMSwgMV0sXG4gICAgXCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwLCAxXSxcbiAgICBcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjgsIDFdLFxuICAgIFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzLCAxXSxcbiAgICBcInJlZFwiOiBbMjU1LCAwLCAwLCAxXSxcbiAgICBcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0MywgMV0sXG4gICAgXCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNSwgMV0sXG4gICAgXCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTksIDFdLFxuICAgIFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0LCAxXSxcbiAgICBcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5NiwgMV0sXG4gICAgXCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODcsIDFdLFxuICAgIFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzgsIDFdLFxuICAgIFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NSwgMV0sXG4gICAgXCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTIsIDFdLFxuICAgIFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNSwgMV0sXG4gICAgXCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNSwgMV0sXG4gICAgXCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDQsIDFdLFxuICAgIFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgICBcInNub3dcIjogWzI1NSwgMjUwLCAyNTAsIDFdLFxuICAgIFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3LCAxXSxcbiAgICBcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwLCAxXSxcbiAgICBcInRhblwiOiBbMjEwLCAxODAsIDE0MCwgMV0sXG4gICAgXCJ0ZWFsXCI6IFswLCAxMjgsIDEyOCwgMV0sXG4gICAgXCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2LCAxXSxcbiAgICBcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzEsIDFdLFxuICAgIFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDgsIDFdLFxuICAgIFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4LCAxXSxcbiAgICBcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5LCAxXSxcbiAgICBcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1LCAxXSxcbiAgICBcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDUsIDFdLFxuICAgIFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMCwgMV0sXG4gICAgXCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwLCAxXVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNsYW1wX2Nzc19ieXRlKGkpIHtcbiAgICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMjU1LlxuICAgIGkgPSBNYXRoLnJvdW5kKGkpOyAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cblxuICAgIHJldHVybiBpIDwgMCA/IDAgOiBpID4gMjU1ID8gMjU1IDogaTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsYW1wX2Nzc19mbG9hdChmKSB7XG4gICAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgICByZXR1cm4gZiA8IDAgPyAwIDogZiA+IDEgPyAxIDogZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlX2Nzc19pbnQoc3RyKSB7XG4gICAgLy8gaW50IG9yIHBlcmNlbnRhZ2UuXG4gICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJykgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlRmxvYXQoc3RyKSAvIDEwMCAqIDI1NSk7XG4gICAgcmV0dXJuIGNsYW1wX2Nzc19ieXRlKHBhcnNlSW50KHN0cikpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VfY3NzX2Zsb2F0KHN0cikge1xuICAgIC8vIGZsb2F0IG9yIHBlcmNlbnRhZ2UuXG4gICAgaWYgKHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICclJykgcmV0dXJuIGNsYW1wX2Nzc19mbG9hdChwYXJzZUZsb2F0KHN0cikgLyAxMDApO1xuICAgIHJldHVybiBjbGFtcF9jc3NfZmxvYXQocGFyc2VGbG9hdChzdHIpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCkge1xuICAgIGlmIChoIDwgMCkgaCArPSAxO2Vsc2UgaWYgKGggPiAxKSBoIC09IDE7XG4gICAgaWYgKGggKiA2IDwgMSkgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gICAgaWYgKGggKiAyIDwgMSkgcmV0dXJuIG0yO1xuICAgIGlmIChoICogMyA8IDIpIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNjtcbiAgICByZXR1cm4gbTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUNTU0NvbG9yKGNzc19zdHIpIHtcbiAgICAvLyBSZW1vdmUgYWxsIHdoaXRlc3BhY2UsIG5vdCBjb21wbGlhbnQsIGJ1dCBzaG91bGQganVzdCBiZSBtb3JlIGFjY2VwdGluZy5cbiAgICB2YXIgc3RyID0gY3NzX3N0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpOyAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG5cbiAgICBpZiAoc3RyIGluIGtDU1NDb2xvclRhYmxlKSByZXR1cm4ga0NTU0NvbG9yVGFibGVbc3RyXS5zbGljZSgpOyAvLyBkdXAuXG4gICAgLy8gI2FiYyBhbmQgI2FiYzEyMyBzeW50YXguXG5cbiAgICBpZiAoc3RyWzBdID09PSAnIycpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG5cbiAgICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZikpIHJldHVybiBudWxsOyAvLyBDb3ZlcnMgTmFOLlxuXG4gICAgICAgIHJldHVybiBbKGl2ICYgMHhmMDApID4+IDQgfCAoaXYgJiAweGYwMCkgPj4gOCwgaXYgJiAweGYwIHwgKGl2ICYgMHhmMCkgPj4gNCwgaXYgJiAweGYgfCAoaXYgJiAweGYpIDw8IDQsIDFdO1xuICAgICAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID09PSA3KSB7XG4gICAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG5cbiAgICAgICAgaWYgKCEoaXYgPj0gMCAmJiBpdiA8PSAweGZmZmZmZikpIHJldHVybiBudWxsOyAvLyBDb3ZlcnMgTmFOLlxuXG4gICAgICAgIHJldHVybiBbKGl2ICYgMHhmZjAwMDApID4+IDE2LCAoaXYgJiAweGZmMDApID4+IDgsIGl2ICYgMHhmZiwgMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBvcCA9IHN0ci5pbmRleE9mKCcoJyksXG4gICAgICAgIGVwID0gc3RyLmluZGV4T2YoJyknKTtcblxuICAgIGlmIChvcCAhPT0gLTEgJiYgZXAgKyAxID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICB2YXIgZm5hbWUgPSBzdHIuc3Vic3RyKDAsIG9wKTtcbiAgICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wICsgMSwgZXAgLSAob3AgKyAxKSkuc3BsaXQoJywnKTtcbiAgICAgIHZhciBhbHBoYSA9IDE7IC8vIFRvIGFsbG93IGNhc2UgZmFsbHRocm91Z2guXG5cbiAgICAgIHN3aXRjaCAoZm5hbWUpIHtcbiAgICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDQpIHJldHVybiBudWxsO1xuICAgICAgICAgIGFscGhhID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtcy5wb3AoKSk7XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaC5cblxuICAgICAgICBjYXNlICdyZ2InOlxuICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICByZXR1cm4gW3BhcnNlX2Nzc19pbnQocGFyYW1zWzBdKSwgcGFyc2VfY3NzX2ludChwYXJhbXNbMV0pLCBwYXJzZV9jc3NfaW50KHBhcmFtc1syXSksIGFscGhhXTtcblxuICAgICAgICBjYXNlICdoc2xhJzpcbiAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gNCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgYWxwaGEgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuXG4gICAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IDMpIHJldHVybiBudWxsO1xuICAgICAgICAgIHZhciBoID0gKHBhcnNlRmxvYXQocGFyYW1zWzBdKSAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7IC8vIDAgLi4gMVxuICAgICAgICAgIC8vIE5PVEUoZGVhbm0pOiBBY2NvcmRpbmcgdG8gdGhlIENTUyBzcGVjIHMvbCBzaG91bGQgb25seSBiZVxuICAgICAgICAgIC8vIHBlcmNlbnRhZ2VzLCBidXQgd2UgZG9uJ3QgYm90aGVyIGFuZCBsZXQgZmxvYXQgb3IgcGVyY2VudGFnZS5cblxuICAgICAgICAgIHZhciBzID0gcGFyc2VfY3NzX2Zsb2F0KHBhcmFtc1sxXSk7XG4gICAgICAgICAgdmFyIGwgPSBwYXJzZV9jc3NfZmxvYXQocGFyYW1zWzJdKTtcbiAgICAgICAgICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgICB2YXIgbTEgPSBsICogMiAtIG0yO1xuICAgICAgICAgIHJldHVybiBbY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoICsgMSAvIDMpICogMjU1KSwgY2xhbXBfY3NzX2J5dGUoY3NzX2h1ZV90b19yZ2IobTEsIG0yLCBoKSAqIDI1NSksIGNsYW1wX2Nzc19ieXRlKGNzc19odWVfdG9fcmdiKG0xLCBtMiwgaCAtIDEgLyAzKSAqIDI1NSksIGFscGhhXTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBleHBvcnRzLnBhcnNlQ1NTQ29sb3IgPSBwYXJzZUNTU0NvbG9yO1xuICB9IGNhdGNoIChlKSB7fVxufSk7XG5cbnZhciBDb2xvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbG9yKHIsIGcsIGIpIHtcbiAgICB2YXIgYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvcik7XG5cbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMuZyA9IGc7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmEgPSBhO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbG9yLCBbe1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBfdGhpcyR0b0FycmF5ID0gdGhpcy50b0FycmF5KCksXG4gICAgICAgICAgX3RoaXMkdG9BcnJheTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyR0b0FycmF5LCA0KSxcbiAgICAgICAgICByID0gX3RoaXMkdG9BcnJheTJbMF0sXG4gICAgICAgICAgZyA9IF90aGlzJHRvQXJyYXkyWzFdLFxuICAgICAgICAgIGIgPSBfdGhpcyR0b0FycmF5MlsyXSxcbiAgICAgICAgICBhID0gX3RoaXMkdG9BcnJheTJbM107XG5cbiAgICAgIHJldHVybiBcInJnYmEoXCIuY29uY2F0KE1hdGgucm91bmQociksIFwiLFwiKS5jb25jYXQoTWF0aC5yb3VuZChnKSwgXCIsXCIpLmNvbmNhdChNYXRoLnJvdW5kKGIpLCBcIixcIikuY29uY2F0KGEsIFwiKVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9BcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgdmFyIHIgPSB0aGlzLnIsXG4gICAgICAgICAgZyA9IHRoaXMuZyxcbiAgICAgICAgICBiID0gdGhpcy5iLFxuICAgICAgICAgIGEgPSB0aGlzLmE7XG4gICAgICByZXR1cm4gYSA9PT0gMCA/IFswLCAwLCAwLCAwXSA6IFtyICogMjU1IC8gYSwgZyAqIDI1NSAvIGEsIGIgKiAyNTUgLyBhLCBhXTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciByZ2JhID0gY3NzY29sb3JwYXJzZXIucGFyc2VDU1NDb2xvcihpbnB1dCk7XG5cbiAgICAgIGlmICghcmdiYSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IENvbG9yKHJnYmFbMF0gLyAyNTUgKiByZ2JhWzNdLCByZ2JhWzFdIC8gMjU1ICogcmdiYVszXSwgcmdiYVsyXSAvIDI1NSAqIHJnYmFbM10sIHJnYmFbM10pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2xvcjtcbn0oKTtcblxuQ29sb3IuYmxhY2sgPSBuZXcgQ29sb3IoMCwgMCwgMCwgMSk7XG5Db2xvci53aGl0ZSA9IG5ldyBDb2xvcigxLCAxLCAxLCAxKTtcbkNvbG9yLnRyYW5zcGFyZW50ID0gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuQ29sb3IucmVkID0gbmV3IENvbG9yKDEsIDAsIDAsIDEpO1xuQ29sb3IuYmx1ZSA9IG5ldyBDb2xvcigwLCAwLCAxLCAxKTtcblxudmFyIENvbGxhdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29sbGF0b3IoY2FzZVNlbnNpdGl2ZSwgZGlhY3JpdGljU2Vuc2l0aXZlLCBsb2NhbGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sbGF0b3IpO1xuXG4gICAgaWYgKGNhc2VTZW5zaXRpdmUpIHRoaXMuc2Vuc2l0aXZpdHkgPSBkaWFjcml0aWNTZW5zaXRpdmUgPyAndmFyaWFudCcgOiAnY2FzZSc7ZWxzZSB0aGlzLnNlbnNpdGl2aXR5ID0gZGlhY3JpdGljU2Vuc2l0aXZlID8gJ2FjY2VudCcgOiAnYmFzZSc7XG4gICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5jb2xsYXRvciA9IG5ldyBJbnRsLkNvbGxhdG9yKHRoaXMubG9jYWxlID8gdGhpcy5sb2NhbGUgOiBbXSwge1xuICAgICAgc2Vuc2l0aXZpdHk6IHRoaXMuc2Vuc2l0aXZpdHksXG4gICAgICB1c2FnZTogJ3NlYXJjaCdcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2xsYXRvciwgW3tcbiAgICBrZXk6IFwiY29tcGFyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKGxocywgcmhzKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb2xsYXRvci5jb21wYXJlKGxocywgcmhzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzb2x2ZWRMb2NhbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZWRMb2NhbGUoKSB7XG4gICAgICByZXR1cm4gbmV3IEludGwuQ29sbGF0b3IodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZSA6IFtdKS5yZXNvbHZlZE9wdGlvbnMoKS5sb2NhbGU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbGxhdG9yO1xufSgpO1xuXG52YXIgRm9ybWF0dGVkU2VjdGlvbiA9IGZ1bmN0aW9uIEZvcm1hdHRlZFNlY3Rpb24odGV4dCwgaW1hZ2UsIHNjYWxlLCBmb250U3RhY2ssIHRleHRDb2xvcikge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9ybWF0dGVkU2VjdGlvbik7XG5cbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gIHRoaXMuZm9udFN0YWNrID0gZm9udFN0YWNrO1xuICB0aGlzLnRleHRDb2xvciA9IHRleHRDb2xvcjtcbn07XG5cbnZhciBGb3JtYXR0ZWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb3JtYXR0ZWQoc2VjdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9ybWF0dGVkKTtcblxuICAgIHRoaXMuc2VjdGlvbnMgPSBzZWN0aW9ucztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGb3JtYXR0ZWQsIFt7XG4gICAga2V5OiBcImlzRW1wdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICAgIGlmICh0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gIXRoaXMuc2VjdGlvbnMuc29tZShmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gc2VjdGlvbi50ZXh0Lmxlbmd0aCAhPT0gMCB8fCBzZWN0aW9uLmltYWdlICYmIHNlY3Rpb24uaW1hZ2UubmFtZS5sZW5ndGggIT09IDA7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICBpZiAodGhpcy5zZWN0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgICAgIHJldHVybiB0aGlzLnNlY3Rpb25zLm1hcChmdW5jdGlvbiAoc2VjdGlvbikge1xuICAgICAgICByZXR1cm4gc2VjdGlvbi50ZXh0O1xuICAgICAgfSkuam9pbignJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgc2VyaWFsaXplZCA9IFsnZm9ybWF0J107XG5cbiAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5zZWN0aW9ucyksXG4gICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBzZWN0aW9uID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKHNlY3Rpb24uaW1hZ2UpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChbJ2ltYWdlJywgc2VjdGlvbi5pbWFnZS5uYW1lXSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXJpYWxpemVkLnB1c2goc2VjdGlvbi50ZXh0KTtcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICAgICAgaWYgKHNlY3Rpb24uZm9udFN0YWNrKSB7XG4gICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWZvbnQnXSA9IFsnbGl0ZXJhbCcsIHNlY3Rpb24uZm9udFN0YWNrLnNwbGl0KCcsJyldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN0aW9uLnNjYWxlKSB7XG4gICAgICAgICAgICBvcHRpb25zWydmb250LXNjYWxlJ10gPSBzZWN0aW9uLnNjYWxlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN0aW9uLnRleHRDb2xvcikge1xuICAgICAgICAgICAgb3B0aW9uc1sndGV4dC1jb2xvciddID0gWydyZ2JhJ10uY29uY2F0KHNlY3Rpb24udGV4dENvbG9yLnRvQXJyYXkoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VyaWFsaXplZC5wdXNoKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU3RyaW5nKHVuZm9ybWF0dGVkKSB7XG4gICAgICByZXR1cm4gbmV3IEZvcm1hdHRlZChbbmV3IEZvcm1hdHRlZFNlY3Rpb24odW5mb3JtYXR0ZWQsIG51bGwsIG51bGwsIG51bGwsIG51bGwpXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZhY3RvcnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmFjdG9yeSh0ZXh0KSB7XG4gICAgICBpZiAodGV4dCBpbnN0YW5jZW9mIEZvcm1hdHRlZCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZWQuZnJvbVN0cmluZyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9ybWF0dGVkO1xufSgpO1xuXG52YXIgUmVzb2x2ZWRJbWFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlc29sdmVkSW1hZ2Uob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNvbHZlZEltYWdlKTtcblxuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLmF2YWlsYWJsZSA9IG9wdGlvbnMuYXZhaWxhYmxlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFJlc29sdmVkSW1hZ2UsIFt7XG4gICAga2V5OiBcInRvU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIHJldHVybiBbJ2ltYWdlJywgdGhpcy5uYW1lXTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tU3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21TdHJpbmcobmFtZSkge1xuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRJbWFnZSh7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGF2YWlsYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZXNvbHZlZEltYWdlO1xufSgpO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVJHQkEociwgZywgYiwgYSkge1xuICBpZiAoISh0eXBlb2YgciA9PT0gJ251bWJlcicgJiYgciA+PSAwICYmIHIgPD0gMjU1ICYmIHR5cGVvZiBnID09PSAnbnVtYmVyJyAmJiBnID49IDAgJiYgZyA8PSAyNTUgJiYgdHlwZW9mIGIgPT09ICdudW1iZXInICYmIGIgPj0gMCAmJiBiIDw9IDI1NSkpIHtcbiAgICB2YXIgdmFsdWUgPSB0eXBlb2YgYSA9PT0gJ251bWJlcicgPyBbciwgZywgYiwgYV0gOiBbciwgZywgYl07XG4gICAgcmV0dXJuIFwiSW52YWxpZCByZ2JhIHZhbHVlIFtcIi5jb25jYXQodmFsdWUuam9pbignLCAnKSwgXCJdOiAncicsICdnJywgYW5kICdiJyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMjU1LlwiKTtcbiAgfVxuXG4gIGlmICghKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgYSA+PSAwICYmIGEgPD0gMSkpIHtcbiAgICByZXR1cm4gXCJJbnZhbGlkIHJnYmEgdmFsdWUgW1wiLmNvbmNhdChbciwgZywgYiwgYV0uam9pbignLCAnKSwgXCJdOiAnYScgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXCIpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVmFsdWUobWl4ZWQpIHtcbiAgaWYgKG1peGVkID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKG1peGVkIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mIENvbGxhdG9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAobWl4ZWQgaW5zdGFuY2VvZiBGb3JtYXR0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChtaXhlZCBpbnN0YW5jZW9mIFJlc29sdmVkSW1hZ2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG1peGVkKSkge1xuICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobWl4ZWQpLFxuICAgICAgICBfc3RlcDU7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgICAgaWYgKCFpc1ZhbHVlKGl0ZW0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1peGVkID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIGtleSBpbiBtaXhlZCkge1xuICAgICAgaWYgKCFpc1ZhbHVlKG1peGVkW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHlwZU9mKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBOdWxsVHlwZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIFN0cmluZ1R5cGU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICByZXR1cm4gQm9vbGVhblR5cGU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBOdW1iZXJUeXBlO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICByZXR1cm4gQ29sb3JUeXBlO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ29sbGF0b3IpIHtcbiAgICByZXR1cm4gQ29sbGF0b3JUeXBlO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRm9ybWF0dGVkKSB7XG4gICAgcmV0dXJuIEZvcm1hdHRlZFR5cGU7XG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZXNvbHZlZEltYWdlKSB7XG4gICAgcmV0dXJuIFJlc29sdmVkSW1hZ2VUeXBlO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICB2YXIgaXRlbVR5cGU7XG5cbiAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHZhbHVlKSxcbiAgICAgICAgX3N0ZXA2O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBpdGVtID0gX3N0ZXA2LnZhbHVlO1xuICAgICAgICB2YXIgdCA9IHR5cGVPZihpdGVtKTtcblxuICAgICAgICBpZiAoIWl0ZW1UeXBlKSB7XG4gICAgICAgICAgaXRlbVR5cGUgPSB0O1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1UeXBlID09PSB0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVR5cGUgPSBWYWx1ZVR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXkoaXRlbVR5cGUgfHwgVmFsdWVUeXBlLCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBPYmplY3RUeXBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvU3RyaW5nJDEodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ29sb3IgfHwgdmFsdWUgaW5zdGFuY2VvZiBGb3JtYXR0ZWQgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZXNvbHZlZEltYWdlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxufVxuXG52YXIgTGl0ZXJhbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExpdGVyYWwodHlwZSwgdmFsdWUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGl0ZXJhbCk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaXRlcmFsLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKCkge31cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2FycmF5JyB8fCB0aGlzLnR5cGUua2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIFsnbGl0ZXJhbCcsIHRoaXMudmFsdWVdO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgICAgICAgcmV0dXJuIFsncmdiYSddLmNvbmNhdCh0aGlzLnZhbHVlLnRvQXJyYXkoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgaW5zdGFuY2VvZiBGb3JtYXR0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc2VyaWFsaXplKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHJldHVybiBjb250ZXh0LmVycm9yKFwiJ2xpdGVyYWwnIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIGJ1dCBmb3VuZCBcIi5jb25jYXQoYXJncy5sZW5ndGggLSAxLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICBpZiAoIWlzVmFsdWUoYXJnc1sxXSkpIHJldHVybiBjb250ZXh0LmVycm9yKFwiaW52YWxpZCB2YWx1ZVwiKTtcbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3NbMV07XG4gICAgICB2YXIgdHlwZSA9IHR5cGVPZih2YWx1ZSk7XG4gICAgICB2YXIgZXhwZWN0ZWQgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcblxuICAgICAgaWYgKHR5cGUua2luZCA9PT0gJ2FycmF5JyAmJiB0eXBlLk4gPT09IDAgJiYgZXhwZWN0ZWQgJiYgZXhwZWN0ZWQua2luZCA9PT0gJ2FycmF5JyAmJiAodHlwZW9mIGV4cGVjdGVkLk4gIT09ICdudW1iZXInIHx8IGV4cGVjdGVkLk4gPT09IDApKSB7XG4gICAgICAgIHR5cGUgPSBleHBlY3RlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBMaXRlcmFsKHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGl0ZXJhbDtcbn0oKTtcblxudmFyIFJ1bnRpbWVFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJ1bnRpbWVFcnJvcihtZXNzYWdlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJ1bnRpbWVFcnJvcik7XG5cbiAgICB0aGlzLm5hbWUgPSAnRXhwcmVzc2lvbkV2YWx1YXRpb25FcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSdW50aW1lRXJyb3IsIFt7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSdW50aW1lRXJyb3I7XG59KCk7XG5cbnZhciB0eXBlcyA9IHtcbiAgc3RyaW5nOiBTdHJpbmdUeXBlLFxuICBudW1iZXI6IE51bWJlclR5cGUsXG4gIGJvb2xlYW46IEJvb2xlYW5UeXBlLFxuICBvYmplY3Q6IE9iamVjdFR5cGVcbn07XG5cbnZhciBBc3NlcnRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBc3NlcnRpb24odHlwZSwgYXJncykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBc3NlcnRpb24pO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFzc2VydGlvbiwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmFyZ3NbaV0uZXZhbHVhdGUoY3R4KTtcblxuICAgICAgICB2YXIgX2Vycm9yID0gX2NoZWNrU3VidHlwZSh0aGlzLnR5cGUsIHR5cGVPZih2YWx1ZSkpO1xuXG4gICAgICAgIGlmICghX2Vycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPT09IHRoaXMuYXJncy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgXCIuY29uY2F0KHRvU3RyaW5nKHRoaXMudHlwZSksIFwiLCBidXQgZm91bmQgXCIpLmNvbmNhdCh0b1N0cmluZyh0eXBlT2YodmFsdWUpKSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICB0aGlzLmFyZ3MuZm9yRWFjaChmbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm91dHB1dERlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnLm91dHB1dERlZmluZWQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICB2YXIgc2VyaWFsaXplZCA9IFt0eXBlLmtpbmRdO1xuXG4gICAgICBpZiAodHlwZS5raW5kID09PSAnYXJyYXknKSB7XG4gICAgICAgIHZhciBpdGVtVHlwZSA9IHR5cGUuaXRlbVR5cGU7XG5cbiAgICAgICAgaWYgKGl0ZW1UeXBlLmtpbmQgPT09ICdzdHJpbmcnIHx8IGl0ZW1UeXBlLmtpbmQgPT09ICdudW1iZXInIHx8IGl0ZW1UeXBlLmtpbmQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChpdGVtVHlwZS5raW5kKTtcbiAgICAgICAgICB2YXIgTiA9IHR5cGUuTjtcblxuICAgICAgICAgIGlmICh0eXBlb2YgTiA9PT0gJ251bWJlcicgfHwgdGhpcy5hcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChOKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQuY29uY2F0KHRoaXMuYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnLnNlcmlhbGl6ZSgpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50LlwiKTtcbiAgICAgIHZhciBpID0gMTtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgdmFyIG5hbWUgPSBhcmdzWzBdO1xuXG4gICAgICBpZiAobmFtZSA9PT0gJ2FycmF5Jykge1xuICAgICAgICB2YXIgaXRlbVR5cGU7XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMikge1xuICAgICAgICAgIHZhciBfdHlwZSA9IGFyZ3NbMV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBfdHlwZSAhPT0gJ3N0cmluZycgfHwgIShfdHlwZSBpbiB0eXBlcykgfHwgX3R5cGUgPT09ICdvYmplY3QnKSByZXR1cm4gY29udGV4dC5lcnJvcignVGhlIGl0ZW0gdHlwZSBhcmd1bWVudCBvZiBcImFycmF5XCIgbXVzdCBiZSBvbmUgb2Ygc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4nLCAxKTtcbiAgICAgICAgICBpdGVtVHlwZSA9IHR5cGVzW190eXBlXTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVR5cGUgPSBWYWx1ZVR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgTjtcblxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgaWYgKGFyZ3NbMl0gIT09IG51bGwgJiYgKHR5cGVvZiBhcmdzWzJdICE9PSAnbnVtYmVyJyB8fCBhcmdzWzJdIDwgMCB8fCBhcmdzWzJdICE9PSBNYXRoLmZsb29yKGFyZ3NbMl0pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ1RoZSBsZW5ndGggYXJndW1lbnQgdG8gXCJhcnJheVwiIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxpdGVyYWwnLCAyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBOID0gYXJnc1syXTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlID0gYXJyYXkoaXRlbVR5cGUsIE4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHR5cGVzW25hbWVdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyc2VkID0gW107XG5cbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIGksIFZhbHVlVHlwZSk7XG4gICAgICAgIGlmICghaW5wdXQpIHJldHVybiBudWxsO1xuICAgICAgICBwYXJzZWQucHVzaChpbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgQXNzZXJ0aW9uKHR5cGUsIHBhcnNlZCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFzc2VydGlvbjtcbn0oKTtcblxudmFyIEZvcm1hdEV4cHJlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb3JtYXRFeHByZXNzaW9uKHNlY3Rpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcm1hdEV4cHJlc3Npb24pO1xuXG4gICAgdGhpcy50eXBlID0gRm9ybWF0dGVkVHlwZTtcbiAgICB0aGlzLnNlY3Rpb25zID0gc2VjdGlvbnM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRm9ybWF0RXhwcmVzc2lvbiwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICB2YXIgZXZhbHVhdGVTZWN0aW9uID0gZnVuY3Rpb24gZXZhbHVhdGVTZWN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgdmFyIGV2YWx1YXRlZENvbnRlbnQgPSBzZWN0aW9uLmNvbnRlbnQuZXZhbHVhdGUoY3R4KTtcblxuICAgICAgICBpZiAodHlwZU9mKGV2YWx1YXRlZENvbnRlbnQpID09PSBSZXNvbHZlZEltYWdlVHlwZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRm9ybWF0dGVkU2VjdGlvbignJywgZXZhbHVhdGVkQ29udGVudCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IEZvcm1hdHRlZFNlY3Rpb24odG9TdHJpbmckMShldmFsdWF0ZWRDb250ZW50KSwgbnVsbCwgc2VjdGlvbi5zY2FsZSA/IHNlY3Rpb24uc2NhbGUuZXZhbHVhdGUoY3R4KSA6IG51bGwsIHNlY3Rpb24uZm9udCA/IHNlY3Rpb24uZm9udC5ldmFsdWF0ZShjdHgpLmpvaW4oJywnKSA6IG51bGwsIHNlY3Rpb24udGV4dENvbG9yID8gc2VjdGlvbi50ZXh0Q29sb3IuZXZhbHVhdGUoY3R4KSA6IG51bGwpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG5ldyBGb3JtYXR0ZWQodGhpcy5zZWN0aW9ucy5tYXAoZXZhbHVhdGVTZWN0aW9uKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5zZWN0aW9ucyksXG4gICAgICAgICAgX3N0ZXA3O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjcucygpOyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBzZWN0aW9uID0gX3N0ZXA3LnZhbHVlO1xuICAgICAgICAgIGZuKHNlY3Rpb24uY29udGVudCk7XG5cbiAgICAgICAgICBpZiAoc2VjdGlvbi5zY2FsZSkge1xuICAgICAgICAgICAgZm4oc2VjdGlvbi5zY2FsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3Rpb24uZm9udCkge1xuICAgICAgICAgICAgZm4oc2VjdGlvbi5mb250KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdGlvbi50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgIGZuKHNlY3Rpb24udGV4dENvbG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjcuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgc2VyaWFsaXplZCA9IFsnZm9ybWF0J107XG5cbiAgICAgIHZhciBfaXRlcmF0b3I4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5zZWN0aW9ucyksXG4gICAgICAgICAgX3N0ZXA4O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjgucygpOyAhKF9zdGVwOCA9IF9pdGVyYXRvcjgubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBzZWN0aW9uID0gX3N0ZXA4LnZhbHVlO1xuICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChzZWN0aW9uLmNvbnRlbnQuc2VyaWFsaXplKCkpO1xuICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG5cbiAgICAgICAgICBpZiAoc2VjdGlvbi5zY2FsZSkge1xuICAgICAgICAgICAgb3B0aW9uc1snZm9udC1zY2FsZSddID0gc2VjdGlvbi5zY2FsZS5zZXJpYWxpemUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdGlvbi5mb250KSB7XG4gICAgICAgICAgICBvcHRpb25zWyd0ZXh0LWZvbnQnXSA9IHNlY3Rpb24uZm9udC5zZXJpYWxpemUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdGlvbi50ZXh0Q29sb3IpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbJ3RleHQtY29sb3InXSA9IHNlY3Rpb24udGV4dENvbG9yLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjguZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yOC5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmlyc3RBcmcgPSBhcmdzWzFdO1xuXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlyc3RBcmcpICYmIHR5cGVvZiBmaXJzdEFyZyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIGltYWdlIG9yIHRleHQgc2VjdGlvbi5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuICAgICAgdmFyIG5leHRUb2tlbk1heUJlT2JqZWN0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IGFyZ3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIHZhciBhcmcgPSBhcmdzW2ldO1xuXG4gICAgICAgIGlmIChuZXh0VG9rZW5NYXlCZU9iamVjdCAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgbmV4dFRva2VuTWF5QmVPYmplY3QgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgc2NhbGUgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGFyZ1snZm9udC1zY2FsZSddKSB7XG4gICAgICAgICAgICBzY2FsZSA9IGNvbnRleHQucGFyc2UoYXJnWydmb250LXNjYWxlJ10sIDEsIE51bWJlclR5cGUpO1xuICAgICAgICAgICAgaWYgKCFzY2FsZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGZvbnQgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGFyZ1sndGV4dC1mb250J10pIHtcbiAgICAgICAgICAgIGZvbnQgPSBjb250ZXh0LnBhcnNlKGFyZ1sndGV4dC1mb250J10sIDEsIGFycmF5KFN0cmluZ1R5cGUpKTtcbiAgICAgICAgICAgIGlmICghZm9udCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRleHRDb2xvciA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoYXJnWyd0ZXh0LWNvbG9yJ10pIHtcbiAgICAgICAgICAgIHRleHRDb2xvciA9IGNvbnRleHQucGFyc2UoYXJnWyd0ZXh0LWNvbG9yJ10sIDEsIENvbG9yVHlwZSk7XG4gICAgICAgICAgICBpZiAoIXRleHRDb2xvcikgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGxhc3RFeHByZXNzaW9uID0gc2VjdGlvbnNbc2VjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgbGFzdEV4cHJlc3Npb24uc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICBsYXN0RXhwcmVzc2lvbi5mb250ID0gZm9udDtcbiAgICAgICAgICBsYXN0RXhwcmVzc2lvbi50ZXh0Q29sb3IgPSB0ZXh0Q29sb3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgICAgICAgaWYgKCFjb250ZW50KSByZXR1cm4gbnVsbDtcbiAgICAgICAgICB2YXIga2luZCA9IGNvbnRlbnQudHlwZS5raW5kO1xuICAgICAgICAgIGlmIChraW5kICE9PSAnc3RyaW5nJyAmJiBraW5kICE9PSAndmFsdWUnICYmIGtpbmQgIT09ICdudWxsJyAmJiBraW5kICE9PSAncmVzb2x2ZWRJbWFnZScpIHJldHVybiBjb250ZXh0LmVycm9yKFwiRm9ybWF0dGVkIHRleHQgdHlwZSBtdXN0IGJlICdzdHJpbmcnLCAndmFsdWUnLCAnaW1hZ2UnIG9yICdudWxsJy5cIik7XG4gICAgICAgICAgbmV4dFRva2VuTWF5QmVPYmplY3QgPSB0cnVlO1xuICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgY29udGVudDogY29udGVudCxcbiAgICAgICAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgICAgICAgZm9udDogbnVsbCxcbiAgICAgICAgICAgIHRleHRDb2xvcjogbnVsbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRm9ybWF0RXhwcmVzc2lvbihzZWN0aW9ucyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvcm1hdEV4cHJlc3Npb247XG59KCk7XG5cbnZhciBJbWFnZUV4cHJlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbWFnZUV4cHJlc3Npb24oaW5wdXQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2VFeHByZXNzaW9uKTtcblxuICAgIHRoaXMudHlwZSA9IFJlc29sdmVkSW1hZ2VUeXBlO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbWFnZUV4cHJlc3Npb24sIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgdmFyIGV2YWx1YXRlZEltYWdlTmFtZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcbiAgICAgIHZhciB2YWx1ZSA9IFJlc29sdmVkSW1hZ2UuZnJvbVN0cmluZyhldmFsdWF0ZWRJbWFnZU5hbWUpO1xuICAgICAgaWYgKHZhbHVlICYmIGN0eC5hdmFpbGFibGVJbWFnZXMpIHZhbHVlLmF2YWlsYWJsZSA9IGN0eC5hdmFpbGFibGVJbWFnZXMuaW5kZXhPZihldmFsdWF0ZWRJbWFnZU5hbWUpID4gLTE7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIGZuKHRoaXMuaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICByZXR1cm4gWydpbWFnZScsIHRoaXMuaW5wdXQuc2VyaWFsaXplKCldO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIHR3byBhcmd1bWVudHMuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgU3RyaW5nVHlwZSk7XG4gICAgICBpZiAoIW5hbWUpIHJldHVybiBjb250ZXh0LmVycm9yKFwiTm8gaW1hZ2UgbmFtZSBwcm92aWRlZC5cIik7XG4gICAgICByZXR1cm4gbmV3IEltYWdlRXhwcmVzc2lvbihuYW1lKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW1hZ2VFeHByZXNzaW9uO1xufSgpO1xuXG52YXIgdHlwZXMkMSA9IHtcbiAgJ3RvLWJvb2xlYW4nOiBCb29sZWFuVHlwZSxcbiAgJ3RvLWNvbG9yJzogQ29sb3JUeXBlLFxuICAndG8tbnVtYmVyJzogTnVtYmVyVHlwZSxcbiAgJ3RvLXN0cmluZyc6IFN0cmluZ1R5cGVcbn07XG5cbnZhciBDb2VyY2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvZXJjaW9uKHR5cGUsIGFyZ3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29lcmNpb24pO1xuXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvZXJjaW9uLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdjb2xvcicpIHtcbiAgICAgICAgdmFyIGlucHV0O1xuXG4gICAgICAgIHZhciBfZXJyb3IyO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3I5ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5hcmdzKSxcbiAgICAgICAgICAgIF9zdGVwOTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yOS5zKCk7ICEoX3N0ZXA5ID0gX2l0ZXJhdG9yOS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gX3N0ZXA5LnZhbHVlO1xuICAgICAgICAgICAgaW5wdXQgPSBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIF9lcnJvcjIgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdmFyIGMgPSBjdHgucGFyc2VDb2xvcihpbnB1dCk7XG4gICAgICAgICAgICAgIGlmIChjKSByZXR1cm4gYztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA8IDMgfHwgaW5wdXQubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgIF9lcnJvcjIgPSBcIkludmFsaWQgcmJnYSB2YWx1ZSBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkoaW5wdXQpLCBcIjogZXhwZWN0ZWQgYW4gYXJyYXkgY29udGFpbmluZyBlaXRoZXIgdGhyZWUgb3IgZm91ciBudW1lcmljIHZhbHVlcy5cIik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX2Vycm9yMiA9IHZhbGlkYXRlUkdCQShpbnB1dFswXSwgaW5wdXRbMV0sIGlucHV0WzJdLCBpbnB1dFszXSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIV9lcnJvcjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKGlucHV0WzBdIC8gMjU1LCBpbnB1dFsxXSAvIDI1NSwgaW5wdXRbMl0gLyAyNTUsIGlucHV0WzNdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yOS5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yOS5mKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKF9lcnJvcjIgfHwgXCJDb3VsZCBub3QgcGFyc2UgY29sb3IgZnJvbSB2YWx1ZSAnXCIuY29uY2F0KHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBpbnB1dCA6IFN0cmluZyhKU09OLnN0cmluZ2lmeShpbnB1dCkpLCBcIidcIikpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yMTAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmFyZ3MpLFxuICAgICAgICAgICAgX3N0ZXAxMDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMTAucygpOyAhKF9zdGVwMTAgPSBfaXRlcmF0b3IxMC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgX2FyZyA9IF9zdGVwMTAudmFsdWU7XG4gICAgICAgICAgICB2YWx1ZSA9IF9hcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgICAgICAgICB2YXIgbnVtID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc05hTihudW0pKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBudW07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IxMC5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMTAuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIkNvdWxkIG5vdCBjb252ZXJ0IFwiLmNvbmNhdChKU09OLnN0cmluZ2lmeSh2YWx1ZSksIFwiIHRvIG51bWJlci5cIikpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2Zvcm1hdHRlZCcpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlZC5mcm9tU3RyaW5nKHRvU3RyaW5nJDEodGhpcy5hcmdzWzBdLmV2YWx1YXRlKGN0eCkpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50eXBlLmtpbmQgPT09ICdyZXNvbHZlZEltYWdlJykge1xuICAgICAgICByZXR1cm4gUmVzb2x2ZWRJbWFnZS5mcm9tU3RyaW5nKHRvU3RyaW5nJDEodGhpcy5hcmdzWzBdLmV2YWx1YXRlKGN0eCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZyQxKHRoaXMuYXJnc1swXS5ldmFsdWF0ZShjdHgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgICAgdGhpcy5hcmdzLmZvckVhY2goZm4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcmdzLmV2ZXJ5KGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUua2luZCA9PT0gJ2Zvcm1hdHRlZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXRFeHByZXNzaW9uKFt7XG4gICAgICAgICAgY29udGVudDogdGhpcy5hcmdzWzBdLFxuICAgICAgICAgIHNjYWxlOiBudWxsLFxuICAgICAgICAgIGZvbnQ6IG51bGwsXG4gICAgICAgICAgdGV4dENvbG9yOiBudWxsXG4gICAgICAgIH1dKS5zZXJpYWxpemUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHlwZS5raW5kID09PSAncmVzb2x2ZWRJbWFnZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbWFnZUV4cHJlc3Npb24odGhpcy5hcmdzWzBdKS5zZXJpYWxpemUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbXCJ0by1cIi5jb25jYXQodGhpcy50eXBlLmtpbmQpXTtcbiAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSBhcmd1bWVudC5cIik7XG4gICAgICB2YXIgbmFtZSA9IGFyZ3NbMF07XG4gICAgICBpZiAoKG5hbWUgPT09ICd0by1ib29sZWFuJyB8fCBuYW1lID09PSAndG8tc3RyaW5nJykgJiYgYXJncy5sZW5ndGggIT09IDIpIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgb25lIGFyZ3VtZW50LlwiKTtcbiAgICAgIHZhciB0eXBlID0gdHlwZXMkMVtuYW1lXTtcbiAgICAgIHZhciBwYXJzZWQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1tpXSwgaSwgVmFsdWVUeXBlKTtcbiAgICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHBhcnNlZC5wdXNoKGlucHV0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBDb2VyY2lvbih0eXBlLCBwYXJzZWQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb2VyY2lvbjtcbn0oKTtcblxudmFyIGdlb21ldHJ5VHlwZXMgPSBbJ1Vua25vd24nLCAnUG9pbnQnLCAnTGluZVN0cmluZycsICdQb2x5Z29uJ107XG5cbnZhciBFdmFsdWF0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2YWx1YXRpb25Db250ZXh0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFdmFsdWF0aW9uQ29udGV4dCk7XG5cbiAgICB0aGlzLmdsb2JhbHMgPSBudWxsO1xuICAgIHRoaXMuZmVhdHVyZSA9IG51bGw7XG4gICAgdGhpcy5mZWF0dXJlU3RhdGUgPSBudWxsO1xuICAgIHRoaXMuZm9ybWF0dGVkU2VjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5fcGFyc2VDb2xvckNhY2hlID0ge307XG4gICAgdGhpcy5hdmFpbGFibGVJbWFnZXMgPSBudWxsO1xuICAgIHRoaXMuY2Fub25pY2FsID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmFsdWF0aW9uQ29udGV4dCwgW3tcbiAgICBrZXk6IFwiaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZWF0dXJlICYmICdpZCcgaW4gdGhpcy5mZWF0dXJlID8gdGhpcy5mZWF0dXJlLmlkIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VvbWV0cnlUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlb21ldHJ5VHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUgPyB0eXBlb2YgdGhpcy5mZWF0dXJlLnR5cGUgPT09ICdudW1iZXInID8gZ2VvbWV0cnlUeXBlc1t0aGlzLmZlYXR1cmUudHlwZV0gOiB0aGlzLmZlYXR1cmUudHlwZSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlb21ldHJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlb21ldHJ5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZSAmJiAnZ2VvbWV0cnknIGluIHRoaXMuZmVhdHVyZSA/IHRoaXMuZmVhdHVyZS5nZW9tZXRyeSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbm9uaWNhbElEXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbm9uaWNhbElEKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9wZXJ0aWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZUNvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlQ29sb3IoaW5wdXQpIHtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzLl9wYXJzZUNvbG9yQ2FjaGVbaW5wdXRdO1xuXG4gICAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICBjYWNoZWQgPSB0aGlzLl9wYXJzZUNvbG9yQ2FjaGVbaW5wdXRdID0gQ29sb3IucGFyc2UoaW5wdXQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmFsdWF0aW9uQ29udGV4dDtcbn0oKTtcblxudmFyIENvbXBvdW5kRXhwcmVzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbXBvdW5kRXhwcmVzc2lvbihuYW1lLCB0eXBlLCBldmFsdWF0ZSwgYXJncykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wb3VuZEV4cHJlc3Npb24pO1xuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuX2V2YWx1YXRlID0gZXZhbHVhdGU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb21wb3VuZEV4cHJlc3Npb24sIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V2YWx1YXRlKGN0eCwgdGhpcy5hcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgICAgdGhpcy5hcmdzLmZvckVhY2goZm4pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICByZXR1cm4gW3RoaXMubmFtZV0uY29uY2F0KHRoaXMuYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gYXJnLnNlcmlhbGl6ZSgpO1xuICAgICAgfSkpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIHZhciBvcCA9IGFyZ3NbMF07XG4gICAgICB2YXIgZGVmaW5pdGlvbiA9IENvbXBvdW5kRXhwcmVzc2lvbi5kZWZpbml0aW9uc1tvcF07XG5cbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIlVua25vd24gZXhwcmVzc2lvbiBcXFwiXCIuY29uY2F0KG9wLCBcIlxcXCIuIElmIHlvdSB3YW50ZWQgYSBsaXRlcmFsIGFycmF5LCB1c2UgW1xcXCJsaXRlcmFsXFxcIiwgWy4uLl1dLlwiKSwgMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlID0gQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSA/IGRlZmluaXRpb25bMF0gOiBkZWZpbml0aW9uLnR5cGU7XG4gICAgICB2YXIgYXZhaWxhYmxlT3ZlcmxvYWRzID0gQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSA/IFtbZGVmaW5pdGlvblsxXSwgZGVmaW5pdGlvblsyXV1dIDogZGVmaW5pdGlvbi5vdmVybG9hZHM7XG4gICAgICB2YXIgb3ZlcmxvYWRzID0gYXZhaWxhYmxlT3ZlcmxvYWRzLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAxKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IF9yZWYyWzBdO1xuXG4gICAgICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShzaWduYXR1cmUpIHx8IHNpZ25hdHVyZS5sZW5ndGggPT09IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNpZ25hdHVyZUNvbnRleHQgPSBudWxsO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMTEgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvdmVybG9hZHMpLFxuICAgICAgICAgIF9zdGVwMTE7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTEucygpOyAhKF9zdGVwMTEgPSBfaXRlcmF0b3IxMS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMTEkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDExLnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgcGFyYW1zID0gX3N0ZXAxMSR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgZXZhbHVhdGUgPSBfc3RlcDExJHZhbHVlWzFdO1xuXG4gICAgICAgICAgc2lnbmF0dXJlQ29udGV4dCA9IG5ldyBQYXJzaW5nQ29udGV4dChjb250ZXh0LnJlZ2lzdHJ5LCBjb250ZXh0LnBhdGgsIG51bGwsIGNvbnRleHQuc2NvcGUpO1xuICAgICAgICAgIHZhciBwYXJzZWRBcmdzID0gW107XG4gICAgICAgICAgdmFyIGFyZ1BhcnNlRmFpbGVkID0gZmFsc2U7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAxOyBfaTMgPCBhcmdzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW19pM107XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlID0gQXJyYXkuaXNBcnJheShwYXJhbXMpID8gcGFyYW1zW19pMyAtIDFdIDogcGFyYW1zLnR5cGU7XG5cbiAgICAgICAgICAgIHZhciBfcGFyc2VkID0gc2lnbmF0dXJlQ29udGV4dC5wYXJzZShhcmcsIDEgKyBwYXJzZWRBcmdzLmxlbmd0aCwgZXhwZWN0ZWRUeXBlKTtcblxuICAgICAgICAgICAgaWYgKCFfcGFyc2VkKSB7XG4gICAgICAgICAgICAgIGFyZ1BhcnNlRmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnNlZEFyZ3MucHVzaChfcGFyc2VkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXJnUGFyc2VGYWlsZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSBwYXJzZWRBcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBzaWduYXR1cmVDb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgXCIuY29uY2F0KHBhcmFtcy5sZW5ndGgsIFwiIGFyZ3VtZW50cywgYnV0IGZvdW5kIFwiKS5jb25jYXQocGFyc2VkQXJncy5sZW5ndGgsIFwiIGluc3RlYWQuXCIpKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgcGFyc2VkQXJncy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgICB2YXIgX2V4cGVjdGVkID0gQXJyYXkuaXNBcnJheShwYXJhbXMpID8gcGFyYW1zW19pNF0gOiBwYXJhbXMudHlwZTtcblxuICAgICAgICAgICAgdmFyIF9hcmcyID0gcGFyc2VkQXJnc1tfaTRdO1xuICAgICAgICAgICAgc2lnbmF0dXJlQ29udGV4dC5jb25jYXQoX2k0ICsgMSkuY2hlY2tTdWJ0eXBlKF9leHBlY3RlZCwgX2FyZzIudHlwZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNpZ25hdHVyZUNvbnRleHQuZXJyb3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wb3VuZEV4cHJlc3Npb24ob3AsIHR5cGUsIGV2YWx1YXRlLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IxMS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IxMS5mKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdmVybG9hZHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBfY29udGV4dCRlcnJvcnM7XG5cbiAgICAgICAgKF9jb250ZXh0JGVycm9ycyA9IGNvbnRleHQuZXJyb3JzKS5wdXNoLmFwcGx5KF9jb250ZXh0JGVycm9ycywgX3RvQ29uc3VtYWJsZUFycmF5KHNpZ25hdHVyZUNvbnRleHQuZXJyb3JzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXhwZWN0ZWQgPSBvdmVybG9hZHMubGVuZ3RoID8gb3ZlcmxvYWRzIDogYXZhaWxhYmxlT3ZlcmxvYWRzO1xuICAgICAgICB2YXIgc2lnbmF0dXJlcyA9IGV4cGVjdGVkLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMSksXG4gICAgICAgICAgICAgIHBhcmFtcyA9IF9yZWY0WzBdO1xuXG4gICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVNpZ25hdHVyZShwYXJhbXMpO1xuICAgICAgICB9KS5qb2luKCcgfCAnKTtcbiAgICAgICAgdmFyIGFjdHVhbFR5cGVzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhcnNlZCA9IGNvbnRleHQucGFyc2UoYXJnc1tpXSwgMSArIGFjdHVhbFR5cGVzLmxlbmd0aCk7XG4gICAgICAgICAgaWYgKCFwYXJzZWQpIHJldHVybiBudWxsO1xuICAgICAgICAgIGFjdHVhbFR5cGVzLnB1c2godG9TdHJpbmcocGFyc2VkLnR5cGUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBhcmd1bWVudHMgb2YgdHlwZSBcIi5jb25jYXQoc2lnbmF0dXJlcywgXCIsIGJ1dCBmb3VuZCAoXCIpLmNvbmNhdChhY3R1YWxUeXBlcy5qb2luKCcsICcpLCBcIikgaW5zdGVhZC5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIocmVnaXN0cnksIGRlZmluaXRpb25zKSB7XG4gICAgICBDb21wb3VuZEV4cHJlc3Npb24uZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcblxuICAgICAgZm9yICh2YXIgbmFtZSBpbiBkZWZpbml0aW9ucykge1xuICAgICAgICByZWdpc3RyeVtuYW1lXSA9IENvbXBvdW5kRXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29tcG91bmRFeHByZXNzaW9uO1xufSgpO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNpZ25hdHVyZSkpIHtcbiAgICByZXR1cm4gXCIoXCIuY29uY2F0KHNpZ25hdHVyZS5tYXAodG9TdHJpbmcpLmpvaW4oJywgJyksIFwiKVwiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCIoXCIuY29uY2F0KHRvU3RyaW5nKHNpZ25hdHVyZS50eXBlKSwgXCIuLi4pXCIpO1xuICB9XG59XG5cbnZhciBDb2xsYXRvckV4cHJlc3Npb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2xsYXRvckV4cHJlc3Npb24oY2FzZVNlbnNpdGl2ZSwgZGlhY3JpdGljU2Vuc2l0aXZlLCBsb2NhbGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29sbGF0b3JFeHByZXNzaW9uKTtcblxuICAgIHRoaXMudHlwZSA9IENvbGxhdG9yVHlwZTtcbiAgICB0aGlzLmxvY2FsZSA9IGxvY2FsZTtcbiAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSBjYXNlU2Vuc2l0aXZlO1xuICAgIHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlID0gZGlhY3JpdGljU2Vuc2l0aXZlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbGxhdG9yRXhwcmVzc2lvbiwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICByZXR1cm4gbmV3IENvbGxhdG9yKHRoaXMuY2FzZVNlbnNpdGl2ZS5ldmFsdWF0ZShjdHgpLCB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZS5ldmFsdWF0ZShjdHgpLCB0aGlzLmxvY2FsZSA/IHRoaXMubG9jYWxlLmV2YWx1YXRlKGN0eCkgOiBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgICAgZm4odGhpcy5jYXNlU2Vuc2l0aXZlKTtcbiAgICAgIGZuKHRoaXMuZGlhY3JpdGljU2Vuc2l0aXZlKTtcblxuICAgICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgIGZuKHRoaXMubG9jYWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgIG9wdGlvbnNbJ2Nhc2Utc2Vuc2l0aXZlJ10gPSB0aGlzLmNhc2VTZW5zaXRpdmUuc2VyaWFsaXplKCk7XG4gICAgICBvcHRpb25zWydkaWFjcml0aWMtc2Vuc2l0aXZlJ10gPSB0aGlzLmRpYWNyaXRpY1NlbnNpdGl2ZS5zZXJpYWxpemUoKTtcblxuICAgICAgaWYgKHRoaXMubG9jYWxlKSB7XG4gICAgICAgIG9wdGlvbnNbJ2xvY2FsZSddID0gdGhpcy5sb2NhbGUuc2VyaWFsaXplKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbJ2NvbGxhdG9yJywgb3B0aW9uc107XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIG9uZSBhcmd1bWVudC5cIik7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3NbMV07XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHJldHVybiBjb250ZXh0LmVycm9yKFwiQ29sbGF0b3Igb3B0aW9ucyBhcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC5cIik7XG4gICAgICB2YXIgY2FzZVNlbnNpdGl2ZSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snY2FzZS1zZW5zaXRpdmUnXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zWydjYXNlLXNlbnNpdGl2ZSddLCAxLCBCb29sZWFuVHlwZSk7XG4gICAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGRpYWNyaXRpY1NlbnNpdGl2ZSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snZGlhY3JpdGljLXNlbnNpdGl2ZSddID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnNbJ2RpYWNyaXRpYy1zZW5zaXRpdmUnXSwgMSwgQm9vbGVhblR5cGUpO1xuICAgICAgaWYgKCFkaWFjcml0aWNTZW5zaXRpdmUpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGxvY2FsZSA9IG51bGw7XG5cbiAgICAgIGlmIChvcHRpb25zWydsb2NhbGUnXSkge1xuICAgICAgICBsb2NhbGUgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2xvY2FsZSddLCAxLCBTdHJpbmdUeXBlKTtcbiAgICAgICAgaWYgKCFsb2NhbGUpIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IENvbGxhdG9yRXhwcmVzc2lvbihjYXNlU2Vuc2l0aXZlLCBkaWFjcml0aWNTZW5zaXRpdmUsIGxvY2FsZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbGxhdG9yRXhwcmVzc2lvbjtcbn0oKTtcblxudmFyIEVYVEVOVCA9IDgxOTI7XG5cbmZ1bmN0aW9uIHVwZGF0ZUJCb3goYmJveCwgY29vcmQpIHtcbiAgYmJveFswXSA9IE1hdGgubWluKGJib3hbMF0sIGNvb3JkWzBdKTtcbiAgYmJveFsxXSA9IE1hdGgubWluKGJib3hbMV0sIGNvb3JkWzFdKTtcbiAgYmJveFsyXSA9IE1hdGgubWF4KGJib3hbMl0sIGNvb3JkWzBdKTtcbiAgYmJveFszXSA9IE1hdGgubWF4KGJib3hbM10sIGNvb3JkWzFdKTtcbn1cblxuZnVuY3Rpb24gbWVyY2F0b3JYZnJvbUxuZyhsbmcpIHtcbiAgcmV0dXJuICgxODAgKyBsbmcpIC8gMzYwO1xufVxuXG5mdW5jdGlvbiBtZXJjYXRvcllmcm9tTGF0KGxhdCkge1xuICByZXR1cm4gKDE4MCAtIDE4MCAvIE1hdGguUEkgKiBNYXRoLmxvZyhNYXRoLnRhbihNYXRoLlBJIC8gNCArIGxhdCAqIE1hdGguUEkgLyAzNjApKSkgLyAzNjA7XG59XG5cbmZ1bmN0aW9uIGJveFdpdGhpbkJveChiYm94MSwgYmJveDIpIHtcbiAgaWYgKGJib3gxWzBdIDw9IGJib3gyWzBdKSByZXR1cm4gZmFsc2U7XG4gIGlmIChiYm94MVsyXSA+PSBiYm94MlsyXSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoYmJveDFbMV0gPD0gYmJveDJbMV0pIHJldHVybiBmYWxzZTtcbiAgaWYgKGJib3gxWzNdID49IGJib3gyWzNdKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRUaWxlQ29vcmRpbmF0ZXMocCwgY2Fub25pY2FsKSB7XG4gIHZhciB4ID0gbWVyY2F0b3JYZnJvbUxuZyhwWzBdKTtcbiAgdmFyIHkgPSBtZXJjYXRvcllmcm9tTGF0KHBbMV0pO1xuICB2YXIgdGlsZXNBdFpvb20gPSBNYXRoLnBvdygyLCBjYW5vbmljYWwueik7XG4gIHJldHVybiBbTWF0aC5yb3VuZCh4ICogdGlsZXNBdFpvb20gKiBFWFRFTlQpLCBNYXRoLnJvdW5kKHkgKiB0aWxlc0F0Wm9vbSAqIEVYVEVOVCldO1xufVxuXG5mdW5jdGlvbiBvbkJvdW5kYXJ5KHAsIHAxLCBwMikge1xuICB2YXIgeDEgPSBwWzBdIC0gcDFbMF07XG4gIHZhciB5MSA9IHBbMV0gLSBwMVsxXTtcbiAgdmFyIHgyID0gcFswXSAtIHAyWzBdO1xuICB2YXIgeTIgPSBwWzFdIC0gcDJbMV07XG4gIHJldHVybiB4MSAqIHkyIC0geDIgKiB5MSA9PT0gMCAmJiB4MSAqIHgyIDw9IDAgJiYgeTEgKiB5MiA8PSAwO1xufVxuXG5mdW5jdGlvbiByYXlJbnRlcnNlY3QocCwgcDEsIHAyKSB7XG4gIHJldHVybiBwMVsxXSA+IHBbMV0gIT09IHAyWzFdID4gcFsxXSAmJiBwWzBdIDwgKHAyWzBdIC0gcDFbMF0pICogKHBbMV0gLSBwMVsxXSkgLyAocDJbMV0gLSBwMVsxXSkgKyBwMVswXTtcbn1cblxuZnVuY3Rpb24gcG9pbnRXaXRoaW5Qb2x5Z29uKHBvaW50LCByaW5ncykge1xuICB2YXIgaW5zaWRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJpbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIHJpbmcgPSByaW5nc1tpXTtcblxuICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gcmluZy5sZW5ndGg7IGogPCBsZW4yIC0gMTsgaisrKSB7XG4gICAgICBpZiAob25Cb3VuZGFyeShwb2ludCwgcmluZ1tqXSwgcmluZ1tqICsgMV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAocmF5SW50ZXJzZWN0KHBvaW50LCByaW5nW2pdLCByaW5nW2ogKyAxXSkpIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc2lkZTtcbn1cblxuZnVuY3Rpb24gcG9pbnRXaXRoaW5Qb2x5Z29ucyhwb2ludCwgcG9seWdvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29ucy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwb2ludFdpdGhpblBvbHlnb24ocG9pbnQsIHBvbHlnb25zW2ldKSkgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBlcnAodjEsIHYyKSB7XG4gIHJldHVybiB2MVswXSAqIHYyWzFdIC0gdjFbMV0gKiB2MlswXTtcbn1cblxuZnVuY3Rpb24gdHdvU2lkZWQocDEsIHAyLCBxMSwgcTIpIHtcbiAgdmFyIHgxID0gcDFbMF0gLSBxMVswXTtcbiAgdmFyIHkxID0gcDFbMV0gLSBxMVsxXTtcbiAgdmFyIHgyID0gcDJbMF0gLSBxMVswXTtcbiAgdmFyIHkyID0gcDJbMV0gLSBxMVsxXTtcbiAgdmFyIHgzID0gcTJbMF0gLSBxMVswXTtcbiAgdmFyIHkzID0gcTJbMV0gLSBxMVsxXTtcbiAgdmFyIGRldDEgPSB4MSAqIHkzIC0geDMgKiB5MTtcbiAgdmFyIGRldDIgPSB4MiAqIHkzIC0geDMgKiB5MjtcbiAgaWYgKGRldDEgPiAwICYmIGRldDIgPCAwIHx8IGRldDEgPCAwICYmIGRldDIgPiAwKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0TGluZShhLCBiLCBjLCBkKSB7XG4gIHZhciB2ZWN0b3JQID0gW2JbMF0gLSBhWzBdLCBiWzFdIC0gYVsxXV07XG4gIHZhciB2ZWN0b3JRID0gW2RbMF0gLSBjWzBdLCBkWzFdIC0gY1sxXV07XG4gIGlmIChwZXJwKHZlY3RvclEsIHZlY3RvclApID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0d29TaWRlZChhLCBiLCBjLCBkKSAmJiB0d29TaWRlZChjLCBkLCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbGluZUludGVyc2VjdFBvbHlnb24ocDEsIHAyLCBwb2x5Z29uKSB7XG4gIHZhciBfaXRlcmF0b3IxMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBvbHlnb24pLFxuICAgICAgX3N0ZXAxMjtcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yMTIucygpOyAhKF9zdGVwMTIgPSBfaXRlcmF0b3IxMi5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgcmluZyA9IF9zdGVwMTIudmFsdWU7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZy5sZW5ndGggLSAxOyArK2opIHtcbiAgICAgICAgaWYgKGxpbmVJbnRlcnNlY3RMaW5lKHAxLCBwMiwgcmluZ1tqXSwgcmluZ1tqICsgMV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjEyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IxMi5mKCk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29uKGxpbmUsIHBvbHlnb24pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFwb2ludFdpdGhpblBvbHlnb24obGluZVtpXSwgcG9seWdvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBsaW5lLmxlbmd0aCAtIDE7ICsrX2k1KSB7XG4gICAgaWYgKGxpbmVJbnRlcnNlY3RQb2x5Z29uKGxpbmVbX2k1XSwgbGluZVtfaTUgKyAxXSwgcG9seWdvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbGluZVN0cmluZ1dpdGhpblBvbHlnb25zKGxpbmUsIHBvbHlnb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGluZVN0cmluZ1dpdGhpblBvbHlnb24obGluZSwgcG9seWdvbnNbaV0pKSByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0VGlsZVBvbHlnb24oY29vcmRpbmF0ZXMsIGJib3gsIGNhbm9uaWNhbCkge1xuICB2YXIgcG9seWdvbiA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmluZyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb29yZGluYXRlc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIGNvb3JkID0gZ2V0VGlsZUNvb3JkaW5hdGVzKGNvb3JkaW5hdGVzW2ldW2pdLCBjYW5vbmljYWwpO1xuICAgICAgdXBkYXRlQkJveChiYm94LCBjb29yZCk7XG4gICAgICByaW5nLnB1c2goY29vcmQpO1xuICAgIH1cblxuICAgIHBvbHlnb24ucHVzaChyaW5nKTtcbiAgfVxuXG4gIHJldHVybiBwb2x5Z29uO1xufVxuXG5mdW5jdGlvbiBnZXRUaWxlUG9seWdvbnMoY29vcmRpbmF0ZXMsIGJib3gsIGNhbm9uaWNhbCkge1xuICB2YXIgcG9seWdvbnMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBvbHlnb24gPSBnZXRUaWxlUG9seWdvbihjb29yZGluYXRlc1tpXSwgYmJveCwgY2Fub25pY2FsKTtcbiAgICBwb2x5Z29ucy5wdXNoKHBvbHlnb24pO1xuICB9XG5cbiAgcmV0dXJuIHBvbHlnb25zO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQb2ludChwLCBiYm94LCBwb2x5QkJveCwgd29ybGRTaXplKSB7XG4gIGlmIChwWzBdIDwgcG9seUJCb3hbMF0gfHwgcFswXSA+IHBvbHlCQm94WzJdKSB7XG4gICAgdmFyIGhhbGZXb3JsZFNpemUgPSB3b3JsZFNpemUgKiAwLjU7XG4gICAgdmFyIHNoaWZ0ID0gcFswXSAtIHBvbHlCQm94WzBdID4gaGFsZldvcmxkU2l6ZSA/IC13b3JsZFNpemUgOiBwb2x5QkJveFswXSAtIHBbMF0gPiBoYWxmV29ybGRTaXplID8gd29ybGRTaXplIDogMDtcblxuICAgIGlmIChzaGlmdCA9PT0gMCkge1xuICAgICAgc2hpZnQgPSBwWzBdIC0gcG9seUJCb3hbMl0gPiBoYWxmV29ybGRTaXplID8gLXdvcmxkU2l6ZSA6IHBvbHlCQm94WzJdIC0gcFswXSA+IGhhbGZXb3JsZFNpemUgPyB3b3JsZFNpemUgOiAwO1xuICAgIH1cblxuICAgIHBbMF0gKz0gc2hpZnQ7XG4gIH1cblxuICB1cGRhdGVCQm94KGJib3gsIHApO1xufVxuXG5mdW5jdGlvbiByZXNldEJCb3goYmJveCkge1xuICBiYm94WzBdID0gYmJveFsxXSA9IEluZmluaXR5O1xuICBiYm94WzJdID0gYmJveFszXSA9IC1JbmZpbml0eTtcbn1cblxuZnVuY3Rpb24gZ2V0VGlsZVBvaW50cyhnZW9tZXRyeSwgcG9pbnRCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKSB7XG4gIHZhciB3b3JsZFNpemUgPSBNYXRoLnBvdygyLCBjYW5vbmljYWwueikgKiBFWFRFTlQ7XG4gIHZhciBzaGlmdHMgPSBbY2Fub25pY2FsLnggKiBFWFRFTlQsIGNhbm9uaWNhbC55ICogRVhURU5UXTtcbiAgdmFyIHRpbGVQb2ludHMgPSBbXTtcblxuICB2YXIgX2l0ZXJhdG9yMTMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihnZW9tZXRyeSksXG4gICAgICBfc3RlcDEzO1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IxMy5zKCk7ICEoX3N0ZXAxMyA9IF9pdGVyYXRvcjEzLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBwb2ludHMgPSBfc3RlcDEzLnZhbHVlO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMTQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwb2ludHMpLFxuICAgICAgICAgIF9zdGVwMTQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTQucygpOyAhKF9zdGVwMTQgPSBfaXRlcmF0b3IxNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gX3N0ZXAxNC52YWx1ZTtcbiAgICAgICAgICB2YXIgcCA9IFtwb2ludC54ICsgc2hpZnRzWzBdLCBwb2ludC55ICsgc2hpZnRzWzFdXTtcbiAgICAgICAgICB1cGRhdGVQb2ludChwLCBwb2ludEJCb3gsIHBvbHlCQm94LCB3b3JsZFNpemUpO1xuICAgICAgICAgIHRpbGVQb2ludHMucHVzaChwKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjE0LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjE0LmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9pdGVyYXRvcjEzLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IxMy5mKCk7XG4gIH1cblxuICByZXR1cm4gdGlsZVBvaW50cztcbn1cblxuZnVuY3Rpb24gZ2V0VGlsZUxpbmVzKGdlb21ldHJ5LCBsaW5lQkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCkge1xuICB2YXIgd29ybGRTaXplID0gTWF0aC5wb3coMiwgY2Fub25pY2FsLnopICogRVhURU5UO1xuICB2YXIgc2hpZnRzID0gW2Nhbm9uaWNhbC54ICogRVhURU5ULCBjYW5vbmljYWwueSAqIEVYVEVOVF07XG4gIHZhciB0aWxlTGluZXMgPSBbXTtcblxuICB2YXIgX2l0ZXJhdG9yMTUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihnZW9tZXRyeSksXG4gICAgICBfc3RlcDE1O1xuXG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IxNS5zKCk7ICEoX3N0ZXAxNSA9IF9pdGVyYXRvcjE1Lm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBfbGluZSA9IF9zdGVwMTUudmFsdWU7XG4gICAgICB2YXIgdGlsZUxpbmUgPSBbXTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjE4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX2xpbmUpLFxuICAgICAgICAgIF9zdGVwMTg7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMTgucygpOyAhKF9zdGVwMTggPSBfaXRlcmF0b3IxOC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHBvaW50ID0gX3N0ZXAxOC52YWx1ZTtcbiAgICAgICAgICB2YXIgX3AgPSBbcG9pbnQueCArIHNoaWZ0c1swXSwgcG9pbnQueSArIHNoaWZ0c1sxXV07XG4gICAgICAgICAgdXBkYXRlQkJveChsaW5lQkJveCwgX3ApO1xuICAgICAgICAgIHRpbGVMaW5lLnB1c2goX3ApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMTguZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMTguZigpO1xuICAgICAgfVxuXG4gICAgICB0aWxlTGluZXMucHVzaCh0aWxlTGluZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IxNS5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yMTUuZigpO1xuICB9XG5cbiAgaWYgKGxpbmVCQm94WzJdIC0gbGluZUJCb3hbMF0gPD0gd29ybGRTaXplIC8gMikge1xuICAgIHJlc2V0QkJveChsaW5lQkJveCk7XG5cbiAgICB2YXIgX2l0ZXJhdG9yMTYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aWxlTGluZXMpLFxuICAgICAgICBfc3RlcDE2O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMTYucygpOyAhKF9zdGVwMTYgPSBfaXRlcmF0b3IxNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBsaW5lID0gX3N0ZXAxNi52YWx1ZTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yMTcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsaW5lKSxcbiAgICAgICAgICAgIF9zdGVwMTc7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjE3LnMoKTsgIShfc3RlcDE3ID0gX2l0ZXJhdG9yMTcubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHAgPSBfc3RlcDE3LnZhbHVlO1xuICAgICAgICAgICAgdXBkYXRlUG9pbnQocCwgbGluZUJCb3gsIHBvbHlCQm94LCB3b3JsZFNpemUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMTcuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjE3LmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMTYuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IxNi5mKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRpbGVMaW5lcztcbn1cblxuZnVuY3Rpb24gcG9pbnRzV2l0aGluUG9seWdvbnMoY3R4LCBwb2x5Z29uR2VvbWV0cnkpIHtcbiAgdmFyIHBvaW50QkJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgdmFyIHBvbHlCQm94ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICB2YXIgY2Fub25pY2FsID0gY3R4LmNhbm9uaWNhbElEKCk7XG5cbiAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICB2YXIgdGlsZVBvbHlnb24gPSBnZXRUaWxlUG9seWdvbihwb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuICAgIHZhciB0aWxlUG9pbnRzID0gZ2V0VGlsZVBvaW50cyhjdHguZ2VvbWV0cnkoKSwgcG9pbnRCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKTtcbiAgICBpZiAoIWJveFdpdGhpbkJveChwb2ludEJCb3gsIHBvbHlCQm94KSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIF9pdGVyYXRvcjE5ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGlsZVBvaW50cyksXG4gICAgICAgIF9zdGVwMTk7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IxOS5zKCk7ICEoX3N0ZXAxOSA9IF9pdGVyYXRvcjE5Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHBvaW50ID0gX3N0ZXAxOS52YWx1ZTtcbiAgICAgICAgaWYgKCFwb2ludFdpdGhpblBvbHlnb24ocG9pbnQsIHRpbGVQb2x5Z29uKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMTkuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IxOS5mKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBvbHlnb25HZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgIHZhciB0aWxlUG9seWdvbnMgPSBnZXRUaWxlUG9seWdvbnMocG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzLCBwb2x5QkJveCwgY2Fub25pY2FsKTtcblxuICAgIHZhciBfdGlsZVBvaW50cyA9IGdldFRpbGVQb2ludHMoY3R4Lmdlb21ldHJ5KCksIHBvaW50QkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG5cbiAgICBpZiAoIWJveFdpdGhpbkJveChwb2ludEJCb3gsIHBvbHlCQm94KSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIF9pdGVyYXRvcjIwID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX3RpbGVQb2ludHMpLFxuICAgICAgICBfc3RlcDIwO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMjAucygpOyAhKF9zdGVwMjAgPSBfaXRlcmF0b3IyMC5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfcG9pbnQgPSBfc3RlcDIwLnZhbHVlO1xuICAgICAgICBpZiAoIXBvaW50V2l0aGluUG9seWdvbnMoX3BvaW50LCB0aWxlUG9seWdvbnMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyMC5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIwLmYoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gbGluZXNXaXRoaW5Qb2x5Z29ucyhjdHgsIHBvbHlnb25HZW9tZXRyeSkge1xuICB2YXIgbGluZUJCb3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gIHZhciBwb2x5QkJveCA9IFtJbmZpbml0eSwgSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XTtcbiAgdmFyIGNhbm9uaWNhbCA9IGN0eC5jYW5vbmljYWxJRCgpO1xuXG4gIGlmIChwb2x5Z29uR2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgdmFyIHRpbGVQb2x5Z29uID0gZ2V0VGlsZVBvbHlnb24ocG9seWdvbkdlb21ldHJ5LmNvb3JkaW5hdGVzLCBwb2x5QkJveCwgY2Fub25pY2FsKTtcbiAgICB2YXIgdGlsZUxpbmVzID0gZ2V0VGlsZUxpbmVzKGN0eC5nZW9tZXRyeSgpLCBsaW5lQkJveCwgcG9seUJCb3gsIGNhbm9uaWNhbCk7XG4gICAgaWYgKCFib3hXaXRoaW5Cb3gobGluZUJCb3gsIHBvbHlCQm94KSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIF9pdGVyYXRvcjIxID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGlsZUxpbmVzKSxcbiAgICAgICAgX3N0ZXAyMTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIxLnMoKTsgIShfc3RlcDIxID0gX2l0ZXJhdG9yMjEubigpKS5kb25lOykge1xuICAgICAgICB2YXIgbGluZSA9IF9zdGVwMjEudmFsdWU7XG4gICAgICAgIGlmICghbGluZVN0cmluZ1dpdGhpblBvbHlnb24obGluZSwgdGlsZVBvbHlnb24pKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyMS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIxLmYoKTtcbiAgICB9XG4gIH1cblxuICBpZiAocG9seWdvbkdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgdmFyIHRpbGVQb2x5Z29ucyA9IGdldFRpbGVQb2x5Z29ucyhwb2x5Z29uR2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBvbHlCQm94LCBjYW5vbmljYWwpO1xuXG4gICAgdmFyIF90aWxlTGluZXMgPSBnZXRUaWxlTGluZXMoY3R4Lmdlb21ldHJ5KCksIGxpbmVCQm94LCBwb2x5QkJveCwgY2Fub25pY2FsKTtcblxuICAgIGlmICghYm94V2l0aGluQm94KGxpbmVCQm94LCBwb2x5QkJveCkpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBfaXRlcmF0b3IyMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF90aWxlTGluZXMpLFxuICAgICAgICBfc3RlcDIyO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMjIucygpOyAhKF9zdGVwMjIgPSBfaXRlcmF0b3IyMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfbGluZTIgPSBfc3RlcDIyLnZhbHVlO1xuICAgICAgICBpZiAoIWxpbmVTdHJpbmdXaXRoaW5Qb2x5Z29ucyhfbGluZTIsIHRpbGVQb2x5Z29ucykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjIyLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMjIuZigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgV2l0aGluID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV2l0aGluKGdlb2pzb24sIGdlb21ldHJpZXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2l0aGluKTtcblxuICAgIHRoaXMudHlwZSA9IEJvb2xlYW5UeXBlO1xuICAgIHRoaXMuZ2VvanNvbiA9IGdlb2pzb247XG4gICAgdGhpcy5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXaXRoaW4sIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgaWYgKGN0eC5nZW9tZXRyeSgpICE9IG51bGwgJiYgY3R4LmNhbm9uaWNhbElEKCkgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY3R4Lmdlb21ldHJ5VHlwZSgpID09PSAnUG9pbnQnKSB7XG4gICAgICAgICAgcmV0dXJuIHBvaW50c1dpdGhpblBvbHlnb25zKGN0eCwgdGhpcy5nZW9tZXRyaWVzKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdHguZ2VvbWV0cnlUeXBlKCkgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBsaW5lc1dpdGhpblBvbHlnb25zKGN0eCwgdGhpcy5nZW9tZXRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIm91dHB1dERlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIFsnd2l0aGluJywgdGhpcy5nZW9qc29uXTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIpIHJldHVybiBjb250ZXh0LmVycm9yKFwiJ3dpdGhpbicgZXhwcmVzc2lvbiByZXF1aXJlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgYnV0IGZvdW5kIFwiLmNvbmNhdChhcmdzLmxlbmd0aCAtIDEsIFwiIGluc3RlYWQuXCIpKTtcblxuICAgICAgaWYgKGlzVmFsdWUoYXJnc1sxXSkpIHtcbiAgICAgICAgdmFyIGdlb2pzb24gPSBhcmdzWzFdO1xuXG4gICAgICAgIGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZ2VvanNvbi5mZWF0dXJlc1tpXS5nZW9tZXRyeS50eXBlO1xuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgV2l0aGluKGdlb2pzb24sIGdlb2pzb24uZmVhdHVyZXNbaV0uZ2VvbWV0cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICAgIHZhciBfdHlwZTIgPSBnZW9qc29uLmdlb21ldHJ5LnR5cGU7XG5cbiAgICAgICAgICBpZiAoX3R5cGUyID09PSAnUG9seWdvbicgfHwgX3R5cGUyID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXaXRoaW4oZ2VvanNvbiwgZ2VvanNvbi5nZW9tZXRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdlb2pzb24udHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb2pzb24udHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFdpdGhpbihnZW9qc29uLCBnZW9qc29uKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIid3aXRoaW4nIGV4cHJlc3Npb24gcmVxdWlyZXMgdmFsaWQgZ2VvanNvbiBvYmplY3QgdGhhdCBjb250YWlucyBwb2x5Z29uIGdlb21ldHJ5IHR5cGUuXCIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXaXRoaW47XG59KCk7XG5cbmZ1bmN0aW9uIGlzRmVhdHVyZUNvbnN0YW50KGUpIHtcbiAgaWYgKGUgaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24pIHtcbiAgICBpZiAoZS5uYW1lID09PSAnZ2V0JyAmJiBlLmFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdmZWF0dXJlLXN0YXRlJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZS5uYW1lID09PSAnaGFzJyAmJiBlLmFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdwcm9wZXJ0aWVzJyB8fCBlLm5hbWUgPT09ICdnZW9tZXRyeS10eXBlJyB8fCBlLm5hbWUgPT09ICdpZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKC9eZmlsdGVyLS8udGVzdChlLm5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGUgaW5zdGFuY2VvZiBXaXRoaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgZS5lYWNoQ2hpbGQoZnVuY3Rpb24gKGFyZykge1xuICAgIGlmIChyZXN1bHQgJiYgIWlzRmVhdHVyZUNvbnN0YW50KGFyZykpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGlzU3RhdGVDb25zdGFudChlKSB7XG4gIGlmIChlIGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uKSB7XG4gICAgaWYgKGUubmFtZSA9PT0gJ2ZlYXR1cmUtc3RhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIGUuZWFjaENoaWxkKGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAocmVzdWx0ICYmICFpc1N0YXRlQ29uc3RhbnQoYXJnKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGUsIHByb3BlcnRpZXMpIHtcbiAgaWYgKGUgaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24gJiYgcHJvcGVydGllcy5pbmRleE9mKGUubmFtZSkgPj0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBlLmVhY2hDaGlsZChmdW5jdGlvbiAoYXJnKSB7XG4gICAgaWYgKHJlc3VsdCAmJiAhaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGFyZywgcHJvcGVydGllcykpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBWYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWYXIobmFtZSwgYm91bmRFeHByZXNzaW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZhcik7XG5cbiAgICB0aGlzLnR5cGUgPSBib3VuZEV4cHJlc3Npb24udHlwZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuYm91bmRFeHByZXNzaW9uID0gYm91bmRFeHByZXNzaW9uO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFZhciwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICByZXR1cm4gdGhpcy5ib3VuZEV4cHJlc3Npb24uZXZhbHVhdGUoY3R4KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2hDaGlsZCgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIFsndmFyJywgdGhpcy5uYW1lXTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IDIgfHwgdHlwZW9mIGFyZ3NbMV0gIT09ICdzdHJpbmcnKSByZXR1cm4gY29udGV4dC5lcnJvcihcIid2YXInIGV4cHJlc3Npb24gcmVxdWlyZXMgZXhhY3RseSBvbmUgc3RyaW5nIGxpdGVyYWwgYXJndW1lbnQuXCIpO1xuICAgICAgdmFyIG5hbWUgPSBhcmdzWzFdO1xuXG4gICAgICBpZiAoIWNvbnRleHQuc2NvcGUuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiVW5rbm93biB2YXJpYWJsZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIi4gTWFrZSBzdXJlIFxcXCJcIikuY29uY2F0KG5hbWUsIFwiXFxcIiBoYXMgYmVlbiBib3VuZCBpbiBhbiBlbmNsb3NpbmcgXFxcImxldFxcXCIgZXhwcmVzc2lvbiBiZWZvcmUgdXNpbmcgaXQuXCIpLCAxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBWYXIobmFtZSwgY29udGV4dC5zY29wZS5nZXQobmFtZSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWYXI7XG59KCk7XG5cbnZhciBQYXJzaW5nQ29udGV4dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBhcnNpbmdDb250ZXh0KHJlZ2lzdHJ5KSB7XG4gICAgdmFyIHBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgIHZhciBleHBlY3RlZFR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgc2NvcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG5ldyBTY29wZSgpO1xuICAgIHZhciBlcnJvcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IFtdO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhcnNpbmdDb250ZXh0KTtcblxuICAgIHRoaXMucmVnaXN0cnkgPSByZWdpc3RyeTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMua2V5ID0gcGF0aC5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgIHJldHVybiBcIltcIi5jb25jYXQocGFydCwgXCJdXCIpO1xuICAgIH0pLmpvaW4oJycpO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICB0aGlzLmV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQYXJzaW5nQ29udGV4dCwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoZXhwciwgaW5kZXgsIGV4cGVjdGVkVHlwZSwgYmluZGluZ3MpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiB7fTtcblxuICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmNhdChpbmRleCwgZXhwZWN0ZWRUeXBlLCBiaW5kaW5ncykuX3BhcnNlKGV4cHIsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2UoZXhwciwgb3B0aW9ucyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2UoZXhwciwgb3B0aW9ucykge1xuICAgICAgaWYgKGV4cHIgPT09IG51bGwgfHwgdHlwZW9mIGV4cHIgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBleHByID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIGV4cHIgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGV4cHIgPSBbJ2xpdGVyYWwnLCBleHByXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYW5ub3RhdGUocGFyc2VkLCB0eXBlLCB0eXBlQW5ub3RhdGlvbikge1xuICAgICAgICBpZiAodHlwZUFubm90YXRpb24gPT09ICdhc3NlcnQnKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBc3NlcnRpb24odHlwZSwgW3BhcnNlZF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVBbm5vdGF0aW9uID09PSAnY29lcmNlJykge1xuICAgICAgICAgIHJldHVybiBuZXcgQ29lcmNpb24odHlwZSwgW3BhcnNlZF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhwcikpIHtcbiAgICAgICAgaWYgKGV4cHIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJFeHBlY3RlZCBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBlbGVtZW50LiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcXFwibGl0ZXJhbFxcXCIsIFtdXS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3AgPSBleHByWzBdO1xuXG4gICAgICAgIGlmICh0eXBlb2Ygb3AgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcihcIkV4cHJlc3Npb24gbmFtZSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgZm91bmQgXCIuY29uY2F0KHR5cGVvZiBvcCwgXCIgaW5zdGVhZC4gSWYgeW91IHdhbnRlZCBhIGxpdGVyYWwgYXJyYXksIHVzZSBbXFxcImxpdGVyYWxcXFwiLCBbLi4uXV0uXCIpLCAwKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBFeHByID0gdGhpcy5yZWdpc3RyeVtvcF07XG5cbiAgICAgICAgaWYgKEV4cHIpIHtcbiAgICAgICAgICB2YXIgcGFyc2VkID0gRXhwci5wYXJzZShleHByLCB0aGlzKTtcbiAgICAgICAgICBpZiAoIXBhcnNlZCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBpZiAodGhpcy5leHBlY3RlZFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBleHBlY3RlZCA9IHRoaXMuZXhwZWN0ZWRUeXBlO1xuICAgICAgICAgICAgdmFyIGFjdHVhbCA9IHBhcnNlZC50eXBlO1xuXG4gICAgICAgICAgICBpZiAoKGV4cGVjdGVkLmtpbmQgPT09ICdzdHJpbmcnIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdudW1iZXInIHx8IGV4cGVjdGVkLmtpbmQgPT09ICdib29sZWFuJyB8fCBleHBlY3RlZC5raW5kID09PSAnb2JqZWN0JyB8fCBleHBlY3RlZC5raW5kID09PSAnYXJyYXknKSAmJiBhY3R1YWwua2luZCA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICBwYXJzZWQgPSBhbm5vdGF0ZShwYXJzZWQsIGV4cGVjdGVkLCBvcHRpb25zLnR5cGVBbm5vdGF0aW9uIHx8ICdhc3NlcnQnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGV4cGVjdGVkLmtpbmQgPT09ICdjb2xvcicgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ2Zvcm1hdHRlZCcgfHwgZXhwZWN0ZWQua2luZCA9PT0gJ3Jlc29sdmVkSW1hZ2UnKSAmJiAoYWN0dWFsLmtpbmQgPT09ICd2YWx1ZScgfHwgYWN0dWFsLmtpbmQgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICBwYXJzZWQgPSBhbm5vdGF0ZShwYXJzZWQsIGV4cGVjdGVkLCBvcHRpb25zLnR5cGVBbm5vdGF0aW9uIHx8ICdjb2VyY2UnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGVja1N1YnR5cGUoZXhwZWN0ZWQsIGFjdHVhbCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCEocGFyc2VkIGluc3RhbmNlb2YgTGl0ZXJhbCkgJiYgcGFyc2VkLnR5cGUua2luZCAhPT0gJ3Jlc29sdmVkSW1hZ2UnICYmIGlzQ29uc3RhbnQocGFyc2VkKSkge1xuICAgICAgICAgICAgdmFyIGVjID0gbmV3IEV2YWx1YXRpb25Db250ZXh0KCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHBhcnNlZCA9IG5ldyBMaXRlcmFsKHBhcnNlZC50eXBlLCBwYXJzZWQuZXZhbHVhdGUoZWMpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5lcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCJVbmtub3duIGV4cHJlc3Npb24gXFxcIlwiLmNvbmNhdChvcCwgXCJcXFwiLiBJZiB5b3Ugd2FudGVkIGEgbGl0ZXJhbCBhcnJheSwgdXNlIFtcXFwibGl0ZXJhbFxcXCIsIFsuLi5dXS5cIiksIDApO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3IoXCIndW5kZWZpbmVkJyB2YWx1ZSBpbnZhbGlkLiBVc2UgbnVsbCBpbnN0ZWFkLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cHIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKFwiQmFyZSBvYmplY3RzIGludmFsaWQuIFVzZSBbXFxcImxpdGVyYWxcXFwiLCB7Li4ufV0gaW5zdGVhZC5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIkV4cGVjdGVkIGFuIGFycmF5LCBidXQgZm91bmQgXCIuY29uY2F0KHR5cGVvZiBleHByLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQoaW5kZXgsIGV4cGVjdGVkVHlwZSwgYmluZGluZ3MpIHtcbiAgICAgIHZhciBwYXRoID0gdHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJyA/IHRoaXMucGF0aC5jb25jYXQoaW5kZXgpIDogdGhpcy5wYXRoO1xuICAgICAgdmFyIHNjb3BlID0gYmluZGluZ3MgPyB0aGlzLnNjb3BlLmNvbmNhdChiaW5kaW5ncykgOiB0aGlzLnNjb3BlO1xuICAgICAgcmV0dXJuIG5ldyBQYXJzaW5nQ29udGV4dCh0aGlzLnJlZ2lzdHJ5LCBwYXRoLCBleHBlY3RlZFR5cGUgfHwgbnVsbCwgc2NvcGUsIHRoaXMuZXJyb3JzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXJyb3IoX2Vycm9yMykge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBrZXlzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjI7IF9rZXk0KyspIHtcbiAgICAgICAga2V5c1tfa2V5NCAtIDFdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleSA9IFwiXCIuY29uY2F0KHRoaXMua2V5KS5jb25jYXQoa2V5cy5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIFwiW1wiLmNvbmNhdChrLCBcIl1cIik7XG4gICAgICB9KS5qb2luKCcnKSk7XG4gICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBQYXJzaW5nRXJyb3Ioa2V5LCBfZXJyb3IzKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrU3VidHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1N1YnR5cGUoZXhwZWN0ZWQsIHQpIHtcbiAgICAgIHZhciBlcnJvciA9IF9jaGVja1N1YnR5cGUoZXhwZWN0ZWQsIHQpO1xuXG4gICAgICBpZiAoZXJyb3IpIHRoaXMuZXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXJzaW5nQ29udGV4dDtcbn0oKTtcblxuZnVuY3Rpb24gaXNDb25zdGFudChleHByZXNzaW9uKSB7XG4gIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgVmFyKSB7XG4gICAgcmV0dXJuIGlzQ29uc3RhbnQoZXhwcmVzc2lvbi5ib3VuZEV4cHJlc3Npb24pO1xuICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb21wb3VuZEV4cHJlc3Npb24gJiYgZXhwcmVzc2lvbi5uYW1lID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb2xsYXRvckV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFdpdGhpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc1R5cGVBbm5vdGF0aW9uID0gZXhwcmVzc2lvbiBpbnN0YW5jZW9mIENvZXJjaW9uIHx8IGV4cHJlc3Npb24gaW5zdGFuY2VvZiBBc3NlcnRpb247XG4gIHZhciBjaGlsZHJlbkNvbnN0YW50ID0gdHJ1ZTtcbiAgZXhwcmVzc2lvbi5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGlzVHlwZUFubm90YXRpb24pIHtcbiAgICAgIGNoaWxkcmVuQ29uc3RhbnQgPSBjaGlsZHJlbkNvbnN0YW50ICYmIGlzQ29uc3RhbnQoY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbkNvbnN0YW50ID0gY2hpbGRyZW5Db25zdGFudCAmJiBjaGlsZCBpbnN0YW5jZW9mIExpdGVyYWw7XG4gICAgfVxuICB9KTtcblxuICBpZiAoIWNoaWxkcmVuQ29uc3RhbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gaXNGZWF0dXJlQ29uc3RhbnQoZXhwcmVzc2lvbikgJiYgaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGV4cHJlc3Npb24sIFsnem9vbScsICdoZWF0bWFwLWRlbnNpdHknLCAnbGluZS1wcm9ncmVzcycsICdza3ktcmFkaWFsLXByb2dyZXNzJywgJ2FjY3VtdWxhdGVkJywgJ2lzLXN1cHBvcnRlZC1zY3JpcHQnXSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRTdG9wTGVzc1RoYW5PckVxdWFsVG8oc3RvcHMsIGlucHV0KSB7XG4gIHZhciBsYXN0SW5kZXggPSBzdG9wcy5sZW5ndGggLSAxO1xuICB2YXIgbG93ZXJJbmRleCA9IDA7XG4gIHZhciB1cHBlckluZGV4ID0gbGFzdEluZGV4O1xuICB2YXIgY3VycmVudEluZGV4ID0gMDtcbiAgdmFyIGN1cnJlbnRWYWx1ZSwgbmV4dFZhbHVlO1xuXG4gIHdoaWxlIChsb3dlckluZGV4IDw9IHVwcGVySW5kZXgpIHtcbiAgICBjdXJyZW50SW5kZXggPSBNYXRoLmZsb29yKChsb3dlckluZGV4ICsgdXBwZXJJbmRleCkgLyAyKTtcbiAgICBjdXJyZW50VmFsdWUgPSBzdG9wc1tjdXJyZW50SW5kZXhdO1xuICAgIG5leHRWYWx1ZSA9IHN0b3BzW2N1cnJlbnRJbmRleCArIDFdO1xuXG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA8PSBpbnB1dCkge1xuICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gbGFzdEluZGV4IHx8IGlucHV0IDwgbmV4dFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50SW5kZXg7XG4gICAgICB9XG5cbiAgICAgIGxvd2VySW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gaW5wdXQpIHtcbiAgICAgIHVwcGVySW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKCdJbnB1dCBpcyBub3QgYSBudW1iZXIuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbnZhciBTdGVwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RlcCh0eXBlLCBpbnB1dCwgc3RvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RlcCk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuXG4gICAgdmFyIF9pdGVyYXRvcjIzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3RvcHMpLFxuICAgICAgICBfc3RlcDIzO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yMjMucygpOyAhKF9zdGVwMjMgPSBfaXRlcmF0b3IyMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RlcDIzJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAyMy52YWx1ZSwgMiksXG4gICAgICAgICAgICBsYWJlbCA9IF9zdGVwMjMkdmFsdWVbMF0sXG4gICAgICAgICAgICBfZXhwcmVzc2lvbjIgPSBfc3RlcDIzJHZhbHVlWzFdO1xuXG4gICAgICAgIHRoaXMubGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICB0aGlzLm91dHB1dHMucHVzaChfZXhwcmVzc2lvbjIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMjMuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IyMy5mKCk7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0ZXAsIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgdmFyIGxhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgICAgdmFyIG91dHB1dHMgPSB0aGlzLm91dHB1dHM7XG5cbiAgICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcblxuICAgICAgaWYgKHZhbHVlIDw9IGxhYmVsc1swXSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0c1swXS5ldmFsdWF0ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RvcENvdW50ID0gbGFiZWxzLmxlbmd0aDtcblxuICAgICAgaWYgKHZhbHVlID49IGxhYmVsc1tzdG9wQ291bnQgLSAxXSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0c1tzdG9wQ291bnQgLSAxXS5ldmFsdWF0ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKGxhYmVscywgdmFsdWUpO1xuICAgICAgcmV0dXJuIG91dHB1dHNbaW5kZXhdLmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIGZuKHRoaXMuaW5wdXQpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLm91dHB1dHMpLFxuICAgICAgICAgIF9zdGVwMjQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMjQucygpOyAhKF9zdGVwMjQgPSBfaXRlcmF0b3IyNC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9leHByZXNzaW9uMyA9IF9zdGVwMjQudmFsdWU7XG4gICAgICAgICAgZm4oX2V4cHJlc3Npb24zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjI0LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjI0LmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHJldHVybiBvdXQub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgc2VyaWFsaXplZCA9IFsnc3RlcCcsIHRoaXMuaW5wdXQuc2VyaWFsaXplKCldO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLmxhYmVsc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5vdXRwdXRzW2ldLnNlcmlhbGl6ZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoIC0gMSA8IDQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBhdCBsZWFzdCA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIG9ubHkgXCIuY29uY2F0KGFyZ3MubGVuZ3RoIC0gMSwgXCIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChhcmdzLmxlbmd0aCAtIDEpICUgMiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cy5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnB1dCA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgICBpZiAoIWlucHV0KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBzdG9wcyA9IFtdO1xuICAgICAgdmFyIG91dHB1dFR5cGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICBvdXRwdXRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB2YXIgbGFiZWwgPSBpID09PSAxID8gLUluZmluaXR5IDogYXJnc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnc1tpICsgMV07XG4gICAgICAgIHZhciBsYWJlbEtleSA9IGk7XG4gICAgICAgIHZhciB2YWx1ZUtleSA9IGkgKyAxO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGFiZWwgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJzdGVwXCIgZXhwcmVzc2lvbnMgbXVzdCBiZSBkZWZpbmVkIHVzaW5nIGxpdGVyYWwgbnVtZXJpYyB2YWx1ZXMgKG5vdCBjb21wdXRlZCBleHByZXNzaW9ucykgZm9yIHRoZSBpbnB1dCB2YWx1ZXMuJywgbGFiZWxLZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0b3BzLmxlbmd0aCAmJiBzdG9wc1tzdG9wcy5sZW5ndGggLSAxXVswXSA+PSBsYWJlbCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwic3RlcFwiIGV4cHJlc3Npb25zIG11c3QgYmUgYXJyYW5nZWQgd2l0aCBpbnB1dCB2YWx1ZXMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLicsIGxhYmVsS2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKHZhbHVlLCB2YWx1ZUtleSwgb3V0cHV0VHlwZSk7XG4gICAgICAgIGlmICghcGFyc2VkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcGFyc2VkLnR5cGU7XG4gICAgICAgIHN0b3BzLnB1c2goW2xhYmVsLCBwYXJzZWRdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBTdGVwKG91dHB1dFR5cGUsIGlucHV0LCBzdG9wcyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0ZXA7XG59KCk7XG4vKlxuICogQ29weXJpZ2h0IChDKSAyMDA4IEFwcGxlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogYXJlIG1ldDpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIEFQUExFIElOQy4gYGBBUyBJUycnIEFORCBBTllcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVJcbiAqIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBBUFBMRSBJTkMuIE9SXG4gKiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiAqIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAqIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICogUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWVxuICogT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gKiAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0VcbiAqIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKlxuICogUG9ydGVkIGZyb20gV2Via2l0XG4gKiBodHRwOi8vc3ZuLndlYmtpdC5vcmcvcmVwb3NpdG9yeS93ZWJraXQvdHJ1bmsvU291cmNlL1dlYkNvcmUvcGxhdGZvcm0vZ3JhcGhpY3MvVW5pdEJlemllci5oXG4gKi9cblxuXG52YXIgdW5pdGJlemllciA9IFVuaXRCZXppZXI7XG5cbmZ1bmN0aW9uIFVuaXRCZXppZXIocDF4LCBwMXksIHAyeCwgcDJ5KSB7XG4gIC8vIENhbGN1bGF0ZSB0aGUgcG9seW5vbWlhbCBjb2VmZmljaWVudHMsIGltcGxpY2l0IGZpcnN0IGFuZCBsYXN0IGNvbnRyb2wgcG9pbnRzIGFyZSAoMCwwKSBhbmQgKDEsMSkuXG4gIHRoaXMuY3ggPSAzLjAgKiBwMXg7XG4gIHRoaXMuYnggPSAzLjAgKiAocDJ4IC0gcDF4KSAtIHRoaXMuY3g7XG4gIHRoaXMuYXggPSAxLjAgLSB0aGlzLmN4IC0gdGhpcy5ieDtcbiAgdGhpcy5jeSA9IDMuMCAqIHAxeTtcbiAgdGhpcy5ieSA9IDMuMCAqIChwMnkgLSBwMXkpIC0gdGhpcy5jeTtcbiAgdGhpcy5heSA9IDEuMCAtIHRoaXMuY3kgLSB0aGlzLmJ5O1xuICB0aGlzLnAxeCA9IHAxeDtcbiAgdGhpcy5wMXkgPSBwMnk7XG4gIHRoaXMucDJ4ID0gcDJ4O1xuICB0aGlzLnAyeSA9IHAyeTtcbn1cblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVYID0gZnVuY3Rpb24gKHQpIHtcbiAgLy8gYGF4IHReMyArIGJ4IHReMiArIGN4IHQnIGV4cGFuZGVkIHVzaW5nIEhvcm5lcidzIHJ1bGUuXG4gIHJldHVybiAoKHRoaXMuYXggKiB0ICsgdGhpcy5ieCkgKiB0ICsgdGhpcy5jeCkgKiB0O1xufTtcblxuVW5pdEJlemllci5wcm90b3R5cGUuc2FtcGxlQ3VydmVZID0gZnVuY3Rpb24gKHQpIHtcbiAgcmV0dXJuICgodGhpcy5heSAqIHQgKyB0aGlzLmJ5KSAqIHQgKyB0aGlzLmN5KSAqIHQ7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYID0gZnVuY3Rpb24gKHQpIHtcbiAgcmV0dXJuICgzLjAgKiB0aGlzLmF4ICogdCArIDIuMCAqIHRoaXMuYngpICogdCArIHRoaXMuY3g7XG59O1xuXG5Vbml0QmV6aWVyLnByb3RvdHlwZS5zb2x2ZUN1cnZlWCA9IGZ1bmN0aW9uICh4LCBlcHNpbG9uKSB7XG4gIGlmICh0eXBlb2YgZXBzaWxvbiA9PT0gJ3VuZGVmaW5lZCcpIGVwc2lsb24gPSAxZS02O1xuICB2YXIgdDAsIHQxLCB0MiwgeDIsIGk7IC8vIEZpcnN0IHRyeSBhIGZldyBpdGVyYXRpb25zIG9mIE5ld3RvbidzIG1ldGhvZCAtLSBub3JtYWxseSB2ZXJ5IGZhc3QuXG5cbiAgZm9yICh0MiA9IHgsIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0MikgLSB4O1xuICAgIGlmIChNYXRoLmFicyh4MikgPCBlcHNpbG9uKSByZXR1cm4gdDI7XG4gICAgdmFyIGQyID0gdGhpcy5zYW1wbGVDdXJ2ZURlcml2YXRpdmVYKHQyKTtcbiAgICBpZiAoTWF0aC5hYnMoZDIpIDwgMWUtNikgYnJlYWs7XG4gICAgdDIgPSB0MiAtIHgyIC8gZDI7XG4gIH0gLy8gRmFsbCBiYWNrIHRvIHRoZSBiaXNlY3Rpb24gbWV0aG9kIGZvciByZWxpYWJpbGl0eS5cblxuXG4gIHQwID0gMC4wO1xuICB0MSA9IDEuMDtcbiAgdDIgPSB4O1xuICBpZiAodDIgPCB0MCkgcmV0dXJuIHQwO1xuICBpZiAodDIgPiB0MSkgcmV0dXJuIHQxO1xuXG4gIHdoaWxlICh0MCA8IHQxKSB7XG4gICAgeDIgPSB0aGlzLnNhbXBsZUN1cnZlWCh0Mik7XG4gICAgaWYgKE1hdGguYWJzKHgyIC0geCkgPCBlcHNpbG9uKSByZXR1cm4gdDI7XG5cbiAgICBpZiAoeCA+IHgyKSB7XG4gICAgICB0MCA9IHQyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0MSA9IHQyO1xuICAgIH1cblxuICAgIHQyID0gKHQxIC0gdDApICogMC41ICsgdDA7XG4gIH0gLy8gRmFpbHVyZS5cblxuXG4gIHJldHVybiB0Mjtcbn07XG5cblVuaXRCZXppZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24gKHgsIGVwc2lsb24pIHtcbiAgcmV0dXJuIHRoaXMuc2FtcGxlQ3VydmVZKHRoaXMuc29sdmVDdXJ2ZVgoeCwgZXBzaWxvbikpO1xufTtcblxuZnVuY3Rpb24gbnVtYmVyKGEsIGIsIHQpIHtcbiAgcmV0dXJuIGEgKiAoMSAtIHQpICsgYiAqIHQ7XG59XG5cbmZ1bmN0aW9uIGNvbG9yKGZyb20sIHRvLCB0KSB7XG4gIHJldHVybiBuZXcgQ29sb3IobnVtYmVyKGZyb20uciwgdG8uciwgdCksIG51bWJlcihmcm9tLmcsIHRvLmcsIHQpLCBudW1iZXIoZnJvbS5iLCB0by5iLCB0KSwgbnVtYmVyKGZyb20uYSwgdG8uYSwgdCkpO1xufVxuXG5mdW5jdGlvbiBhcnJheSQxKGZyb20sIHRvLCB0KSB7XG4gIHJldHVybiBmcm9tLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiBudW1iZXIoZCwgdG9baV0sIHQpO1xuICB9KTtcbn1cblxudmFyIGludGVycG9sYXRlID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIG51bWJlcjogbnVtYmVyLFxuICBjb2xvcjogY29sb3IsXG4gIGFycmF5OiBhcnJheSQxXG59KTtcbnZhciBYbiA9IDAuOTUwNDcsXG4gICAgWW4gPSAxLFxuICAgIFpuID0gMS4wODg4MyxcbiAgICB0MCA9IDQgLyAyOSxcbiAgICB0MSA9IDYgLyAyOSxcbiAgICB0MiA9IDMgKiB0MSAqIHQxLFxuICAgIHQzID0gdDEgKiB0MSAqIHQxLFxuICAgIGRlZzJyYWQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIHJhZDJkZWcgPSAxODAgLyBNYXRoLlBJO1xuXG5mdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG59XG5cbmZ1bmN0aW9uIHh5ejJyZ2IoeCkge1xuICByZXR1cm4gMjU1ICogKHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1KTtcbn1cblxuZnVuY3Rpb24gcmdiMnh5eih4KSB7XG4gIHggLz0gMjU1O1xuICByZXR1cm4geCA8PSAwLjA0MDQ1ID8geCAvIDEyLjkyIDogTWF0aC5wb3coKHggKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbn1cblxuZnVuY3Rpb24gcmdiVG9MYWIocmdiQ29sb3IpIHtcbiAgdmFyIGIgPSByZ2IyeHl6KHJnYkNvbG9yLnIpLFxuICAgICAgYSA9IHJnYjJ4eXoocmdiQ29sb3IuZyksXG4gICAgICBsID0gcmdiMnh5eihyZ2JDb2xvci5iKSxcbiAgICAgIHggPSB4eXoybGFiKCgwLjQxMjQ1NjQgKiBiICsgMC4zNTc1NzYxICogYSArIDAuMTgwNDM3NSAqIGwpIC8gWG4pLFxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjEyNjcyOSAqIGIgKyAwLjcxNTE1MjIgKiBhICsgMC4wNzIxNzUgKiBsKSAvIFluKSxcbiAgICAgIHogPSB4eXoybGFiKCgwLjAxOTMzMzkgKiBiICsgMC4xMTkxOTIgKiBhICsgMC45NTAzMDQxICogbCkgLyBabik7XG4gIHJldHVybiB7XG4gICAgbDogMTE2ICogeSAtIDE2LFxuICAgIGE6IDUwMCAqICh4IC0geSksXG4gICAgYjogMjAwICogKHkgLSB6KSxcbiAgICBhbHBoYTogcmdiQ29sb3IuYVxuICB9O1xufVxuXG5mdW5jdGlvbiBsYWJUb1JnYihsYWJDb2xvcikge1xuICB2YXIgeSA9IChsYWJDb2xvci5sICsgMTYpIC8gMTE2LFxuICAgICAgeCA9IGlzTmFOKGxhYkNvbG9yLmEpID8geSA6IHkgKyBsYWJDb2xvci5hIC8gNTAwLFxuICAgICAgeiA9IGlzTmFOKGxhYkNvbG9yLmIpID8geSA6IHkgLSBsYWJDb2xvci5iIC8gMjAwO1xuICB5ID0gWW4gKiBsYWIyeHl6KHkpO1xuICB4ID0gWG4gKiBsYWIyeHl6KHgpO1xuICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICByZXR1cm4gbmV3IENvbG9yKHh5ejJyZ2IoMy4yNDA0NTQyICogeCAtIDEuNTM3MTM4NSAqIHkgLSAwLjQ5ODUzMTQgKiB6KSwgeHl6MnJnYigtMC45NjkyNjYgKiB4ICsgMS44NzYwMTA4ICogeSArIDAuMDQxNTU2ICogeiksIHh5ejJyZ2IoMC4wNTU2NDM0ICogeCAtIDAuMjA0MDI1OSAqIHkgKyAxLjA1NzIyNTIgKiB6KSwgbGFiQ29sb3IuYWxwaGEpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUxhYihmcm9tLCB0bywgdCkge1xuICByZXR1cm4ge1xuICAgIGw6IG51bWJlcihmcm9tLmwsIHRvLmwsIHQpLFxuICAgIGE6IG51bWJlcihmcm9tLmEsIHRvLmEsIHQpLFxuICAgIGI6IG51bWJlcihmcm9tLmIsIHRvLmIsIHQpLFxuICAgIGFscGhhOiBudW1iZXIoZnJvbS5hbHBoYSwgdG8uYWxwaGEsIHQpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJnYlRvSGNsKHJnYkNvbG9yKSB7XG4gIHZhciBfcmdiVG9MYWIgPSByZ2JUb0xhYihyZ2JDb2xvciksXG4gICAgICBsID0gX3JnYlRvTGFiLmwsXG4gICAgICBhID0gX3JnYlRvTGFiLmEsXG4gICAgICBiID0gX3JnYlRvTGFiLmI7XG5cbiAgdmFyIGggPSBNYXRoLmF0YW4yKGIsIGEpICogcmFkMmRlZztcbiAgcmV0dXJuIHtcbiAgICBoOiBoIDwgMCA/IGggKyAzNjAgOiBoLFxuICAgIGM6IE1hdGguc3FydChhICogYSArIGIgKiBiKSxcbiAgICBsOiBsLFxuICAgIGFscGhhOiByZ2JDb2xvci5hXG4gIH07XG59XG5cbmZ1bmN0aW9uIGhjbFRvUmdiKGhjbENvbG9yKSB7XG4gIHZhciBoID0gaGNsQ29sb3IuaCAqIGRlZzJyYWQsXG4gICAgICBjID0gaGNsQ29sb3IuYyxcbiAgICAgIGwgPSBoY2xDb2xvci5sO1xuICByZXR1cm4gbGFiVG9SZ2Ioe1xuICAgIGw6IGwsXG4gICAgYTogTWF0aC5jb3MoaCkgKiBjLFxuICAgIGI6IE1hdGguc2luKGgpICogYyxcbiAgICBhbHBoYTogaGNsQ29sb3IuYWxwaGFcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlSHVlKGEsIGIsIHQpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGEgKyB0ICogKGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUhjbChmcm9tLCB0bywgdCkge1xuICByZXR1cm4ge1xuICAgIGg6IGludGVycG9sYXRlSHVlKGZyb20uaCwgdG8uaCwgdCksXG4gICAgYzogbnVtYmVyKGZyb20uYywgdG8uYywgdCksXG4gICAgbDogbnVtYmVyKGZyb20ubCwgdG8ubCwgdCksXG4gICAgYWxwaGE6IG51bWJlcihmcm9tLmFscGhhLCB0by5hbHBoYSwgdClcbiAgfTtcbn1cblxudmFyIGxhYiA9IHtcbiAgZm9yd2FyZDogcmdiVG9MYWIsXG4gIHJldmVyc2U6IGxhYlRvUmdiLFxuICBpbnRlcnBvbGF0ZTogaW50ZXJwb2xhdGVMYWJcbn07XG52YXIgaGNsID0ge1xuICBmb3J3YXJkOiByZ2JUb0hjbCxcbiAgcmV2ZXJzZTogaGNsVG9SZ2IsXG4gIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZUhjbFxufTtcbnZhciBjb2xvclNwYWNlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBsYWI6IGxhYixcbiAgaGNsOiBoY2xcbn0pO1xuXG52YXIgSW50ZXJwb2xhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnRlcnBvbGF0ZSh0eXBlLCBvcGVyYXRvciwgaW50ZXJwb2xhdGlvbiwgaW5wdXQsIHN0b3BzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludGVycG9sYXRlKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XG4gICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgdGhpcy5vdXRwdXRzID0gW107XG5cbiAgICB2YXIgX2l0ZXJhdG9yMjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzdG9wcyksXG4gICAgICAgIF9zdGVwMjU7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IyNS5zKCk7ICEoX3N0ZXAyNSA9IF9pdGVyYXRvcjI1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9zdGVwMjUkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcDI1LnZhbHVlLCAyKSxcbiAgICAgICAgICAgIGxhYmVsID0gX3N0ZXAyNSR2YWx1ZVswXSxcbiAgICAgICAgICAgIF9leHByZXNzaW9uNCA9IF9zdGVwMjUkdmFsdWVbMV07XG5cbiAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKF9leHByZXNzaW9uNCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IyNS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjI1LmYoKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSW50ZXJwb2xhdGUsIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgdmFyIGxhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgICAgdmFyIG91dHB1dHMgPSB0aGlzLm91dHB1dHM7XG5cbiAgICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRzWzBdLmV2YWx1YXRlKGN0eCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaW5wdXQuZXZhbHVhdGUoY3R4KTtcblxuICAgICAgaWYgKHZhbHVlIDw9IGxhYmVsc1swXSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0c1swXS5ldmFsdWF0ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RvcENvdW50ID0gbGFiZWxzLmxlbmd0aDtcblxuICAgICAgaWYgKHZhbHVlID49IGxhYmVsc1tzdG9wQ291bnQgLSAxXSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0c1tzdG9wQ291bnQgLSAxXS5ldmFsdWF0ZShjdHgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKGxhYmVscywgdmFsdWUpO1xuICAgICAgdmFyIGxvd2VyID0gbGFiZWxzW2luZGV4XTtcbiAgICAgIHZhciB1cHBlciA9IGxhYmVsc1tpbmRleCArIDFdO1xuICAgICAgdmFyIHQgPSBJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0aW9uRmFjdG9yKHRoaXMuaW50ZXJwb2xhdGlvbiwgdmFsdWUsIGxvd2VyLCB1cHBlcik7XG4gICAgICB2YXIgb3V0cHV0TG93ZXIgPSBvdXRwdXRzW2luZGV4XS5ldmFsdWF0ZShjdHgpO1xuICAgICAgdmFyIG91dHB1dFVwcGVyID0gb3V0cHV0c1tpbmRleCArIDFdLmV2YWx1YXRlKGN0eCk7XG5cbiAgICAgIGlmICh0aGlzLm9wZXJhdG9yID09PSAnaW50ZXJwb2xhdGUnKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVt0aGlzLnR5cGUua2luZC50b0xvd2VyQ2FzZSgpXShvdXRwdXRMb3dlciwgb3V0cHV0VXBwZXIsIHQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wZXJhdG9yID09PSAnaW50ZXJwb2xhdGUtaGNsJykge1xuICAgICAgICByZXR1cm4gaGNsLnJldmVyc2UoaGNsLmludGVycG9sYXRlKGhjbC5mb3J3YXJkKG91dHB1dExvd2VyKSwgaGNsLmZvcndhcmQob3V0cHV0VXBwZXIpLCB0KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGFiLnJldmVyc2UobGFiLmludGVycG9sYXRlKGxhYi5mb3J3YXJkKG91dHB1dExvd2VyKSwgbGFiLmZvcndhcmQob3V0cHV0VXBwZXIpLCB0KSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIGZuKHRoaXMuaW5wdXQpO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLm91dHB1dHMpLFxuICAgICAgICAgIF9zdGVwMjY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMjYucygpOyAhKF9zdGVwMjYgPSBfaXRlcmF0b3IyNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9leHByZXNzaW9uNSA9IF9zdGVwMjYudmFsdWU7XG4gICAgICAgICAgZm4oX2V4cHJlc3Npb241KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjI2LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjI2LmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3V0cHV0cy5ldmVyeShmdW5jdGlvbiAob3V0KSB7XG4gICAgICAgIHJldHVybiBvdXQub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgaW50ZXJwb2xhdGlvbjtcblxuICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnbGluZWFyJykge1xuICAgICAgICBpbnRlcnBvbGF0aW9uID0gWydsaW5lYXInXTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbnRlcnBvbGF0aW9uLm5hbWUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJwb2xhdGlvbi5iYXNlID09PSAxKSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IFsnbGluZWFyJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IFsnZXhwb25lbnRpYWwnLCB0aGlzLmludGVycG9sYXRpb24uYmFzZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRpb24gPSBbJ2N1YmljLWJlemllciddLmNvbmNhdCh0aGlzLmludGVycG9sYXRpb24uY29udHJvbFBvaW50cyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXJpYWxpemVkID0gW3RoaXMub3BlcmF0b3IsIGludGVycG9sYXRpb24sIHRoaXMuaW5wdXQuc2VyaWFsaXplKCldO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLmxhYmVsc1tpXSwgdGhpcy5vdXRwdXRzW2ldLnNlcmlhbGl6ZSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiaW50ZXJwb2xhdGlvbkZhY3RvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnRlcnBvbGF0aW9uRmFjdG9yKGludGVycG9sYXRpb24sIGlucHV0LCBsb3dlciwgdXBwZXIpIHtcbiAgICAgIHZhciB0ID0gMDtcblxuICAgICAgaWYgKGludGVycG9sYXRpb24ubmFtZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICB0ID0gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCBpbnRlcnBvbGF0aW9uLmJhc2UsIGxvd2VyLCB1cHBlcik7XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb24ubmFtZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgdCA9IGV4cG9uZW50aWFsSW50ZXJwb2xhdGlvbihpbnB1dCwgMSwgbG93ZXIsIHVwcGVyKTtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvbi5uYW1lID09PSAnY3ViaWMtYmV6aWVyJykge1xuICAgICAgICB2YXIgYyA9IGludGVycG9sYXRpb24uY29udHJvbFBvaW50cztcbiAgICAgICAgdmFyIHViID0gbmV3IHVuaXRiZXppZXIoY1swXSwgY1sxXSwgY1syXSwgY1szXSk7XG4gICAgICAgIHQgPSB1Yi5zb2x2ZShleHBvbmVudGlhbEludGVycG9sYXRpb24oaW5wdXQsIDEsIGxvd2VyLCB1cHBlcikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgdmFyIF9hcmdzID0gX3RvQXJyYXkoYXJncyksXG4gICAgICAgICAgb3BlcmF0b3IgPSBfYXJnc1swXSxcbiAgICAgICAgICBpbnRlcnBvbGF0aW9uID0gX2FyZ3NbMV0sXG4gICAgICAgICAgaW5wdXQgPSBfYXJnc1syXSxcbiAgICAgICAgICByZXN0ID0gX2FyZ3Muc2xpY2UoMyk7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnRlcnBvbGF0aW9uKSB8fCBpbnRlcnBvbGF0aW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGFuIGludGVycG9sYXRpb24gdHlwZSBleHByZXNzaW9uLlwiLCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdsaW5lYXInKSB7XG4gICAgICAgIGludGVycG9sYXRpb24gPSB7XG4gICAgICAgICAgbmFtZTogJ2xpbmVhcidcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGlvblswXSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgICAgICB2YXIgYmFzZSA9IGludGVycG9sYXRpb25bMV07XG4gICAgICAgIGlmICh0eXBlb2YgYmFzZSAhPT0gJ251bWJlcicpIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwb25lbnRpYWwgaW50ZXJwb2xhdGlvbiByZXF1aXJlcyBhIG51bWVyaWMgYmFzZS5cIiwgMSwgMSk7XG4gICAgICAgIGludGVycG9sYXRpb24gPSB7XG4gICAgICAgICAgbmFtZTogJ2V4cG9uZW50aWFsJyxcbiAgICAgICAgICBiYXNlOiBiYXNlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRpb25bMF0gPT09ICdjdWJpYy1iZXppZXInKSB7XG4gICAgICAgIHZhciBjb250cm9sUG9pbnRzID0gaW50ZXJwb2xhdGlvbi5zbGljZSgxKTtcblxuICAgICAgICBpZiAoY29udHJvbFBvaW50cy5sZW5ndGggIT09IDQgfHwgY29udHJvbFBvaW50cy5zb21lKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB0ICE9PSAnbnVtYmVyJyB8fCB0IDwgMCB8fCB0ID4gMTtcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcignQ3ViaWMgYmV6aWVyIGludGVycG9sYXRpb24gcmVxdWlyZXMgZm91ciBudW1lcmljIGFyZ3VtZW50cyB3aXRoIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuJywgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnRlcnBvbGF0aW9uID0ge1xuICAgICAgICAgIG5hbWU6ICdjdWJpYy1iZXppZXInLFxuICAgICAgICAgIGNvbnRyb2xQb2ludHM6IGNvbnRyb2xQb2ludHNcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiVW5rbm93biBpbnRlcnBvbGF0aW9uIHR5cGUgXCIuY29uY2F0KFN0cmluZyhpbnRlcnBvbGF0aW9uWzBdKSksIDEsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5sZW5ndGggLSAxIDwgNCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSBcIi5jb25jYXQoYXJncy5sZW5ndGggLSAxLCBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGFyZ3MubGVuZ3RoIC0gMSkgJSAyICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzLlwiKTtcbiAgICAgIH1cblxuICAgICAgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGlucHV0LCAyLCBOdW1iZXJUeXBlKTtcbiAgICAgIGlmICghaW5wdXQpIHJldHVybiBudWxsO1xuICAgICAgdmFyIHN0b3BzID0gW107XG4gICAgICB2YXIgb3V0cHV0VHlwZSA9IG51bGw7XG5cbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJ2ludGVycG9sYXRlLWhjbCcgfHwgb3BlcmF0b3IgPT09ICdpbnRlcnBvbGF0ZS1sYWInKSB7XG4gICAgICAgIG91dHB1dFR5cGUgPSBDb2xvclR5cGU7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRleHQuZXhwZWN0ZWRUeXBlICYmIGNvbnRleHQuZXhwZWN0ZWRUeXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgb3V0cHV0VHlwZSA9IGNvbnRleHQuZXhwZWN0ZWRUeXBlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3QubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gcmVzdFtpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdFtpICsgMV07XG4gICAgICAgIHZhciBsYWJlbEtleSA9IGkgKyAzO1xuICAgICAgICB2YXIgdmFsdWVLZXkgPSBpICsgNDtcblxuICAgICAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdJbnB1dC9vdXRwdXQgcGFpcnMgZm9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9ucyBtdXN0IGJlIGRlZmluZWQgdXNpbmcgbGl0ZXJhbCBudW1lcmljIHZhbHVlcyAobm90IGNvbXB1dGVkIGV4cHJlc3Npb25zKSBmb3IgdGhlIGlucHV0IHZhbHVlcy4nLCBsYWJlbEtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RvcHMubGVuZ3RoICYmIHN0b3BzW3N0b3BzLmxlbmd0aCAtIDFdWzBdID49IGxhYmVsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoJ0lucHV0L291dHB1dCBwYWlycyBmb3IgXCJpbnRlcnBvbGF0ZVwiIGV4cHJlc3Npb25zIG11c3QgYmUgYXJyYW5nZWQgd2l0aCBpbnB1dCB2YWx1ZXMgaW4gc3RyaWN0bHkgYXNjZW5kaW5nIG9yZGVyLicsIGxhYmVsS2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKHZhbHVlLCB2YWx1ZUtleSwgb3V0cHV0VHlwZSk7XG4gICAgICAgIGlmICghcGFyc2VkKSByZXR1cm4gbnVsbDtcbiAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcGFyc2VkLnR5cGU7XG4gICAgICAgIHN0b3BzLnB1c2goW2xhYmVsLCBwYXJzZWRdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG91dHB1dFR5cGUua2luZCAhPT0gJ251bWJlcicgJiYgb3V0cHV0VHlwZS5raW5kICE9PSAnY29sb3InICYmICEob3V0cHV0VHlwZS5raW5kID09PSAnYXJyYXknICYmIG91dHB1dFR5cGUuaXRlbVR5cGUua2luZCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG91dHB1dFR5cGUuTiA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiVHlwZSBcIi5jb25jYXQodG9TdHJpbmcob3V0cHV0VHlwZSksIFwiIGlzIG5vdCBpbnRlcnBvbGF0YWJsZS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEludGVycG9sYXRlKG91dHB1dFR5cGUsIG9wZXJhdG9yLCBpbnRlcnBvbGF0aW9uLCBpbnB1dCwgc3RvcHMpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbnRlcnBvbGF0ZTtcbn0oKTtcblxuZnVuY3Rpb24gZXhwb25lbnRpYWxJbnRlcnBvbGF0aW9uKGlucHV0LCBiYXNlLCBsb3dlclZhbHVlLCB1cHBlclZhbHVlKSB7XG4gIHZhciBkaWZmZXJlbmNlID0gdXBwZXJWYWx1ZSAtIGxvd2VyVmFsdWU7XG4gIHZhciBwcm9ncmVzcyA9IGlucHV0IC0gbG93ZXJWYWx1ZTtcblxuICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGJhc2UgPT09IDEpIHtcbiAgICByZXR1cm4gcHJvZ3Jlc3MgLyBkaWZmZXJlbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoTWF0aC5wb3coYmFzZSwgcHJvZ3Jlc3MpIC0gMSkgLyAoTWF0aC5wb3coYmFzZSwgZGlmZmVyZW5jZSkgLSAxKTtcbiAgfVxufVxuXG52YXIgQ29hbGVzY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb2FsZXNjZSh0eXBlLCBhcmdzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvYWxlc2NlKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDb2FsZXNjZSwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgIHZhciBhcmdDb3VudCA9IDA7XG4gICAgICB2YXIgcmVxdWVzdGVkSW1hZ2VOYW1lO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmFyZ3MpLFxuICAgICAgICAgIF9zdGVwMjc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMjcucygpOyAhKF9zdGVwMjcgPSBfaXRlcmF0b3IyNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGFyZyA9IF9zdGVwMjcudmFsdWU7XG4gICAgICAgICAgYXJnQ291bnQrKztcbiAgICAgICAgICByZXN1bHQgPSBhcmcuZXZhbHVhdGUoY3R4KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzb2x2ZWRJbWFnZSAmJiAhcmVzdWx0LmF2YWlsYWJsZSkge1xuICAgICAgICAgICAgaWYgKCFyZXF1ZXN0ZWRJbWFnZU5hbWUpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdGVkSW1hZ2VOYW1lID0gcmVzdWx0Lm5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChhcmdDb3VudCA9PT0gdGhpcy5hcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXF1ZXN0ZWRJbWFnZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyNy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyNy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIHRoaXMuYXJncy5mb3JFYWNoKGZuKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXJncy5ldmVyeShmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBhcmcub3V0cHV0RGVmaW5lZCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgc2VyaWFsaXplZCA9IFsnY29hbGVzY2UnXTtcbiAgICAgIHRoaXMuZWFjaENoaWxkKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKCdFeHBlY3RlY3RlZCBhdCBsZWFzdCBvbmUgYXJndW1lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXRwdXRUeXBlID0gbnVsbDtcbiAgICAgIHZhciBleHBlY3RlZFR5cGUgPSBjb250ZXh0LmV4cGVjdGVkVHlwZTtcblxuICAgICAgaWYgKGV4cGVjdGVkVHlwZSAmJiBleHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICBvdXRwdXRUeXBlID0gZXhwZWN0ZWRUeXBlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFyc2VkQXJncyA9IFtdO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMjggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhcmdzLnNsaWNlKDEpKSxcbiAgICAgICAgICBfc3RlcDI4O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjI4LnMoKTsgIShfc3RlcDI4ID0gX2l0ZXJhdG9yMjgubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBhcmcgPSBfc3RlcDI4LnZhbHVlO1xuICAgICAgICAgIHZhciBwYXJzZWQgPSBjb250ZXh0LnBhcnNlKGFyZywgMSArIHBhcnNlZEFyZ3MubGVuZ3RoLCBvdXRwdXRUeXBlLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIHR5cGVBbm5vdGF0aW9uOiAnb21pdCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXBhcnNlZCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgb3V0cHV0VHlwZSA9IG91dHB1dFR5cGUgfHwgcGFyc2VkLnR5cGU7XG4gICAgICAgICAgcGFyc2VkQXJncy5wdXNoKHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyOC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyOC5mKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWVkc0Fubm90YXRpb24gPSBleHBlY3RlZFR5cGUgJiYgcGFyc2VkQXJncy5zb21lKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIF9jaGVja1N1YnR5cGUoZXhwZWN0ZWRUeXBlLCBhcmcudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZWVkc0Fubm90YXRpb24gPyBuZXcgQ29hbGVzY2UoVmFsdWVUeXBlLCBwYXJzZWRBcmdzKSA6IG5ldyBDb2FsZXNjZShvdXRwdXRUeXBlLCBwYXJzZWRBcmdzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29hbGVzY2U7XG59KCk7XG5cbnZhciBMZXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMZXQoYmluZGluZ3MsIHJlc3VsdCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMZXQpO1xuXG4gICAgdGhpcy50eXBlID0gcmVzdWx0LnR5cGU7XG4gICAgdGhpcy5iaW5kaW5ncyA9IFtdLmNvbmNhdChiaW5kaW5ncyk7XG4gICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGV0LCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5ldmFsdWF0ZShjdHgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMjkgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmJpbmRpbmdzKSxcbiAgICAgICAgICBfc3RlcDI5O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjI5LnMoKTsgIShfc3RlcDI5ID0gX2l0ZXJhdG9yMjkubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBiaW5kaW5nID0gX3N0ZXAyOS52YWx1ZTtcbiAgICAgICAgICBmbihiaW5kaW5nWzFdKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjI5LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjI5LmYoKTtcbiAgICAgIH1cblxuICAgICAgZm4odGhpcy5yZXN1bHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXN1bHQub3V0cHV0RGVmaW5lZCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ2xldCddO1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMzAgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmJpbmRpbmdzKSxcbiAgICAgICAgICBfc3RlcDMwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjMwLnMoKTsgIShfc3RlcDMwID0gX2l0ZXJhdG9yMzAubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDMwJHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzMC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RlcDMwJHZhbHVlWzBdLFxuICAgICAgICAgICAgICBleHByID0gX3N0ZXAzMCR2YWx1ZVsxXTtcblxuICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChuYW1lLCBleHByLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMwLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMwLmYoKTtcbiAgICAgIH1cblxuICAgICAgc2VyaWFsaXplZC5wdXNoKHRoaXMucmVzdWx0LnNlcmlhbGl6ZSgpKTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDQpIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3QgMyBhcmd1bWVudHMsIGJ1dCBmb3VuZCBcIi5jb25jYXQoYXJncy5sZW5ndGggLSAxLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB2YXIgYmluZGluZ3MgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICB2YXIgbmFtZSA9IGFyZ3NbaV07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgc3RyaW5nLCBidXQgZm91bmQgXCIuY29uY2F0KHR5cGVvZiBuYW1lLCBcIiBpbnN0ZWFkLlwiKSwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL1teYS16QS1aMC05X10vLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIlZhcmlhYmxlIG5hbWVzIG11c3QgY29udGFpbiBvbmx5IGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzIG9yICdfJy5cIiwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaSArIDFdLCBpICsgMSk7XG4gICAgICAgIGlmICghdmFsdWUpIHJldHVybiBudWxsO1xuICAgICAgICBiaW5kaW5ncy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gY29udGV4dC5wYXJzZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIGFyZ3MubGVuZ3RoIC0gMSwgY29udGV4dC5leHBlY3RlZFR5cGUsIGJpbmRpbmdzKTtcbiAgICAgIGlmICghcmVzdWx0KSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBuZXcgTGV0KGJpbmRpbmdzLCByZXN1bHQpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMZXQ7XG59KCk7XG5cbnZhciBBdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF0KHR5cGUsIGluZGV4LCBpbnB1dCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdCk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQXQsIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleC5ldmFsdWF0ZShjdHgpO1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiBcIi5jb25jYXQoaW5kZXgsIFwiIDwgMC5cIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPj0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJBcnJheSBpbmRleCBvdXQgb2YgYm91bmRzOiBcIi5jb25jYXQoaW5kZXgsIFwiID4gXCIpLmNvbmNhdChhcnJheS5sZW5ndGggLSAxLCBcIi5cIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggIT09IE1hdGguZmxvb3IoaW5kZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJBcnJheSBpbmRleCBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBmb3VuZCBcIi5jb25jYXQoaW5kZXgsIFwiIGluc3RlYWQuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5W2luZGV4XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgICAgZm4odGhpcy5pbmRleCk7XG4gICAgICBmbih0aGlzLmlucHV0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3V0cHV0RGVmaW5lZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvdXRwdXREZWZpbmVkKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIFsnYXQnLCB0aGlzLmluZGV4LnNlcmlhbGl6ZSgpLCB0aGlzLmlucHV0LnNlcmlhbGl6ZSgpXTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggIT09IDMpIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgMiBhcmd1bWVudHMsIGJ1dCBmb3VuZCBcIi5jb25jYXQoYXJncy5sZW5ndGggLSAxLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB2YXIgaW5kZXggPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIE51bWJlclR5cGUpO1xuICAgICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBhcnJheShjb250ZXh0LmV4cGVjdGVkVHlwZSB8fCBWYWx1ZVR5cGUpKTtcbiAgICAgIGlmICghaW5kZXggfHwgIWlucHV0KSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciB0ID0gaW5wdXQudHlwZTtcbiAgICAgIHJldHVybiBuZXcgQXQodC5pdGVtVHlwZSwgaW5kZXgsIGlucHV0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQXQ7XG59KCk7XG5cbnZhciBJbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEluKG5lZWRsZSwgaGF5c3RhY2spIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW4pO1xuXG4gICAgdGhpcy50eXBlID0gQm9vbGVhblR5cGU7XG4gICAgdGhpcy5uZWVkbGUgPSBuZWVkbGU7XG4gICAgdGhpcy5oYXlzdGFjayA9IGhheXN0YWNrO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEluLCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHZhciBuZWVkbGUgPSB0aGlzLm5lZWRsZS5ldmFsdWF0ZShjdHgpO1xuICAgICAgdmFyIGhheXN0YWNrID0gdGhpcy5oYXlzdGFjay5ldmFsdWF0ZShjdHgpO1xuICAgICAgaWYgKCFoYXlzdGFjaykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKG5lZWRsZSwgWydib29sZWFuJywgJ3N0cmluZycsICdudW1iZXInLCAnbnVsbCddKSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBib29sZWFuLCBzdHJpbmcsIG51bWJlciBvciBudWxsLCBidXQgZm91bmQgXCIuY29uY2F0KHRvU3RyaW5nKHR5cGVPZihuZWVkbGUpKSwgXCIgaW5zdGVhZC5cIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKGhheXN0YWNrLCBbJ3N0cmluZycsICdhcnJheSddKSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiRXhwZWN0ZWQgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYXJyYXkgb3Igc3RyaW5nLCBidXQgZm91bmQgXCIuY29uY2F0KHRvU3RyaW5nKHR5cGVPZihoYXlzdGFjaykpLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSkgPj0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgICAgZm4odGhpcy5uZWVkbGUpO1xuICAgICAgZm4odGhpcy5oYXlzdGFjayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm91dHB1dERlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgcmV0dXJuIFsnaW4nLCB0aGlzLm5lZWRsZS5zZXJpYWxpemUoKSwgdGhpcy5oYXlzdGFjay5zZXJpYWxpemUoKV07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgMiBhcmd1bWVudHMsIGJ1dCBmb3VuZCBcIi5jb25jYXQoYXJncy5sZW5ndGggLSAxLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWVkbGUgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgICB2YXIgaGF5c3RhY2sgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7XG4gICAgICBpZiAoIW5lZWRsZSB8fCAhaGF5c3RhY2spIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAoIWlzVmFsaWRUeXBlKG5lZWRsZS50eXBlLCBbQm9vbGVhblR5cGUsIFN0cmluZ1R5cGUsIE51bWJlclR5cGUsIE51bGxUeXBlLCBWYWx1ZVR5cGVdKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kIFwiLmNvbmNhdCh0b1N0cmluZyhuZWVkbGUudHlwZSksIFwiIGluc3RlYWRcIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEluKG5lZWRsZSwgaGF5c3RhY2spO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbjtcbn0oKTtcblxudmFyIEluZGV4T2YgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2ssIGZyb21JbmRleCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmRleE9mKTtcblxuICAgIHRoaXMudHlwZSA9IE51bWJlclR5cGU7XG4gICAgdGhpcy5uZWVkbGUgPSBuZWVkbGU7XG4gICAgdGhpcy5oYXlzdGFjayA9IGhheXN0YWNrO1xuICAgIHRoaXMuZnJvbUluZGV4ID0gZnJvbUluZGV4O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEluZGV4T2YsIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgdmFyIG5lZWRsZSA9IHRoaXMubmVlZGxlLmV2YWx1YXRlKGN0eCk7XG4gICAgICB2YXIgaGF5c3RhY2sgPSB0aGlzLmhheXN0YWNrLmV2YWx1YXRlKGN0eCk7XG5cbiAgICAgIGlmICghaXNWYWxpZE5hdGl2ZVR5cGUobmVlZGxlLCBbJ2Jvb2xlYW4nLCAnc3RyaW5nJywgJ251bWJlcicsICdudWxsJ10pKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIGJvb2xlYW4sIHN0cmluZywgbnVtYmVyIG9yIG51bGwsIGJ1dCBmb3VuZCBcIi5jb25jYXQodG9TdHJpbmcodHlwZU9mKG5lZWRsZSkpLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNWYWxpZE5hdGl2ZVR5cGUoaGF5c3RhY2ssIFsnc3RyaW5nJywgJ2FycmF5J10pKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJFeHBlY3RlZCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCBcIi5jb25jYXQodG9TdHJpbmcodHlwZU9mKGhheXN0YWNrKSksIFwiIGluc3RlYWQuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSB0aGlzLmZyb21JbmRleC5ldmFsdWF0ZShjdHgpO1xuICAgICAgICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUsIGZyb21JbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBoYXlzdGFjay5pbmRleE9mKG5lZWRsZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIGZuKHRoaXMubmVlZGxlKTtcbiAgICAgIGZuKHRoaXMuaGF5c3RhY2spO1xuXG4gICAgICBpZiAodGhpcy5mcm9tSW5kZXgpIHtcbiAgICAgICAgZm4odGhpcy5mcm9tSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICBpZiAodGhpcy5mcm9tSW5kZXggIT0gbnVsbCAmJiB0aGlzLmZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmcm9tSW5kZXggPSB0aGlzLmZyb21JbmRleC5zZXJpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIFsnaW5kZXgtb2YnLCB0aGlzLm5lZWRsZS5zZXJpYWxpemUoKSwgdGhpcy5oYXlzdGFjay5zZXJpYWxpemUoKSwgZnJvbUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFsnaW5kZXgtb2YnLCB0aGlzLm5lZWRsZS5zZXJpYWxpemUoKSwgdGhpcy5oYXlzdGFjay5zZXJpYWxpemUoKV07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoIDw9IDIgfHwgYXJncy5sZW5ndGggPj0gNSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIDMgb3IgNCBhcmd1bWVudHMsIGJ1dCBmb3VuZCBcIi5jb25jYXQoYXJncy5sZW5ndGggLSAxLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWVkbGUgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEsIFZhbHVlVHlwZSk7XG4gICAgICB2YXIgaGF5c3RhY2sgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIFZhbHVlVHlwZSk7XG4gICAgICBpZiAoIW5lZWRsZSB8fCAhaGF5c3RhY2spIHJldHVybiBudWxsO1xuXG4gICAgICBpZiAoIWlzVmFsaWRUeXBlKG5lZWRsZS50eXBlLCBbQm9vbGVhblR5cGUsIFN0cmluZ1R5cGUsIE51bWJlclR5cGUsIE51bGxUeXBlLCBWYWx1ZVR5cGVdKSkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGZpcnN0IGFyZ3VtZW50IHRvIGJlIG9mIHR5cGUgYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIgb3IgbnVsbCwgYnV0IGZvdW5kIFwiLmNvbmNhdCh0b1N0cmluZyhuZWVkbGUudHlwZSksIFwiIGluc3RlYWRcIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdmFyIGZyb21JbmRleCA9IGNvbnRleHQucGFyc2UoYXJnc1szXSwgMywgTnVtYmVyVHlwZSk7XG4gICAgICAgIGlmICghZnJvbUluZGV4KSByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBJbmRleE9mKG5lZWRsZSwgaGF5c3RhY2ssIGZyb21JbmRleCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEluZGV4T2YobmVlZGxlLCBoYXlzdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEluZGV4T2Y7XG59KCk7XG5cbnZhciBNYXRjaCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hdGNoKGlucHV0VHlwZSwgb3V0cHV0VHlwZSwgaW5wdXQsIGNhc2VzLCBvdXRwdXRzLCBvdGhlcndpc2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWF0Y2gpO1xuXG4gICAgdGhpcy5pbnB1dFR5cGUgPSBpbnB1dFR5cGU7XG4gICAgdGhpcy50eXBlID0gb3V0cHV0VHlwZTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5jYXNlcyA9IGNhc2VzO1xuICAgIHRoaXMub3V0cHV0cyA9IG91dHB1dHM7XG4gICAgdGhpcy5vdGhlcndpc2UgPSBvdGhlcndpc2U7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTWF0Y2gsIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuICAgICAgdmFyIG91dHB1dCA9IHR5cGVPZihpbnB1dCkgPT09IHRoaXMuaW5wdXRUeXBlICYmIHRoaXMub3V0cHV0c1t0aGlzLmNhc2VzW2lucHV0XV0gfHwgdGhpcy5vdGhlcndpc2U7XG4gICAgICByZXR1cm4gb3V0cHV0LmV2YWx1YXRlKGN0eCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIGZuKHRoaXMuaW5wdXQpO1xuICAgICAgdGhpcy5vdXRwdXRzLmZvckVhY2goZm4pO1xuICAgICAgZm4odGhpcy5vdGhlcndpc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vdXRwdXRzLmV2ZXJ5KGZ1bmN0aW9uIChvdXQpIHtcbiAgICAgICAgcmV0dXJuIG91dC5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbJ21hdGNoJywgdGhpcy5pbnB1dC5zZXJpYWxpemUoKV07XG4gICAgICB2YXIgc29ydGVkTGFiZWxzID0gT2JqZWN0LmtleXModGhpcy5jYXNlcykuc29ydCgpO1xuICAgICAgdmFyIGdyb3VwZWRCeU91dHB1dCA9IFtdO1xuICAgICAgdmFyIG91dHB1dExvb2t1cCA9IHt9O1xuXG4gICAgICB2YXIgX2l0ZXJhdG9yMzEgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihzb3J0ZWRMYWJlbHMpLFxuICAgICAgICAgIF9zdGVwMzE7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMzEucygpOyAhKF9zdGVwMzEgPSBfaXRlcmF0b3IzMS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGxhYmVsID0gX3N0ZXAzMS52YWx1ZTtcbiAgICAgICAgICB2YXIgX291dHB1dEluZGV4ID0gb3V0cHV0TG9va3VwW3RoaXMuY2FzZXNbbGFiZWxdXTtcblxuICAgICAgICAgIGlmIChfb3V0cHV0SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3V0cHV0TG9va3VwW3RoaXMuY2FzZXNbbGFiZWxdXSA9IGdyb3VwZWRCeU91dHB1dC5sZW5ndGg7XG4gICAgICAgICAgICBncm91cGVkQnlPdXRwdXQucHVzaChbdGhpcy5jYXNlc1tsYWJlbF0sIFtsYWJlbF1dKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXBlZEJ5T3V0cHV0W19vdXRwdXRJbmRleF1bMV0ucHVzaChsYWJlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMzEuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMzEuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29lcmNlTGFiZWwgPSBmdW5jdGlvbiBjb2VyY2VMYWJlbChsYWJlbCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmlucHV0VHlwZS5raW5kID09PSAnbnVtYmVyJyA/IE51bWJlcihsYWJlbCkgOiBsYWJlbDtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIF9pNiA9IDAsIF9ncm91cGVkQnlPdXRwdXQgPSBncm91cGVkQnlPdXRwdXQ7IF9pNiA8IF9ncm91cGVkQnlPdXRwdXQubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICB2YXIgX2dyb3VwZWRCeU91dHB1dCRfaSA9IF9zbGljZWRUb0FycmF5KF9ncm91cGVkQnlPdXRwdXRbX2k2XSwgMiksXG4gICAgICAgICAgICBvdXRwdXRJbmRleCA9IF9ncm91cGVkQnlPdXRwdXQkX2lbMF0sXG4gICAgICAgICAgICBsYWJlbHMgPSBfZ3JvdXBlZEJ5T3V0cHV0JF9pWzFdO1xuXG4gICAgICAgIGlmIChsYWJlbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNvZXJjZUxhYmVsKGxhYmVsc1swXSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlcmlhbGl6ZWQucHVzaChsYWJlbHMubWFwKGNvZXJjZUxhYmVsKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJpYWxpemVkLnB1c2godGhpcy5vdXRwdXRzW291dHB1dEluZGV4XS5zZXJpYWxpemUoKSk7XG4gICAgICB9XG5cbiAgICAgIHNlcmlhbGl6ZWQucHVzaCh0aGlzLm90aGVyd2lzZS5zZXJpYWxpemUoKSk7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCA1KSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGF0IGxlYXN0IDQgYXJndW1lbnRzLCBidXQgZm91bmQgb25seSBcIi5jb25jYXQoYXJncy5sZW5ndGggLSAxLCBcIi5cIikpO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICUgMiAhPT0gMSkgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCBhbiBldmVuIG51bWJlciBvZiBhcmd1bWVudHMuXCIpO1xuICAgICAgdmFyIGlucHV0VHlwZTtcbiAgICAgIHZhciBvdXRwdXRUeXBlO1xuXG4gICAgICBpZiAoY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICBvdXRwdXRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYXNlcyA9IHt9O1xuICAgICAgdmFyIG91dHB1dHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmdzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgICAgICB2YXIgbGFiZWxzID0gYXJnc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnc1tpICsgMV07XG5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxhYmVscykpIHtcbiAgICAgICAgICBsYWJlbHMgPSBbbGFiZWxzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYWJlbENvbnRleHQgPSBjb250ZXh0LmNvbmNhdChpKTtcblxuICAgICAgICBpZiAobGFiZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSBicmFuY2ggbGFiZWwuJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2l0ZXJhdG9yMzIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihsYWJlbHMpLFxuICAgICAgICAgICAgX3N0ZXAzMjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMzIucygpOyAhKF9zdGVwMzIgPSBfaXRlcmF0b3IzMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBfc3RlcDMyLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGFiZWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoXCJCcmFuY2ggbGFiZWxzIG11c3QgYmUgbnVtYmVycyBvciBzdHJpbmdzLlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxhYmVsID09PSAnbnVtYmVyJyAmJiBNYXRoLmFicyhsYWJlbCkgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgICByZXR1cm4gbGFiZWxDb250ZXh0LmVycm9yKFwiQnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXJzIG5vIGxhcmdlciB0aGFuIFwiLmNvbmNhdChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgXCIuXCIpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxhYmVsID09PSAnbnVtYmVyJyAmJiBNYXRoLmZsb29yKGxhYmVsKSAhPT0gbGFiZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsQ29udGV4dC5lcnJvcihcIk51bWVyaWMgYnJhbmNoIGxhYmVscyBtdXN0IGJlIGludGVnZXIgdmFsdWVzLlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlucHV0VHlwZSkge1xuICAgICAgICAgICAgICBpbnB1dFR5cGUgPSB0eXBlT2YobGFiZWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYWJlbENvbnRleHQuY2hlY2tTdWJ0eXBlKGlucHV0VHlwZSwgdHlwZU9mKGxhYmVsKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FzZXNbU3RyaW5nKGxhYmVsKV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsYWJlbENvbnRleHQuZXJyb3IoJ0JyYW5jaCBsYWJlbHMgbXVzdCBiZSB1bmlxdWUuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2VzW1N0cmluZyhsYWJlbCldID0gb3V0cHV0cy5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IzMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMzIuZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNvbnRleHQucGFyc2UodmFsdWUsIGksIG91dHB1dFR5cGUpO1xuICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIG51bGw7XG4gICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHJlc3VsdC50eXBlO1xuICAgICAgICBvdXRwdXRzLnB1c2gocmVzdWx0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgb3RoZXJ3aXNlID0gY29udGV4dC5wYXJzZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIGFyZ3MubGVuZ3RoIC0gMSwgb3V0cHV0VHlwZSk7XG4gICAgICBpZiAoIW90aGVyd2lzZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGlmIChpbnB1dC50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgY29udGV4dC5jb25jYXQoMSkuY2hlY2tTdWJ0eXBlKGlucHV0VHlwZSwgaW5wdXQudHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTWF0Y2goaW5wdXRUeXBlLCBvdXRwdXRUeXBlLCBpbnB1dCwgY2FzZXMsIG91dHB1dHMsIG90aGVyd2lzZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1hdGNoO1xufSgpO1xuXG52YXIgQ2FzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhc2UodHlwZSwgYnJhbmNoZXMsIG90aGVyd2lzZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXNlKTtcblxuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5icmFuY2hlcyA9IGJyYW5jaGVzO1xuICAgIHRoaXMub3RoZXJ3aXNlID0gb3RoZXJ3aXNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENhc2UsIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgdmFyIF9pdGVyYXRvcjMzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5icmFuY2hlcyksXG4gICAgICAgICAgX3N0ZXAzMztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzMy5zKCk7ICEoX3N0ZXAzMyA9IF9pdGVyYXRvcjMzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXAzMyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwMzMudmFsdWUsIDIpLFxuICAgICAgICAgICAgICB0ZXN0ID0gX3N0ZXAzMyR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgX2V4cHJlc3Npb242ID0gX3N0ZXAzMyR2YWx1ZVsxXTtcblxuICAgICAgICAgIGlmICh0ZXN0LmV2YWx1YXRlKGN0eCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfZXhwcmVzc2lvbjYuZXZhbHVhdGUoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzMy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzMy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm90aGVyd2lzZS5ldmFsdWF0ZShjdHgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWFjaENoaWxkKGZuKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMzQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLmJyYW5jaGVzKSxcbiAgICAgICAgICBfc3RlcDM0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjM0LnMoKTsgIShfc3RlcDM0ID0gX2l0ZXJhdG9yMzQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfc3RlcDM0JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXAzNC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIHRlc3QgPSBfc3RlcDM0JHZhbHVlWzBdLFxuICAgICAgICAgICAgICBfZXhwcmVzc2lvbjcgPSBfc3RlcDM0JHZhbHVlWzFdO1xuXG4gICAgICAgICAgZm4odGVzdCk7XG4gICAgICAgICAgZm4oX2V4cHJlc3Npb243KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjM0LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjM0LmYoKTtcbiAgICAgIH1cblxuICAgICAgZm4odGhpcy5vdGhlcndpc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5icmFuY2hlcy5ldmVyeShmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDIpLFxuICAgICAgICAgICAgXyA9IF9yZWY2WzBdLFxuICAgICAgICAgICAgb3V0ID0gX3JlZjZbMV07XG5cbiAgICAgICAgcmV0dXJuIG91dC5vdXRwdXREZWZpbmVkKCk7XG4gICAgICB9KSAmJiB0aGlzLm90aGVyd2lzZS5vdXRwdXREZWZpbmVkKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgc2VyaWFsaXplZCA9IFsnY2FzZSddO1xuICAgICAgdGhpcy5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQucHVzaChjaGlsZC5zZXJpYWxpemUoKSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcInBhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlKGFyZ3MsIGNvbnRleHQpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDQpIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgYXQgbGVhc3QgMyBhcmd1bWVudHMsIGJ1dCBmb3VuZCBvbmx5IFwiLmNvbmNhdChhcmdzLmxlbmd0aCAtIDEsIFwiLlwiKSk7XG4gICAgICBpZiAoYXJncy5sZW5ndGggJSAyICE9PSAwKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGFuIG9kZCBudW1iZXIgb2YgYXJndW1lbnRzLlwiKTtcbiAgICAgIHZhciBvdXRwdXRUeXBlO1xuXG4gICAgICBpZiAoY29udGV4dC5leHBlY3RlZFR5cGUgJiYgY29udGV4dC5leHBlY3RlZFR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICBvdXRwdXRUeXBlID0gY29udGV4dC5leHBlY3RlZFR5cGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBicmFuY2hlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgICAgIHZhciB0ZXN0ID0gY29udGV4dC5wYXJzZShhcmdzW2ldLCBpLCBCb29sZWFuVHlwZSk7XG4gICAgICAgIGlmICghdGVzdCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciByZXN1bHQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbaSArIDFdLCBpICsgMSwgb3V0cHV0VHlwZSk7XG4gICAgICAgIGlmICghcmVzdWx0KSByZXR1cm4gbnVsbDtcbiAgICAgICAgYnJhbmNoZXMucHVzaChbdGVzdCwgcmVzdWx0XSk7XG4gICAgICAgIG91dHB1dFR5cGUgPSBvdXRwdXRUeXBlIHx8IHJlc3VsdC50eXBlO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3RoZXJ3aXNlID0gY29udGV4dC5wYXJzZShhcmdzW2FyZ3MubGVuZ3RoIC0gMV0sIGFyZ3MubGVuZ3RoIC0gMSwgb3V0cHV0VHlwZSk7XG4gICAgICBpZiAoIW90aGVyd2lzZSkgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbmV3IENhc2Uob3V0cHV0VHlwZSwgYnJhbmNoZXMsIG90aGVyd2lzZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhc2U7XG59KCk7XG5cbnZhciBTbGljZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNsaWNlKHR5cGUsIGlucHV0LCBiZWdpbkluZGV4LCBlbmRJbmRleCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTbGljZSk7XG5cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmJlZ2luSW5kZXggPSBiZWdpbkluZGV4O1xuICAgIHRoaXMuZW5kSW5kZXggPSBlbmRJbmRleDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTbGljZSwgW3tcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoY3R4KSB7XG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLmlucHV0LmV2YWx1YXRlKGN0eCk7XG4gICAgICB2YXIgYmVnaW5JbmRleCA9IHRoaXMuYmVnaW5JbmRleC5ldmFsdWF0ZShjdHgpO1xuXG4gICAgICBpZiAoIWlzVmFsaWROYXRpdmVUeXBlKGlucHV0LCBbJ3N0cmluZycsICdhcnJheSddKSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCBcIi5jb25jYXQodG9TdHJpbmcodHlwZU9mKGlucHV0KSksIFwiIGluc3RlYWQuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZW5kSW5kZXgpIHtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gdGhpcy5lbmRJbmRleC5ldmFsdWF0ZShjdHgpO1xuICAgICAgICByZXR1cm4gaW5wdXQuc2xpY2UoYmVnaW5JbmRleCwgZW5kSW5kZXgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5wdXQuc2xpY2UoYmVnaW5JbmRleCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIGZuKHRoaXMuaW5wdXQpO1xuICAgICAgZm4odGhpcy5iZWdpbkluZGV4KTtcblxuICAgICAgaWYgKHRoaXMuZW5kSW5kZXgpIHtcbiAgICAgICAgZm4odGhpcy5lbmRJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm91dHB1dERlZmluZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgIGlmICh0aGlzLmVuZEluZGV4ICE9IG51bGwgJiYgdGhpcy5lbmRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IHRoaXMuZW5kSW5kZXguc2VyaWFsaXplKCk7XG4gICAgICAgIHJldHVybiBbJ3NsaWNlJywgdGhpcy5pbnB1dC5zZXJpYWxpemUoKSwgdGhpcy5iZWdpbkluZGV4LnNlcmlhbGl6ZSgpLCBlbmRJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbJ3NsaWNlJywgdGhpcy5pbnB1dC5zZXJpYWxpemUoKSwgdGhpcy5iZWdpbkluZGV4LnNlcmlhbGl6ZSgpXTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPD0gMiB8fCBhcmdzLmxlbmd0aCA+PSA1KSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgMyBvciA0IGFyZ3VtZW50cywgYnV0IGZvdW5kIFwiLmNvbmNhdChhcmdzLmxlbmd0aCAtIDEsIFwiIGluc3RlYWQuXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlucHV0ID0gY29udGV4dC5wYXJzZShhcmdzWzFdLCAxLCBWYWx1ZVR5cGUpO1xuICAgICAgdmFyIGJlZ2luSW5kZXggPSBjb250ZXh0LnBhcnNlKGFyZ3NbMl0sIDIsIE51bWJlclR5cGUpO1xuICAgICAgaWYgKCFpbnB1dCB8fCAhYmVnaW5JbmRleCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGlmICghaXNWYWxpZFR5cGUoaW5wdXQudHlwZSwgW2FycmF5KFZhbHVlVHlwZSksIFN0cmluZ1R5cGUsIFZhbHVlVHlwZV0pKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBhcnJheSBvciBzdHJpbmcsIGJ1dCBmb3VuZCBcIi5jb25jYXQodG9TdHJpbmcoaW5wdXQudHlwZSksIFwiIGluc3RlYWRcIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gY29udGV4dC5wYXJzZShhcmdzWzNdLCAzLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFlbmRJbmRleCkgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoaW5wdXQudHlwZSwgaW5wdXQsIGJlZ2luSW5kZXgsIGVuZEluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoaW5wdXQudHlwZSwgaW5wdXQsIGJlZ2luSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTbGljZTtcbn0oKTtcblxuZnVuY3Rpb24gaXNDb21wYXJhYmxlVHlwZShvcCwgdHlwZSkge1xuICBpZiAob3AgPT09ICc9PScgfHwgb3AgPT09ICchPScpIHtcbiAgICByZXR1cm4gdHlwZS5raW5kID09PSAnYm9vbGVhbicgfHwgdHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCB0eXBlLmtpbmQgPT09ICdudW1iZXInIHx8IHR5cGUua2luZCA9PT0gJ251bGwnIHx8IHR5cGUua2luZCA9PT0gJ3ZhbHVlJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHlwZS5raW5kID09PSAnc3RyaW5nJyB8fCB0eXBlLmtpbmQgPT09ICdudW1iZXInIHx8IHR5cGUua2luZCA9PT0gJ3ZhbHVlJztcbiAgfVxufVxuXG5mdW5jdGlvbiBlcShjdHgsIGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59XG5cbmZ1bmN0aW9uIG5lcShjdHgsIGEsIGIpIHtcbiAgcmV0dXJuIGEgIT09IGI7XG59XG5cbmZ1bmN0aW9uIGx0KGN0eCwgYSwgYikge1xuICByZXR1cm4gYSA8IGI7XG59XG5cbmZ1bmN0aW9uIGd0KGN0eCwgYSwgYikge1xuICByZXR1cm4gYSA+IGI7XG59XG5cbmZ1bmN0aW9uIGx0ZXEoY3R4LCBhLCBiKSB7XG4gIHJldHVybiBhIDw9IGI7XG59XG5cbmZ1bmN0aW9uIGd0ZXEoY3R4LCBhLCBiKSB7XG4gIHJldHVybiBhID49IGI7XG59XG5cbmZ1bmN0aW9uIGVxQ29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIGMuY29tcGFyZShhLCBiKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gbmVxQ29sbGF0ZShjdHgsIGEsIGIsIGMpIHtcbiAgcmV0dXJuICFlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKTtcbn1cblxuZnVuY3Rpb24gbHRDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICByZXR1cm4gYy5jb21wYXJlKGEsIGIpIDwgMDtcbn1cblxuZnVuY3Rpb24gZ3RDb2xsYXRlKGN0eCwgYSwgYiwgYykge1xuICByZXR1cm4gYy5jb21wYXJlKGEsIGIpID4gMDtcbn1cblxuZnVuY3Rpb24gbHRlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPD0gMDtcbn1cblxuZnVuY3Rpb24gZ3RlcUNvbGxhdGUoY3R4LCBhLCBiLCBjKSB7XG4gIHJldHVybiBjLmNvbXBhcmUoYSwgYikgPj0gMDtcbn1cblxuZnVuY3Rpb24gbWFrZUNvbXBhcmlzb24ob3AsIGNvbXBhcmVCYXNpYywgY29tcGFyZVdpdGhDb2xsYXRvcikge1xuICB2YXIgaXNPcmRlckNvbXBhcmlzb24gPSBvcCAhPT0gJz09JyAmJiBvcCAhPT0gJyE9JztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29tcGFyaXNvbihsaHMsIHJocywgY29sbGF0b3IpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wYXJpc29uKTtcblxuICAgICAgdGhpcy50eXBlID0gQm9vbGVhblR5cGU7XG4gICAgICB0aGlzLmxocyA9IGxocztcbiAgICAgIHRoaXMucmhzID0gcmhzO1xuICAgICAgdGhpcy5jb2xsYXRvciA9IGNvbGxhdG9yO1xuICAgICAgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQgPSBsaHMudHlwZS5raW5kID09PSAndmFsdWUnIHx8IHJocy50eXBlLmtpbmQgPT09ICd2YWx1ZSc7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENvbXBhcmlzb24sIFt7XG4gICAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgICAgdmFyIGxocyA9IHRoaXMubGhzLmV2YWx1YXRlKGN0eCk7XG4gICAgICAgIHZhciByaHMgPSB0aGlzLnJocy5ldmFsdWF0ZShjdHgpO1xuXG4gICAgICAgIGlmIChpc09yZGVyQ29tcGFyaXNvbiAmJiB0aGlzLmhhc1VudHlwZWRBcmd1bWVudCkge1xuICAgICAgICAgIHZhciBfbHQgPSB0eXBlT2YobGhzKTtcblxuICAgICAgICAgIHZhciBydCA9IHR5cGVPZihyaHMpO1xuXG4gICAgICAgICAgaWYgKF9sdC5raW5kICE9PSBydC5raW5kIHx8ICEoX2x0LmtpbmQgPT09ICdzdHJpbmcnIHx8IF9sdC5raW5kID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXCJFeHBlY3RlZCBhcmd1bWVudHMgZm9yIFxcXCJcIi5jb25jYXQob3AsIFwiXFxcIiB0byBiZSAoc3RyaW5nLCBzdHJpbmcpIG9yIChudW1iZXIsIG51bWJlciksIGJ1dCBmb3VuZCAoXCIpLmNvbmNhdChfbHQua2luZCwgXCIsIFwiKS5jb25jYXQocnQua2luZCwgXCIpIGluc3RlYWQuXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb2xsYXRvciAmJiAhaXNPcmRlckNvbXBhcmlzb24gJiYgdGhpcy5oYXNVbnR5cGVkQXJndW1lbnQpIHtcbiAgICAgICAgICB2YXIgX2x0MiA9IHR5cGVPZihsaHMpO1xuXG4gICAgICAgICAgdmFyIF9ydCA9IHR5cGVPZihyaHMpO1xuXG4gICAgICAgICAgaWYgKF9sdDIua2luZCAhPT0gJ3N0cmluZycgfHwgX3J0LmtpbmQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZUJhc2ljKGN0eCwgbGhzLCByaHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxhdG9yID8gY29tcGFyZVdpdGhDb2xsYXRvcihjdHgsIGxocywgcmhzLCB0aGlzLmNvbGxhdG9yLmV2YWx1YXRlKGN0eCkpIDogY29tcGFyZUJhc2ljKGN0eCwgbGhzLCByaHMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlYWNoQ2hpbGRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgICAgZm4odGhpcy5saHMpO1xuICAgICAgICBmbih0aGlzLnJocyk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sbGF0b3IpIHtcbiAgICAgICAgICBmbih0aGlzLmNvbGxhdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb3V0cHV0RGVmaW5lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZWQgPSBbb3BdO1xuICAgICAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICBzZXJpYWxpemVkLnB1c2goY2hpbGQuc2VyaWFsaXplKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwicGFyc2VcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShhcmdzLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMyAmJiBhcmdzLmxlbmd0aCAhPT0gNCkgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJFeHBlY3RlZCB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlwiKTtcbiAgICAgICAgdmFyIG9wID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGxocyA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgVmFsdWVUeXBlKTtcbiAgICAgICAgaWYgKCFsaHMpIHJldHVybiBudWxsO1xuXG4gICAgICAgIGlmICghaXNDb21wYXJhYmxlVHlwZShvcCwgbGhzLnR5cGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY29uY2F0KDEpLmVycm9yKFwiXFxcIlwiLmNvbmNhdChvcCwgXCJcXFwiIGNvbXBhcmlzb25zIGFyZSBub3Qgc3VwcG9ydGVkIGZvciB0eXBlICdcIikuY29uY2F0KHRvU3RyaW5nKGxocy50eXBlKSwgXCInLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmhzID0gY29udGV4dC5wYXJzZShhcmdzWzJdLCAyLCBWYWx1ZVR5cGUpO1xuICAgICAgICBpZiAoIXJocykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgaWYgKCFpc0NvbXBhcmFibGVUeXBlKG9wLCByaHMudHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jb25jYXQoMikuZXJyb3IoXCJcXFwiXCIuY29uY2F0KG9wLCBcIlxcXCIgY29tcGFyaXNvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIHR5cGUgJ1wiKS5jb25jYXQodG9TdHJpbmcocmhzLnR5cGUpLCBcIicuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaHMudHlwZS5raW5kICE9PSByaHMudHlwZS5raW5kICYmIGxocy50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmVycm9yKFwiQ2Fubm90IGNvbXBhcmUgdHlwZXMgJ1wiLmNvbmNhdCh0b1N0cmluZyhsaHMudHlwZSksIFwiJyBhbmQgJ1wiKS5jb25jYXQodG9TdHJpbmcocmhzLnR5cGUpLCBcIicuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc09yZGVyQ29tcGFyaXNvbikge1xuICAgICAgICAgIGlmIChsaHMudHlwZS5raW5kID09PSAndmFsdWUnICYmIHJocy50eXBlLmtpbmQgIT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgIGxocyA9IG5ldyBBc3NlcnRpb24ocmhzLnR5cGUsIFtsaHNdKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxocy50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgcmhzID0gbmV3IEFzc2VydGlvbihsaHMudHlwZSwgW3Joc10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2xsYXRvciA9IG51bGw7XG5cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgaWYgKGxocy50eXBlLmtpbmQgIT09ICdzdHJpbmcnICYmIHJocy50eXBlLmtpbmQgIT09ICdzdHJpbmcnICYmIGxocy50eXBlLmtpbmQgIT09ICd2YWx1ZScgJiYgcmhzLnR5cGUua2luZCAhPT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZXJyb3IoXCJDYW5ub3QgdXNlIGNvbGxhdG9yIHRvIGNvbXBhcmUgbm9uLXN0cmluZyB0eXBlcy5cIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29sbGF0b3IgPSBjb250ZXh0LnBhcnNlKGFyZ3NbM10sIDMsIENvbGxhdG9yVHlwZSk7XG4gICAgICAgICAgaWYgKCFjb2xsYXRvcikgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IENvbXBhcmlzb24obGhzLCByaHMsIGNvbGxhdG9yKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29tcGFyaXNvbjtcbiAgfSgpO1xufVxuXG52YXIgRXF1YWxzID0gbWFrZUNvbXBhcmlzb24oJz09JywgZXEsIGVxQ29sbGF0ZSk7XG52YXIgTm90RXF1YWxzID0gbWFrZUNvbXBhcmlzb24oJyE9JywgbmVxLCBuZXFDb2xsYXRlKTtcbnZhciBMZXNzVGhhbiA9IG1ha2VDb21wYXJpc29uKCc8JywgbHQsIGx0Q29sbGF0ZSk7XG52YXIgR3JlYXRlclRoYW4gPSBtYWtlQ29tcGFyaXNvbignPicsIGd0LCBndENvbGxhdGUpO1xudmFyIExlc3NUaGFuT3JFcXVhbCA9IG1ha2VDb21wYXJpc29uKCc8PScsIGx0ZXEsIGx0ZXFDb2xsYXRlKTtcbnZhciBHcmVhdGVyVGhhbk9yRXF1YWwgPSBtYWtlQ29tcGFyaXNvbignPj0nLCBndGVxLCBndGVxQ29sbGF0ZSk7XG5cbnZhciBOdW1iZXJGb3JtYXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOdW1iZXJGb3JtYXQobnVtYmVyLCBsb2NhbGUsIGN1cnJlbmN5LCBtaW5GcmFjdGlvbkRpZ2l0cywgbWF4RnJhY3Rpb25EaWdpdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTnVtYmVyRm9ybWF0KTtcblxuICAgIHRoaXMudHlwZSA9IFN0cmluZ1R5cGU7XG4gICAgdGhpcy5udW1iZXIgPSBudW1iZXI7XG4gICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgdGhpcy5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgIHRoaXMubWluRnJhY3Rpb25EaWdpdHMgPSBtaW5GcmFjdGlvbkRpZ2l0cztcbiAgICB0aGlzLm1heEZyYWN0aW9uRGlnaXRzID0gbWF4RnJhY3Rpb25EaWdpdHM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTnVtYmVyRm9ybWF0LCBbe1xuICAgIGtleTogXCJldmFsdWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBldmFsdWF0ZShjdHgpIHtcbiAgICAgIHJldHVybiBuZXcgSW50bC5OdW1iZXJGb3JtYXQodGhpcy5sb2NhbGUgPyB0aGlzLmxvY2FsZS5ldmFsdWF0ZShjdHgpIDogW10sIHtcbiAgICAgICAgc3R5bGU6IHRoaXMuY3VycmVuY3kgPyAnY3VycmVuY3knIDogJ2RlY2ltYWwnLFxuICAgICAgICBjdXJyZW5jeTogdGhpcy5jdXJyZW5jeSA/IHRoaXMuY3VycmVuY3kuZXZhbHVhdGUoY3R4KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiB0aGlzLm1pbkZyYWN0aW9uRGlnaXRzID8gdGhpcy5taW5GcmFjdGlvbkRpZ2l0cy5ldmFsdWF0ZShjdHgpIDogdW5kZWZpbmVkLFxuICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMgPyB0aGlzLm1heEZyYWN0aW9uRGlnaXRzLmV2YWx1YXRlKGN0eCkgOiB1bmRlZmluZWRcbiAgICAgIH0pLmZvcm1hdCh0aGlzLm51bWJlci5ldmFsdWF0ZShjdHgpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZWFjaENoaWxkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVhY2hDaGlsZChmbikge1xuICAgICAgZm4odGhpcy5udW1iZXIpO1xuXG4gICAgICBpZiAodGhpcy5sb2NhbGUpIHtcbiAgICAgICAgZm4odGhpcy5sb2NhbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jdXJyZW5jeSkge1xuICAgICAgICBmbih0aGlzLmN1cnJlbmN5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWluRnJhY3Rpb25EaWdpdHMpIHtcbiAgICAgICAgZm4odGhpcy5taW5GcmFjdGlvbkRpZ2l0cyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1heEZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIGZuKHRoaXMubWF4RnJhY3Rpb25EaWdpdHMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5sb2NhbGUpIHtcbiAgICAgICAgb3B0aW9uc1snbG9jYWxlJ10gPSB0aGlzLmxvY2FsZS5zZXJpYWxpemUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VycmVuY3kpIHtcbiAgICAgICAgb3B0aW9uc1snY3VycmVuY3knXSA9IHRoaXMuY3VycmVuY3kuc2VyaWFsaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1pbkZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIG9wdGlvbnNbJ21pbi1mcmFjdGlvbi1kaWdpdHMnXSA9IHRoaXMubWluRnJhY3Rpb25EaWdpdHMuc2VyaWFsaXplKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1heEZyYWN0aW9uRGlnaXRzKSB7XG4gICAgICAgIG9wdGlvbnNbJ21heC1mcmFjdGlvbi1kaWdpdHMnXSA9IHRoaXMubWF4RnJhY3Rpb25EaWdpdHMuc2VyaWFsaXplKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbJ251bWJlci1mb3JtYXQnLCB0aGlzLm51bWJlci5zZXJpYWxpemUoKSwgb3B0aW9uc107XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAzKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIHR3byBhcmd1bWVudHMuXCIpO1xuICAgICAgdmFyIG51bWJlciA9IGNvbnRleHQucGFyc2UoYXJnc1sxXSwgMSwgTnVtYmVyVHlwZSk7XG4gICAgICBpZiAoIW51bWJlcikgcmV0dXJuIG51bGw7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3NbMl07XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHJldHVybiBjb250ZXh0LmVycm9yKFwiTnVtYmVyRm9ybWF0IG9wdGlvbnMgYXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuXCIpO1xuICAgICAgdmFyIGxvY2FsZSA9IG51bGw7XG5cbiAgICAgIGlmIChvcHRpb25zWydsb2NhbGUnXSkge1xuICAgICAgICBsb2NhbGUgPSBjb250ZXh0LnBhcnNlKG9wdGlvbnNbJ2xvY2FsZSddLCAxLCBTdHJpbmdUeXBlKTtcbiAgICAgICAgaWYgKCFsb2NhbGUpIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVuY3kgPSBudWxsO1xuXG4gICAgICBpZiAob3B0aW9uc1snY3VycmVuY3knXSkge1xuICAgICAgICBjdXJyZW5jeSA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snY3VycmVuY3knXSwgMSwgU3RyaW5nVHlwZSk7XG4gICAgICAgIGlmICghY3VycmVuY3kpIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWluRnJhY3Rpb25EaWdpdHMgPSBudWxsO1xuXG4gICAgICBpZiAob3B0aW9uc1snbWluLWZyYWN0aW9uLWRpZ2l0cyddKSB7XG4gICAgICAgIG1pbkZyYWN0aW9uRGlnaXRzID0gY29udGV4dC5wYXJzZShvcHRpb25zWydtaW4tZnJhY3Rpb24tZGlnaXRzJ10sIDEsIE51bWJlclR5cGUpO1xuICAgICAgICBpZiAoIW1pbkZyYWN0aW9uRGlnaXRzKSByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heEZyYWN0aW9uRGlnaXRzID0gbnVsbDtcblxuICAgICAgaWYgKG9wdGlvbnNbJ21heC1mcmFjdGlvbi1kaWdpdHMnXSkge1xuICAgICAgICBtYXhGcmFjdGlvbkRpZ2l0cyA9IGNvbnRleHQucGFyc2Uob3B0aW9uc1snbWF4LWZyYWN0aW9uLWRpZ2l0cyddLCAxLCBOdW1iZXJUeXBlKTtcbiAgICAgICAgaWYgKCFtYXhGcmFjdGlvbkRpZ2l0cykgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgTnVtYmVyRm9ybWF0KG51bWJlciwgbG9jYWxlLCBjdXJyZW5jeSwgbWluRnJhY3Rpb25EaWdpdHMsIG1heEZyYWN0aW9uRGlnaXRzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTnVtYmVyRm9ybWF0O1xufSgpO1xuXG52YXIgTGVuZ3RoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGVuZ3RoKGlucHV0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExlbmd0aCk7XG5cbiAgICB0aGlzLnR5cGUgPSBOdW1iZXJUeXBlO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMZW5ndGgsIFt7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGN0eCkge1xuICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dC5ldmFsdWF0ZShjdHgpO1xuXG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5wdXQubGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gaW5wdXQubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG9mIHR5cGUgc3RyaW5nIG9yIGFycmF5LCBidXQgZm91bmQgXCIuY29uY2F0KHRvU3RyaW5nKHR5cGVPZihpbnB1dCkpLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVhY2hDaGlsZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlYWNoQ2hpbGQoZm4pIHtcbiAgICAgIGZuKHRoaXMuaW5wdXQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvdXRwdXREZWZpbmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG91dHB1dERlZmluZWQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgc2VyaWFsaXplZCA9IFsnbGVuZ3RoJ107XG4gICAgICB0aGlzLmVhY2hDaGlsZChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKGNoaWxkLnNlcmlhbGl6ZSgpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoYXJncywgY29udGV4dCkge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoICE9PSAyKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIDEgYXJndW1lbnQsIGJ1dCBmb3VuZCBcIi5jb25jYXQoYXJncy5sZW5ndGggLSAxLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICB2YXIgaW5wdXQgPSBjb250ZXh0LnBhcnNlKGFyZ3NbMV0sIDEpO1xuICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoaW5wdXQudHlwZS5raW5kICE9PSAnYXJyYXknICYmIGlucHV0LnR5cGUua2luZCAhPT0gJ3N0cmluZycgJiYgaW5wdXQudHlwZS5raW5kICE9PSAndmFsdWUnKSByZXR1cm4gY29udGV4dC5lcnJvcihcIkV4cGVjdGVkIGFyZ3VtZW50IG9mIHR5cGUgc3RyaW5nIG9yIGFycmF5LCBidXQgZm91bmQgXCIuY29uY2F0KHRvU3RyaW5nKGlucHV0LnR5cGUpLCBcIiBpbnN0ZWFkLlwiKSk7XG4gICAgICByZXR1cm4gbmV3IExlbmd0aChpbnB1dCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExlbmd0aDtcbn0oKTtcblxudmFyIGV4cHJlc3Npb25zID0ge1xuICAnPT0nOiBFcXVhbHMsXG4gICchPSc6IE5vdEVxdWFscyxcbiAgJz4nOiBHcmVhdGVyVGhhbixcbiAgJzwnOiBMZXNzVGhhbixcbiAgJz49JzogR3JlYXRlclRoYW5PckVxdWFsLFxuICAnPD0nOiBMZXNzVGhhbk9yRXF1YWwsXG4gICdhcnJheSc6IEFzc2VydGlvbixcbiAgJ2F0JzogQXQsXG4gICdib29sZWFuJzogQXNzZXJ0aW9uLFxuICAnY2FzZSc6IENhc2UsXG4gICdjb2FsZXNjZSc6IENvYWxlc2NlLFxuICAnY29sbGF0b3InOiBDb2xsYXRvckV4cHJlc3Npb24sXG4gICdmb3JtYXQnOiBGb3JtYXRFeHByZXNzaW9uLFxuICAnaW1hZ2UnOiBJbWFnZUV4cHJlc3Npb24sXG4gICdpbic6IEluLFxuICAnaW5kZXgtb2YnOiBJbmRleE9mLFxuICAnaW50ZXJwb2xhdGUnOiBJbnRlcnBvbGF0ZSxcbiAgJ2ludGVycG9sYXRlLWhjbCc6IEludGVycG9sYXRlLFxuICAnaW50ZXJwb2xhdGUtbGFiJzogSW50ZXJwb2xhdGUsXG4gICdsZW5ndGgnOiBMZW5ndGgsXG4gICdsZXQnOiBMZXQsXG4gICdsaXRlcmFsJzogTGl0ZXJhbCxcbiAgJ21hdGNoJzogTWF0Y2gsXG4gICdudW1iZXInOiBBc3NlcnRpb24sXG4gICdudW1iZXItZm9ybWF0JzogTnVtYmVyRm9ybWF0LFxuICAnb2JqZWN0JzogQXNzZXJ0aW9uLFxuICAnc2xpY2UnOiBTbGljZSxcbiAgJ3N0ZXAnOiBTdGVwLFxuICAnc3RyaW5nJzogQXNzZXJ0aW9uLFxuICAndG8tYm9vbGVhbic6IENvZXJjaW9uLFxuICAndG8tY29sb3InOiBDb2VyY2lvbixcbiAgJ3RvLW51bWJlcic6IENvZXJjaW9uLFxuICAndG8tc3RyaW5nJzogQ29lcmNpb24sXG4gICd2YXInOiBWYXIsXG4gICd3aXRoaW4nOiBXaXRoaW5cbn07XG5cbmZ1bmN0aW9uIHJnYmEoY3R4LCBfcmVmNykge1xuICB2YXIgX3JlZjggPSBfc2xpY2VkVG9BcnJheShfcmVmNywgNCksXG4gICAgICByID0gX3JlZjhbMF0sXG4gICAgICBnID0gX3JlZjhbMV0sXG4gICAgICBiID0gX3JlZjhbMl0sXG4gICAgICBhID0gX3JlZjhbM107XG5cbiAgciA9IHIuZXZhbHVhdGUoY3R4KTtcbiAgZyA9IGcuZXZhbHVhdGUoY3R4KTtcbiAgYiA9IGIuZXZhbHVhdGUoY3R4KTtcbiAgdmFyIGFscGhhID0gYSA/IGEuZXZhbHVhdGUoY3R4KSA6IDE7XG4gIHZhciBlcnJvciA9IHZhbGlkYXRlUkdCQShyLCBnLCBiLCBhbHBoYSk7XG4gIGlmIChlcnJvcikgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihlcnJvcik7XG4gIHJldHVybiBuZXcgQ29sb3IociAvIDI1NSAqIGFscGhhLCBnIC8gMjU1ICogYWxwaGEsIGIgLyAyNTUgKiBhbHBoYSwgYWxwaGEpO1xufVxuXG5mdW5jdGlvbiBoYXMoa2V5LCBvYmopIHtcbiAgcmV0dXJuIGtleSBpbiBvYmo7XG59XG5cbmZ1bmN0aW9uIGdldChrZXksIG9iaikge1xuICB2YXIgdiA9IG9ialtrZXldO1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHY7XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaCh2LCBhLCBpLCBqKSB7XG4gIHdoaWxlIChpIDw9IGopIHtcbiAgICB2YXIgbSA9IGkgKyBqID4+IDE7XG4gICAgaWYgKGFbbV0gPT09IHYpIHJldHVybiB0cnVlO1xuICAgIGlmIChhW21dID4gdikgaiA9IG0gLSAxO2Vsc2UgaSA9IG0gKyAxO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB2YXJhcmdzKHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlXG4gIH07XG59XG5cbkNvbXBvdW5kRXhwcmVzc2lvbi5yZWdpc3RlcihleHByZXNzaW9ucywge1xuICAnZXJyb3InOiBbRXJyb3JUeXBlLCBbU3RyaW5nVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY5KSB7XG4gICAgdmFyIF9yZWYxMCA9IF9zbGljZWRUb0FycmF5KF9yZWY5LCAxKSxcbiAgICAgICAgdiA9IF9yZWYxMFswXTtcblxuICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3Iodi5ldmFsdWF0ZShjdHgpKTtcbiAgfV0sXG4gICd0eXBlb2YnOiBbU3RyaW5nVHlwZSwgW1ZhbHVlVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYxMSkge1xuICAgIHZhciBfcmVmMTIgPSBfc2xpY2VkVG9BcnJheShfcmVmMTEsIDEpLFxuICAgICAgICB2ID0gX3JlZjEyWzBdO1xuXG4gICAgcmV0dXJuIHRvU3RyaW5nKHR5cGVPZih2LmV2YWx1YXRlKGN0eCkpKTtcbiAgfV0sXG4gICd0by1yZ2JhJzogW2FycmF5KE51bWJlclR5cGUsIDQpLCBbQ29sb3JUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjEzKSB7XG4gICAgdmFyIF9yZWYxNCA9IF9zbGljZWRUb0FycmF5KF9yZWYxMywgMSksXG4gICAgICAgIHYgPSBfcmVmMTRbMF07XG5cbiAgICByZXR1cm4gdi5ldmFsdWF0ZShjdHgpLnRvQXJyYXkoKTtcbiAgfV0sXG4gICdyZ2InOiBbQ29sb3JUeXBlLCBbTnVtYmVyVHlwZSwgTnVtYmVyVHlwZSwgTnVtYmVyVHlwZV0sIHJnYmFdLFxuICAncmdiYSc6IFtDb2xvclR5cGUsIFtOdW1iZXJUeXBlLCBOdW1iZXJUeXBlLCBOdW1iZXJUeXBlLCBOdW1iZXJUeXBlXSwgcmdiYV0sXG4gICdoYXMnOiB7XG4gICAgdHlwZTogQm9vbGVhblR5cGUsXG4gICAgb3ZlcmxvYWRzOiBbW1tTdHJpbmdUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjE1KSB7XG4gICAgICB2YXIgX3JlZjE2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE1LCAxKSxcbiAgICAgICAgICBrZXkgPSBfcmVmMTZbMF07XG5cbiAgICAgIHJldHVybiBoYXMoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5wcm9wZXJ0aWVzKCkpO1xuICAgIH1dLCBbW1N0cmluZ1R5cGUsIE9iamVjdFR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMTcpIHtcbiAgICAgIHZhciBfcmVmMTggPSBfc2xpY2VkVG9BcnJheShfcmVmMTcsIDIpLFxuICAgICAgICAgIGtleSA9IF9yZWYxOFswXSxcbiAgICAgICAgICBvYmogPSBfcmVmMThbMV07XG5cbiAgICAgIHJldHVybiBoYXMoa2V5LmV2YWx1YXRlKGN0eCksIG9iai5ldmFsdWF0ZShjdHgpKTtcbiAgICB9XV1cbiAgfSxcbiAgJ2dldCc6IHtcbiAgICB0eXBlOiBWYWx1ZVR5cGUsXG4gICAgb3ZlcmxvYWRzOiBbW1tTdHJpbmdUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjE5KSB7XG4gICAgICB2YXIgX3JlZjIwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE5LCAxKSxcbiAgICAgICAgICBrZXkgPSBfcmVmMjBbMF07XG5cbiAgICAgIHJldHVybiBnZXQoa2V5LmV2YWx1YXRlKGN0eCksIGN0eC5wcm9wZXJ0aWVzKCkpO1xuICAgIH1dLCBbW1N0cmluZ1R5cGUsIE9iamVjdFR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMjEpIHtcbiAgICAgIHZhciBfcmVmMjIgPSBfc2xpY2VkVG9BcnJheShfcmVmMjEsIDIpLFxuICAgICAgICAgIGtleSA9IF9yZWYyMlswXSxcbiAgICAgICAgICBvYmogPSBfcmVmMjJbMV07XG5cbiAgICAgIHJldHVybiBnZXQoa2V5LmV2YWx1YXRlKGN0eCksIG9iai5ldmFsdWF0ZShjdHgpKTtcbiAgICB9XV1cbiAgfSxcbiAgJ2ZlYXR1cmUtc3RhdGUnOiBbVmFsdWVUeXBlLCBbU3RyaW5nVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYyMykge1xuICAgIHZhciBfcmVmMjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMjMsIDEpLFxuICAgICAgICBrZXkgPSBfcmVmMjRbMF07XG5cbiAgICByZXR1cm4gZ2V0KGtleS5ldmFsdWF0ZShjdHgpLCBjdHguZmVhdHVyZVN0YXRlIHx8IHt9KTtcbiAgfV0sXG4gICdwcm9wZXJ0aWVzJzogW09iamVjdFR5cGUsIFtdLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgcmV0dXJuIGN0eC5wcm9wZXJ0aWVzKCk7XG4gIH1dLFxuICAnZ2VvbWV0cnktdHlwZSc6IFtTdHJpbmdUeXBlLCBbXSwgZnVuY3Rpb24gKGN0eCkge1xuICAgIHJldHVybiBjdHguZ2VvbWV0cnlUeXBlKCk7XG4gIH1dLFxuICAnaWQnOiBbVmFsdWVUeXBlLCBbXSwgZnVuY3Rpb24gKGN0eCkge1xuICAgIHJldHVybiBjdHguaWQoKTtcbiAgfV0sXG4gICd6b29tJzogW051bWJlclR5cGUsIFtdLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgcmV0dXJuIGN0eC5nbG9iYWxzLnpvb207XG4gIH1dLFxuICAnaGVhdG1hcC1kZW5zaXR5JzogW051bWJlclR5cGUsIFtdLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgcmV0dXJuIGN0eC5nbG9iYWxzLmhlYXRtYXBEZW5zaXR5IHx8IDA7XG4gIH1dLFxuICAnbGluZS1wcm9ncmVzcyc6IFtOdW1iZXJUeXBlLCBbXSwgZnVuY3Rpb24gKGN0eCkge1xuICAgIHJldHVybiBjdHguZ2xvYmFscy5saW5lUHJvZ3Jlc3MgfHwgMDtcbiAgfV0sXG4gICdza3ktcmFkaWFsLXByb2dyZXNzJzogW051bWJlclR5cGUsIFtdLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgcmV0dXJuIGN0eC5nbG9iYWxzLnNreVJhZGlhbFByb2dyZXNzIHx8IDA7XG4gIH1dLFxuICAnYWNjdW11bGF0ZWQnOiBbVmFsdWVUeXBlLCBbXSwgZnVuY3Rpb24gKGN0eCkge1xuICAgIHJldHVybiBjdHguZ2xvYmFscy5hY2N1bXVsYXRlZCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGN0eC5nbG9iYWxzLmFjY3VtdWxhdGVkO1xuICB9XSxcbiAgJysnOiBbTnVtYmVyVHlwZSwgdmFyYXJncyhOdW1iZXJUeXBlKSwgZnVuY3Rpb24gKGN0eCwgYXJncykge1xuICAgIHZhciByZXN1bHQgPSAwO1xuXG4gICAgdmFyIF9pdGVyYXRvcjM1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYXJncyksXG4gICAgICAgIF9zdGVwMzU7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IzNS5zKCk7ICEoX3N0ZXAzNSA9IF9pdGVyYXRvcjM1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGFyZyA9IF9zdGVwMzUudmFsdWU7XG4gICAgICAgIHJlc3VsdCArPSBhcmcuZXZhbHVhdGUoY3R4KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjM1LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yMzUuZigpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1dLFxuICAnKic6IFtOdW1iZXJUeXBlLCB2YXJhcmdzKE51bWJlclR5cGUpLCBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7XG4gICAgdmFyIHJlc3VsdCA9IDE7XG5cbiAgICB2YXIgX2l0ZXJhdG9yMzYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhcmdzKSxcbiAgICAgICAgX3N0ZXAzNjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjM2LnMoKTsgIShfc3RlcDM2ID0gX2l0ZXJhdG9yMzYubigpKS5kb25lOykge1xuICAgICAgICB2YXIgYXJnID0gX3N0ZXAzNi52YWx1ZTtcbiAgICAgICAgcmVzdWx0ICo9IGFyZy5ldmFsdWF0ZShjdHgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMzYuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3IzNi5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfV0sXG4gICctJzoge1xuICAgIHR5cGU6IE51bWJlclR5cGUsXG4gICAgb3ZlcmxvYWRzOiBbW1tOdW1iZXJUeXBlLCBOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjI1KSB7XG4gICAgICB2YXIgX3JlZjI2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjI1LCAyKSxcbiAgICAgICAgICBhID0gX3JlZjI2WzBdLFxuICAgICAgICAgIGIgPSBfcmVmMjZbMV07XG5cbiAgICAgIHJldHVybiBhLmV2YWx1YXRlKGN0eCkgLSBiLmV2YWx1YXRlKGN0eCk7XG4gICAgfV0sIFtbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYyNykge1xuICAgICAgdmFyIF9yZWYyOCA9IF9zbGljZWRUb0FycmF5KF9yZWYyNywgMSksXG4gICAgICAgICAgYSA9IF9yZWYyOFswXTtcblxuICAgICAgcmV0dXJuIC1hLmV2YWx1YXRlKGN0eCk7XG4gICAgfV1dXG4gIH0sXG4gICcvJzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlLCBOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjI5KSB7XG4gICAgdmFyIF9yZWYzMCA9IF9zbGljZWRUb0FycmF5KF9yZWYyOSwgMiksXG4gICAgICAgIGEgPSBfcmVmMzBbMF0sXG4gICAgICAgIGIgPSBfcmVmMzBbMV07XG5cbiAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpIC8gYi5ldmFsdWF0ZShjdHgpO1xuICB9XSxcbiAgJyUnOiBbTnVtYmVyVHlwZSwgW051bWJlclR5cGUsIE51bWJlclR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMzEpIHtcbiAgICB2YXIgX3JlZjMyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjMxLCAyKSxcbiAgICAgICAgYSA9IF9yZWYzMlswXSxcbiAgICAgICAgYiA9IF9yZWYzMlsxXTtcblxuICAgIHJldHVybiBhLmV2YWx1YXRlKGN0eCkgJSBiLmV2YWx1YXRlKGN0eCk7XG4gIH1dLFxuICAnbG4yJzogW051bWJlclR5cGUsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguTE4yO1xuICB9XSxcbiAgJ3BpJzogW051bWJlclR5cGUsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE1hdGguUEk7XG4gIH1dLFxuICAnZSc6IFtOdW1iZXJUeXBlLCBbXSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBNYXRoLkU7XG4gIH1dLFxuICAnXic6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZSwgTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYzMykge1xuICAgIHZhciBfcmVmMzQgPSBfc2xpY2VkVG9BcnJheShfcmVmMzMsIDIpLFxuICAgICAgICBiID0gX3JlZjM0WzBdLFxuICAgICAgICBlID0gX3JlZjM0WzFdO1xuXG4gICAgcmV0dXJuIE1hdGgucG93KGIuZXZhbHVhdGUoY3R4KSwgZS5ldmFsdWF0ZShjdHgpKTtcbiAgfV0sXG4gICdzcXJ0JzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjM1KSB7XG4gICAgdmFyIF9yZWYzNiA9IF9zbGljZWRUb0FycmF5KF9yZWYzNSwgMSksXG4gICAgICAgIHggPSBfcmVmMzZbMF07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHguZXZhbHVhdGUoY3R4KSk7XG4gIH1dLFxuICAnbG9nMTAnOiBbTnVtYmVyVHlwZSwgW051bWJlclR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMzcpIHtcbiAgICB2YXIgX3JlZjM4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjM3LCAxKSxcbiAgICAgICAgbiA9IF9yZWYzOFswXTtcblxuICAgIHJldHVybiBNYXRoLmxvZyhuLmV2YWx1YXRlKGN0eCkpIC8gTWF0aC5MTjEwO1xuICB9XSxcbiAgJ2xuJzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjM5KSB7XG4gICAgdmFyIF9yZWY0MCA9IF9zbGljZWRUb0FycmF5KF9yZWYzOSwgMSksXG4gICAgICAgIG4gPSBfcmVmNDBbMF07XG5cbiAgICByZXR1cm4gTWF0aC5sb2cobi5ldmFsdWF0ZShjdHgpKTtcbiAgfV0sXG4gICdsb2cyJzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjQxKSB7XG4gICAgdmFyIF9yZWY0MiA9IF9zbGljZWRUb0FycmF5KF9yZWY0MSwgMSksXG4gICAgICAgIG4gPSBfcmVmNDJbMF07XG5cbiAgICByZXR1cm4gTWF0aC5sb2cobi5ldmFsdWF0ZShjdHgpKSAvIE1hdGguTE4yO1xuICB9XSxcbiAgJ3Npbic6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY0Mykge1xuICAgIHZhciBfcmVmNDQgPSBfc2xpY2VkVG9BcnJheShfcmVmNDMsIDEpLFxuICAgICAgICBuID0gX3JlZjQ0WzBdO1xuXG4gICAgcmV0dXJuIE1hdGguc2luKG4uZXZhbHVhdGUoY3R4KSk7XG4gIH1dLFxuICAnY29zJzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjQ1KSB7XG4gICAgdmFyIF9yZWY0NiA9IF9zbGljZWRUb0FycmF5KF9yZWY0NSwgMSksXG4gICAgICAgIG4gPSBfcmVmNDZbMF07XG5cbiAgICByZXR1cm4gTWF0aC5jb3Mobi5ldmFsdWF0ZShjdHgpKTtcbiAgfV0sXG4gICd0YW4nOiBbTnVtYmVyVHlwZSwgW051bWJlclR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNDcpIHtcbiAgICB2YXIgX3JlZjQ4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjQ3LCAxKSxcbiAgICAgICAgbiA9IF9yZWY0OFswXTtcblxuICAgIHJldHVybiBNYXRoLnRhbihuLmV2YWx1YXRlKGN0eCkpO1xuICB9XSxcbiAgJ2FzaW4nOiBbTnVtYmVyVHlwZSwgW051bWJlclR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNDkpIHtcbiAgICB2YXIgX3JlZjUwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjQ5LCAxKSxcbiAgICAgICAgbiA9IF9yZWY1MFswXTtcblxuICAgIHJldHVybiBNYXRoLmFzaW4obi5ldmFsdWF0ZShjdHgpKTtcbiAgfV0sXG4gICdhY29zJzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjUxKSB7XG4gICAgdmFyIF9yZWY1MiA9IF9zbGljZWRUb0FycmF5KF9yZWY1MSwgMSksXG4gICAgICAgIG4gPSBfcmVmNTJbMF07XG5cbiAgICByZXR1cm4gTWF0aC5hY29zKG4uZXZhbHVhdGUoY3R4KSk7XG4gIH1dLFxuICAnYXRhbic6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY1Mykge1xuICAgIHZhciBfcmVmNTQgPSBfc2xpY2VkVG9BcnJheShfcmVmNTMsIDEpLFxuICAgICAgICBuID0gX3JlZjU0WzBdO1xuXG4gICAgcmV0dXJuIE1hdGguYXRhbihuLmV2YWx1YXRlKGN0eCkpO1xuICB9XSxcbiAgJ21pbic6IFtOdW1iZXJUeXBlLCB2YXJhcmdzKE51bWJlclR5cGUpLCBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7XG4gICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gYXJnLmV2YWx1YXRlKGN0eCk7XG4gICAgfSkpKTtcbiAgfV0sXG4gICdtYXgnOiBbTnVtYmVyVHlwZSwgdmFyYXJncyhOdW1iZXJUeXBlKSwgZnVuY3Rpb24gKGN0eCwgYXJncykge1xuICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkoYXJncy5tYXAoZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZy5ldmFsdWF0ZShjdHgpO1xuICAgIH0pKSk7XG4gIH1dLFxuICAnYWJzJzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjU1KSB7XG4gICAgdmFyIF9yZWY1NiA9IF9zbGljZWRUb0FycmF5KF9yZWY1NSwgMSksXG4gICAgICAgIG4gPSBfcmVmNTZbMF07XG5cbiAgICByZXR1cm4gTWF0aC5hYnMobi5ldmFsdWF0ZShjdHgpKTtcbiAgfV0sXG4gICdyb3VuZCc6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY1Nykge1xuICAgIHZhciBfcmVmNTggPSBfc2xpY2VkVG9BcnJheShfcmVmNTcsIDEpLFxuICAgICAgICBuID0gX3JlZjU4WzBdO1xuXG4gICAgdmFyIHYgPSBuLmV2YWx1YXRlKGN0eCk7XG4gICAgcmV0dXJuIHYgPCAwID8gLU1hdGgucm91bmQoLXYpIDogTWF0aC5yb3VuZCh2KTtcbiAgfV0sXG4gICdmbG9vcic6IFtOdW1iZXJUeXBlLCBbTnVtYmVyVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY1OSkge1xuICAgIHZhciBfcmVmNjAgPSBfc2xpY2VkVG9BcnJheShfcmVmNTksIDEpLFxuICAgICAgICBuID0gX3JlZjYwWzBdO1xuXG4gICAgcmV0dXJuIE1hdGguZmxvb3Iobi5ldmFsdWF0ZShjdHgpKTtcbiAgfV0sXG4gICdjZWlsJzogW051bWJlclR5cGUsIFtOdW1iZXJUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjYxKSB7XG4gICAgdmFyIF9yZWY2MiA9IF9zbGljZWRUb0FycmF5KF9yZWY2MSwgMSksXG4gICAgICAgIG4gPSBfcmVmNjJbMF07XG5cbiAgICByZXR1cm4gTWF0aC5jZWlsKG4uZXZhbHVhdGUoY3R4KSk7XG4gIH1dLFxuICAnZmlsdGVyLT09JzogW0Jvb2xlYW5UeXBlLCBbU3RyaW5nVHlwZSwgVmFsdWVUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjYzKSB7XG4gICAgdmFyIF9yZWY2NCA9IF9zbGljZWRUb0FycmF5KF9yZWY2MywgMiksXG4gICAgICAgIGsgPSBfcmVmNjRbMF0sXG4gICAgICAgIHYgPSBfcmVmNjRbMV07XG5cbiAgICByZXR1cm4gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXSA9PT0gdi52YWx1ZTtcbiAgfV0sXG4gICdmaWx0ZXItaWQtPT0nOiBbQm9vbGVhblR5cGUsIFtWYWx1ZVR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNjUpIHtcbiAgICB2YXIgX3JlZjY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjY1LCAxKSxcbiAgICAgICAgdiA9IF9yZWY2NlswXTtcblxuICAgIHJldHVybiBjdHguaWQoKSA9PT0gdi52YWx1ZTtcbiAgfV0sXG4gICdmaWx0ZXItdHlwZS09PSc6IFtCb29sZWFuVHlwZSwgW1N0cmluZ1R5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNjcpIHtcbiAgICB2YXIgX3JlZjY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjY3LCAxKSxcbiAgICAgICAgdiA9IF9yZWY2OFswXTtcblxuICAgIHJldHVybiBjdHguZ2VvbWV0cnlUeXBlKCkgPT09IHYudmFsdWU7XG4gIH1dLFxuICAnZmlsdGVyLTwnOiBbQm9vbGVhblR5cGUsIFtTdHJpbmdUeXBlLCBWYWx1ZVR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNjkpIHtcbiAgICB2YXIgX3JlZjcwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjY5LCAyKSxcbiAgICAgICAgayA9IF9yZWY3MFswXSxcbiAgICAgICAgdiA9IF9yZWY3MFsxXTtcblxuICAgIHZhciBhID0gY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXTtcbiAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDwgYjtcbiAgfV0sXG4gICdmaWx0ZXItaWQtPCc6IFtCb29sZWFuVHlwZSwgW1ZhbHVlVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY3MSkge1xuICAgIHZhciBfcmVmNzIgPSBfc2xpY2VkVG9BcnJheShfcmVmNzEsIDEpLFxuICAgICAgICB2ID0gX3JlZjcyWzBdO1xuXG4gICAgdmFyIGEgPSBjdHguaWQoKTtcbiAgICB2YXIgYiA9IHYudmFsdWU7XG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYiAmJiBhIDwgYjtcbiAgfV0sXG4gICdmaWx0ZXItPic6IFtCb29sZWFuVHlwZSwgW1N0cmluZ1R5cGUsIFZhbHVlVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY3Mykge1xuICAgIHZhciBfcmVmNzQgPSBfc2xpY2VkVG9BcnJheShfcmVmNzMsIDIpLFxuICAgICAgICBrID0gX3JlZjc0WzBdLFxuICAgICAgICB2ID0gX3JlZjc0WzFdO1xuXG4gICAgdmFyIGEgPSBjdHgucHJvcGVydGllcygpW2sudmFsdWVdO1xuICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPiBiO1xuICB9XSxcbiAgJ2ZpbHRlci1pZC0+JzogW0Jvb2xlYW5UeXBlLCBbVmFsdWVUeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjc1KSB7XG4gICAgdmFyIF9yZWY3NiA9IF9zbGljZWRUb0FycmF5KF9yZWY3NSwgMSksXG4gICAgICAgIHYgPSBfcmVmNzZbMF07XG5cbiAgICB2YXIgYSA9IGN0eC5pZCgpO1xuICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPiBiO1xuICB9XSxcbiAgJ2ZpbHRlci08PSc6IFtCb29sZWFuVHlwZSwgW1N0cmluZ1R5cGUsIFZhbHVlVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY3Nykge1xuICAgIHZhciBfcmVmNzggPSBfc2xpY2VkVG9BcnJheShfcmVmNzcsIDIpLFxuICAgICAgICBrID0gX3JlZjc4WzBdLFxuICAgICAgICB2ID0gX3JlZjc4WzFdO1xuXG4gICAgdmFyIGEgPSBjdHgucHJvcGVydGllcygpW2sudmFsdWVdO1xuICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPD0gYjtcbiAgfV0sXG4gICdmaWx0ZXItaWQtPD0nOiBbQm9vbGVhblR5cGUsIFtWYWx1ZVR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmNzkpIHtcbiAgICB2YXIgX3JlZjgwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjc5LCAxKSxcbiAgICAgICAgdiA9IF9yZWY4MFswXTtcblxuICAgIHZhciBhID0gY3R4LmlkKCk7XG4gICAgdmFyIGIgPSB2LnZhbHVlO1xuICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA8PSBiO1xuICB9XSxcbiAgJ2ZpbHRlci0+PSc6IFtCb29sZWFuVHlwZSwgW1N0cmluZ1R5cGUsIFZhbHVlVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY4MSkge1xuICAgIHZhciBfcmVmODIgPSBfc2xpY2VkVG9BcnJheShfcmVmODEsIDIpLFxuICAgICAgICBrID0gX3JlZjgyWzBdLFxuICAgICAgICB2ID0gX3JlZjgyWzFdO1xuXG4gICAgdmFyIGEgPSBjdHgucHJvcGVydGllcygpW2sudmFsdWVdO1xuICAgIHZhciBiID0gdi52YWx1ZTtcbiAgICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIGEgPj0gYjtcbiAgfV0sXG4gICdmaWx0ZXItaWQtPj0nOiBbQm9vbGVhblR5cGUsIFtWYWx1ZVR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmODMpIHtcbiAgICB2YXIgX3JlZjg0ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjgzLCAxKSxcbiAgICAgICAgdiA9IF9yZWY4NFswXTtcblxuICAgIHZhciBhID0gY3R4LmlkKCk7XG4gICAgdmFyIGIgPSB2LnZhbHVlO1xuICAgIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGIgJiYgYSA+PSBiO1xuICB9XSxcbiAgJ2ZpbHRlci1oYXMnOiBbQm9vbGVhblR5cGUsIFtWYWx1ZVR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmODUpIHtcbiAgICB2YXIgX3JlZjg2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjg1LCAxKSxcbiAgICAgICAgayA9IF9yZWY4NlswXTtcblxuICAgIHJldHVybiBrLnZhbHVlIGluIGN0eC5wcm9wZXJ0aWVzKCk7XG4gIH1dLFxuICAnZmlsdGVyLWhhcy1pZCc6IFtCb29sZWFuVHlwZSwgW10sIGZ1bmN0aW9uIChjdHgpIHtcbiAgICByZXR1cm4gY3R4LmlkKCkgIT09IG51bGwgJiYgY3R4LmlkKCkgIT09IHVuZGVmaW5lZDtcbiAgfV0sXG4gICdmaWx0ZXItdHlwZS1pbic6IFtCb29sZWFuVHlwZSwgW2FycmF5KFN0cmluZ1R5cGUpXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjg3KSB7XG4gICAgdmFyIF9yZWY4OCA9IF9zbGljZWRUb0FycmF5KF9yZWY4NywgMSksXG4gICAgICAgIHYgPSBfcmVmODhbMF07XG5cbiAgICByZXR1cm4gdi52YWx1ZS5pbmRleE9mKGN0eC5nZW9tZXRyeVR5cGUoKSkgPj0gMDtcbiAgfV0sXG4gICdmaWx0ZXItaWQtaW4nOiBbQm9vbGVhblR5cGUsIFthcnJheShWYWx1ZVR5cGUpXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjg5KSB7XG4gICAgdmFyIF9yZWY5MCA9IF9zbGljZWRUb0FycmF5KF9yZWY4OSwgMSksXG4gICAgICAgIHYgPSBfcmVmOTBbMF07XG5cbiAgICByZXR1cm4gdi52YWx1ZS5pbmRleE9mKGN0eC5pZCgpKSA+PSAwO1xuICB9XSxcbiAgJ2ZpbHRlci1pbi1zbWFsbCc6IFtCb29sZWFuVHlwZSwgW1N0cmluZ1R5cGUsIGFycmF5KFZhbHVlVHlwZSldLCBmdW5jdGlvbiAoY3R4LCBfcmVmOTEpIHtcbiAgICB2YXIgX3JlZjkyID0gX3NsaWNlZFRvQXJyYXkoX3JlZjkxLCAyKSxcbiAgICAgICAgayA9IF9yZWY5MlswXSxcbiAgICAgICAgdiA9IF9yZWY5MlsxXTtcblxuICAgIHJldHVybiB2LnZhbHVlLmluZGV4T2YoY3R4LnByb3BlcnRpZXMoKVtrLnZhbHVlXSkgPj0gMDtcbiAgfV0sXG4gICdmaWx0ZXItaW4tbGFyZ2UnOiBbQm9vbGVhblR5cGUsIFtTdHJpbmdUeXBlLCBhcnJheShWYWx1ZVR5cGUpXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjkzKSB7XG4gICAgdmFyIF9yZWY5NCA9IF9zbGljZWRUb0FycmF5KF9yZWY5MywgMiksXG4gICAgICAgIGsgPSBfcmVmOTRbMF0sXG4gICAgICAgIHYgPSBfcmVmOTRbMV07XG5cbiAgICByZXR1cm4gYmluYXJ5U2VhcmNoKGN0eC5wcm9wZXJ0aWVzKClbay52YWx1ZV0sIHYudmFsdWUsIDAsIHYudmFsdWUubGVuZ3RoIC0gMSk7XG4gIH1dLFxuICAnYWxsJzoge1xuICAgIHR5cGU6IEJvb2xlYW5UeXBlLFxuICAgIG92ZXJsb2FkczogW1tbQm9vbGVhblR5cGUsIEJvb2xlYW5UeXBlXSwgZnVuY3Rpb24gKGN0eCwgX3JlZjk1KSB7XG4gICAgICB2YXIgX3JlZjk2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjk1LCAyKSxcbiAgICAgICAgICBhID0gX3JlZjk2WzBdLFxuICAgICAgICAgIGIgPSBfcmVmOTZbMV07XG5cbiAgICAgIHJldHVybiBhLmV2YWx1YXRlKGN0eCkgJiYgYi5ldmFsdWF0ZShjdHgpO1xuICAgIH1dLCBbdmFyYXJncyhCb29sZWFuVHlwZSksIGZ1bmN0aW9uIChjdHgsIGFyZ3MpIHtcbiAgICAgIHZhciBfaXRlcmF0b3IzNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGFyZ3MpLFxuICAgICAgICAgIF9zdGVwMzc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMzcucygpOyAhKF9zdGVwMzcgPSBfaXRlcmF0b3IzNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGFyZyA9IF9zdGVwMzcudmFsdWU7XG4gICAgICAgICAgaWYgKCFhcmcuZXZhbHVhdGUoY3R4KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMzcuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMzcuZigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XV1cbiAgfSxcbiAgJ2FueSc6IHtcbiAgICB0eXBlOiBCb29sZWFuVHlwZSxcbiAgICBvdmVybG9hZHM6IFtbW0Jvb2xlYW5UeXBlLCBCb29sZWFuVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY5Nykge1xuICAgICAgdmFyIF9yZWY5OCA9IF9zbGljZWRUb0FycmF5KF9yZWY5NywgMiksXG4gICAgICAgICAgYSA9IF9yZWY5OFswXSxcbiAgICAgICAgICBiID0gX3JlZjk4WzFdO1xuXG4gICAgICByZXR1cm4gYS5ldmFsdWF0ZShjdHgpIHx8IGIuZXZhbHVhdGUoY3R4KTtcbiAgICB9XSwgW3ZhcmFyZ3MoQm9vbGVhblR5cGUpLCBmdW5jdGlvbiAoY3R4LCBhcmdzKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMzggPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhcmdzKSxcbiAgICAgICAgICBfc3RlcDM4O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjM4LnMoKTsgIShfc3RlcDM4ID0gX2l0ZXJhdG9yMzgubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBhcmcgPSBfc3RlcDM4LnZhbHVlO1xuICAgICAgICAgIGlmIChhcmcuZXZhbHVhdGUoY3R4KSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzOC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IzOC5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XV1cbiAgfSxcbiAgJyEnOiBbQm9vbGVhblR5cGUsIFtCb29sZWFuVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWY5OSkge1xuICAgIHZhciBfcmVmMTAwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjk5LCAxKSxcbiAgICAgICAgYiA9IF9yZWYxMDBbMF07XG5cbiAgICByZXR1cm4gIWIuZXZhbHVhdGUoY3R4KTtcbiAgfV0sXG4gICdpcy1zdXBwb3J0ZWQtc2NyaXB0JzogW0Jvb2xlYW5UeXBlLCBbU3RyaW5nVHlwZV0sIGZ1bmN0aW9uIChjdHgsIF9yZWYxMDEpIHtcbiAgICB2YXIgX3JlZjEwMiA9IF9zbGljZWRUb0FycmF5KF9yZWYxMDEsIDEpLFxuICAgICAgICBzID0gX3JlZjEwMlswXTtcblxuICAgIHZhciBpc1N1cHBvcnRlZFNjcmlwdCA9IGN0eC5nbG9iYWxzICYmIGN0eC5nbG9iYWxzLmlzU3VwcG9ydGVkU2NyaXB0O1xuXG4gICAgaWYgKGlzU3VwcG9ydGVkU2NyaXB0KSB7XG4gICAgICByZXR1cm4gaXNTdXBwb3J0ZWRTY3JpcHQocy5ldmFsdWF0ZShjdHgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfV0sXG4gICd1cGNhc2UnOiBbU3RyaW5nVHlwZSwgW1N0cmluZ1R5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMTAzKSB7XG4gICAgdmFyIF9yZWYxMDQgPSBfc2xpY2VkVG9BcnJheShfcmVmMTAzLCAxKSxcbiAgICAgICAgcyA9IF9yZWYxMDRbMF07XG5cbiAgICByZXR1cm4gcy5ldmFsdWF0ZShjdHgpLnRvVXBwZXJDYXNlKCk7XG4gIH1dLFxuICAnZG93bmNhc2UnOiBbU3RyaW5nVHlwZSwgW1N0cmluZ1R5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMTA1KSB7XG4gICAgdmFyIF9yZWYxMDYgPSBfc2xpY2VkVG9BcnJheShfcmVmMTA1LCAxKSxcbiAgICAgICAgcyA9IF9yZWYxMDZbMF07XG5cbiAgICByZXR1cm4gcy5ldmFsdWF0ZShjdHgpLnRvTG93ZXJDYXNlKCk7XG4gIH1dLFxuICAnY29uY2F0JzogW1N0cmluZ1R5cGUsIHZhcmFyZ3MoVmFsdWVUeXBlKSwgZnVuY3Rpb24gKGN0eCwgYXJncykge1xuICAgIHJldHVybiBhcmdzLm1hcChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmckMShhcmcuZXZhbHVhdGUoY3R4KSk7XG4gICAgfSkuam9pbignJyk7XG4gIH1dLFxuICAncmVzb2x2ZWQtbG9jYWxlJzogW1N0cmluZ1R5cGUsIFtDb2xsYXRvclR5cGVdLCBmdW5jdGlvbiAoY3R4LCBfcmVmMTA3KSB7XG4gICAgdmFyIF9yZWYxMDggPSBfc2xpY2VkVG9BcnJheShfcmVmMTA3LCAxKSxcbiAgICAgICAgY29sbGF0b3IgPSBfcmVmMTA4WzBdO1xuXG4gICAgcmV0dXJuIGNvbGxhdG9yLmV2YWx1YXRlKGN0eCkucmVzb2x2ZWRMb2NhbGUoKTtcbiAgfV1cbn0pO1xuXG5mdW5jdGlvbiBzdWNjZXNzKHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiAnc3VjY2VzcycsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGVycm9yKHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdWx0OiAnZXJyb3InLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBzdXBwb3J0c1Byb3BlcnR5RXhwcmVzc2lvbihzcGVjKSB7XG4gIHJldHVybiBzcGVjWydwcm9wZXJ0eS10eXBlJ10gPT09ICdkYXRhLWRyaXZlbicgfHwgc3BlY1sncHJvcGVydHktdHlwZSddID09PSAnY3Jvc3MtZmFkZWQtZGF0YS1kcml2ZW4nO1xufVxuXG5mdW5jdGlvbiBzdXBwb3J0c1pvb21FeHByZXNzaW9uKHNwZWMpIHtcbiAgcmV0dXJuICEhc3BlYy5leHByZXNzaW9uICYmIHNwZWMuZXhwcmVzc2lvbi5wYXJhbWV0ZXJzLmluZGV4T2YoJ3pvb20nKSA+IC0xO1xufVxuXG5mdW5jdGlvbiBzdXBwb3J0c0ludGVycG9sYXRpb24oc3BlYykge1xuICByZXR1cm4gISFzcGVjLmV4cHJlc3Npb24gJiYgc3BlYy5leHByZXNzaW9uLmludGVycG9sYXRlZDtcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgIHJldHVybiAnbnVtYmVyJztcbiAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICByZXR1cm4gJ3N0cmluZyc7XG4gIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgIHJldHVybiAnYm9vbGVhbic7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uJDEodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eUZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykge1xuICB2YXIgaXNDb2xvciA9IHByb3BlcnR5U3BlYy50eXBlID09PSAnY29sb3InO1xuICB2YXIgem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgPSBwYXJhbWV0ZXJzLnN0b3BzICYmIHR5cGVvZiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzBdID09PSAnb2JqZWN0JztcbiAgdmFyIGZlYXR1cmVEZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCBwYXJhbWV0ZXJzLnByb3BlcnR5ICE9PSB1bmRlZmluZWQ7XG4gIHZhciB6b29tRGVwZW5kZW50ID0gem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgfHwgIWZlYXR1cmVEZXBlbmRlbnQ7XG4gIHZhciB0eXBlID0gcGFyYW1ldGVycy50eXBlIHx8IChzdXBwb3J0c0ludGVycG9sYXRpb24ocHJvcGVydHlTcGVjKSA/ICdleHBvbmVudGlhbCcgOiAnaW50ZXJ2YWwnKTtcblxuICBpZiAoaXNDb2xvcikge1xuICAgIHBhcmFtZXRlcnMgPSBleHRlbmQoe30sIHBhcmFtZXRlcnMpO1xuXG4gICAgaWYgKHBhcmFtZXRlcnMuc3RvcHMpIHtcbiAgICAgIHBhcmFtZXRlcnMuc3RvcHMgPSBwYXJhbWV0ZXJzLnN0b3BzLm1hcChmdW5jdGlvbiAoc3RvcCkge1xuICAgICAgICByZXR1cm4gW3N0b3BbMF0sIENvbG9yLnBhcnNlKHN0b3BbMV0pXTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChwYXJhbWV0ZXJzLmRlZmF1bHQpIHtcbiAgICAgIHBhcmFtZXRlcnMuZGVmYXVsdCA9IENvbG9yLnBhcnNlKHBhcmFtZXRlcnMuZGVmYXVsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtZXRlcnMuZGVmYXVsdCA9IENvbG9yLnBhcnNlKHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFyYW1ldGVycy5jb2xvclNwYWNlICYmIHBhcmFtZXRlcnMuY29sb3JTcGFjZSAhPT0gJ3JnYicgJiYgIWNvbG9yU3BhY2VzW3BhcmFtZXRlcnMuY29sb3JTcGFjZV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbG9yIHNwYWNlOiBcIi5jb25jYXQocGFyYW1ldGVycy5jb2xvclNwYWNlKSk7XG4gIH1cblxuICB2YXIgaW5uZXJGdW47XG4gIHZhciBoYXNoZWRTdG9wcztcbiAgdmFyIGNhdGVnb3JpY2FsS2V5VHlwZTtcblxuICBpZiAodHlwZSA9PT0gJ2V4cG9uZW50aWFsJykge1xuICAgIGlubmVyRnVuID0gZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnRlcnZhbCcpIHtcbiAgICBpbm5lckZ1biA9IGV2YWx1YXRlSW50ZXJ2YWxGdW5jdGlvbjtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnKSB7XG4gICAgaW5uZXJGdW4gPSBldmFsdWF0ZUNhdGVnb3JpY2FsRnVuY3Rpb247XG4gICAgaGFzaGVkU3RvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdmFyIF9pdGVyYXRvcjM5ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGFyYW1ldGVycy5zdG9wcyksXG4gICAgICAgIF9zdGVwMzk7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IzOS5zKCk7ICEoX3N0ZXAzOSA9IF9pdGVyYXRvcjM5Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIHN0b3AgPSBfc3RlcDM5LnZhbHVlO1xuICAgICAgICBoYXNoZWRTdG9wc1tzdG9wWzBdXSA9IHN0b3BbMV07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3IzOS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjM5LmYoKTtcbiAgICB9XG5cbiAgICBjYXRlZ29yaWNhbEtleVR5cGUgPSB0eXBlb2YgcGFyYW1ldGVycy5zdG9wc1swXVswXTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnaWRlbnRpdHknKSB7XG4gICAgaW5uZXJGdW4gPSBldmFsdWF0ZUlkZW50aXR5RnVuY3Rpb247XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBmdW5jdGlvbiB0eXBlIFxcXCJcIi5jb25jYXQodHlwZSwgXCJcXFwiXCIpKTtcbiAgfVxuXG4gIGlmICh6b29tQW5kRmVhdHVyZURlcGVuZGVudCkge1xuICAgIHZhciBmZWF0dXJlRnVuY3Rpb25zID0ge307XG4gICAgdmFyIHpvb21TdG9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDsgcysrKSB7XG4gICAgICB2YXIgX3N0b3AgPSBwYXJhbWV0ZXJzLnN0b3BzW3NdO1xuICAgICAgdmFyIHpvb20gPSBfc3RvcFswXS56b29tO1xuXG4gICAgICBpZiAoZmVhdHVyZUZ1bmN0aW9uc1t6b29tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZlYXR1cmVGdW5jdGlvbnNbem9vbV0gPSB7XG4gICAgICAgICAgem9vbTogem9vbSxcbiAgICAgICAgICB0eXBlOiBwYXJhbWV0ZXJzLnR5cGUsXG4gICAgICAgICAgcHJvcGVydHk6IHBhcmFtZXRlcnMucHJvcGVydHksXG4gICAgICAgICAgZGVmYXVsdDogcGFyYW1ldGVycy5kZWZhdWx0LFxuICAgICAgICAgIHN0b3BzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB6b29tU3RvcHMucHVzaCh6b29tKTtcbiAgICAgIH1cblxuICAgICAgZmVhdHVyZUZ1bmN0aW9uc1t6b29tXS5zdG9wcy5wdXNoKFtfc3RvcFswXS52YWx1ZSwgX3N0b3BbMV1dKTtcbiAgICB9XG5cbiAgICB2YXIgZmVhdHVyZUZ1bmN0aW9uU3RvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIF9pNyA9IDAsIF96b29tU3RvcHMgPSB6b29tU3RvcHM7IF9pNyA8IF96b29tU3RvcHMubGVuZ3RoOyBfaTcrKykge1xuICAgICAgdmFyIHogPSBfem9vbVN0b3BzW19pN107XG4gICAgICBmZWF0dXJlRnVuY3Rpb25TdG9wcy5wdXNoKFtmZWF0dXJlRnVuY3Rpb25zW3pdLnpvb20sIGNyZWF0ZUZ1bmN0aW9uKGZlYXR1cmVGdW5jdGlvbnNbel0sIHByb3BlcnR5U3BlYyldKTtcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJwb2xhdGlvblR5cGUgPSB7XG4gICAgICBuYW1lOiAnbGluZWFyJ1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6ICdjb21wb3NpdGUnLFxuICAgICAgaW50ZXJwb2xhdGlvblR5cGU6IGludGVycG9sYXRpb25UeXBlLFxuICAgICAgaW50ZXJwb2xhdGlvbkZhY3RvcjogSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvci5iaW5kKHVuZGVmaW5lZCwgaW50ZXJwb2xhdGlvblR5cGUpLFxuICAgICAgem9vbVN0b3BzOiBmZWF0dXJlRnVuY3Rpb25TdG9wcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHNbMF07XG4gICAgICB9KSxcbiAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiBldmFsdWF0ZShfcmVmMTA5LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciB6b29tID0gX3JlZjEwOS56b29tO1xuICAgICAgICByZXR1cm4gZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uKHtcbiAgICAgICAgICBzdG9wczogZmVhdHVyZUZ1bmN0aW9uU3RvcHMsXG4gICAgICAgICAgYmFzZTogcGFyYW1ldGVycy5iYXNlXG4gICAgICAgIH0sIHByb3BlcnR5U3BlYywgem9vbSkuZXZhbHVhdGUoem9vbSwgcHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh6b29tRGVwZW5kZW50KSB7XG4gICAgdmFyIF9pbnRlcnBvbGF0aW9uVHlwZSA9IHR5cGUgPT09ICdleHBvbmVudGlhbCcgPyB7XG4gICAgICBuYW1lOiAnZXhwb25lbnRpYWwnLFxuICAgICAgYmFzZTogcGFyYW1ldGVycy5iYXNlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmJhc2UgOiAxXG4gICAgfSA6IG51bGw7XG5cbiAgICByZXR1cm4ge1xuICAgICAga2luZDogJ2NhbWVyYScsXG4gICAgICBpbnRlcnBvbGF0aW9uVHlwZTogX2ludGVycG9sYXRpb25UeXBlLFxuICAgICAgaW50ZXJwb2xhdGlvbkZhY3RvcjogSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvci5iaW5kKHVuZGVmaW5lZCwgX2ludGVycG9sYXRpb25UeXBlKSxcbiAgICAgIHpvb21TdG9wczogcGFyYW1ldGVycy5zdG9wcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuIHNbMF07XG4gICAgICB9KSxcbiAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiBldmFsdWF0ZShfcmVmMTEwKSB7XG4gICAgICAgIHZhciB6b29tID0gX3JlZjExMC56b29tO1xuICAgICAgICByZXR1cm4gaW5uZXJGdW4ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCB6b29tLCBoYXNoZWRTdG9wcywgY2F0ZWdvcmljYWxLZXlUeXBlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBraW5kOiAnc291cmNlJyxcbiAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiBldmFsdWF0ZShfLCBmZWF0dXJlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGZlYXR1cmUgJiYgZmVhdHVyZS5wcm9wZXJ0aWVzID8gZmVhdHVyZS5wcm9wZXJ0aWVzW3BhcmFtZXRlcnMucHJvcGVydHldIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGNvYWxlc2NlKHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlubmVyRnVuKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgdmFsdWUsIGhhc2hlZFN0b3BzLCBjYXRlZ29yaWNhbEtleVR5cGUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gY29hbGVzY2UoYSwgYiwgYykge1xuICBpZiAoYSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYTtcbiAgaWYgKGIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGI7XG4gIGlmIChjICE9PSB1bmRlZmluZWQpIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBldmFsdWF0ZUNhdGVnb3JpY2FsRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBpbnB1dCwgaGFzaGVkU3RvcHMsIGtleVR5cGUpIHtcbiAgdmFyIGV2YWx1YXRlZCA9IHR5cGVvZiBpbnB1dCA9PT0ga2V5VHlwZSA/IGhhc2hlZFN0b3BzW2lucHV0XSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGNvYWxlc2NlKGV2YWx1YXRlZCwgcGFyYW1ldGVycy5kZWZhdWx0LCBwcm9wZXJ0eVNwZWMuZGVmYXVsdCk7XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJ2YWxGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0KSB7XG4gIGlmIChnZXRUeXBlKGlucHV0KSAhPT0gJ251bWJlcicpIHJldHVybiBjb2FsZXNjZShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbiAgdmFyIG4gPSBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDtcbiAgaWYgKG4gPT09IDEpIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xuICBpZiAoaW5wdXQgPD0gcGFyYW1ldGVycy5zdG9wc1swXVswXSkgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07XG4gIGlmIChpbnB1dCA+PSBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVswXSkgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzFdO1xuICB2YXIgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHBhcmFtZXRlcnMuc3RvcHMubWFwKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgcmV0dXJuIHN0b3BbMF07XG4gIH0pLCBpbnB1dCk7XG4gIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4XVsxXTtcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVFeHBvbmVudGlhbEZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgaW5wdXQpIHtcbiAgdmFyIGJhc2UgPSBwYXJhbWV0ZXJzLmJhc2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYmFzZSA6IDE7XG4gIGlmIChnZXRUeXBlKGlucHV0KSAhPT0gJ251bWJlcicpIHJldHVybiBjb2FsZXNjZShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KTtcbiAgdmFyIG4gPSBwYXJhbWV0ZXJzLnN0b3BzLmxlbmd0aDtcbiAgaWYgKG4gPT09IDEpIHJldHVybiBwYXJhbWV0ZXJzLnN0b3BzWzBdWzFdO1xuICBpZiAoaW5wdXQgPD0gcGFyYW1ldGVycy5zdG9wc1swXVswXSkgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbMF1bMV07XG4gIGlmIChpbnB1dCA+PSBwYXJhbWV0ZXJzLnN0b3BzW24gLSAxXVswXSkgcmV0dXJuIHBhcmFtZXRlcnMuc3RvcHNbbiAtIDFdWzFdO1xuICB2YXIgaW5kZXggPSBmaW5kU3RvcExlc3NUaGFuT3JFcXVhbFRvKHBhcmFtZXRlcnMuc3RvcHMubWFwKGZ1bmN0aW9uIChzdG9wKSB7XG4gICAgcmV0dXJuIHN0b3BbMF07XG4gIH0pLCBpbnB1dCk7XG4gIHZhciB0ID0gaW50ZXJwb2xhdGlvbkZhY3RvcihpbnB1dCwgYmFzZSwgcGFyYW1ldGVycy5zdG9wc1tpbmRleF1bMF0sIHBhcmFtZXRlcnMuc3RvcHNbaW5kZXggKyAxXVswXSk7XG4gIHZhciBvdXRwdXRMb3dlciA9IHBhcmFtZXRlcnMuc3RvcHNbaW5kZXhdWzFdO1xuICB2YXIgb3V0cHV0VXBwZXIgPSBwYXJhbWV0ZXJzLnN0b3BzW2luZGV4ICsgMV1bMV07XG4gIHZhciBpbnRlcnAgPSBpbnRlcnBvbGF0ZVtwcm9wZXJ0eVNwZWMudHlwZV0gfHwgaWRlbnRpdHlGdW5jdGlvbjtcblxuICBpZiAocGFyYW1ldGVycy5jb2xvclNwYWNlICYmIHBhcmFtZXRlcnMuY29sb3JTcGFjZSAhPT0gJ3JnYicpIHtcbiAgICB2YXIgY29sb3JzcGFjZSA9IGNvbG9yU3BhY2VzW3BhcmFtZXRlcnMuY29sb3JTcGFjZV07XG5cbiAgICBpbnRlcnAgPSBmdW5jdGlvbiBpbnRlcnAoYSwgYikge1xuICAgICAgcmV0dXJuIGNvbG9yc3BhY2UucmV2ZXJzZShjb2xvcnNwYWNlLmludGVycG9sYXRlKGNvbG9yc3BhY2UuZm9yd2FyZChhKSwgY29sb3JzcGFjZS5mb3J3YXJkKGIpLCB0KSk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3V0cHV0TG93ZXIuZXZhbHVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIGV2YWx1YXRlKCkge1xuICAgICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjM7IF9rZXk1KyspIHtcbiAgICAgICAgICBhcmdzW19rZXk1XSA9IGFyZ3VtZW50c1tfa2V5NV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXZhbHVhdGVkTG93ZXIgPSBvdXRwdXRMb3dlci5ldmFsdWF0ZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICB2YXIgZXZhbHVhdGVkVXBwZXIgPSBvdXRwdXRVcHBlci5ldmFsdWF0ZS5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuXG4gICAgICAgIGlmIChldmFsdWF0ZWRMb3dlciA9PT0gdW5kZWZpbmVkIHx8IGV2YWx1YXRlZFVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGludGVycChldmFsdWF0ZWRMb3dlciwgZXZhbHVhdGVkVXBwZXIsIHQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gaW50ZXJwKG91dHB1dExvd2VyLCBvdXRwdXRVcHBlciwgdCk7XG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlSWRlbnRpdHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIGlucHV0KSB7XG4gIGlmIChwcm9wZXJ0eVNwZWMudHlwZSA9PT0gJ2NvbG9yJykge1xuICAgIGlucHV0ID0gQ29sb3IucGFyc2UoaW5wdXQpO1xuICB9IGVsc2UgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAnZm9ybWF0dGVkJykge1xuICAgIGlucHV0ID0gRm9ybWF0dGVkLmZyb21TdHJpbmcoaW5wdXQudG9TdHJpbmcoKSk7XG4gIH0gZWxzZSBpZiAocHJvcGVydHlTcGVjLnR5cGUgPT09ICdyZXNvbHZlZEltYWdlJykge1xuICAgIGlucHV0ID0gUmVzb2x2ZWRJbWFnZS5mcm9tU3RyaW5nKGlucHV0LnRvU3RyaW5nKCkpO1xuICB9IGVsc2UgaWYgKGdldFR5cGUoaW5wdXQpICE9PSBwcm9wZXJ0eVNwZWMudHlwZSAmJiAocHJvcGVydHlTcGVjLnR5cGUgIT09ICdlbnVtJyB8fCAhcHJvcGVydHlTcGVjLnZhbHVlc1tpbnB1dF0pKSB7XG4gICAgaW5wdXQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gY29hbGVzY2UoaW5wdXQsIHBhcmFtZXRlcnMuZGVmYXVsdCwgcHJvcGVydHlTcGVjLmRlZmF1bHQpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0aW9uRmFjdG9yKGlucHV0LCBiYXNlLCBsb3dlclZhbHVlLCB1cHBlclZhbHVlKSB7XG4gIHZhciBkaWZmZXJlbmNlID0gdXBwZXJWYWx1ZSAtIGxvd2VyVmFsdWU7XG4gIHZhciBwcm9ncmVzcyA9IGlucHV0IC0gbG93ZXJWYWx1ZTtcblxuICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGJhc2UgPT09IDEpIHtcbiAgICByZXR1cm4gcHJvZ3Jlc3MgLyBkaWZmZXJlbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoTWF0aC5wb3coYmFzZSwgcHJvZ3Jlc3MpIC0gMSkgLyAoTWF0aC5wb3coYmFzZSwgZGlmZmVyZW5jZSkgLSAxKTtcbiAgfVxufVxuXG52YXIgU3R5bGVFeHByZXNzaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3R5bGVFeHByZXNzaW9uKGV4cHJlc3Npb24sIHByb3BlcnR5U3BlYykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHlsZUV4cHJlc3Npb24pO1xuXG4gICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB0aGlzLl93YXJuaW5nSGlzdG9yeSA9IHt9O1xuICAgIHRoaXMuX2V2YWx1YXRvciA9IG5ldyBFdmFsdWF0aW9uQ29udGV4dCgpO1xuICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IHByb3BlcnR5U3BlYyA/IGdldERlZmF1bHRWYWx1ZShwcm9wZXJ0eVNwZWMpIDogbnVsbDtcbiAgICB0aGlzLl9lbnVtVmFsdWVzID0gcHJvcGVydHlTcGVjICYmIHByb3BlcnR5U3BlYy50eXBlID09PSAnZW51bScgPyBwcm9wZXJ0eVNwZWMudmFsdWVzIDogbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdHlsZUV4cHJlc3Npb24sIFt7XG4gICAga2V5OiBcImV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgICB0aGlzLl9ldmFsdWF0b3IuZ2xvYmFscyA9IGdsb2JhbHM7XG4gICAgICB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZVN0YXRlID0gZmVhdHVyZVN0YXRlO1xuICAgICAgdGhpcy5fZXZhbHVhdG9yLmNhbm9uaWNhbCA9IGNhbm9uaWNhbDtcbiAgICAgIHRoaXMuX2V2YWx1YXRvci5hdmFpbGFibGVJbWFnZXMgPSBhdmFpbGFibGVJbWFnZXMgfHwgbnVsbDtcbiAgICAgIHRoaXMuX2V2YWx1YXRvci5mb3JtYXR0ZWRTZWN0aW9uID0gZm9ybWF0dGVkU2VjdGlvbjtcbiAgICAgIHJldHVybiB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUodGhpcy5fZXZhbHVhdG9yKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZXZhbHVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGUoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbikge1xuICAgICAgdGhpcy5fZXZhbHVhdG9yLmdsb2JhbHMgPSBnbG9iYWxzO1xuICAgICAgdGhpcy5fZXZhbHVhdG9yLmZlYXR1cmUgPSBmZWF0dXJlIHx8IG51bGw7XG4gICAgICB0aGlzLl9ldmFsdWF0b3IuZmVhdHVyZVN0YXRlID0gZmVhdHVyZVN0YXRlIHx8IG51bGw7XG4gICAgICB0aGlzLl9ldmFsdWF0b3IuY2Fub25pY2FsID0gY2Fub25pY2FsO1xuICAgICAgdGhpcy5fZXZhbHVhdG9yLmF2YWlsYWJsZUltYWdlcyA9IGF2YWlsYWJsZUltYWdlcyB8fCBudWxsO1xuICAgICAgdGhpcy5fZXZhbHVhdG9yLmZvcm1hdHRlZFNlY3Rpb24gPSBmb3JtYXR0ZWRTZWN0aW9uIHx8IG51bGw7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmV4cHJlc3Npb24uZXZhbHVhdGUodGhpcy5fZXZhbHVhdG9yKTtcblxuICAgICAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIHZhbCAhPT0gdmFsKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9lbnVtVmFsdWVzICYmICEodmFsIGluIHRoaXMuX2VudW1WYWx1ZXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcIkV4cGVjdGVkIHZhbHVlIHRvIGJlIG9uZSBvZiBcIi5jb25jYXQoT2JqZWN0LmtleXModGhpcy5fZW51bVZhbHVlcykubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgICAgfSkuam9pbignLCAnKSwgXCIsIGJ1dCBmb3VuZCBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KHZhbCksIFwiIGluc3RlYWQuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghdGhpcy5fd2FybmluZ0hpc3RvcnlbZS5tZXNzYWdlXSkge1xuICAgICAgICAgIHRoaXMuX3dhcm5pbmdIaXN0b3J5W2UubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGUubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3R5bGVFeHByZXNzaW9uO1xufSgpO1xuXG5mdW5jdGlvbiBpc0V4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShleHByZXNzaW9uKSAmJiBleHByZXNzaW9uLmxlbmd0aCA+IDAgJiYgdHlwZW9mIGV4cHJlc3Npb25bMF0gPT09ICdzdHJpbmcnICYmIGV4cHJlc3Npb25bMF0gaW4gZXhwcmVzc2lvbnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV4cHJlc3Npb24oZXhwcmVzc2lvbiwgcHJvcGVydHlTcGVjKSB7XG4gIHZhciBwYXJzZXIgPSBuZXcgUGFyc2luZ0NvbnRleHQoZXhwcmVzc2lvbnMsIFtdLCBwcm9wZXJ0eVNwZWMgPyBnZXRFeHBlY3RlZFR5cGUocHJvcGVydHlTcGVjKSA6IHVuZGVmaW5lZCk7XG4gIHZhciBwYXJzZWQgPSBwYXJzZXIucGFyc2UoZXhwcmVzc2lvbiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgcHJvcGVydHlTcGVjICYmIHByb3BlcnR5U3BlYy50eXBlID09PSAnc3RyaW5nJyA/IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogJ2NvZXJjZSdcbiAgfSA6IHVuZGVmaW5lZCk7XG5cbiAgaWYgKCFwYXJzZWQpIHtcbiAgICByZXR1cm4gZXJyb3IocGFyc2VyLmVycm9ycyk7XG4gIH1cblxuICByZXR1cm4gc3VjY2VzcyhuZXcgU3R5bGVFeHByZXNzaW9uKHBhcnNlZCwgcHJvcGVydHlTcGVjKSk7XG59XG5cbnZhciBab29tQ29uc3RhbnRFeHByZXNzaW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWm9vbUNvbnN0YW50RXhwcmVzc2lvbihraW5kLCBleHByZXNzaW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFpvb21Db25zdGFudEV4cHJlc3Npb24pO1xuXG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLl9zdHlsZUV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IGtpbmQgIT09ICdjb25zdGFudCcgJiYgIWlzU3RhdGVDb25zdGFudChleHByZXNzaW9uLmV4cHJlc3Npb24pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFpvb21Db25zdGFudEV4cHJlc3Npb24sIFt7XG4gICAga2V5OiBcImV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGUoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFpvb21Db25zdGFudEV4cHJlc3Npb247XG59KCk7XG5cbnZhciBab29tRGVwZW5kZW50RXhwcmVzc2lvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFpvb21EZXBlbmRlbnRFeHByZXNzaW9uKGtpbmQsIGV4cHJlc3Npb24sIHpvb21TdG9wcywgaW50ZXJwb2xhdGlvblR5cGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWm9vbURlcGVuZGVudEV4cHJlc3Npb24pO1xuXG4gICAgdGhpcy5raW5kID0ga2luZDtcbiAgICB0aGlzLnpvb21TdG9wcyA9IHpvb21TdG9wcztcbiAgICB0aGlzLl9zdHlsZUV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIHRoaXMuaXNTdGF0ZURlcGVuZGVudCA9IGtpbmQgIT09ICdjYW1lcmEnICYmICFpc1N0YXRlQ29uc3RhbnQoZXhwcmVzc2lvbi5leHByZXNzaW9uKTtcbiAgICB0aGlzLmludGVycG9sYXRpb25UeXBlID0gaW50ZXJwb2xhdGlvblR5cGU7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWm9vbURlcGVuZGVudEV4cHJlc3Npb24sIFt7XG4gICAga2V5OiBcImV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZXZhbHVhdGVXaXRob3V0RXJyb3JIYW5kbGluZyhnbG9iYWxzLCBmZWF0dXJlLCBmZWF0dXJlU3RhdGUsIGNhbm9uaWNhbCwgYXZhaWxhYmxlSW1hZ2VzLCBmb3JtYXR0ZWRTZWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGVFeHByZXNzaW9uLmV2YWx1YXRlV2l0aG91dEVycm9ySGFuZGxpbmcoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV2YWx1YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV2YWx1YXRlKGdsb2JhbHMsIGZlYXR1cmUsIGZlYXR1cmVTdGF0ZSwgY2Fub25pY2FsLCBhdmFpbGFibGVJbWFnZXMsIGZvcm1hdHRlZFNlY3Rpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZUV4cHJlc3Npb24uZXZhbHVhdGUoZ2xvYmFscywgZmVhdHVyZSwgZmVhdHVyZVN0YXRlLCBjYW5vbmljYWwsIGF2YWlsYWJsZUltYWdlcywgZm9ybWF0dGVkU2VjdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImludGVycG9sYXRpb25GYWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW50ZXJwb2xhdGlvbkZhY3RvcihpbnB1dCwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAodGhpcy5pbnRlcnBvbGF0aW9uVHlwZSkge1xuICAgICAgICByZXR1cm4gSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGlvbkZhY3Rvcih0aGlzLmludGVycG9sYXRpb25UeXBlLCBpbnB1dCwgbG93ZXIsIHVwcGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBab29tRGVwZW5kZW50RXhwcmVzc2lvbjtcbn0oKTtcblxuZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uKGV4cHJlc3Npb24sIHByb3BlcnR5U3BlYykge1xuICBleHByZXNzaW9uID0gY3JlYXRlRXhwcmVzc2lvbihleHByZXNzaW9uLCBwcm9wZXJ0eVNwZWMpO1xuXG4gIGlmIChleHByZXNzaW9uLnJlc3VsdCA9PT0gJ2Vycm9yJykge1xuICAgIHJldHVybiBleHByZXNzaW9uO1xuICB9XG5cbiAgdmFyIHBhcnNlZCA9IGV4cHJlc3Npb24udmFsdWUuZXhwcmVzc2lvbjtcbiAgdmFyIGlzRmVhdHVyZUNvbnN0YW50JDEgPSBpc0ZlYXR1cmVDb25zdGFudChwYXJzZWQpO1xuXG4gIGlmICghaXNGZWF0dXJlQ29uc3RhbnQkMSAmJiAhc3VwcG9ydHNQcm9wZXJ0eUV4cHJlc3Npb24ocHJvcGVydHlTcGVjKSkge1xuICAgIHJldHVybiBlcnJvcihbbmV3IFBhcnNpbmdFcnJvcignJywgJ2RhdGEgZXhwcmVzc2lvbnMgbm90IHN1cHBvcnRlZCcpXSk7XG4gIH1cblxuICB2YXIgaXNab29tQ29uc3RhbnQgPSBpc0dsb2JhbFByb3BlcnR5Q29uc3RhbnQocGFyc2VkLCBbJ3pvb20nXSk7XG5cbiAgaWYgKCFpc1pvb21Db25zdGFudCAmJiAhc3VwcG9ydHNab29tRXhwcmVzc2lvbihwcm9wZXJ0eVNwZWMpKSB7XG4gICAgcmV0dXJuIGVycm9yKFtuZXcgUGFyc2luZ0Vycm9yKCcnLCAnem9vbSBleHByZXNzaW9ucyBub3Qgc3VwcG9ydGVkJyldKTtcbiAgfVxuXG4gIHZhciB6b29tQ3VydmUgPSBmaW5kWm9vbUN1cnZlKHBhcnNlZCk7XG5cbiAgaWYgKCF6b29tQ3VydmUgJiYgIWlzWm9vbUNvbnN0YW50KSB7XG4gICAgcmV0dXJuIGVycm9yKFtuZXcgUGFyc2luZ0Vycm9yKCcnLCAnXCJ6b29tXCIgZXhwcmVzc2lvbiBtYXkgb25seSBiZSB1c2VkIGFzIGlucHV0IHRvIGEgdG9wLWxldmVsIFwic3RlcFwiIG9yIFwiaW50ZXJwb2xhdGVcIiBleHByZXNzaW9uLicpXSk7XG4gIH0gZWxzZSBpZiAoem9vbUN1cnZlIGluc3RhbmNlb2YgUGFyc2luZ0Vycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yKFt6b29tQ3VydmVdKTtcbiAgfSBlbHNlIGlmICh6b29tQ3VydmUgaW5zdGFuY2VvZiBJbnRlcnBvbGF0ZSAmJiAhc3VwcG9ydHNJbnRlcnBvbGF0aW9uKHByb3BlcnR5U3BlYykpIHtcbiAgICByZXR1cm4gZXJyb3IoW25ldyBQYXJzaW5nRXJyb3IoJycsICdcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbnMgY2Fubm90IGJlIHVzZWQgd2l0aCB0aGlzIHByb3BlcnR5JyldKTtcbiAgfVxuXG4gIGlmICghem9vbUN1cnZlKSB7XG4gICAgcmV0dXJuIHN1Y2Nlc3MoaXNGZWF0dXJlQ29uc3RhbnQkMSA/IG5ldyBab29tQ29uc3RhbnRFeHByZXNzaW9uKCdjb25zdGFudCcsIGV4cHJlc3Npb24udmFsdWUpIDogbmV3IFpvb21Db25zdGFudEV4cHJlc3Npb24oJ3NvdXJjZScsIGV4cHJlc3Npb24udmFsdWUpKTtcbiAgfVxuXG4gIHZhciBpbnRlcnBvbGF0aW9uVHlwZSA9IHpvb21DdXJ2ZSBpbnN0YW5jZW9mIEludGVycG9sYXRlID8gem9vbUN1cnZlLmludGVycG9sYXRpb24gOiB1bmRlZmluZWQ7XG4gIHJldHVybiBzdWNjZXNzKGlzRmVhdHVyZUNvbnN0YW50JDEgPyBuZXcgWm9vbURlcGVuZGVudEV4cHJlc3Npb24oJ2NhbWVyYScsIGV4cHJlc3Npb24udmFsdWUsIHpvb21DdXJ2ZS5sYWJlbHMsIGludGVycG9sYXRpb25UeXBlKSA6IG5ldyBab29tRGVwZW5kZW50RXhwcmVzc2lvbignY29tcG9zaXRlJywgZXhwcmVzc2lvbi52YWx1ZSwgem9vbUN1cnZlLmxhYmVscywgaW50ZXJwb2xhdGlvblR5cGUpKTtcbn1cblxudmFyIFN0eWxlUHJvcGVydHlGdW5jdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0eWxlUHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBzcGVjaWZpY2F0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0eWxlUHJvcGVydHlGdW5jdGlvbik7XG5cbiAgICB0aGlzLl9wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcbiAgICB0aGlzLl9zcGVjaWZpY2F0aW9uID0gc3BlY2lmaWNhdGlvbjtcbiAgICBleHRlbmQodGhpcywgY3JlYXRlRnVuY3Rpb24odGhpcy5fcGFyYW1ldGVycywgdGhpcy5fc3BlY2lmaWNhdGlvbikpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0eWxlUHJvcGVydHlGdW5jdGlvbiwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZGVzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgICAgcmV0dXJuIG5ldyBTdHlsZVByb3BlcnR5RnVuY3Rpb24oc2VyaWFsaXplZC5fcGFyYW1ldGVycywgc2VyaWFsaXplZC5fc3BlY2lmaWNhdGlvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoaW5wdXQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIF9wYXJhbWV0ZXJzOiBpbnB1dC5fcGFyYW1ldGVycyxcbiAgICAgICAgX3NwZWNpZmljYXRpb246IGlucHV0Ll9zcGVjaWZpY2F0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdHlsZVByb3BlcnR5RnVuY3Rpb247XG59KCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BlcnR5RXhwcmVzc2lvbih2YWx1ZSwgc3BlY2lmaWNhdGlvbikge1xuICBpZiAoaXNGdW5jdGlvbiQxKHZhbHVlKSkge1xuICAgIHJldHVybiBuZXcgU3R5bGVQcm9wZXJ0eUZ1bmN0aW9uKHZhbHVlLCBzcGVjaWZpY2F0aW9uKTtcbiAgfSBlbHNlIGlmIChpc0V4cHJlc3Npb24odmFsdWUpKSB7XG4gICAgdmFyIF9leHByZXNzaW9uOCA9IGNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbih2YWx1ZSwgc3BlY2lmaWNhdGlvbik7XG5cbiAgICBpZiAoX2V4cHJlc3Npb244LnJlc3VsdCA9PT0gJ2Vycm9yJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKF9leHByZXNzaW9uOC52YWx1ZS5tYXAoZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoZXJyLmtleSwgXCI6IFwiKS5jb25jYXQoZXJyLm1lc3NhZ2UpO1xuICAgICAgfSkuam9pbignLCAnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leHByZXNzaW9uOC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29uc3RhbnQgPSB2YWx1ZTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHNwZWNpZmljYXRpb24udHlwZSA9PT0gJ2NvbG9yJykge1xuICAgICAgY29uc3RhbnQgPSBDb2xvci5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtpbmQ6ICdjb25zdGFudCcsXG4gICAgICBldmFsdWF0ZTogZnVuY3Rpb24gZXZhbHVhdGUoKSB7XG4gICAgICAgIHJldHVybiBjb25zdGFudDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRab29tQ3VydmUoZXhwcmVzc2lvbikge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcblxuICBpZiAoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIExldCkge1xuICAgIHJlc3VsdCA9IGZpbmRab29tQ3VydmUoZXhwcmVzc2lvbi5yZXN1bHQpO1xuICB9IGVsc2UgaWYgKGV4cHJlc3Npb24gaW5zdGFuY2VvZiBDb2FsZXNjZSkge1xuICAgIHZhciBfaXRlcmF0b3I0MCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGV4cHJlc3Npb24uYXJncyksXG4gICAgICAgIF9zdGVwNDA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I0MC5zKCk7ICEoX3N0ZXA0MCA9IF9pdGVyYXRvcjQwLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGFyZyA9IF9zdGVwNDAudmFsdWU7XG4gICAgICAgIHJlc3VsdCA9IGZpbmRab29tQ3VydmUoYXJnKTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjQwLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNDAuZigpO1xuICAgIH1cbiAgfSBlbHNlIGlmICgoZXhwcmVzc2lvbiBpbnN0YW5jZW9mIFN0ZXAgfHwgZXhwcmVzc2lvbiBpbnN0YW5jZW9mIEludGVycG9sYXRlKSAmJiBleHByZXNzaW9uLmlucHV0IGluc3RhbmNlb2YgQ29tcG91bmRFeHByZXNzaW9uICYmIGV4cHJlc3Npb24uaW5wdXQubmFtZSA9PT0gJ3pvb20nKSB7XG4gICAgcmVzdWx0ID0gZXhwcmVzc2lvbjtcbiAgfVxuXG4gIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQYXJzaW5nRXJyb3IpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZXhwcmVzc2lvbi5lYWNoQ2hpbGQoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgdmFyIGNoaWxkUmVzdWx0ID0gZmluZFpvb21DdXJ2ZShjaGlsZCk7XG5cbiAgICBpZiAoY2hpbGRSZXN1bHQgaW5zdGFuY2VvZiBQYXJzaW5nRXJyb3IpIHtcbiAgICAgIHJlc3VsdCA9IGNoaWxkUmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoIXJlc3VsdCAmJiBjaGlsZFJlc3VsdCkge1xuICAgICAgcmVzdWx0ID0gbmV3IFBhcnNpbmdFcnJvcignJywgJ1wiem9vbVwiIGV4cHJlc3Npb24gbWF5IG9ubHkgYmUgdXNlZCBhcyBpbnB1dCB0byBhIHRvcC1sZXZlbCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgZXhwcmVzc2lvbi4nKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdCAmJiBjaGlsZFJlc3VsdCAmJiByZXN1bHQgIT09IGNoaWxkUmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSBuZXcgUGFyc2luZ0Vycm9yKCcnLCAnT25seSBvbmUgem9vbS1iYXNlZCBcInN0ZXBcIiBvciBcImludGVycG9sYXRlXCIgc3ViZXhwcmVzc2lvbiBtYXkgYmUgdXNlZCBpbiBhbiBleHByZXNzaW9uLicpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldEV4cGVjdGVkVHlwZShzcGVjKSB7XG4gIHZhciB0eXBlcyA9IHtcbiAgICBjb2xvcjogQ29sb3JUeXBlLFxuICAgIHN0cmluZzogU3RyaW5nVHlwZSxcbiAgICBudW1iZXI6IE51bWJlclR5cGUsXG4gICAgZW51bTogU3RyaW5nVHlwZSxcbiAgICBib29sZWFuOiBCb29sZWFuVHlwZSxcbiAgICBmb3JtYXR0ZWQ6IEZvcm1hdHRlZFR5cGUsXG4gICAgcmVzb2x2ZWRJbWFnZTogUmVzb2x2ZWRJbWFnZVR5cGVcbiAgfTtcblxuICBpZiAoc3BlYy50eXBlID09PSAnYXJyYXknKSB7XG4gICAgcmV0dXJuIGFycmF5KHR5cGVzW3NwZWMudmFsdWVdIHx8IFZhbHVlVHlwZSwgc3BlYy5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVzW3NwZWMudHlwZV07XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRWYWx1ZShzcGVjKSB7XG4gIGlmIChzcGVjLnR5cGUgPT09ICdjb2xvcicgJiYgaXNGdW5jdGlvbiQxKHNwZWMuZGVmYXVsdCkpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKDAsIDAsIDAsIDApO1xuICB9IGVsc2UgaWYgKHNwZWMudHlwZSA9PT0gJ2NvbG9yJykge1xuICAgIHJldHVybiBDb2xvci5wYXJzZShzcGVjLmRlZmF1bHQpIHx8IG51bGw7XG4gIH0gZWxzZSBpZiAoc3BlYy5kZWZhdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3BlYy5kZWZhdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRMaXRlcmFsKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gWydsaXRlcmFsJywgdmFsdWVdIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpIHtcbiAgdmFyIHN0b3BzID0gcGFyYW1ldGVycy5zdG9wcztcblxuICBpZiAoIXN0b3BzKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRJZGVudGl0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYyk7XG4gIH1cblxuICB2YXIgem9vbUFuZEZlYXR1cmVEZXBlbmRlbnQgPSBzdG9wcyAmJiB0eXBlb2Ygc3RvcHNbMF1bMF0gPT09ICdvYmplY3QnO1xuICB2YXIgZmVhdHVyZURlcGVuZGVudCA9IHpvb21BbmRGZWF0dXJlRGVwZW5kZW50IHx8IHBhcmFtZXRlcnMucHJvcGVydHkgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHpvb21EZXBlbmRlbnQgPSB6b29tQW5kRmVhdHVyZURlcGVuZGVudCB8fCAhZmVhdHVyZURlcGVuZGVudDtcbiAgc3RvcHMgPSBzdG9wcy5tYXAoZnVuY3Rpb24gKHN0b3ApIHtcbiAgICBpZiAoIWZlYXR1cmVEZXBlbmRlbnQgJiYgcHJvcGVydHlTcGVjLnRva2VucyAmJiB0eXBlb2Ygc3RvcFsxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBbc3RvcFswXSwgY29udmVydFRva2VuU3RyaW5nKHN0b3BbMV0pXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3N0b3BbMF0sIGNvbnZlcnRMaXRlcmFsKHN0b3BbMV0pXTtcbiAgfSk7XG5cbiAgaWYgKHpvb21BbmRGZWF0dXJlRGVwZW5kZW50KSB7XG4gICAgcmV0dXJuIGNvbnZlcnRab29tQW5kUHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKTtcbiAgfSBlbHNlIGlmICh6b29tRGVwZW5kZW50KSB7XG4gICAgcmV0dXJuIGNvbnZlcnRab29tRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnZlcnRQcm9wZXJ0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYywgc3RvcHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRJZGVudGl0eUZ1bmN0aW9uKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykge1xuICB2YXIgZ2V0ID0gWydnZXQnLCBwYXJhbWV0ZXJzLnByb3BlcnR5XTtcblxuICBpZiAocGFyYW1ldGVycy5kZWZhdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvcGVydHlTcGVjLnR5cGUgPT09ICdzdHJpbmcnID8gWydzdHJpbmcnLCBnZXRdIDogZ2V0O1xuICB9IGVsc2UgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAnZW51bScpIHtcbiAgICByZXR1cm4gWydtYXRjaCcsIGdldCwgT2JqZWN0LmtleXMocHJvcGVydHlTcGVjLnZhbHVlcyksIGdldCwgcGFyYW1ldGVycy5kZWZhdWx0XTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2V4cHJlc3Npb245ID0gW3Byb3BlcnR5U3BlYy50eXBlID09PSAnY29sb3InID8gJ3RvLWNvbG9yJyA6IHByb3BlcnR5U3BlYy50eXBlLCBnZXQsIGNvbnZlcnRMaXRlcmFsKHBhcmFtZXRlcnMuZGVmYXVsdCldO1xuXG4gICAgaWYgKHByb3BlcnR5U3BlYy50eXBlID09PSAnYXJyYXknKSB7XG4gICAgICBfZXhwcmVzc2lvbjkuc3BsaWNlKDEsIDAsIHByb3BlcnR5U3BlYy52YWx1ZSwgcHJvcGVydHlTcGVjLmxlbmd0aCB8fCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4cHJlc3Npb245O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycykge1xuICBzd2l0Y2ggKHBhcmFtZXRlcnMuY29sb3JTcGFjZSkge1xuICAgIGNhc2UgJ2hjbCc6XG4gICAgICByZXR1cm4gJ2ludGVycG9sYXRlLWhjbCc7XG5cbiAgICBjYXNlICdsYWInOlxuICAgICAgcmV0dXJuICdpbnRlcnBvbGF0ZS1sYWInO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnaW50ZXJwb2xhdGUnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRab29tQW5kUHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKSB7XG4gIHZhciBmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzID0ge307XG4gIHZhciBmZWF0dXJlRnVuY3Rpb25TdG9wcyA9IHt9O1xuICB2YXIgem9vbVN0b3BzID0gW107XG5cbiAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdG9wcy5sZW5ndGg7IHMrKykge1xuICAgIHZhciBzdG9wID0gc3RvcHNbc107XG4gICAgdmFyIHpvb20gPSBzdG9wWzBdLnpvb207XG5cbiAgICBpZiAoZmVhdHVyZUZ1bmN0aW9uUGFyYW1ldGVyc1t6b29tXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW3pvb21dID0ge1xuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICB0eXBlOiBwYXJhbWV0ZXJzLnR5cGUsXG4gICAgICAgIHByb3BlcnR5OiBwYXJhbWV0ZXJzLnByb3BlcnR5LFxuICAgICAgICBkZWZhdWx0OiBwYXJhbWV0ZXJzLmRlZmF1bHRcbiAgICAgIH07XG4gICAgICBmZWF0dXJlRnVuY3Rpb25TdG9wc1t6b29tXSA9IFtdO1xuICAgICAgem9vbVN0b3BzLnB1c2goem9vbSk7XG4gICAgfVxuXG4gICAgZmVhdHVyZUZ1bmN0aW9uU3RvcHNbem9vbV0ucHVzaChbc3RvcFswXS52YWx1ZSwgc3RvcFsxXV0pO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uVHlwZSA9IGdldEZ1bmN0aW9uVHlwZSh7fSwgcHJvcGVydHlTcGVjKTtcblxuICBpZiAoZnVuY3Rpb25UeXBlID09PSAnZXhwb25lbnRpYWwnKSB7XG4gICAgdmFyIF9leHByZXNzaW9uMTAgPSBbZ2V0SW50ZXJwb2xhdGVPcGVyYXRvcihwYXJhbWV0ZXJzKSwgWydsaW5lYXInXSwgWyd6b29tJ11dO1xuXG4gICAgdmFyIF9pdGVyYXRvcjQxID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoem9vbVN0b3BzKSxcbiAgICAgICAgX3N0ZXA0MTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjQxLnMoKTsgIShfc3RlcDQxID0gX2l0ZXJhdG9yNDEubigpKS5kb25lOykge1xuICAgICAgICB2YXIgeiA9IF9zdGVwNDEudmFsdWU7XG4gICAgICAgIHZhciBvdXRwdXQgPSBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihmZWF0dXJlRnVuY3Rpb25QYXJhbWV0ZXJzW3pdLCBwcm9wZXJ0eVNwZWMsIGZlYXR1cmVGdW5jdGlvblN0b3BzW3pdKTtcbiAgICAgICAgYXBwZW5kU3RvcFBhaXIoX2V4cHJlc3Npb24xMCwgeiwgb3V0cHV0LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I0MS5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjQxLmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V4cHJlc3Npb24xMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2V4cHJlc3Npb24xMSA9IFsnc3RlcCcsIFsnem9vbSddXTtcblxuICAgIHZhciBfaXRlcmF0b3I0MiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHpvb21TdG9wcyksXG4gICAgICAgIF9zdGVwNDI7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I0Mi5zKCk7ICEoX3N0ZXA0MiA9IF9pdGVyYXRvcjQyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF96ID0gX3N0ZXA0Mi52YWx1ZTtcblxuICAgICAgICB2YXIgX291dHB1dCA9IGNvbnZlcnRQcm9wZXJ0eUZ1bmN0aW9uKGZlYXR1cmVGdW5jdGlvblBhcmFtZXRlcnNbX3pdLCBwcm9wZXJ0eVNwZWMsIGZlYXR1cmVGdW5jdGlvblN0b3BzW196XSk7XG5cbiAgICAgICAgYXBwZW5kU3RvcFBhaXIoX2V4cHJlc3Npb24xMSwgX3osIF9vdXRwdXQsIHRydWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNDIuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I0Mi5mKCk7XG4gICAgfVxuXG4gICAgZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKF9leHByZXNzaW9uMTEpO1xuICAgIHJldHVybiBfZXhwcmVzc2lvbjExO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvYWxlc2NlJDEoYSwgYikge1xuICBpZiAoYSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYTtcbiAgaWYgKGIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGI7XG59XG5cbmZ1bmN0aW9uIGdldEZhbGxiYWNrKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykge1xuICB2YXIgZGVmYXVsdFZhbHVlID0gY29udmVydExpdGVyYWwoY29hbGVzY2UkMShwYXJhbWV0ZXJzLmRlZmF1bHQsIHByb3BlcnR5U3BlYy5kZWZhdWx0KSk7XG5cbiAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIHByb3BlcnR5U3BlYy50eXBlID09PSAncmVzb2x2ZWRJbWFnZScpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0UHJvcGVydHlGdW5jdGlvbihwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMsIHN0b3BzKSB7XG4gIHZhciB0eXBlID0gZ2V0RnVuY3Rpb25UeXBlKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYyk7XG4gIHZhciBnZXQgPSBbJ2dldCcsIHBhcmFtZXRlcnMucHJvcGVydHldO1xuXG4gIGlmICh0eXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHR5cGVvZiBzdG9wc1swXVswXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFyIF9leHByZXNzaW9uMTIgPSBbJ2Nhc2UnXTtcblxuICAgIHZhciBfaXRlcmF0b3I0MyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0b3BzKSxcbiAgICAgICAgX3N0ZXA0MztcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjQzLnMoKTsgIShfc3RlcDQzID0gX2l0ZXJhdG9yNDMubigpKS5kb25lOykge1xuICAgICAgICB2YXIgc3RvcCA9IF9zdGVwNDMudmFsdWU7XG5cbiAgICAgICAgX2V4cHJlc3Npb24xMi5wdXNoKFsnPT0nLCBnZXQsIHN0b3BbMF1dLCBzdG9wWzFdKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjQzLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNDMuZigpO1xuICAgIH1cblxuICAgIF9leHByZXNzaW9uMTIucHVzaChnZXRGYWxsYmFjayhwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpKTtcblxuICAgIHJldHVybiBfZXhwcmVzc2lvbjEyO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjYXRlZ29yaWNhbCcpIHtcbiAgICB2YXIgX2V4cHJlc3Npb24xMyA9IFsnbWF0Y2gnLCBnZXRdO1xuXG4gICAgdmFyIF9pdGVyYXRvcjQ0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3RvcHMpLFxuICAgICAgICBfc3RlcDQ0O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNDQucygpOyAhKF9zdGVwNDQgPSBfaXRlcmF0b3I0NC5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBfc3RvcDIgPSBfc3RlcDQ0LnZhbHVlO1xuICAgICAgICBhcHBlbmRTdG9wUGFpcihfZXhwcmVzc2lvbjEzLCBfc3RvcDJbMF0sIF9zdG9wMlsxXSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNDQuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I0NC5mKCk7XG4gICAgfVxuXG4gICAgX2V4cHJlc3Npb24xMy5wdXNoKGdldEZhbGxiYWNrKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykpO1xuXG4gICAgcmV0dXJuIF9leHByZXNzaW9uMTM7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludGVydmFsJykge1xuICAgIHZhciBfZXhwcmVzc2lvbjE0ID0gWydzdGVwJywgWydudW1iZXInLCBnZXRdXTtcblxuICAgIHZhciBfaXRlcmF0b3I0NSA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0b3BzKSxcbiAgICAgICAgX3N0ZXA0NTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjQ1LnMoKTsgIShfc3RlcDQ1ID0gX2l0ZXJhdG9yNDUubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0b3AzID0gX3N0ZXA0NS52YWx1ZTtcbiAgICAgICAgYXBwZW5kU3RvcFBhaXIoX2V4cHJlc3Npb24xNCwgX3N0b3AzWzBdLCBfc3RvcDNbMV0sIHRydWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yNDUuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I0NS5mKCk7XG4gICAgfVxuXG4gICAgZml4dXBEZWdlbmVyYXRlU3RlcEN1cnZlKF9leHByZXNzaW9uMTQpO1xuICAgIHJldHVybiBwYXJhbWV0ZXJzLmRlZmF1bHQgPT09IHVuZGVmaW5lZCA/IF9leHByZXNzaW9uMTQgOiBbJ2Nhc2UnLCBbJz09JywgWyd0eXBlb2YnLCBnZXRdLCAnbnVtYmVyJ10sIF9leHByZXNzaW9uMTQsIGNvbnZlcnRMaXRlcmFsKHBhcmFtZXRlcnMuZGVmYXVsdCldO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICB2YXIgYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMTtcbiAgICB2YXIgX2V4cHJlc3Npb24xNSA9IFtnZXRJbnRlcnBvbGF0ZU9wZXJhdG9yKHBhcmFtZXRlcnMpLCBiYXNlID09PSAxID8gWydsaW5lYXInXSA6IFsnZXhwb25lbnRpYWwnLCBiYXNlXSwgWydudW1iZXInLCBnZXRdXTtcblxuICAgIHZhciBfaXRlcmF0b3I0NiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0b3BzKSxcbiAgICAgICAgX3N0ZXA0NjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjQ2LnMoKTsgIShfc3RlcDQ2ID0gX2l0ZXJhdG9yNDYubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX3N0b3A0ID0gX3N0ZXA0Ni52YWx1ZTtcbiAgICAgICAgYXBwZW5kU3RvcFBhaXIoX2V4cHJlc3Npb24xNSwgX3N0b3A0WzBdLCBfc3RvcDRbMV0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjQ2LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNDYuZigpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbWV0ZXJzLmRlZmF1bHQgPT09IHVuZGVmaW5lZCA/IF9leHByZXNzaW9uMTUgOiBbJ2Nhc2UnLCBbJz09JywgWyd0eXBlb2YnLCBnZXRdLCAnbnVtYmVyJ10sIF9leHByZXNzaW9uMTUsIGNvbnZlcnRMaXRlcmFsKHBhcmFtZXRlcnMuZGVmYXVsdCldO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcHJvcGVydHkgZnVuY3Rpb24gdHlwZSBcIi5jb25jYXQodHlwZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRab29tRnVuY3Rpb24ocGFyYW1ldGVycywgcHJvcGVydHlTcGVjLCBzdG9wcykge1xuICB2YXIgaW5wdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFsnem9vbSddO1xuICB2YXIgdHlwZSA9IGdldEZ1bmN0aW9uVHlwZShwYXJhbWV0ZXJzLCBwcm9wZXJ0eVNwZWMpO1xuICB2YXIgZXhwcmVzc2lvbjtcbiAgdmFyIGlzU3RlcCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnKSB7XG4gICAgZXhwcmVzc2lvbiA9IFsnc3RlcCcsIGlucHV0XTtcbiAgICBpc1N0ZXAgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdleHBvbmVudGlhbCcpIHtcbiAgICB2YXIgYmFzZSA9IHBhcmFtZXRlcnMuYmFzZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5iYXNlIDogMTtcbiAgICBleHByZXNzaW9uID0gW2dldEludGVycG9sYXRlT3BlcmF0b3IocGFyYW1ldGVycyksIGJhc2UgPT09IDEgPyBbJ2xpbmVhciddIDogWydleHBvbmVudGlhbCcsIGJhc2VdLCBpbnB1dF07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB6b29tIGZ1bmN0aW9uIHR5cGUgXFxcIlwiLmNvbmNhdCh0eXBlLCBcIlxcXCJcIikpO1xuICB9XG5cbiAgdmFyIF9pdGVyYXRvcjQ3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc3RvcHMpLFxuICAgICAgX3N0ZXA0NztcblxuICB0cnkge1xuICAgIGZvciAoX2l0ZXJhdG9yNDcucygpOyAhKF9zdGVwNDcgPSBfaXRlcmF0b3I0Ny5uKCkpLmRvbmU7KSB7XG4gICAgICB2YXIgc3RvcCA9IF9zdGVwNDcudmFsdWU7XG4gICAgICBhcHBlbmRTdG9wUGFpcihleHByZXNzaW9uLCBzdG9wWzBdLCBzdG9wWzFdLCBpc1N0ZXApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yNDcuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvcjQ3LmYoKTtcbiAgfVxuXG4gIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShleHByZXNzaW9uKTtcbiAgcmV0dXJuIGV4cHJlc3Npb247XG59XG5cbmZ1bmN0aW9uIGZpeHVwRGVnZW5lcmF0ZVN0ZXBDdXJ2ZShleHByZXNzaW9uKSB7XG4gIGlmIChleHByZXNzaW9uWzBdID09PSAnc3RlcCcgJiYgZXhwcmVzc2lvbi5sZW5ndGggPT09IDMpIHtcbiAgICBleHByZXNzaW9uLnB1c2goMCk7XG4gICAgZXhwcmVzc2lvbi5wdXNoKGV4cHJlc3Npb25bM10pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGVuZFN0b3BQYWlyKGN1cnZlLCBpbnB1dCwgb3V0cHV0LCBpc1N0ZXApIHtcbiAgaWYgKGN1cnZlLmxlbmd0aCA+IDMgJiYgaW5wdXQgPT09IGN1cnZlW2N1cnZlLmxlbmd0aCAtIDJdKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCEoaXNTdGVwICYmIGN1cnZlLmxlbmd0aCA9PT0gMikpIHtcbiAgICBjdXJ2ZS5wdXNoKGlucHV0KTtcbiAgfVxuXG4gIGN1cnZlLnB1c2gob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gZ2V0RnVuY3Rpb25UeXBlKHBhcmFtZXRlcnMsIHByb3BlcnR5U3BlYykge1xuICBpZiAocGFyYW1ldGVycy50eXBlKSB7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnMudHlwZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJvcGVydHlTcGVjLmV4cHJlc3Npb24uaW50ZXJwb2xhdGVkID8gJ2V4cG9uZW50aWFsJyA6ICdpbnRlcnZhbCc7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29udmVydFRva2VuU3RyaW5nKHMpIHtcbiAgdmFyIHJlc3VsdCA9IFsnY29uY2F0J107XG4gIHZhciByZSA9IC97KFtee31dKyl9L2c7XG4gIHZhciBwb3MgPSAwO1xuXG4gIGZvciAodmFyIG1hdGNoID0gcmUuZXhlYyhzKTsgbWF0Y2ggIT09IG51bGw7IG1hdGNoID0gcmUuZXhlYyhzKSkge1xuICAgIHZhciBsaXRlcmFsID0gcy5zbGljZShwb3MsIHJlLmxhc3RJbmRleCAtIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgcG9zID0gcmUubGFzdEluZGV4O1xuICAgIGlmIChsaXRlcmFsLmxlbmd0aCA+IDApIHJlc3VsdC5wdXNoKGxpdGVyYWwpO1xuICAgIHJlc3VsdC5wdXNoKFsnZ2V0JywgbWF0Y2hbMV1dKTtcbiAgfVxuXG4gIGlmIChyZXN1bHQubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cblxuICBpZiAocG9zIDwgcy5sZW5ndGgpIHtcbiAgICByZXN1bHQucHVzaChzLnNsaWNlKHBvcykpO1xuICB9IGVsc2UgaWYgKHJlc3VsdC5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gWyd0by1zdHJpbmcnLCByZXN1bHRbMV1dO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gaXNFeHByZXNzaW9uRmlsdGVyKGZpbHRlcikge1xuICBpZiAoZmlsdGVyID09PSB0cnVlIHx8IGZpbHRlciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShmaWx0ZXIpIHx8IGZpbHRlci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzd2l0Y2ggKGZpbHRlclswXSkge1xuICAgIGNhc2UgJ2hhcyc6XG4gICAgICByZXR1cm4gZmlsdGVyLmxlbmd0aCA+PSAyICYmIGZpbHRlclsxXSAhPT0gJyRpZCcgJiYgZmlsdGVyWzFdICE9PSAnJHR5cGUnO1xuXG4gICAgY2FzZSAnaW4nOlxuICAgICAgcmV0dXJuIGZpbHRlci5sZW5ndGggPj0gMyAmJiAodHlwZW9mIGZpbHRlclsxXSAhPT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShmaWx0ZXJbMl0pKTtcblxuICAgIGNhc2UgJyFpbic6XG4gICAgY2FzZSAnIWhhcyc6XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjYXNlICc9PSc6XG4gICAgY2FzZSAnIT0nOlxuICAgIGNhc2UgJz4nOlxuICAgIGNhc2UgJz49JzpcbiAgICBjYXNlICc8JzpcbiAgICBjYXNlICc8PSc6XG4gICAgICByZXR1cm4gZmlsdGVyLmxlbmd0aCAhPT0gMyB8fCBBcnJheS5pc0FycmF5KGZpbHRlclsxXSkgfHwgQXJyYXkuaXNBcnJheShmaWx0ZXJbMl0pO1xuXG4gICAgY2FzZSAnYW55JzpcbiAgICBjYXNlICdhbGwnOlxuICAgICAgdmFyIF9pdGVyYXRvcjQ4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZmlsdGVyLnNsaWNlKDEpKSxcbiAgICAgICAgICBfc3RlcDQ4O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjQ4LnMoKTsgIShfc3RlcDQ4ID0gX2l0ZXJhdG9yNDgubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBmID0gX3N0ZXA0OC52YWx1ZTtcblxuICAgICAgICAgIGlmICghaXNFeHByZXNzaW9uRmlsdGVyKGYpICYmIHR5cGVvZiBmICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I0OC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I0OC5mKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBmaWx0ZXJTcGVjID0ge1xuICAndHlwZSc6ICdib29sZWFuJyxcbiAgJ2RlZmF1bHQnOiBmYWxzZSxcbiAgJ3RyYW5zaXRpb24nOiBmYWxzZSxcbiAgJ3Byb3BlcnR5LXR5cGUnOiAnZGF0YS1kcml2ZW4nLFxuICAnZXhwcmVzc2lvbic6IHtcbiAgICAnaW50ZXJwb2xhdGVkJzogZmFsc2UsXG4gICAgJ3BhcmFtZXRlcnMnOiBbJ3pvb20nLCAnZmVhdHVyZSddXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpbHRlcihmaWx0ZXIpIHtcbiAgaWYgKGZpbHRlciA9PT0gbnVsbCB8fCBmaWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgbmVlZEdlb21ldHJ5OiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBpZiAoIWlzRXhwcmVzc2lvbkZpbHRlcihmaWx0ZXIpKSB7XG4gICAgZmlsdGVyID0gY29udmVydEZpbHRlcihmaWx0ZXIpO1xuICB9XG5cbiAgdmFyIGNvbXBpbGVkID0gY3JlYXRlRXhwcmVzc2lvbihmaWx0ZXIsIGZpbHRlclNwZWMpO1xuXG4gIGlmIChjb21waWxlZC5yZXN1bHQgPT09ICdlcnJvcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoY29tcGlsZWQudmFsdWUubWFwKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJldHVybiBcIlwiLmNvbmNhdChlcnIua2V5LCBcIjogXCIpLmNvbmNhdChlcnIubWVzc2FnZSk7XG4gICAgfSkuam9pbignLCAnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5lZWRHZW9tZXRyeSA9IGdlb21ldHJ5TmVlZGVkKGZpbHRlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGdsb2JhbFByb3BlcnRpZXMsIGZlYXR1cmUsIGNhbm9uaWNhbCkge1xuICAgICAgICByZXR1cm4gY29tcGlsZWQudmFsdWUuZXZhbHVhdGUoZ2xvYmFsUHJvcGVydGllcywgZmVhdHVyZSwge30sIGNhbm9uaWNhbCk7XG4gICAgICB9LFxuICAgICAgbmVlZEdlb21ldHJ5OiBuZWVkR2VvbWV0cnlcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG59XG5cbmZ1bmN0aW9uIGdlb21ldHJ5TmVlZGVkKGZpbHRlcikge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyWzBdID09PSAnd2l0aGluJykgcmV0dXJuIHRydWU7XG5cbiAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGZpbHRlci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBpZiAoZ2VvbWV0cnlOZWVkZWQoZmlsdGVyW2luZGV4XSkpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0RmlsdGVyKGZpbHRlcikge1xuICBpZiAoIWZpbHRlcikgcmV0dXJuIHRydWU7XG4gIHZhciBvcCA9IGZpbHRlclswXTtcbiAgaWYgKGZpbHRlci5sZW5ndGggPD0gMSkgcmV0dXJuIG9wICE9PSAnYW55JztcbiAgdmFyIGNvbnZlcnRlZCA9IG9wID09PSAnPT0nID8gY29udmVydENvbXBhcmlzb25PcChmaWx0ZXJbMV0sIGZpbHRlclsyXSwgJz09JykgOiBvcCA9PT0gJyE9JyA/IGNvbnZlcnROZWdhdGlvbihjb252ZXJ0Q29tcGFyaXNvbk9wKGZpbHRlclsxXSwgZmlsdGVyWzJdLCAnPT0nKSkgOiBvcCA9PT0gJzwnIHx8IG9wID09PSAnPicgfHwgb3AgPT09ICc8PScgfHwgb3AgPT09ICc+PScgPyBjb252ZXJ0Q29tcGFyaXNvbk9wKGZpbHRlclsxXSwgZmlsdGVyWzJdLCBvcCkgOiBvcCA9PT0gJ2FueScgPyBjb252ZXJ0RGlzanVuY3Rpb25PcChmaWx0ZXIuc2xpY2UoMSkpIDogb3AgPT09ICdhbGwnID8gWydhbGwnXS5jb25jYXQoZmlsdGVyLnNsaWNlKDEpLm1hcChjb252ZXJ0RmlsdGVyKSkgOiBvcCA9PT0gJ25vbmUnID8gWydhbGwnXS5jb25jYXQoZmlsdGVyLnNsaWNlKDEpLm1hcChjb252ZXJ0RmlsdGVyKS5tYXAoY29udmVydE5lZ2F0aW9uKSkgOiBvcCA9PT0gJ2luJyA/IGNvbnZlcnRJbk9wKGZpbHRlclsxXSwgZmlsdGVyLnNsaWNlKDIpKSA6IG9wID09PSAnIWluJyA/IGNvbnZlcnROZWdhdGlvbihjb252ZXJ0SW5PcChmaWx0ZXJbMV0sIGZpbHRlci5zbGljZSgyKSkpIDogb3AgPT09ICdoYXMnID8gY29udmVydEhhc09wKGZpbHRlclsxXSkgOiBvcCA9PT0gJyFoYXMnID8gY29udmVydE5lZ2F0aW9uKGNvbnZlcnRIYXNPcChmaWx0ZXJbMV0pKSA6IG9wID09PSAnd2l0aGluJyA/IGZpbHRlciA6IHRydWU7XG4gIHJldHVybiBjb252ZXJ0ZWQ7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRDb21wYXJpc29uT3AocHJvcGVydHksIHZhbHVlLCBvcCkge1xuICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnJHR5cGUnOlxuICAgICAgcmV0dXJuIFtcImZpbHRlci10eXBlLVwiLmNvbmNhdChvcCksIHZhbHVlXTtcblxuICAgIGNhc2UgJyRpZCc6XG4gICAgICByZXR1cm4gW1wiZmlsdGVyLWlkLVwiLmNvbmNhdChvcCksIHZhbHVlXTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gW1wiZmlsdGVyLVwiLmNvbmNhdChvcCksIHByb3BlcnR5LCB2YWx1ZV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY29udmVydERpc2p1bmN0aW9uT3AoZmlsdGVycykge1xuICByZXR1cm4gWydhbnknXS5jb25jYXQoZmlsdGVycy5tYXAoY29udmVydEZpbHRlcikpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0SW5PcChwcm9wZXJ0eSwgdmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3dpdGNoIChwcm9wZXJ0eSkge1xuICAgIGNhc2UgJyR0eXBlJzpcbiAgICAgIHJldHVybiBbXCJmaWx0ZXItdHlwZS1pblwiLCBbJ2xpdGVyYWwnLCB2YWx1ZXNdXTtcblxuICAgIGNhc2UgJyRpZCc6XG4gICAgICByZXR1cm4gW1wiZmlsdGVyLWlkLWluXCIsIFsnbGl0ZXJhbCcsIHZhbHVlc11dO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMjAwICYmICF2YWx1ZXMuc29tZShmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHYgIT09IHR5cGVvZiB2YWx1ZXNbMF07XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm4gWydmaWx0ZXItaW4tbGFyZ2UnLCBwcm9wZXJ0eSwgWydsaXRlcmFsJywgdmFsdWVzLnNvcnQoY29tcGFyZSldXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbJ2ZpbHRlci1pbi1zbWFsbCcsIHByb3BlcnR5LCBbJ2xpdGVyYWwnLCB2YWx1ZXNdXTtcbiAgICAgIH1cblxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRIYXNPcChwcm9wZXJ0eSkge1xuICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnJHR5cGUnOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlICckaWQnOlxuICAgICAgcmV0dXJuIFtcImZpbHRlci1oYXMtaWRcIl07XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtcImZpbHRlci1oYXNcIiwgcHJvcGVydHldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnROZWdhdGlvbihmaWx0ZXIpIHtcbiAgcmV0dXJuIFsnIScsIGZpbHRlcl07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRGaWx0ZXIkMShmaWx0ZXIpIHtcbiAgcmV0dXJuIF9jb252ZXJ0RmlsdGVyKGZpbHRlciwge30pO1xufVxuXG5mdW5jdGlvbiBfY29udmVydEZpbHRlcihmaWx0ZXIsIGV4cGVjdGVkVHlwZXMpIHtcbiAgaWYgKGlzRXhwcmVzc2lvbkZpbHRlcihmaWx0ZXIpKSB7XG4gICAgcmV0dXJuIGZpbHRlcjtcbiAgfVxuXG4gIGlmICghZmlsdGVyKSByZXR1cm4gdHJ1ZTtcbiAgdmFyIG9wID0gZmlsdGVyWzBdO1xuICBpZiAoZmlsdGVyLmxlbmd0aCA8PSAxKSByZXR1cm4gb3AgIT09ICdhbnknO1xuICB2YXIgY29udmVydGVkO1xuXG4gIGlmIChvcCA9PT0gJz09JyB8fCBvcCA9PT0gJyE9JyB8fCBvcCA9PT0gJzwnIHx8IG9wID09PSAnPicgfHwgb3AgPT09ICc8PScgfHwgb3AgPT09ICc+PScpIHtcbiAgICB2YXIgX2ZpbHRlciA9IF9zbGljZWRUb0FycmF5KGZpbHRlciwgMyksXG4gICAgICAgIHByb3BlcnR5ID0gX2ZpbHRlclsxXSxcbiAgICAgICAgdmFsdWUgPSBfZmlsdGVyWzJdO1xuXG4gICAgY29udmVydGVkID0gY29udmVydENvbXBhcmlzb25PcCQxKHByb3BlcnR5LCB2YWx1ZSwgb3AsIGV4cGVjdGVkVHlwZXMpO1xuICB9IGVsc2UgaWYgKG9wID09PSAnYW55Jykge1xuICAgIHZhciBjaGlsZHJlbiA9IGZpbHRlci5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgIHZhciB0eXBlcyA9IHt9O1xuXG4gICAgICB2YXIgY2hpbGQgPSBfY29udmVydEZpbHRlcihmLCB0eXBlcyk7XG5cbiAgICAgIHZhciB0eXBlY2hlY2tzID0gcnVudGltZVR5cGVDaGVja3ModHlwZXMpO1xuICAgICAgcmV0dXJuIHR5cGVjaGVja3MgPT09IHRydWUgPyBjaGlsZCA6IFsnY2FzZScsIHR5cGVjaGVja3MsIGNoaWxkLCBmYWxzZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIFsnYW55J10uY29uY2F0KGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmIChvcCA9PT0gJ2FsbCcpIHtcbiAgICB2YXIgX3JlZjExMTtcblxuICAgIHZhciBfY2hpbGRyZW4gPSBmaWx0ZXIuc2xpY2UoMSkubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICByZXR1cm4gX2NvbnZlcnRGaWx0ZXIoZiwgZXhwZWN0ZWRUeXBlcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX2NoaWxkcmVuLmxlbmd0aCA+IDEgPyBbJ2FsbCddLmNvbmNhdChfY2hpbGRyZW4pIDogKF9yZWYxMTEgPSBbXSkuY29uY2F0LmFwcGx5KF9yZWYxMTEsIF90b0NvbnN1bWFibGVBcnJheShfY2hpbGRyZW4pKTtcbiAgfSBlbHNlIGlmIChvcCA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIFsnIScsIF9jb252ZXJ0RmlsdGVyKFsnYW55J10uY29uY2F0KGZpbHRlci5zbGljZSgxKSksIHt9KV07XG4gIH0gZWxzZSBpZiAob3AgPT09ICdpbicpIHtcbiAgICBjb252ZXJ0ZWQgPSBjb252ZXJ0SW5PcCQxKGZpbHRlclsxXSwgZmlsdGVyLnNsaWNlKDIpKTtcbiAgfSBlbHNlIGlmIChvcCA9PT0gJyFpbicpIHtcbiAgICBjb252ZXJ0ZWQgPSBjb252ZXJ0SW5PcCQxKGZpbHRlclsxXSwgZmlsdGVyLnNsaWNlKDIpLCB0cnVlKTtcbiAgfSBlbHNlIGlmIChvcCA9PT0gJ2hhcycpIHtcbiAgICBjb252ZXJ0ZWQgPSBjb252ZXJ0SGFzT3AkMShmaWx0ZXJbMV0pO1xuICB9IGVsc2UgaWYgKG9wID09PSAnIWhhcycpIHtcbiAgICBjb252ZXJ0ZWQgPSBbJyEnLCBjb252ZXJ0SGFzT3AkMShmaWx0ZXJbMV0pXTtcbiAgfSBlbHNlIHtcbiAgICBjb252ZXJ0ZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRlZDtcbn1cblxuZnVuY3Rpb24gcnVudGltZVR5cGVDaGVja3MoZXhwZWN0ZWRUeXBlcykge1xuICB2YXIgY29uZGl0aW9ucyA9IFtdO1xuXG4gIGZvciAodmFyIHByb3BlcnR5IGluIGV4cGVjdGVkVHlwZXMpIHtcbiAgICB2YXIgX2dldCA9IHByb3BlcnR5ID09PSAnJGlkJyA/IFsnaWQnXSA6IFsnZ2V0JywgcHJvcGVydHldO1xuXG4gICAgY29uZGl0aW9ucy5wdXNoKFsnPT0nLCBbJ3R5cGVvZicsIF9nZXRdLCBleHBlY3RlZFR5cGVzW3Byb3BlcnR5XV0pO1xuICB9XG5cbiAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvbmRpdGlvbnMubGVuZ3RoID09PSAxKSByZXR1cm4gY29uZGl0aW9uc1swXTtcbiAgcmV0dXJuIFsnYWxsJ10uY29uY2F0KGNvbmRpdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0Q29tcGFyaXNvbk9wJDEocHJvcGVydHksIHZhbHVlLCBvcCwgZXhwZWN0ZWRUeXBlcykge1xuICB2YXIgZ2V0O1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJyR0eXBlJykge1xuICAgIHJldHVybiBbb3AsIFsnZ2VvbWV0cnktdHlwZSddLCB2YWx1ZV07XG4gIH0gZWxzZSBpZiAocHJvcGVydHkgPT09ICckaWQnKSB7XG4gICAgZ2V0ID0gWydpZCddO1xuICB9IGVsc2Uge1xuICAgIGdldCA9IFsnZ2V0JywgcHJvcGVydHldO1xuICB9XG5cbiAgaWYgKGV4cGVjdGVkVHlwZXMgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICBleHBlY3RlZFR5cGVzW3Byb3BlcnR5XSA9IHR5cGU7XG4gIH1cblxuICBpZiAob3AgPT09ICc9PScgJiYgcHJvcGVydHkgIT09ICckaWQnICYmIHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFsnYWxsJywgWydoYXMnLCBwcm9wZXJ0eV0sIFsnPT0nLCBnZXQsIG51bGxdXTtcbiAgfSBlbHNlIGlmIChvcCA9PT0gJyE9JyAmJiBwcm9wZXJ0eSAhPT0gJyRpZCcgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gWydhbnknLCBbJyEnLCBbJ2hhcycsIHByb3BlcnR5XV0sIFsnIT0nLCBnZXQsIG51bGxdXTtcbiAgfVxuXG4gIHJldHVybiBbb3AsIGdldCwgdmFsdWVdO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0SW5PcCQxKHByb3BlcnR5LCB2YWx1ZXMpIHtcbiAgdmFyIG5lZ2F0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gbmVnYXRlO1xuICB2YXIgZ2V0O1xuXG4gIGlmIChwcm9wZXJ0eSA9PT0gJyR0eXBlJykge1xuICAgIGdldCA9IFsnZ2VvbWV0cnktdHlwZSddO1xuICB9IGVsc2UgaWYgKHByb3BlcnR5ID09PSAnJGlkJykge1xuICAgIGdldCA9IFsnaWQnXTtcbiAgfSBlbHNlIHtcbiAgICBnZXQgPSBbJ2dldCcsIHByb3BlcnR5XTtcbiAgfVxuXG4gIHZhciB1bmlmb3JtVHlwZXMgPSB0cnVlO1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZXNbMF07XG5cbiAgdmFyIF9pdGVyYXRvcjQ5ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodmFsdWVzKSxcbiAgICAgIF9zdGVwNDk7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pdGVyYXRvcjQ5LnMoKTsgIShfc3RlcDQ5ID0gX2l0ZXJhdG9yNDkubigpKS5kb25lOykge1xuICAgICAgdmFyIHZhbHVlID0gX3N0ZXA0OS52YWx1ZTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gdHlwZSkge1xuICAgICAgICB1bmlmb3JtVHlwZXMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3I0OS5lKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgX2l0ZXJhdG9yNDkuZigpO1xuICB9XG5cbiAgaWYgKHVuaWZvcm1UeXBlcyAmJiAodHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicpKSB7XG4gICAgdmFyIHVuaXF1ZVZhbHVlcyA9IHZhbHVlcy5zb3J0KCkuZmlsdGVyKGZ1bmN0aW9uICh2LCBpKSB7XG4gICAgICByZXR1cm4gaSA9PT0gMCB8fCB2YWx1ZXNbaSAtIDFdICE9PSB2O1xuICAgIH0pO1xuICAgIHJldHVybiBbJ21hdGNoJywgZ2V0LCB1bmlxdWVWYWx1ZXMsICFuZWdhdGUsIG5lZ2F0ZV07XG4gIH1cblxuICByZXR1cm4gW25lZ2F0ZSA/ICdhbGwnIDogJ2FueSddLmNvbmNhdCh2YWx1ZXMubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIFtuZWdhdGUgPyAnIT0nIDogJz09JywgZ2V0LCB2XTtcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0SGFzT3AkMShwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICckdHlwZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJyRpZCcpIHtcbiAgICByZXR1cm4gWychPScsIFsnaWQnXSwgbnVsbF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFsnaGFzJywgcHJvcGVydHldO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1pZ3JhdGVUb0V4cHJlc3Npb25zKHN0eWxlKSB7XG4gIHZhciBjb252ZXJ0ZWQgPSBbXTtcbiAgZWFjaExheWVyKHN0eWxlLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICBpZiAobGF5ZXIuZmlsdGVyKSB7XG4gICAgICBsYXllci5maWx0ZXIgPSBjb252ZXJ0RmlsdGVyJDEobGF5ZXIuZmlsdGVyKTtcbiAgICB9XG4gIH0pO1xuICBlYWNoUHJvcGVydHkoc3R5bGUsIHtcbiAgICBwYWludDogdHJ1ZSxcbiAgICBsYXlvdXQ6IHRydWVcbiAgfSwgZnVuY3Rpb24gKF9yZWYxMTIpIHtcbiAgICB2YXIgcGF0aCA9IF9yZWYxMTIucGF0aCxcbiAgICAgICAgdmFsdWUgPSBfcmVmMTEyLnZhbHVlLFxuICAgICAgICByZWZlcmVuY2UgPSBfcmVmMTEyLnJlZmVyZW5jZSxcbiAgICAgICAgc2V0ID0gX3JlZjExMi5zZXQ7XG4gICAgaWYgKGlzRXhwcmVzc2lvbih2YWx1ZSkpIHJldHVybjtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgc2V0KGNvbnZlcnRGdW5jdGlvbih2YWx1ZSwgcmVmZXJlbmNlKSk7XG4gICAgICBjb252ZXJ0ZWQucHVzaChwYXRoLmpvaW4oJy4nKSk7XG4gICAgfSBlbHNlIGlmIChyZWZlcmVuY2UudG9rZW5zICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHNldChjb252ZXJ0VG9rZW5TdHJpbmcodmFsdWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIG1pZ3JhdGUoc3R5bGUpIHtcbiAgdmFyIG1pZ3JhdGVkID0gZmFsc2U7XG5cbiAgaWYgKHN0eWxlLnZlcnNpb24gPT09IDcpIHtcbiAgICBzdHlsZSA9IG1pZ3JhdGVUb1Y4KHN0eWxlKTtcbiAgICBtaWdyYXRlZCA9IHRydWU7XG4gIH1cblxuICBpZiAoc3R5bGUudmVyc2lvbiA9PT0gOCkge1xuICAgIG1pZ3JhdGVkID0gbWlncmF0ZVRvRXhwcmVzc2lvbnMoc3R5bGUpO1xuICAgIG1pZ3JhdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICghbWlncmF0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBtaWdyYXRlIGZyb20nLCBzdHlsZS52ZXJzaW9uKTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY29tcG9zaXRlKHN0eWxlKSB7XG4gIHZhciBzdHlsZUlEcyA9IFtdO1xuICB2YXIgc291cmNlSURzID0gW107XG4gIHZhciBjb21wb3NpdGVkU291cmNlTGF5ZXJzID0gW107XG5cbiAgZm9yICh2YXIgaWQgaW4gc3R5bGUuc291cmNlcykge1xuICAgIHZhciBfc291cmNlID0gc3R5bGUuc291cmNlc1tpZF07XG4gICAgaWYgKF9zb3VyY2UudHlwZSAhPT0gJ3ZlY3RvcicpIGNvbnRpbnVlO1xuICAgIHZhciBtYXRjaCA9IC9ebWFwYm94OlxcL1xcLyguKikvLmV4ZWMoX3NvdXJjZS51cmwpO1xuICAgIGlmICghbWF0Y2gpIGNvbnRpbnVlO1xuICAgIHN0eWxlSURzLnB1c2goaWQpO1xuICAgIHNvdXJjZUlEcy5wdXNoKG1hdGNoWzFdKTtcbiAgfVxuXG4gIGlmIChzdHlsZUlEcy5sZW5ndGggPCAyKSByZXR1cm4gc3R5bGU7XG4gIHN0eWxlSURzLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgZGVsZXRlIHN0eWxlLnNvdXJjZXNbaWRdO1xuICB9KTtcbiAgdmFyIGNvbXBvc2l0ZUlEID0gc291cmNlSURzLmpvaW4oJywnKTtcbiAgc3R5bGUuc291cmNlc1tjb21wb3NpdGVJRF0gPSB7XG4gICAgJ3R5cGUnOiAndmVjdG9yJyxcbiAgICAndXJsJzogXCJtYXBib3g6Ly9cIi5jb25jYXQoY29tcG9zaXRlSUQpXG4gIH07XG4gIHN0eWxlLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgIGlmIChzdHlsZUlEcy5pbmRleE9mKGxheWVyLnNvdXJjZSkgPj0gMCkge1xuICAgICAgbGF5ZXIuc291cmNlID0gY29tcG9zaXRlSUQ7XG5cbiAgICAgIGlmICgnc291cmNlLWxheWVyJyBpbiBsYXllcikge1xuICAgICAgICBpZiAoY29tcG9zaXRlZFNvdXJjZUxheWVycy5pbmRleE9mKGxheWVyWydzb3VyY2UtbGF5ZXInXSkgPj0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmxpY3Rpbmcgc291cmNlIGxheWVyIG5hbWVzJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcG9zaXRlZFNvdXJjZUxheWVycy5wdXNoKGxheWVyWydzb3VyY2UtbGF5ZXInXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbnZhciByZWZQcm9wZXJ0aWVzID0gWyd0eXBlJywgJ3NvdXJjZScsICdzb3VyY2UtbGF5ZXInLCAnbWluem9vbScsICdtYXh6b29tJywgJ2ZpbHRlcicsICdsYXlvdXQnXTtcblxuZnVuY3Rpb24gZGVyZWYobGF5ZXIsIHBhcmVudCkge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgZm9yICh2YXIgayBpbiBsYXllcikge1xuICAgIGlmIChrICE9PSAncmVmJykge1xuICAgICAgcmVzdWx0W2tdID0gbGF5ZXJba107XG4gICAgfVxuICB9XG5cbiAgcmVmUHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgaWYgKGsgaW4gcGFyZW50KSB7XG4gICAgICByZXN1bHRba10gPSBwYXJlbnRba107XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZGVyZWZMYXllcnMobGF5ZXJzKSB7XG4gIGxheWVycyA9IGxheWVycy5zbGljZSgpO1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgIG1hcFtsYXllcnNbaV0uaWRdID0gbGF5ZXJzW2ldO1xuICB9XG5cbiAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgbGF5ZXJzLmxlbmd0aDsgX2k4KyspIHtcbiAgICBpZiAoJ3JlZicgaW4gbGF5ZXJzW19pOF0pIHtcbiAgICAgIGxheWVyc1tfaThdID0gZGVyZWYobGF5ZXJzW19pOF0sIG1hcFtsYXllcnNbX2k4XS5yZWZdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGF5ZXJzO1xufVxuXG5mdW5jdGlvbiBkZWVwRXF1YWwoYSwgYikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsKSB7XG4gICAgaWYgKCEodHlwZW9mIGIgPT09ICdvYmplY3QnKSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAodmFyIGtleSBpbiBhKSB7XG4gICAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBhID09PSBiO1xufVxuXG52YXIgb3BlcmF0aW9ucyA9IHtcbiAgc2V0U3R5bGU6ICdzZXRTdHlsZScsXG4gIGFkZExheWVyOiAnYWRkTGF5ZXInLFxuICByZW1vdmVMYXllcjogJ3JlbW92ZUxheWVyJyxcbiAgc2V0UGFpbnRQcm9wZXJ0eTogJ3NldFBhaW50UHJvcGVydHknLFxuICBzZXRMYXlvdXRQcm9wZXJ0eTogJ3NldExheW91dFByb3BlcnR5JyxcbiAgc2V0RmlsdGVyOiAnc2V0RmlsdGVyJyxcbiAgYWRkU291cmNlOiAnYWRkU291cmNlJyxcbiAgcmVtb3ZlU291cmNlOiAncmVtb3ZlU291cmNlJyxcbiAgc2V0R2VvSlNPTlNvdXJjZURhdGE6ICdzZXRHZW9KU09OU291cmNlRGF0YScsXG4gIHNldExheWVyWm9vbVJhbmdlOiAnc2V0TGF5ZXJab29tUmFuZ2UnLFxuICBzZXRMYXllclByb3BlcnR5OiAnc2V0TGF5ZXJQcm9wZXJ0eScsXG4gIHNldENlbnRlcjogJ3NldENlbnRlcicsXG4gIHNldFpvb206ICdzZXRab29tJyxcbiAgc2V0QmVhcmluZzogJ3NldEJlYXJpbmcnLFxuICBzZXRQaXRjaDogJ3NldFBpdGNoJyxcbiAgc2V0U3ByaXRlOiAnc2V0U3ByaXRlJyxcbiAgc2V0R2x5cGhzOiAnc2V0R2x5cGhzJyxcbiAgc2V0VHJhbnNpdGlvbjogJ3NldFRyYW5zaXRpb24nLFxuICBzZXRMaWdodDogJ3NldExpZ2h0JyxcbiAgc2V0VGVycmFpbjogJ3NldFRlcnJhaW4nLFxuICBzZXRGb2c6ICdzZXRGb2cnXG59O1xuXG5mdW5jdGlvbiBhZGRTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcykge1xuICBjb21tYW5kcy5wdXNoKHtcbiAgICBjb21tYW5kOiBvcGVyYXRpb25zLmFkZFNvdXJjZSxcbiAgICBhcmdzOiBbc291cmNlSWQsIGFmdGVyW3NvdXJjZUlkXV1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNvdXJjZShzb3VyY2VJZCwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKSB7XG4gIGNvbW1hbmRzLnB1c2goe1xuICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMucmVtb3ZlU291cmNlLFxuICAgIGFyZ3M6IFtzb3VyY2VJZF1cbiAgfSk7XG4gIHNvdXJjZXNSZW1vdmVkW3NvdXJjZUlkXSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNvdXJjZShzb3VyY2VJZCwgYWZ0ZXIsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCkge1xuICByZW1vdmVTb3VyY2Uoc291cmNlSWQsIGNvbW1hbmRzLCBzb3VyY2VzUmVtb3ZlZCk7XG4gIGFkZFNvdXJjZShzb3VyY2VJZCwgYWZ0ZXIsIGNvbW1hbmRzKTtcbn1cblxuZnVuY3Rpb24gY2FuVXBkYXRlR2VvSlNPTihiZWZvcmUsIGFmdGVyLCBzb3VyY2VJZCkge1xuICB2YXIgcHJvcDtcblxuICBmb3IgKHByb3AgaW4gYmVmb3JlW3NvdXJjZUlkXSkge1xuICAgIGlmICghYmVmb3JlW3NvdXJjZUlkXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG5cbiAgICBpZiAocHJvcCAhPT0gJ2RhdGEnICYmICFkZWVwRXF1YWwoYmVmb3JlW3NvdXJjZUlkXVtwcm9wXSwgYWZ0ZXJbc291cmNlSWRdW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAocHJvcCBpbiBhZnRlcltzb3VyY2VJZF0pIHtcbiAgICBpZiAoIWFmdGVyW3NvdXJjZUlkXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG5cbiAgICBpZiAocHJvcCAhPT0gJ2RhdGEnICYmICFkZWVwRXF1YWwoYmVmb3JlW3NvdXJjZUlkXVtwcm9wXSwgYWZ0ZXJbc291cmNlSWRdW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBkaWZmU291cmNlcyhiZWZvcmUsIGFmdGVyLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpIHtcbiAgYmVmb3JlID0gYmVmb3JlIHx8IHt9O1xuICBhZnRlciA9IGFmdGVyIHx8IHt9O1xuICB2YXIgc291cmNlSWQ7XG5cbiAgZm9yIChzb3VyY2VJZCBpbiBiZWZvcmUpIHtcbiAgICBpZiAoIWJlZm9yZS5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIGNvbnRpbnVlO1xuXG4gICAgaWYgKCFhZnRlci5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIHtcbiAgICAgIHJlbW92ZVNvdXJjZShzb3VyY2VJZCwgY29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHNvdXJjZUlkIGluIGFmdGVyKSB7XG4gICAgaWYgKCFhZnRlci5oYXNPd25Qcm9wZXJ0eShzb3VyY2VJZCkpIGNvbnRpbnVlO1xuXG4gICAgaWYgKCFiZWZvcmUuaGFzT3duUHJvcGVydHkoc291cmNlSWQpKSB7XG4gICAgICBhZGRTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcyk7XG4gICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGJlZm9yZVtzb3VyY2VJZF0sIGFmdGVyW3NvdXJjZUlkXSkpIHtcbiAgICAgIGlmIChiZWZvcmVbc291cmNlSWRdLnR5cGUgPT09ICdnZW9qc29uJyAmJiBhZnRlcltzb3VyY2VJZF0udHlwZSA9PT0gJ2dlb2pzb24nICYmIGNhblVwZGF0ZUdlb0pTT04oYmVmb3JlLCBhZnRlciwgc291cmNlSWQpKSB7XG4gICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0R2VvSlNPTlNvdXJjZURhdGEsXG4gICAgICAgICAgYXJnczogW3NvdXJjZUlkLCBhZnRlcltzb3VyY2VJZF0uZGF0YV1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVTb3VyY2Uoc291cmNlSWQsIGFmdGVyLCBjb21tYW5kcywgc291cmNlc1JlbW92ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMoYmVmb3JlLCBhZnRlciwgY29tbWFuZHMsIGxheWVySWQsIGtsYXNzLCBjb21tYW5kKSB7XG4gIGJlZm9yZSA9IGJlZm9yZSB8fCB7fTtcbiAgYWZ0ZXIgPSBhZnRlciB8fCB7fTtcbiAgdmFyIHByb3A7XG5cbiAgZm9yIChwcm9wIGluIGJlZm9yZSkge1xuICAgIGlmICghYmVmb3JlLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcblxuICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZVtwcm9wXSwgYWZ0ZXJbcHJvcF0pKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgYXJnczogW2xheWVySWQsIHByb3AsIGFmdGVyW3Byb3BdLCBrbGFzc11cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZvciAocHJvcCBpbiBhZnRlcikge1xuICAgIGlmICghYWZ0ZXIuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgYmVmb3JlLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcblxuICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZVtwcm9wXSwgYWZ0ZXJbcHJvcF0pKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgYXJnczogW2xheWVySWQsIHByb3AsIGFmdGVyW3Byb3BdLCBrbGFzc11cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwbHVja0lkKGxheWVyKSB7XG4gIHJldHVybiBsYXllci5pZDtcbn1cblxuZnVuY3Rpb24gaW5kZXhCeUlkKGdyb3VwLCBsYXllcikge1xuICBncm91cFtsYXllci5pZF0gPSBsYXllcjtcbiAgcmV0dXJuIGdyb3VwO1xufVxuXG5mdW5jdGlvbiBkaWZmTGF5ZXJzKGJlZm9yZSwgYWZ0ZXIsIGNvbW1hbmRzKSB7XG4gIGJlZm9yZSA9IGJlZm9yZSB8fCBbXTtcbiAgYWZ0ZXIgPSBhZnRlciB8fCBbXTtcbiAgdmFyIGJlZm9yZU9yZGVyID0gYmVmb3JlLm1hcChwbHVja0lkKTtcbiAgdmFyIGFmdGVyT3JkZXIgPSBhZnRlci5tYXAocGx1Y2tJZCk7XG4gIHZhciBiZWZvcmVJbmRleCA9IGJlZm9yZS5yZWR1Y2UoaW5kZXhCeUlkLCB7fSk7XG4gIHZhciBhZnRlckluZGV4ID0gYWZ0ZXIucmVkdWNlKGluZGV4QnlJZCwge30pO1xuICB2YXIgdHJhY2tlciA9IGJlZm9yZU9yZGVyLnNsaWNlKCk7XG4gIHZhciBjbGVhbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBpLCBkLCBsYXllcklkLCBiZWZvcmVMYXllciwgYWZ0ZXJMYXllciwgaW5zZXJ0QmVmb3JlTGF5ZXJJZCwgcHJvcDtcblxuICBmb3IgKGkgPSAwLCBkID0gMDsgaSA8IGJlZm9yZU9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgbGF5ZXJJZCA9IGJlZm9yZU9yZGVyW2ldO1xuXG4gICAgaWYgKCFhZnRlckluZGV4Lmhhc093blByb3BlcnR5KGxheWVySWQpKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllcixcbiAgICAgICAgYXJnczogW2xheWVySWRdXG4gICAgICB9KTtcbiAgICAgIHRyYWNrZXIuc3BsaWNlKHRyYWNrZXIuaW5kZXhPZihsYXllcklkLCBkKSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQrKztcbiAgICB9XG4gIH1cblxuICBmb3IgKGkgPSAwLCBkID0gMDsgaSA8IGFmdGVyT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBsYXllcklkID0gYWZ0ZXJPcmRlclthZnRlck9yZGVyLmxlbmd0aCAtIDEgLSBpXTtcbiAgICBpZiAodHJhY2tlclt0cmFja2VyLmxlbmd0aCAtIDEgLSBpXSA9PT0gbGF5ZXJJZCkgY29udGludWU7XG5cbiAgICBpZiAoYmVmb3JlSW5kZXguaGFzT3duUHJvcGVydHkobGF5ZXJJZCkpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZUxheWVyLFxuICAgICAgICBhcmdzOiBbbGF5ZXJJZF1cbiAgICAgIH0pO1xuICAgICAgdHJhY2tlci5zcGxpY2UodHJhY2tlci5sYXN0SW5kZXhPZihsYXllcklkLCB0cmFja2VyLmxlbmd0aCAtIGQpLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZCsrO1xuICAgIH1cblxuICAgIGluc2VydEJlZm9yZUxheWVySWQgPSB0cmFja2VyW3RyYWNrZXIubGVuZ3RoIC0gaV07XG4gICAgY29tbWFuZHMucHVzaCh7XG4gICAgICBjb21tYW5kOiBvcGVyYXRpb25zLmFkZExheWVyLFxuICAgICAgYXJnczogW2FmdGVySW5kZXhbbGF5ZXJJZF0sIGluc2VydEJlZm9yZUxheWVySWRdXG4gICAgfSk7XG4gICAgdHJhY2tlci5zcGxpY2UodHJhY2tlci5sZW5ndGggLSBpLCAwLCBsYXllcklkKTtcbiAgICBjbGVhbltsYXllcklkXSA9IHRydWU7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgYWZ0ZXJPcmRlci5sZW5ndGg7IGkrKykge1xuICAgIGxheWVySWQgPSBhZnRlck9yZGVyW2ldO1xuICAgIGJlZm9yZUxheWVyID0gYmVmb3JlSW5kZXhbbGF5ZXJJZF07XG4gICAgYWZ0ZXJMYXllciA9IGFmdGVySW5kZXhbbGF5ZXJJZF07XG4gICAgaWYgKGNsZWFuW2xheWVySWRdIHx8IGRlZXBFcXVhbChiZWZvcmVMYXllciwgYWZ0ZXJMYXllcikpIGNvbnRpbnVlO1xuXG4gICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIuc291cmNlLCBhZnRlckxheWVyLnNvdXJjZSkgfHwgIWRlZXBFcXVhbChiZWZvcmVMYXllclsnc291cmNlLWxheWVyJ10sIGFmdGVyTGF5ZXJbJ3NvdXJjZS1sYXllciddKSB8fCAhZGVlcEVxdWFsKGJlZm9yZUxheWVyLnR5cGUsIGFmdGVyTGF5ZXIudHlwZSkpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnJlbW92ZUxheWVyLFxuICAgICAgICBhcmdzOiBbbGF5ZXJJZF1cbiAgICAgIH0pO1xuICAgICAgaW5zZXJ0QmVmb3JlTGF5ZXJJZCA9IHRyYWNrZXJbdHJhY2tlci5sYXN0SW5kZXhPZihsYXllcklkKSArIDFdO1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuYWRkTGF5ZXIsXG4gICAgICAgIGFyZ3M6IFthZnRlckxheWVyLCBpbnNlcnRCZWZvcmVMYXllcklkXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMoYmVmb3JlTGF5ZXIubGF5b3V0LCBhZnRlckxheWVyLmxheW91dCwgY29tbWFuZHMsIGxheWVySWQsIG51bGwsIG9wZXJhdGlvbnMuc2V0TGF5b3V0UHJvcGVydHkpO1xuICAgIGRpZmZMYXllclByb3BlcnR5Q2hhbmdlcyhiZWZvcmVMYXllci5wYWludCwgYWZ0ZXJMYXllci5wYWludCwgY29tbWFuZHMsIGxheWVySWQsIG51bGwsIG9wZXJhdGlvbnMuc2V0UGFpbnRQcm9wZXJ0eSk7XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllci5maWx0ZXIsIGFmdGVyTGF5ZXIuZmlsdGVyKSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0RmlsdGVyLFxuICAgICAgICBhcmdzOiBbbGF5ZXJJZCwgYWZ0ZXJMYXllci5maWx0ZXJdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllci5taW56b29tLCBhZnRlckxheWVyLm1pbnpvb20pIHx8ICFkZWVwRXF1YWwoYmVmb3JlTGF5ZXIubWF4em9vbSwgYWZ0ZXJMYXllci5tYXh6b29tKSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGF5ZXJab29tUmFuZ2UsXG4gICAgICAgIGFyZ3M6IFtsYXllcklkLCBhZnRlckxheWVyLm1pbnpvb20sIGFmdGVyTGF5ZXIubWF4em9vbV1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAocHJvcCBpbiBiZWZvcmVMYXllcikge1xuICAgICAgaWYgKCFiZWZvcmVMYXllci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XG4gICAgICBpZiAocHJvcCA9PT0gJ2xheW91dCcgfHwgcHJvcCA9PT0gJ3BhaW50JyB8fCBwcm9wID09PSAnZmlsdGVyJyB8fCBwcm9wID09PSAnbWV0YWRhdGEnIHx8IHByb3AgPT09ICdtaW56b29tJyB8fCBwcm9wID09PSAnbWF4em9vbScpIGNvbnRpbnVlO1xuXG4gICAgICBpZiAocHJvcC5pbmRleE9mKCdwYWludC4nKSA9PT0gMCkge1xuICAgICAgICBkaWZmTGF5ZXJQcm9wZXJ0eUNoYW5nZXMoYmVmb3JlTGF5ZXJbcHJvcF0sIGFmdGVyTGF5ZXJbcHJvcF0sIGNvbW1hbmRzLCBsYXllcklkLCBwcm9wLnNsaWNlKDYpLCBvcGVyYXRpb25zLnNldFBhaW50UHJvcGVydHkpO1xuICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdKSkge1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldExheWVyUHJvcGVydHksXG4gICAgICAgICAgYXJnczogW2xheWVySWQsIHByb3AsIGFmdGVyTGF5ZXJbcHJvcF1dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAocHJvcCBpbiBhZnRlckxheWVyKSB7XG4gICAgICBpZiAoIWFmdGVyTGF5ZXIuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgYmVmb3JlTGF5ZXIuaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xuICAgICAgaWYgKHByb3AgPT09ICdsYXlvdXQnIHx8IHByb3AgPT09ICdwYWludCcgfHwgcHJvcCA9PT0gJ2ZpbHRlcicgfHwgcHJvcCA9PT0gJ21ldGFkYXRhJyB8fCBwcm9wID09PSAnbWluem9vbScgfHwgcHJvcCA9PT0gJ21heHpvb20nKSBjb250aW51ZTtcblxuICAgICAgaWYgKHByb3AuaW5kZXhPZigncGFpbnQuJykgPT09IDApIHtcbiAgICAgICAgZGlmZkxheWVyUHJvcGVydHlDaGFuZ2VzKGJlZm9yZUxheWVyW3Byb3BdLCBhZnRlckxheWVyW3Byb3BdLCBjb21tYW5kcywgbGF5ZXJJZCwgcHJvcC5zbGljZSg2KSwgb3BlcmF0aW9ucy5zZXRQYWludFByb3BlcnR5KTtcbiAgICAgIH0gZWxzZSBpZiAoIWRlZXBFcXVhbChiZWZvcmVMYXllcltwcm9wXSwgYWZ0ZXJMYXllcltwcm9wXSkpIHtcbiAgICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRMYXllclByb3BlcnR5LFxuICAgICAgICAgIGFyZ3M6IFtsYXllcklkLCBwcm9wLCBhZnRlckxheWVyW3Byb3BdXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZlN0eWxlcyhiZWZvcmUsIGFmdGVyKSB7XG4gIGlmICghYmVmb3JlKSByZXR1cm4gW3tcbiAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFN0eWxlLFxuICAgIGFyZ3M6IFthZnRlcl1cbiAgfV07XG4gIHZhciBjb21tYW5kcyA9IFtdO1xuXG4gIHRyeSB7XG4gICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLnZlcnNpb24sIGFmdGVyLnZlcnNpb24pKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRTdHlsZSxcbiAgICAgICAgYXJnczogW2FmdGVyXVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLmNlbnRlciwgYWZ0ZXIuY2VudGVyKSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0Q2VudGVyLFxuICAgICAgICBhcmdzOiBbYWZ0ZXIuY2VudGVyXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFkZWVwRXF1YWwoYmVmb3JlLnpvb20sIGFmdGVyLnpvb20pKSB7XG4gICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRab29tLFxuICAgICAgICBhcmdzOiBbYWZ0ZXIuem9vbV1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5iZWFyaW5nLCBhZnRlci5iZWFyaW5nKSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0QmVhcmluZyxcbiAgICAgICAgYXJnczogW2FmdGVyLmJlYXJpbmddXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUucGl0Y2gsIGFmdGVyLnBpdGNoKSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0UGl0Y2gsXG4gICAgICAgIGFyZ3M6IFthZnRlci5waXRjaF1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5zcHJpdGUsIGFmdGVyLnNwcml0ZSkpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFNwcml0ZSxcbiAgICAgICAgYXJnczogW2FmdGVyLnNwcml0ZV1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5nbHlwaHMsIGFmdGVyLmdseXBocykpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEdseXBocyxcbiAgICAgICAgYXJnczogW2FmdGVyLmdseXBoc11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS50cmFuc2l0aW9uLCBhZnRlci50cmFuc2l0aW9uKSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0VHJhbnNpdGlvbixcbiAgICAgICAgYXJnczogW2FmdGVyLnRyYW5zaXRpb25dXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmUubGlnaHQsIGFmdGVyLmxpZ2h0KSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0TGlnaHQsXG4gICAgICAgIGFyZ3M6IFthZnRlci5saWdodF1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghZGVlcEVxdWFsKGJlZm9yZS5mb2csIGFmdGVyLmZvZykpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldEZvZyxcbiAgICAgICAgYXJnczogW2FmdGVyLmZvZ11cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VzUmVtb3ZlZCA9IHt9O1xuICAgIHZhciByZW1vdmVPckFkZFNvdXJjZUNvbW1hbmRzID0gW107XG4gICAgZGlmZlNvdXJjZXMoYmVmb3JlLnNvdXJjZXMsIGFmdGVyLnNvdXJjZXMsIHJlbW92ZU9yQWRkU291cmNlQ29tbWFuZHMsIHNvdXJjZXNSZW1vdmVkKTtcbiAgICB2YXIgYmVmb3JlTGF5ZXJzID0gW107XG5cbiAgICBpZiAoYmVmb3JlLmxheWVycykge1xuICAgICAgYmVmb3JlLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAoc291cmNlc1JlbW92ZWRbbGF5ZXIuc291cmNlXSkge1xuICAgICAgICAgIGNvbW1hbmRzLnB1c2goe1xuICAgICAgICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5yZW1vdmVMYXllcixcbiAgICAgICAgICAgIGFyZ3M6IFtsYXllci5pZF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZWZvcmVMYXllcnMucHVzaChsYXllcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBiZWZvcmVUZXJyYWluID0gYmVmb3JlLnRlcnJhaW47XG5cbiAgICBpZiAoYmVmb3JlVGVycmFpbikge1xuICAgICAgaWYgKHNvdXJjZXNSZW1vdmVkW2JlZm9yZVRlcnJhaW4uc291cmNlXSkge1xuICAgICAgICBjb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICBjb21tYW5kOiBvcGVyYXRpb25zLnNldFRlcnJhaW4sXG4gICAgICAgICAgYXJnczogW3VuZGVmaW5lZF1cbiAgICAgICAgfSk7XG4gICAgICAgIGJlZm9yZVRlcnJhaW4gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tbWFuZHMgPSBjb21tYW5kcy5jb25jYXQocmVtb3ZlT3JBZGRTb3VyY2VDb21tYW5kcyk7XG5cbiAgICBpZiAoIWRlZXBFcXVhbChiZWZvcmVUZXJyYWluLCBhZnRlci50ZXJyYWluKSkge1xuICAgICAgY29tbWFuZHMucHVzaCh7XG4gICAgICAgIGNvbW1hbmQ6IG9wZXJhdGlvbnMuc2V0VGVycmFpbixcbiAgICAgICAgYXJnczogW2FmdGVyLnRlcnJhaW5dXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkaWZmTGF5ZXJzKGJlZm9yZUxheWVycywgYWZ0ZXIubGF5ZXJzLCBjb21tYW5kcyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLndhcm4oJ1VuYWJsZSB0byBjb21wdXRlIHN0eWxlIGRpZmY6JywgZSk7XG4gICAgY29tbWFuZHMgPSBbe1xuICAgICAgY29tbWFuZDogb3BlcmF0aW9ucy5zZXRTdHlsZSxcbiAgICAgIGFyZ3M6IFthZnRlcl1cbiAgICB9XTtcbiAgfVxuXG4gIHJldHVybiBjb21tYW5kcztcbn1cblxudmFyIFZhbGlkYXRpb25FcnJvciA9IGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBtZXNzYWdlLCBpZGVudGlmaWVyKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWYWxpZGF0aW9uRXJyb3IpO1xuXG4gIHRoaXMubWVzc2FnZSA9IChrZXkgPyBcIlwiLmNvbmNhdChrZXksIFwiOiBcIikgOiAnJykgKyBtZXNzYWdlO1xuICBpZiAoaWRlbnRpZmllcikgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZS5fX2xpbmVfXykge1xuICAgIHRoaXMubGluZSA9IHZhbHVlLl9fbGluZV9fO1xuICB9XG59O1xuXG52YXIgUGFyc2luZ0Vycm9yJDEgPSBmdW5jdGlvbiBQYXJzaW5nRXJyb3IkMShlcnJvcikge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2luZ0Vycm9yJDEpO1xuXG4gIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgdGhpcy5tZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgdmFyIG1hdGNoID0gZXJyb3IubWVzc2FnZS5tYXRjaCgvbGluZSAoXFxkKykvKTtcbiAgdGhpcy5saW5lID0gbWF0Y2ggPyBwYXJzZUludChtYXRjaFsxXSwgMTApIDogMDtcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RhbnRzKG9wdGlvbnMpIHtcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgY29uc3RhbnRzID0gb3B0aW9ucy52YWx1ZTtcblxuICBpZiAoY29uc3RhbnRzKSB7XG4gICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgY29uc3RhbnRzLCAnY29uc3RhbnRzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFzIG9mIHY4JyldO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmJ1bmRsZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgcmV0dXJuIHZhbHVlLnZhbHVlT2YoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVlcFVuYnVuZGxlKHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoZGVlcFVuYnVuZGxlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbikpIHtcbiAgICB2YXIgdW5idW5kbGVkVmFsdWUgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgdW5idW5kbGVkVmFsdWVba2V5XSA9IGRlZXBVbmJ1bmRsZSh2YWx1ZVtrZXldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5idW5kbGVkVmFsdWU7XG4gIH1cblxuICByZXR1cm4gdW5idW5kbGUodmFsdWUpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvcHRpb25zKSB7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgdmFyIG9iamVjdCA9IG9wdGlvbnMudmFsdWU7XG4gIHZhciBlbGVtZW50U3BlY3MgPSBvcHRpb25zLnZhbHVlU3BlYyB8fCB7fTtcbiAgdmFyIGVsZW1lbnRWYWxpZGF0b3JzID0gb3B0aW9ucy5vYmplY3RFbGVtZW50VmFsaWRhdG9ycyB8fCB7fTtcbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciB0eXBlID0gZ2V0VHlwZShvYmplY3QpO1xuXG4gIGlmICh0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG9iamVjdCwgXCJvYmplY3QgZXhwZWN0ZWQsIFwiLmNvbmNhdCh0eXBlLCBcIiBmb3VuZFwiKSldO1xuICB9XG5cbiAgZm9yICh2YXIgb2JqZWN0S2V5IGluIG9iamVjdCkge1xuICAgIHZhciBlbGVtZW50U3BlY0tleSA9IG9iamVjdEtleS5zcGxpdCgnLicpWzBdO1xuICAgIHZhciBlbGVtZW50U3BlYyA9IGVsZW1lbnRTcGVjc1tlbGVtZW50U3BlY0tleV0gfHwgZWxlbWVudFNwZWNzWycqJ107XG4gICAgdmFyIHZhbGlkYXRlRWxlbWVudCA9IHZvaWQgMDtcblxuICAgIGlmIChlbGVtZW50VmFsaWRhdG9yc1tlbGVtZW50U3BlY0tleV0pIHtcbiAgICAgIHZhbGlkYXRlRWxlbWVudCA9IGVsZW1lbnRWYWxpZGF0b3JzW2VsZW1lbnRTcGVjS2V5XTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnRTcGVjc1tlbGVtZW50U3BlY0tleV0pIHtcbiAgICAgIHZhbGlkYXRlRWxlbWVudCA9IHZhbGlkYXRlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudFZhbGlkYXRvcnNbJyonXSkge1xuICAgICAgdmFsaWRhdGVFbGVtZW50ID0gZWxlbWVudFZhbGlkYXRvcnNbJyonXTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnRTcGVjc1snKiddKSB7XG4gICAgICB2YWxpZGF0ZUVsZW1lbnQgPSB2YWxpZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIG9iamVjdFtvYmplY3RLZXldLCBcInVua25vd24gcHJvcGVydHkgXFxcIlwiLmNvbmNhdChvYmplY3RLZXksIFwiXFxcIlwiKSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUVsZW1lbnQoe1xuICAgICAga2V5OiAoa2V5ID8gXCJcIi5jb25jYXQoa2V5LCBcIi5cIikgOiBrZXkpICsgb2JqZWN0S2V5LFxuICAgICAgdmFsdWU6IG9iamVjdFtvYmplY3RLZXldLFxuICAgICAgdmFsdWVTcGVjOiBlbGVtZW50U3BlYyxcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjLFxuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBvYmplY3RLZXk6IG9iamVjdEtleVxuICAgIH0sIG9iamVjdCkpO1xuICB9XG5cbiAgZm9yICh2YXIgX2VsZW1lbnRTcGVjS2V5IGluIGVsZW1lbnRTcGVjcykge1xuICAgIGlmIChlbGVtZW50VmFsaWRhdG9yc1tfZWxlbWVudFNwZWNLZXldKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudFNwZWNzW19lbGVtZW50U3BlY0tleV0ucmVxdWlyZWQgJiYgZWxlbWVudFNwZWNzW19lbGVtZW50U3BlY0tleV1bJ2RlZmF1bHQnXSA9PT0gdW5kZWZpbmVkICYmIG9iamVjdFtfZWxlbWVudFNwZWNLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBvYmplY3QsIFwibWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KF9lbGVtZW50U3BlY0tleSwgXCJcXFwiXCIpKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVBcnJheShvcHRpb25zKSB7XG4gIHZhciBhcnJheSA9IG9wdGlvbnMudmFsdWU7XG4gIHZhciBhcnJheVNwZWMgPSBvcHRpb25zLnZhbHVlU3BlYztcbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gIHZhciB2YWxpZGF0ZUFycmF5RWxlbWVudCA9IG9wdGlvbnMuYXJyYXlFbGVtZW50VmFsaWRhdG9yIHx8IHZhbGlkYXRlO1xuXG4gIGlmIChnZXRUeXBlKGFycmF5KSAhPT0gJ2FycmF5Jykge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGFycmF5LCBcImFycmF5IGV4cGVjdGVkLCBcIi5jb25jYXQoZ2V0VHlwZShhcnJheSksIFwiIGZvdW5kXCIpKV07XG4gIH1cblxuICBpZiAoYXJyYXlTcGVjLmxlbmd0aCAmJiBhcnJheS5sZW5ndGggIT09IGFycmF5U3BlYy5sZW5ndGgpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgXCJhcnJheSBsZW5ndGggXCIuY29uY2F0KGFycmF5U3BlYy5sZW5ndGgsIFwiIGV4cGVjdGVkLCBsZW5ndGggXCIpLmNvbmNhdChhcnJheS5sZW5ndGgsIFwiIGZvdW5kXCIpKV07XG4gIH1cblxuICBpZiAoYXJyYXlTcGVjWydtaW4tbGVuZ3RoJ10gJiYgYXJyYXkubGVuZ3RoIDwgYXJyYXlTcGVjWydtaW4tbGVuZ3RoJ10pIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBhcnJheSwgXCJhcnJheSBsZW5ndGggYXQgbGVhc3QgXCIuY29uY2F0KGFycmF5U3BlY1snbWluLWxlbmd0aCddLCBcIiBleHBlY3RlZCwgbGVuZ3RoIFwiKS5jb25jYXQoYXJyYXkubGVuZ3RoLCBcIiBmb3VuZFwiKSldO1xuICB9XG5cbiAgdmFyIGFycmF5RWxlbWVudFNwZWMgPSB7XG4gICAgJ3R5cGUnOiBhcnJheVNwZWMudmFsdWUsXG4gICAgJ3ZhbHVlcyc6IGFycmF5U3BlYy52YWx1ZXMsXG4gICAgJ21pbmltdW0nOiBhcnJheVNwZWMubWluaW11bSxcbiAgICAnbWF4aW11bSc6IGFycmF5U3BlYy5tYXhpbXVtXG4gIH07XG5cbiAgaWYgKHN0eWxlU3BlYy4kdmVyc2lvbiA8IDcpIHtcbiAgICBhcnJheUVsZW1lbnRTcGVjLmZ1bmN0aW9uID0gYXJyYXlTcGVjLmZ1bmN0aW9uO1xuICB9XG5cbiAgaWYgKGdldFR5cGUoYXJyYXlTcGVjLnZhbHVlKSA9PT0gJ29iamVjdCcpIHtcbiAgICBhcnJheUVsZW1lbnRTcGVjID0gYXJyYXlTcGVjLnZhbHVlO1xuICB9XG5cbiAgdmFyIGVycm9ycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlQXJyYXlFbGVtZW50KHtcbiAgICAgIGFycmF5OiBhcnJheSxcbiAgICAgIGFycmF5SW5kZXg6IGksXG4gICAgICB2YWx1ZTogYXJyYXlbaV0sXG4gICAgICB2YWx1ZVNwZWM6IGFycmF5RWxlbWVudFNwZWMsXG4gICAgICBzdHlsZTogc3R5bGUsXG4gICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgIGtleTogXCJcIi5jb25jYXQoa2V5LCBcIltcIikuY29uY2F0KGksIFwiXVwiKVxuICAgIH0pKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKG9wdGlvbnMpIHtcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG5cbiAgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSB2YWx1ZSkge1xuICAgIHR5cGUgPSAnTmFOJztcbiAgfVxuXG4gIGlmICh0eXBlICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcIm51bWJlciBleHBlY3RlZCwgXCIuY29uY2F0KHR5cGUsIFwiIGZvdW5kXCIpKV07XG4gIH1cblxuICBpZiAoJ21pbmltdW0nIGluIHZhbHVlU3BlYykge1xuICAgIHZhciBzcGVjTWluID0gdmFsdWVTcGVjLm1pbmltdW07XG5cbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZVNwZWMubWluaW11bSkgPT09ICdhcnJheScpIHtcbiAgICAgIHZhciBpID0gb3B0aW9ucy5hcnJheUluZGV4O1xuICAgICAgc3BlY01pbiA9IHZhbHVlU3BlYy5taW5pbXVtW2ldO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSA8IHNwZWNNaW4pIHtcbiAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcIlwiLmNvbmNhdCh2YWx1ZSwgXCIgaXMgbGVzcyB0aGFuIHRoZSBtaW5pbXVtIHZhbHVlIFwiKS5jb25jYXQoc3BlY01pbikpXTtcbiAgICB9XG4gIH1cblxuICBpZiAoJ21heGltdW0nIGluIHZhbHVlU3BlYykge1xuICAgIHZhciBzcGVjTWF4ID0gdmFsdWVTcGVjLm1heGltdW07XG5cbiAgICBpZiAoZ2V0VHlwZSh2YWx1ZVNwZWMubWF4aW11bSkgPT09ICdhcnJheScpIHtcbiAgICAgIHZhciBfaTkgPSBvcHRpb25zLmFycmF5SW5kZXg7XG4gICAgICBzcGVjTWF4ID0gdmFsdWVTcGVjLm1heGltdW1bX2k5XTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPiBzcGVjTWF4KSB7XG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJcIi5jb25jYXQodmFsdWUsIFwiIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSBcIikuY29uY2F0KHNwZWNNYXgpKV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIGZ1bmN0aW9uVmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gIHZhciBmdW5jdGlvblR5cGUgPSB1bmJ1bmRsZShvcHRpb25zLnZhbHVlLnR5cGUpO1xuICB2YXIgc3RvcEtleVR5cGU7XG4gIHZhciBzdG9wRG9tYWluVmFsdWVzID0ge307XG4gIHZhciBwcmV2aW91c1N0b3BEb21haW5WYWx1ZTtcbiAgdmFyIHByZXZpb3VzU3RvcERvbWFpblpvb207XG4gIHZhciBpc1pvb21GdW5jdGlvbiA9IGZ1bmN0aW9uVHlwZSAhPT0gJ2NhdGVnb3JpY2FsJyAmJiBvcHRpb25zLnZhbHVlLnByb3BlcnR5ID09PSB1bmRlZmluZWQ7XG4gIHZhciBpc1Byb3BlcnR5RnVuY3Rpb24gPSAhaXNab29tRnVuY3Rpb247XG4gIHZhciBpc1pvb21BbmRQcm9wZXJ0eUZ1bmN0aW9uID0gZ2V0VHlwZShvcHRpb25zLnZhbHVlLnN0b3BzKSA9PT0gJ2FycmF5JyAmJiBnZXRUeXBlKG9wdGlvbnMudmFsdWUuc3RvcHNbMF0pID09PSAnYXJyYXknICYmIGdldFR5cGUob3B0aW9ucy52YWx1ZS5zdG9wc1swXVswXSkgPT09ICdvYmplY3QnO1xuICB2YXIgZXJyb3JzID0gdmFsaWRhdGVPYmplY3Qoe1xuICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgdmFsdWU6IG9wdGlvbnMudmFsdWUsXG4gICAgdmFsdWVTcGVjOiBvcHRpb25zLnN0eWxlU3BlYy5mdW5jdGlvbixcbiAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICBzdG9wczogdmFsaWRhdGVGdW5jdGlvblN0b3BzLFxuICAgICAgZGVmYXVsdDogdmFsaWRhdGVGdW5jdGlvbkRlZmF1bHRcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChmdW5jdGlvblR5cGUgPT09ICdpZGVudGl0eScgJiYgaXNab29tRnVuY3Rpb24pIHtcbiAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCBvcHRpb25zLnZhbHVlLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInByb3BlcnR5XCInKSk7XG4gIH1cblxuICBpZiAoZnVuY3Rpb25UeXBlICE9PSAnaWRlbnRpdHknICYmICFvcHRpb25zLnZhbHVlLnN0b3BzKSB7XG4gICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ21pc3NpbmcgcmVxdWlyZWQgcHJvcGVydHkgXCJzdG9wc1wiJykpO1xuICB9XG5cbiAgaWYgKGZ1bmN0aW9uVHlwZSA9PT0gJ2V4cG9uZW50aWFsJyAmJiBvcHRpb25zLnZhbHVlU3BlYy5leHByZXNzaW9uICYmICFzdXBwb3J0c0ludGVycG9sYXRpb24ob3B0aW9ucy52YWx1ZVNwZWMpKSB7XG4gICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ2V4cG9uZW50aWFsIGZ1bmN0aW9ucyBub3Qgc3VwcG9ydGVkJykpO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuc3R5bGVTcGVjLiR2ZXJzaW9uID49IDgpIHtcbiAgICBpZiAoaXNQcm9wZXJ0eUZ1bmN0aW9uICYmICFzdXBwb3J0c1Byb3BlcnR5RXhwcmVzc2lvbihvcHRpb25zLnZhbHVlU3BlYykpIHtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdwcm9wZXJ0eSBmdW5jdGlvbnMgbm90IHN1cHBvcnRlZCcpKTtcbiAgICB9IGVsc2UgaWYgKGlzWm9vbUZ1bmN0aW9uICYmICFzdXBwb3J0c1pvb21FeHByZXNzaW9uKG9wdGlvbnMudmFsdWVTcGVjKSkge1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ3pvb20gZnVuY3Rpb25zIG5vdCBzdXBwb3J0ZWQnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKChmdW5jdGlvblR5cGUgPT09ICdjYXRlZ29yaWNhbCcgfHwgaXNab29tQW5kUHJvcGVydHlGdW5jdGlvbikgJiYgb3B0aW9ucy52YWx1ZS5wcm9wZXJ0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ1wicHJvcGVydHlcIiBwcm9wZXJ0eSBpcyByZXF1aXJlZCcpKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvcnM7XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvblN0b3BzKG9wdGlvbnMpIHtcbiAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnaWRlbnRpdHknKSB7XG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdpZGVudGl0eSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgYSBcInN0b3BzXCIgcHJvcGVydHknKV07XG4gICAgfVxuXG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUFycmF5KHtcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICB2YWx1ZVNwZWM6IG9wdGlvbnMudmFsdWVTcGVjLFxuICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgYXJyYXlFbGVtZW50VmFsaWRhdG9yOiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcFxuICAgIH0pKTtcblxuICAgIGlmIChnZXRUeXBlKHZhbHVlKSA9PT0gJ2FycmF5JyAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHZhbHVlLCAnYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzdG9wJykpO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uU3RvcChvcHRpb25zKSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuXG4gICAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnYXJyYXknKSB7XG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJhcnJheSBleHBlY3RlZCwgXCIuY29uY2F0KGdldFR5cGUodmFsdWUpLCBcIiBmb3VuZFwiKSldO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcImFycmF5IGxlbmd0aCAyIGV4cGVjdGVkLCBsZW5ndGggXCIuY29uY2F0KHZhbHVlLmxlbmd0aCwgXCIgZm91bmRcIikpXTtcbiAgICB9XG5cbiAgICBpZiAoaXNab29tQW5kUHJvcGVydHlGdW5jdGlvbikge1xuICAgICAgaWYgKGdldFR5cGUodmFsdWVbMF0pICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJvYmplY3QgZXhwZWN0ZWQsIFwiLmNvbmNhdChnZXRUeXBlKHZhbHVlWzBdKSwgXCIgZm91bmRcIikpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlWzBdLnpvb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ29iamVjdCBzdG9wIGtleSBtdXN0IGhhdmUgem9vbScpXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlWzBdLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdvYmplY3Qgc3RvcCBrZXkgbXVzdCBoYXZlIHZhbHVlJyldO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldmlvdXNTdG9wRG9tYWluWm9vbSAmJiBwcmV2aW91c1N0b3BEb21haW5ab29tID4gdW5idW5kbGUodmFsdWVbMF0uem9vbSkpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWVbMF0uem9vbSwgJ3N0b3Agem9vbSB2YWx1ZXMgbXVzdCBhcHBlYXIgaW4gYXNjZW5kaW5nIG9yZGVyJyldO1xuICAgICAgfVxuXG4gICAgICBpZiAodW5idW5kbGUodmFsdWVbMF0uem9vbSkgIT09IHByZXZpb3VzU3RvcERvbWFpblpvb20pIHtcbiAgICAgICAgcHJldmlvdXNTdG9wRG9tYWluWm9vbSA9IHVuYnVuZGxlKHZhbHVlWzBdLnpvb20pO1xuICAgICAgICBwcmV2aW91c1N0b3BEb21haW5WYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RvcERvbWFpblZhbHVlcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXksIFwiWzBdXCIpLFxuICAgICAgICB2YWx1ZTogdmFsdWVbMF0sXG4gICAgICAgIHZhbHVlU3BlYzoge1xuICAgICAgICAgIHpvb206IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICBvYmplY3RFbGVtZW50VmFsaWRhdG9yczoge1xuICAgICAgICAgIHpvb206IHZhbGlkYXRlTnVtYmVyLFxuICAgICAgICAgIHZhbHVlOiB2YWxpZGF0ZVN0b3BEb21haW5WYWx1ZVxuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVTdG9wRG9tYWluVmFsdWUoe1xuICAgICAgICBrZXk6IFwiXCIuY29uY2F0KGtleSwgXCJbMF1cIiksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVswXSxcbiAgICAgICAgdmFsdWVTcGVjOiB7fSxcbiAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICAgIH0sIHZhbHVlKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzRXhwcmVzc2lvbihkZWVwVW5idW5kbGUodmFsdWVbMV0pKSkge1xuICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3IoXCJcIi5jb25jYXQoa2V5LCBcIlsxXVwiKSwgdmFsdWVbMV0sICdleHByZXNzaW9ucyBhcmUgbm90IGFsbG93ZWQgaW4gZnVuY3Rpb24gc3RvcHMuJyldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICBrZXk6IFwiXCIuY29uY2F0KGtleSwgXCJbMV1cIiksXG4gICAgICB2YWx1ZTogdmFsdWVbMV0sXG4gICAgICB2YWx1ZVNwZWM6IGZ1bmN0aW9uVmFsdWVTcGVjLFxuICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gICAgfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVTdG9wRG9tYWluVmFsdWUob3B0aW9ucywgc3RvcCkge1xuICAgIHZhciB0eXBlID0gZ2V0VHlwZShvcHRpb25zLnZhbHVlKTtcbiAgICB2YXIgdmFsdWUgPSB1bmJ1bmRsZShvcHRpb25zLnZhbHVlKTtcbiAgICB2YXIgcmVwb3J0VmFsdWUgPSBvcHRpb25zLnZhbHVlICE9PSBudWxsID8gb3B0aW9ucy52YWx1ZSA6IHN0b3A7XG5cbiAgICBpZiAoIXN0b3BLZXlUeXBlKSB7XG4gICAgICBzdG9wS2V5VHlwZSA9IHR5cGU7XG4gICAgfSBlbHNlIGlmICh0eXBlICE9PSBzdG9wS2V5VHlwZSkge1xuICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKG9wdGlvbnMua2V5LCByZXBvcnRWYWx1ZSwgXCJcIi5jb25jYXQodHlwZSwgXCIgc3RvcCBkb21haW4gdHlwZSBtdXN0IG1hdGNoIHByZXZpb3VzIHN0b3AgZG9tYWluIHR5cGUgXCIpLmNvbmNhdChzdG9wS2V5VHlwZSkpXTtcbiAgICB9XG5cbiAgICBpZiAodHlwZSAhPT0gJ251bWJlcicgJiYgdHlwZSAhPT0gJ3N0cmluZycgJiYgdHlwZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCAnc3RvcCBkb21haW4gdmFsdWUgbXVzdCBiZSBhIG51bWJlciwgc3RyaW5nLCBvciBib29sZWFuJyldO1xuICAgIH1cblxuICAgIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJiBmdW5jdGlvblR5cGUgIT09ICdjYXRlZ29yaWNhbCcpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gXCJudW1iZXIgZXhwZWN0ZWQsIFwiLmNvbmNhdCh0eXBlLCBcIiBmb3VuZFwiKTtcblxuICAgICAgaWYgKHN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKGZ1bmN0aW9uVmFsdWVTcGVjKSAmJiBmdW5jdGlvblR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXNzYWdlICs9ICdcXG5JZiB5b3UgaW50ZW5kZWQgdG8gdXNlIGEgY2F0ZWdvcmljYWwgZnVuY3Rpb24sIHNwZWNpZnkgYFwidHlwZVwiOiBcImNhdGVnb3JpY2FsXCJgLic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsIG1lc3NhZ2UpXTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHR5cGUgPT09ICdudW1iZXInICYmICghaXNGaW5pdGUodmFsdWUpIHx8IE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsIFwiaW50ZWdlciBleHBlY3RlZCwgZm91bmQgXCIuY29uY2F0KHZhbHVlKSldO1xuICAgIH1cblxuICAgIGlmIChmdW5jdGlvblR5cGUgIT09ICdjYXRlZ29yaWNhbCcgJiYgdHlwZSA9PT0gJ251bWJlcicgJiYgcHJldmlvdXNTdG9wRG9tYWluVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA8IHByZXZpb3VzU3RvcERvbWFpblZhbHVlKSB7XG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIHJlcG9ydFZhbHVlLCAnc3RvcCBkb21haW4gdmFsdWVzIG11c3QgYXBwZWFyIGluIGFzY2VuZGluZyBvcmRlcicpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNTdG9wRG9tYWluVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoZnVuY3Rpb25UeXBlID09PSAnY2F0ZWdvcmljYWwnICYmIHZhbHVlIGluIHN0b3BEb21haW5WYWx1ZXMpIHtcbiAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgcmVwb3J0VmFsdWUsICdzdG9wIGRvbWFpbiB2YWx1ZXMgbXVzdCBiZSB1bmlxdWUnKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3BEb21haW5WYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uRGVmYXVsdChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKHtcbiAgICAgIGtleTogb3B0aW9ucy5rZXksXG4gICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgIHZhbHVlU3BlYzogZnVuY3Rpb25WYWx1ZVNwZWMsXG4gICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWNcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cHJlc3Npb24ob3B0aW9ucykge1xuICB2YXIgZXhwcmVzc2lvbiA9IChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAncHJvcGVydHknID8gY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uIDogY3JlYXRlRXhwcmVzc2lvbikoZGVlcFVuYnVuZGxlKG9wdGlvbnMudmFsdWUpLCBvcHRpb25zLnZhbHVlU3BlYyk7XG5cbiAgaWYgKGV4cHJlc3Npb24ucmVzdWx0ID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24udmFsdWUubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJcIi5jb25jYXQob3B0aW9ucy5rZXkpLmNvbmNhdChlcnJvci5rZXkpLCBvcHRpb25zLnZhbHVlLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBleHByZXNzaW9uT2JqID0gZXhwcmVzc2lvbi52YWx1ZS5leHByZXNzaW9uIHx8IGV4cHJlc3Npb24udmFsdWUuX3N0eWxlRXhwcmVzc2lvbi5leHByZXNzaW9uO1xuXG4gIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAncHJvcGVydHknICYmIG9wdGlvbnMucHJvcGVydHlLZXkgPT09ICd0ZXh0LWZvbnQnICYmICFleHByZXNzaW9uT2JqLm91dHB1dERlZmluZWQoKSkge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgXCJJbnZhbGlkIGRhdGEgZXhwcmVzc2lvbiBmb3IgXFxcIlwiLmNvbmNhdChvcHRpb25zLnByb3BlcnR5S2V5LCBcIlxcXCIuIE91dHB1dCB2YWx1ZXMgbXVzdCBiZSBjb250YWluZWQgYXMgbGl0ZXJhbHMgd2l0aGluIHRoZSBleHByZXNzaW9uLlwiKSldO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdwcm9wZXJ0eScgJiYgb3B0aW9ucy5wcm9wZXJ0eVR5cGUgPT09ICdsYXlvdXQnICYmICFpc1N0YXRlQ29uc3RhbnQoZXhwcmVzc2lvbk9iaikpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdcImZlYXR1cmUtc3RhdGVcIiBkYXRhIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggbGF5b3V0IHByb3BlcnRpZXMuJyldO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZXhwcmVzc2lvbkNvbnRleHQgPT09ICdmaWx0ZXInICYmICFpc1N0YXRlQ29uc3RhbnQoZXhwcmVzc2lvbk9iaikpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdcImZlYXR1cmUtc3RhdGVcIiBkYXRhIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkIHdpdGggZmlsdGVycy4nKV07XG4gIH1cblxuICBpZiAob3B0aW9ucy5leHByZXNzaW9uQ29udGV4dCAmJiBvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0LmluZGV4T2YoJ2NsdXN0ZXInKSA9PT0gMCkge1xuICAgIGlmICghaXNHbG9iYWxQcm9wZXJ0eUNvbnN0YW50KGV4cHJlc3Npb25PYmosIFsnem9vbScsICdmZWF0dXJlLXN0YXRlJ10pKSB7XG4gICAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Iob3B0aW9ucy5rZXksIG9wdGlvbnMudmFsdWUsICdcInpvb21cIiBhbmQgXCJmZWF0dXJlLXN0YXRlXCIgZXhwcmVzc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBjbHVzdGVyIHByb3BlcnRpZXMuJyldO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmV4cHJlc3Npb25Db250ZXh0ID09PSAnY2x1c3Rlci1pbml0aWFsJyAmJiAhaXNGZWF0dXJlQ29uc3RhbnQoZXhwcmVzc2lvbk9iaikpIHtcbiAgICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihvcHRpb25zLmtleSwgb3B0aW9ucy52YWx1ZSwgJ0ZlYXR1cmUgZGF0YSBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIGluaXRpYWwgZXhwcmVzc2lvbiBwYXJ0IG9mIGNsdXN0ZXIgcHJvcGVydGllcy4nKV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUJvb2xlYW4ob3B0aW9ucykge1xuICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gIHZhciB0eXBlID0gZ2V0VHlwZSh2YWx1ZSk7XG5cbiAgaWYgKHR5cGUgIT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcImJvb2xlYW4gZXhwZWN0ZWQsIFwiLmNvbmNhdCh0eXBlLCBcIiBmb3VuZFwiKSldO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbG9yKG9wdGlvbnMpIHtcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcImNvbG9yIGV4cGVjdGVkLCBcIi5jb25jYXQodHlwZSwgXCIgZm91bmRcIikpXTtcbiAgfVxuXG4gIGlmIChjc3Njb2xvcnBhcnNlci5wYXJzZUNTU0NvbG9yKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcImNvbG9yIGV4cGVjdGVkLCBcXFwiXCIuY29uY2F0KHZhbHVlLCBcIlxcXCIgZm91bmRcIikpXTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVFbnVtKG9wdGlvbnMpIHtcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWM7XG4gIHZhciBlcnJvcnMgPSBbXTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZVNwZWMudmFsdWVzKSkge1xuICAgIGlmICh2YWx1ZVNwZWMudmFsdWVzLmluZGV4T2YodW5idW5kbGUodmFsdWUpKSA9PT0gLTEpIHtcbiAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJleHBlY3RlZCBvbmUgb2YgW1wiLmNvbmNhdCh2YWx1ZVNwZWMudmFsdWVzLmpvaW4oJywgJyksIFwiXSwgXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeSh2YWx1ZSksIFwiIGZvdW5kXCIpKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZVNwZWMudmFsdWVzKS5pbmRleE9mKHVuYnVuZGxlKHZhbHVlKSkgPT09IC0xKSB7XG4gICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIFwiZXhwZWN0ZWQgb25lIG9mIFtcIi5jb25jYXQoT2JqZWN0LmtleXModmFsdWVTcGVjLnZhbHVlcykuam9pbignLCAnKSwgXCJdLCBcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KHZhbHVlKSwgXCIgZm91bmRcIikpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZpbHRlcihvcHRpb25zKSB7XG4gIGlmIChpc0V4cHJlc3Npb25GaWx0ZXIoZGVlcFVuYnVuZGxlKG9wdGlvbnMudmFsdWUpKSkge1xuICAgIHJldHVybiB2YWxpZGF0ZUV4cHJlc3Npb24oZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICBleHByZXNzaW9uQ29udGV4dDogJ2ZpbHRlcicsXG4gICAgICB2YWx1ZVNwZWM6IHtcbiAgICAgICAgdmFsdWU6ICdib29sZWFuJ1xuICAgICAgfVxuICAgIH0pKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsaWRhdGVOb25FeHByZXNzaW9uRmlsdGVyKG9wdGlvbnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTm9uRXhwcmVzc2lvbkZpbHRlcihvcHRpb25zKSB7XG4gIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcblxuICBpZiAoZ2V0VHlwZSh2YWx1ZSkgIT09ICdhcnJheScpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJhcnJheSBleHBlY3RlZCwgXCIuY29uY2F0KGdldFR5cGUodmFsdWUpLCBcIiBmb3VuZFwiKSldO1xuICB9XG5cbiAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICB2YXIgdHlwZTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuXG4gIGlmICh2YWx1ZS5sZW5ndGggPCAxKSB7XG4gICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdmaWx0ZXIgYXJyYXkgbXVzdCBoYXZlIGF0IGxlYXN0IDEgZWxlbWVudCcpXTtcbiAgfVxuXG4gIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVFbnVtKHtcbiAgICBrZXk6IFwiXCIuY29uY2F0KGtleSwgXCJbMF1cIiksXG4gICAgdmFsdWU6IHZhbHVlWzBdLFxuICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmZpbHRlcl9vcGVyYXRvcixcbiAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjXG4gIH0pKTtcblxuICBzd2l0Y2ggKHVuYnVuZGxlKHZhbHVlWzBdKSkge1xuICAgIGNhc2UgJzwnOlxuICAgIGNhc2UgJzw9JzpcbiAgICBjYXNlICc+JzpcbiAgICBjYXNlICc+PSc6XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIgJiYgdW5idW5kbGUodmFsdWVbMV0pID09PSAnJHR5cGUnKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJcXFwiJHR5cGVcXFwiIGNhbm5vdCBiZSB1c2Ugd2l0aCBvcGVyYXRvciBcXFwiXCIuY29uY2F0KHZhbHVlWzBdLCBcIlxcXCJcIikpKTtcbiAgICAgIH1cblxuICAgIGNhc2UgJz09JzpcbiAgICBjYXNlICchPSc6XG4gICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgXCJmaWx0ZXIgYXJyYXkgZm9yIG9wZXJhdG9yIFxcXCJcIi5jb25jYXQodmFsdWVbMF0sIFwiXFxcIiBtdXN0IGhhdmUgMyBlbGVtZW50c1wiKSkpO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW4nOlxuICAgIGNhc2UgJyFpbic6XG4gICAgICBpZiAodmFsdWUubGVuZ3RoID49IDIpIHtcbiAgICAgICAgdHlwZSA9IGdldFR5cGUodmFsdWVbMV0pO1xuXG4gICAgICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJcIi5jb25jYXQoa2V5LCBcIlsxXVwiKSwgdmFsdWVbMV0sIFwic3RyaW5nIGV4cGVjdGVkLCBcIi5jb25jYXQodHlwZSwgXCIgZm91bmRcIikpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMjsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlW2ldKTtcblxuICAgICAgICBpZiAodW5idW5kbGUodmFsdWVbMV0pID09PSAnJHR5cGUnKSB7XG4gICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUVudW0oe1xuICAgICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXksIFwiW1wiKS5jb25jYXQoaSwgXCJdXCIpLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuZ2VvbWV0cnlfdHlwZSxcbiAgICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSAnc3RyaW5nJyAmJiB0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKFwiXCIuY29uY2F0KGtleSwgXCJbXCIpLmNvbmNhdChpLCBcIl1cIiksIHZhbHVlW2ldLCBcInN0cmluZywgbnVtYmVyLCBvciBib29sZWFuIGV4cGVjdGVkLCBcIi5jb25jYXQodHlwZSwgXCIgZm91bmRcIikpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FueSc6XG4gICAgY2FzZSAnYWxsJzpcbiAgICBjYXNlICdub25lJzpcbiAgICAgIGZvciAodmFyIF9pMTAgPSAxOyBfaTEwIDwgdmFsdWUubGVuZ3RoOyBfaTEwKyspIHtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZU5vbkV4cHJlc3Npb25GaWx0ZXIoe1xuICAgICAgICAgIGtleTogXCJcIi5jb25jYXQoa2V5LCBcIltcIikuY29uY2F0KF9pMTAsIFwiXVwiKSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVbX2kxMF0sXG4gICAgICAgICAgc3R5bGU6IG9wdGlvbnMuc3R5bGUsXG4gICAgICAgICAgc3R5bGVTcGVjOiBvcHRpb25zLnN0eWxlU3BlY1xuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaGFzJzpcbiAgICBjYXNlICchaGFzJzpcbiAgICAgIHR5cGUgPSBnZXRUeXBlKHZhbHVlWzFdKTtcblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsIFwiZmlsdGVyIGFycmF5IGZvciBcXFwiXCIuY29uY2F0KHZhbHVlWzBdLCBcIlxcXCIgb3BlcmF0b3IgbXVzdCBoYXZlIDIgZWxlbWVudHNcIikpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihcIlwiLmNvbmNhdChrZXksIFwiWzFdXCIpLCB2YWx1ZVsxXSwgXCJzdHJpbmcgZXhwZWN0ZWQsIFwiLmNvbmNhdCh0eXBlLCBcIiBmb3VuZFwiKSkpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3dpdGhpbic6XG4gICAgICB0eXBlID0gZ2V0VHlwZSh2YWx1ZVsxXSk7XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcImZpbHRlciBhcnJheSBmb3IgXFxcIlwiLmNvbmNhdCh2YWx1ZVswXSwgXCJcXFwiIG9wZXJhdG9yIG11c3QgaGF2ZSAyIGVsZW1lbnRzXCIpKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoXCJcIi5jb25jYXQoa2V5LCBcIlsxXVwiKSwgdmFsdWVbMV0sIFwib2JqZWN0IGV4cGVjdGVkLCBcIi5jb25jYXQodHlwZSwgXCIgZm91bmRcIikpKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KG9wdGlvbnMsIHByb3BlcnR5VHlwZSkge1xuICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG4gIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgdmFyIHByb3BlcnR5S2V5ID0gb3B0aW9ucy5vYmplY3RLZXk7XG4gIHZhciBsYXllclNwZWMgPSBzdHlsZVNwZWNbXCJcIi5jb25jYXQocHJvcGVydHlUeXBlLCBcIl9cIikuY29uY2F0KG9wdGlvbnMubGF5ZXJUeXBlKV07XG4gIGlmICghbGF5ZXJTcGVjKSByZXR1cm4gW107XG4gIHZhciB0cmFuc2l0aW9uTWF0Y2ggPSBwcm9wZXJ0eUtleS5tYXRjaCgvXiguKiktdHJhbnNpdGlvbiQvKTtcblxuICBpZiAocHJvcGVydHlUeXBlID09PSAncGFpbnQnICYmIHRyYW5zaXRpb25NYXRjaCAmJiBsYXllclNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXSAmJiBsYXllclNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXS50cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMudHJhbnNpdGlvbixcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgfSk7XG4gIH1cblxuICB2YXIgdmFsdWVTcGVjID0gb3B0aW9ucy52YWx1ZVNwZWMgfHwgbGF5ZXJTcGVjW3Byb3BlcnR5S2V5XTtcblxuICBpZiAoIXZhbHVlU3BlYykge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcInVua25vd24gcHJvcGVydHkgXFxcIlwiLmNvbmNhdChwcm9wZXJ0eUtleSwgXCJcXFwiXCIpKV07XG4gIH1cblxuICB2YXIgdG9rZW5NYXRjaDtcblxuICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnICYmIHN1cHBvcnRzUHJvcGVydHlFeHByZXNzaW9uKHZhbHVlU3BlYykgJiYgIXZhbHVlU3BlYy50b2tlbnMgJiYgKHRva2VuTWF0Y2ggPSAvXnsoW159XSspfSQvLmV4ZWModmFsdWUpKSkge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcIlxcXCJcIi5jb25jYXQocHJvcGVydHlLZXksIFwiXFxcIiBkb2VzIG5vdCBzdXBwb3J0IGludGVycG9sYXRpb24gc3ludGF4XFxuXCIpICsgXCJVc2UgYW4gaWRlbnRpdHkgcHJvcGVydHkgZnVuY3Rpb24gaW5zdGVhZDogYHsgXFxcInR5cGVcXFwiOiBcXFwiaWRlbnRpdHlcXFwiLCBcXFwicHJvcGVydHlcXFwiOiBcIi5jb25jYXQoSlNPTi5zdHJpbmdpZnkodG9rZW5NYXRjaFsxXSksIFwiIH1gLlwiKSldO1xuICB9XG5cbiAgdmFyIGVycm9ycyA9IFtdO1xuXG4gIGlmIChvcHRpb25zLmxheWVyVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICBpZiAocHJvcGVydHlLZXkgPT09ICd0ZXh0LWZpZWxkJyAmJiBzdHlsZSAmJiAhc3R5bGUuZ2x5cGhzKSB7XG4gICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICd1c2Ugb2YgXCJ0ZXh0LWZpZWxkXCIgcmVxdWlyZXMgYSBzdHlsZSBcImdseXBoc1wiIHByb3BlcnR5JykpO1xuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eUtleSA9PT0gJ3RleHQtZm9udCcgJiYgaXNGdW5jdGlvbiQxKGRlZXBVbmJ1bmRsZSh2YWx1ZSkpICYmIHVuYnVuZGxlKHZhbHVlLnR5cGUpID09PSAnaWRlbnRpdHknKSB7XG4gICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcInRleHQtZm9udFwiIGRvZXMgbm90IHN1cHBvcnQgaWRlbnRpdHkgZnVuY3Rpb25zJykpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICB2YWx1ZVNwZWM6IHZhbHVlU3BlYyxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgZXhwcmVzc2lvbkNvbnRleHQ6ICdwcm9wZXJ0eScsXG4gICAgcHJvcGVydHlUeXBlOiBwcm9wZXJ0eVR5cGUsXG4gICAgcHJvcGVydHlLZXk6IHByb3BlcnR5S2V5XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQYWludFByb3BlcnR5KG9wdGlvbnMpIHtcbiAgcmV0dXJuIHZhbGlkYXRlUHJvcGVydHkob3B0aW9ucywgJ3BhaW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGF5b3V0UHJvcGVydHkob3B0aW9ucykge1xuICByZXR1cm4gdmFsaWRhdGVQcm9wZXJ0eShvcHRpb25zLCAnbGF5b3V0Jyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTGF5ZXIob3B0aW9ucykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBsYXllciA9IG9wdGlvbnMudmFsdWU7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuXG4gIGlmICghbGF5ZXIudHlwZSAmJiAhbGF5ZXIucmVmKSB7XG4gICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnZWl0aGVyIFwidHlwZVwiIG9yIFwicmVmXCIgaXMgcmVxdWlyZWQnKSk7XG4gIH1cblxuICB2YXIgdHlwZSA9IHVuYnVuZGxlKGxheWVyLnR5cGUpO1xuICB2YXIgcmVmID0gdW5idW5kbGUobGF5ZXIucmVmKTtcblxuICBpZiAobGF5ZXIuaWQpIHtcbiAgICB2YXIgbGF5ZXJJZCA9IHVuYnVuZGxlKGxheWVyLmlkKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5hcnJheUluZGV4OyBpKyspIHtcbiAgICAgIHZhciBvdGhlckxheWVyID0gc3R5bGUubGF5ZXJzW2ldO1xuXG4gICAgICBpZiAodW5idW5kbGUob3RoZXJMYXllci5pZCkgPT09IGxheWVySWQpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLmlkLCBcImR1cGxpY2F0ZSBsYXllciBpZCBcXFwiXCIuY29uY2F0KGxheWVyLmlkLCBcIlxcXCIsIHByZXZpb3VzbHkgdXNlZCBhdCBsaW5lIFwiKS5jb25jYXQob3RoZXJMYXllci5pZC5fX2xpbmVfXykpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoJ3JlZicgaW4gbGF5ZXIpIHtcbiAgICBbJ3R5cGUnLCAnc291cmNlJywgJ3NvdXJjZS1sYXllcicsICdmaWx0ZXInLCAnbGF5b3V0J10uZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgaWYgKHAgaW4gbGF5ZXIpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyW3BdLCBcIlxcXCJcIi5jb25jYXQocCwgXCJcXFwiIGlzIHByb2hpYml0ZWQgZm9yIHJlZiBsYXllcnNcIikpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgcGFyZW50O1xuICAgIHN0eWxlLmxheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgaWYgKHVuYnVuZGxlKGxheWVyLmlkKSA9PT0gcmVmKSBwYXJlbnQgPSBsYXllcjtcbiAgICB9KTtcblxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIucmVmLCBcInJlZiBsYXllciBcXFwiXCIuY29uY2F0KHJlZiwgXCJcXFwiIG5vdCBmb3VuZFwiKSkpO1xuICAgIH0gZWxzZSBpZiAocGFyZW50LnJlZikge1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnJlZiwgJ3JlZiBjYW5ub3QgcmVmZXJlbmNlIGFub3RoZXIgcmVmIGxheWVyJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdW5idW5kbGUocGFyZW50LnR5cGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghKHR5cGUgPT09ICdiYWNrZ3JvdW5kJyB8fCB0eXBlID09PSAnc2t5JykpIHtcbiAgICBpZiAoIWxheWVyLnNvdXJjZSkge1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCAnbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcInNvdXJjZVwiJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3NvdXJjZTIgPSBzdHlsZS5zb3VyY2VzICYmIHN0eWxlLnNvdXJjZXNbbGF5ZXIuc291cmNlXTtcblxuICAgICAgdmFyIHNvdXJjZVR5cGUgPSBfc291cmNlMiAmJiB1bmJ1bmRsZShfc291cmNlMi50eXBlKTtcblxuICAgICAgaWYgKCFfc291cmNlMikge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCBcInNvdXJjZSBcXFwiXCIuY29uY2F0KGxheWVyLnNvdXJjZSwgXCJcXFwiIG5vdCBmb3VuZFwiKSkpO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2VUeXBlID09PSAndmVjdG9yJyAmJiB0eXBlID09PSAncmFzdGVyJykge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIuc291cmNlLCBcImxheWVyIFxcXCJcIi5jb25jYXQobGF5ZXIuaWQsIFwiXFxcIiByZXF1aXJlcyBhIHJhc3RlciBzb3VyY2VcIikpKTtcbiAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ3Jhc3RlcicgJiYgdHlwZSAhPT0gJ3Jhc3RlcicpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgXCJsYXllciBcXFwiXCIuY29uY2F0KGxheWVyLmlkLCBcIlxcXCIgcmVxdWlyZXMgYSB2ZWN0b3Igc291cmNlXCIpKSk7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZVR5cGUgPT09ICd2ZWN0b3InICYmICFsYXllclsnc291cmNlLWxheWVyJ10pIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLCBcImxheWVyIFxcXCJcIi5jb25jYXQobGF5ZXIuaWQsIFwiXFxcIiBtdXN0IHNwZWNpZnkgYSBcXFwic291cmNlLWxheWVyXFxcIlwiKSkpO1xuICAgICAgfSBlbHNlIGlmIChzb3VyY2VUeXBlID09PSAncmFzdGVyLWRlbScgJiYgdHlwZSAhPT0gJ2hpbGxzaGFkZScpIHtcbiAgICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIGxheWVyLnNvdXJjZSwgJ3Jhc3Rlci1kZW0gc291cmNlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBsYXllciB0eXBlIFxcJ2hpbGxzaGFkZVxcJy4nKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsaW5lJyAmJiBsYXllci5wYWludCAmJiBsYXllci5wYWludFsnbGluZS1ncmFkaWVudCddICYmIChzb3VyY2VUeXBlICE9PSAnZ2VvanNvbicgfHwgIV9zb3VyY2UyLmxpbmVNZXRyaWNzKSkge1xuICAgICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbGF5ZXIsIFwibGF5ZXIgXFxcIlwiLmNvbmNhdChsYXllci5pZCwgXCJcXFwiIHNwZWNpZmllcyBhIGxpbmUtZ3JhZGllbnQsIHdoaWNoIHJlcXVpcmVzIGEgR2VvSlNPTiBzb3VyY2Ugd2l0aCBgbGluZU1ldHJpY3NgIGVuYWJsZWQuXCIpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZU9iamVjdCh7XG4gICAga2V5OiBrZXksXG4gICAgdmFsdWU6IGxheWVyLFxuICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLmxheWVyLFxuICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICcqJzogZnVuY3Rpb24gXygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSxcbiAgICAgIHR5cGU6IGZ1bmN0aW9uIHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh7XG4gICAgICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXksIFwiLnR5cGVcIiksXG4gICAgICAgICAgdmFsdWU6IGxheWVyLnR5cGUsXG4gICAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMubGF5ZXIudHlwZSxcbiAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgIG9iamVjdDogbGF5ZXIsXG4gICAgICAgICAgb2JqZWN0S2V5OiAndHlwZSdcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZmlsdGVyOiB2YWxpZGF0ZUZpbHRlcixcbiAgICAgIGxheW91dDogZnVuY3Rpb24gbGF5b3V0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAgICBsYXllcjogbGF5ZXIsXG4gICAgICAgICAga2V5OiBvcHRpb25zLmtleSxcbiAgICAgICAgICB2YWx1ZTogb3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSxcbiAgICAgICAgICBzdHlsZVNwZWM6IG9wdGlvbnMuc3R5bGVTcGVjLFxuICAgICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiB7XG4gICAgICAgICAgICAnKic6IGZ1bmN0aW9uIF8ob3B0aW9ucykge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVMYXlvdXRQcm9wZXJ0eShleHRlbmQoe1xuICAgICAgICAgICAgICAgIGxheWVyVHlwZTogdHlwZVxuICAgICAgICAgICAgICB9LCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBwYWludDogZnVuY3Rpb24gcGFpbnQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVPYmplY3Qoe1xuICAgICAgICAgIGxheWVyOiBsYXllcixcbiAgICAgICAgICBrZXk6IG9wdGlvbnMua2V5LFxuICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICAgIHN0eWxlU3BlYzogb3B0aW9ucy5zdHlsZVNwZWMsXG4gICAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgICAgICAgICcqJzogZnVuY3Rpb24gXyhvcHRpb25zKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZVBhaW50UHJvcGVydHkoZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBsYXllclR5cGU6IHR5cGVcbiAgICAgICAgICAgICAgfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiBlcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgdmFyIGtleSA9IG9wdGlvbnMua2V5O1xuICB2YXIgdHlwZSA9IGdldFR5cGUodmFsdWUpO1xuXG4gIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBbbmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHZhbHVlLCBcInN0cmluZyBleHBlY3RlZCwgXCIuY29uY2F0KHR5cGUsIFwiIGZvdW5kXCIpKV07XG4gIH1cblxuICByZXR1cm4gW107XG59XG5cbnZhciBvYmplY3RFbGVtZW50VmFsaWRhdG9ycyA9IHtcbiAgcHJvbW90ZUlkOiB2YWxpZGF0ZVByb21vdGVJZFxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVTb3VyY2Uob3B0aW9ucykge1xuICB2YXIgdmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIga2V5ID0gb3B0aW9ucy5rZXk7XG4gIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICBpZiAoIXZhbHVlLnR5cGUpIHtcbiAgICByZXR1cm4gW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1widHlwZVwiIGlzIHJlcXVpcmVkJyldO1xuICB9XG5cbiAgdmFyIHR5cGUgPSB1bmJ1bmRsZSh2YWx1ZS50eXBlKTtcbiAgdmFyIGVycm9ycztcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd2ZWN0b3InOlxuICAgIGNhc2UgJ3Jhc3Rlcic6XG4gICAgY2FzZSAncmFzdGVyLWRlbSc6XG4gICAgICBlcnJvcnMgPSB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjW1wic291cmNlX1wiLmNvbmNhdCh0eXBlLnJlcGxhY2UoJy0nLCAnXycpKV0sXG4gICAgICAgIHN0eWxlOiBvcHRpb25zLnN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICAgICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlcnJvcnM7XG5cbiAgICBjYXNlICdnZW9qc29uJzpcbiAgICAgIGVycm9ycyA9IHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX2dlb2pzb24sXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWMsXG4gICAgICAgIG9iamVjdEVsZW1lbnRWYWxpZGF0b3JzOiBvYmplY3RFbGVtZW50VmFsaWRhdG9yc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh2YWx1ZS5jbHVzdGVyKSB7XG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gdmFsdWUuY2x1c3RlclByb3BlcnRpZXMpIHtcbiAgICAgICAgICB2YXIgX2Vycm9ycywgX2Vycm9yczI7XG5cbiAgICAgICAgICB2YXIgX3ZhbHVlJGNsdXN0ZXJQcm9wZXJ0ID0gX3NsaWNlZFRvQXJyYXkodmFsdWUuY2x1c3RlclByb3BlcnRpZXNbcHJvcF0sIDIpLFxuICAgICAgICAgICAgICBvcGVyYXRvciA9IF92YWx1ZSRjbHVzdGVyUHJvcGVydFswXSxcbiAgICAgICAgICAgICAgbWFwRXhwciA9IF92YWx1ZSRjbHVzdGVyUHJvcGVydFsxXTtcblxuICAgICAgICAgIHZhciByZWR1Y2VFeHByID0gdHlwZW9mIG9wZXJhdG9yID09PSAnc3RyaW5nJyA/IFtvcGVyYXRvciwgWydhY2N1bXVsYXRlZCddLCBbJ2dldCcsIHByb3BdXSA6IG9wZXJhdG9yO1xuXG4gICAgICAgICAgKF9lcnJvcnMgPSBlcnJvcnMpLnB1c2guYXBwbHkoX2Vycm9ycywgX3RvQ29uc3VtYWJsZUFycmF5KHZhbGlkYXRlRXhwcmVzc2lvbih7XG4gICAgICAgICAgICBrZXk6IFwiXCIuY29uY2F0KGtleSwgXCIuXCIpLmNvbmNhdChwcm9wLCBcIi5tYXBcIiksXG4gICAgICAgICAgICB2YWx1ZTogbWFwRXhwcixcbiAgICAgICAgICAgIGV4cHJlc3Npb25Db250ZXh0OiAnY2x1c3Rlci1tYXAnXG4gICAgICAgICAgfSkpKTtcblxuICAgICAgICAgIChfZXJyb3JzMiA9IGVycm9ycykucHVzaC5hcHBseShfZXJyb3JzMiwgX3RvQ29uc3VtYWJsZUFycmF5KHZhbGlkYXRlRXhwcmVzc2lvbih7XG4gICAgICAgICAgICBrZXk6IFwiXCIuY29uY2F0KGtleSwgXCIuXCIpLmNvbmNhdChwcm9wLCBcIi5yZWR1Y2VcIiksXG4gICAgICAgICAgICB2YWx1ZTogcmVkdWNlRXhwcixcbiAgICAgICAgICAgIGV4cHJlc3Npb25Db250ZXh0OiAnY2x1c3Rlci1yZWR1Y2UnXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXJyb3JzO1xuXG4gICAgY2FzZSAndmlkZW8nOlxuICAgICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdmFsdWVTcGVjOiBzdHlsZVNwZWMuc291cmNlX3ZpZGVvLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHJldHVybiB2YWxpZGF0ZU9iamVjdCh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnNvdXJjZV9pbWFnZSxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdjYW52YXMnOlxuICAgICAgcmV0dXJuIFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgbnVsbCwgXCJQbGVhc2UgdXNlIHJ1bnRpbWUgQVBJcyB0byBhZGQgY2FudmFzIHNvdXJjZXMsIHJhdGhlciB0aGFuIGluY2x1ZGluZyB0aGVtIGluIHN0eWxlc2hlZXRzLlwiLCAnc291cmNlLmNhbnZhcycpXTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmFsaWRhdGVFbnVtKHtcbiAgICAgICAga2V5OiBcIlwiLmNvbmNhdChrZXksIFwiLnR5cGVcIiksXG4gICAgICAgIHZhbHVlOiB2YWx1ZS50eXBlLFxuICAgICAgICB2YWx1ZVNwZWM6IHtcbiAgICAgICAgICB2YWx1ZXM6IFsndmVjdG9yJywgJ3Jhc3RlcicsICdyYXN0ZXItZGVtJywgJ2dlb2pzb24nLCAndmlkZW8nLCAnaW1hZ2UnXVxuICAgICAgICB9LFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb21vdGVJZChfcmVmMTEzKSB7XG4gIHZhciBrZXkgPSBfcmVmMTEzLmtleSxcbiAgICAgIHZhbHVlID0gX3JlZjExMy52YWx1ZTtcblxuICBpZiAoZ2V0VHlwZSh2YWx1ZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlU3RyaW5nKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVycm9ycyA9IFtdO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiB2YWx1ZSkge1xuICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBfdG9Db25zdW1hYmxlQXJyYXkodmFsaWRhdGVTdHJpbmcoe1xuICAgICAgICBrZXk6IFwiXCIuY29uY2F0KGtleSwgXCIuXCIpLmNvbmNhdChwcm9wKSxcbiAgICAgICAgdmFsdWU6IHZhbHVlW3Byb3BdXG4gICAgICB9KSkpO1xuICAgIH1cblxuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVMaWdodChvcHRpb25zKSB7XG4gIHZhciBsaWdodCA9IG9wdGlvbnMudmFsdWU7XG4gIHZhciBzdHlsZVNwZWMgPSBvcHRpb25zLnN0eWxlU3BlYztcbiAgdmFyIGxpZ2h0U3BlYyA9IHN0eWxlU3BlYy5saWdodDtcbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgcm9vdFR5cGUgPSBnZXRUeXBlKGxpZ2h0KTtcblxuICBpZiAobGlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBlcnJvcnM7XG4gIH0gZWxzZSBpZiAocm9vdFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChbbmV3IFZhbGlkYXRpb25FcnJvcignbGlnaHQnLCBsaWdodCwgXCJvYmplY3QgZXhwZWN0ZWQsIFwiLmNvbmNhdChyb290VHlwZSwgXCIgZm91bmRcIikpXSk7XG4gICAgcmV0dXJuIGVycm9ycztcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBsaWdodCkge1xuICAgIHZhciB0cmFuc2l0aW9uTWF0Y2ggPSBrZXkubWF0Y2goL14oLiopLXRyYW5zaXRpb24kLyk7XG5cbiAgICBpZiAodHJhbnNpdGlvbk1hdGNoICYmIGxpZ2h0U3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dICYmIGxpZ2h0U3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dLnRyYW5zaXRpb24pIHtcbiAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IGxpZ2h0W2tleV0sXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnRyYW5zaXRpb24sXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgIH0pKTtcbiAgICB9IGVsc2UgaWYgKGxpZ2h0U3BlY1trZXldKSB7XG4gICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHZhbHVlOiBsaWdodFtrZXldLFxuICAgICAgICB2YWx1ZVNwZWM6IGxpZ2h0U3BlY1trZXldLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCBsaWdodFtrZXldLCBcInVua25vd24gcHJvcGVydHkgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIlwiKSldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRlcnJhaW4ob3B0aW9ucykge1xuICB2YXIgdGVycmFpbiA9IG9wdGlvbnMudmFsdWU7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcbiAgdmFyIHN0eWxlU3BlYyA9IG9wdGlvbnMuc3R5bGVTcGVjO1xuICB2YXIgdGVycmFpblNwZWMgPSBzdHlsZVNwZWMudGVycmFpbjtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgcm9vdFR5cGUgPSBnZXRUeXBlKHRlcnJhaW4pO1xuXG4gIGlmICh0ZXJyYWluID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZXJyb3JzO1xuICB9IGVsc2UgaWYgKHJvb3RUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoW25ldyBWYWxpZGF0aW9uRXJyb3IoJ3RlcnJhaW4nLCB0ZXJyYWluLCBcIm9iamVjdCBleHBlY3RlZCwgXCIuY29uY2F0KHJvb3RUeXBlLCBcIiBmb3VuZFwiKSldKTtcbiAgICByZXR1cm4gZXJyb3JzO1xuICB9XG5cbiAgZm9yICh2YXIgX2tleTYgaW4gdGVycmFpbikge1xuICAgIHZhciB0cmFuc2l0aW9uTWF0Y2ggPSBfa2V5Ni5tYXRjaCgvXiguKiktdHJhbnNpdGlvbiQvKTtcblxuICAgIGlmICh0cmFuc2l0aW9uTWF0Y2ggJiYgdGVycmFpblNwZWNbdHJhbnNpdGlvbk1hdGNoWzFdXSAmJiB0ZXJyYWluU3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dLnRyYW5zaXRpb24pIHtcbiAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICBrZXk6IF9rZXk2LFxuICAgICAgICB2YWx1ZTogdGVycmFpbltfa2V5Nl0sXG4gICAgICAgIHZhbHVlU3BlYzogc3R5bGVTcGVjLnRyYW5zaXRpb24sXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgIH0pKTtcbiAgICB9IGVsc2UgaWYgKHRlcnJhaW5TcGVjW19rZXk2XSkge1xuICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZSh7XG4gICAgICAgIGtleTogX2tleTYsXG4gICAgICAgIHZhbHVlOiB0ZXJyYWluW19rZXk2XSxcbiAgICAgICAgdmFsdWVTcGVjOiB0ZXJyYWluU3BlY1tfa2V5Nl0sXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgc3R5bGVTcGVjOiBzdHlsZVNwZWNcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChbbmV3IFZhbGlkYXRpb25FcnJvcihfa2V5NiwgdGVycmFpbltfa2V5Nl0sIFwidW5rbm93biBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KF9rZXk2LCBcIlxcXCJcIikpXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0ZXJyYWluLnNvdXJjZSkge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB0ZXJyYWluLCBcInRlcnJhaW4gaXMgbWlzc2luZyByZXF1aXJlZCBwcm9wZXJ0eSBcXFwic291cmNlXFxcIlwiKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9zb3VyY2UzID0gc3R5bGUuc291cmNlcyAmJiBzdHlsZS5zb3VyY2VzW3RlcnJhaW4uc291cmNlXTtcblxuICAgIHZhciBzb3VyY2VUeXBlID0gX3NvdXJjZTMgJiYgdW5idW5kbGUoX3NvdXJjZTMudHlwZSk7XG5cbiAgICBpZiAoIV9zb3VyY2UzKSB7XG4gICAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdGVycmFpbi5zb3VyY2UsIFwic291cmNlIFxcXCJcIi5jb25jYXQodGVycmFpbi5zb3VyY2UsIFwiXFxcIiBub3QgZm91bmRcIikpKTtcbiAgICB9IGVsc2UgaWYgKHNvdXJjZVR5cGUgIT09ICdyYXN0ZXItZGVtJykge1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihrZXksIHRlcnJhaW4uc291cmNlLCBcInRlcnJhaW4gY2Fubm90IGJlIHVzZWQgd2l0aCBhIHNvdXJjZSBvZiB0eXBlIFwiLmNvbmNhdChzb3VyY2VUeXBlLCBcIiwgaXQgb25seSBiZSB1c2VkIHdpdGggYSBcXFwicmFzdGVyLWRlbVxcXCIgc291cmNlIHR5cGVcIikpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZvZyhvcHRpb25zKSB7XG4gIHZhciBmb2cgPSBvcHRpb25zLnZhbHVlO1xuICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG4gIHZhciBmb2dTcGVjID0gc3R5bGVTcGVjLmZvZztcbiAgdmFyIGVycm9ycyA9IFtdO1xuICB2YXIgcm9vdFR5cGUgPSBnZXRUeXBlKGZvZyk7XG5cbiAgaWYgKGZvZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVycm9ycztcbiAgfSBlbHNlIGlmIChyb290VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKCdmb2cnLCBmb2csIFwib2JqZWN0IGV4cGVjdGVkLCBcIi5jb25jYXQocm9vdFR5cGUsIFwiIGZvdW5kXCIpKV0pO1xuICAgIHJldHVybiBlcnJvcnM7XG4gIH1cblxuICBpZiAoZm9nLnJhbmdlICYmICFpc0V4cHJlc3Npb24oZGVlcFVuYnVuZGxlKGZvZy5yYW5nZSkpICYmIGZvZy5yYW5nZVswXSA+PSBmb2cucmFuZ2VbMV0pIHtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKCdmb2cnLCBmb2csICdmb2cucmFuZ2VbMF0gY2FuXFwndCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gZm9nLnJhbmdlWzFdJyldKTtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBmb2cpIHtcbiAgICB2YXIgdHJhbnNpdGlvbk1hdGNoID0ga2V5Lm1hdGNoKC9eKC4qKS10cmFuc2l0aW9uJC8pO1xuXG4gICAgaWYgKHRyYW5zaXRpb25NYXRjaCAmJiBmb2dTcGVjW3RyYW5zaXRpb25NYXRjaFsxXV0gJiYgZm9nU3BlY1t0cmFuc2l0aW9uTWF0Y2hbMV1dLnRyYW5zaXRpb24pIHtcbiAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IGZvZ1trZXldLFxuICAgICAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy50cmFuc2l0aW9uLFxuICAgICAgICBzdHlsZTogc3R5bGUsXG4gICAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgICB9KSk7XG4gICAgfSBlbHNlIGlmIChmb2dTcGVjW2tleV0pIHtcbiAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGUoe1xuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgdmFsdWU6IGZvZ1trZXldLFxuICAgICAgICB2YWx1ZVNwZWM6IGZvZ1NwZWNba2V5XSxcbiAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICBzdHlsZVNwZWM6IHN0eWxlU3BlY1xuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KFtuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgZm9nW2tleV0sIFwidW5rbm93biBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiXCIpKV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlcnJvcnM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0dGVkKG9wdGlvbnMpIHtcbiAgaWYgKHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZUV4cHJlc3Npb24ob3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW1hZ2Uob3B0aW9ucykge1xuICBpZiAodmFsaWRhdGVTdHJpbmcob3B0aW9ucykubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlRXhwcmVzc2lvbihvcHRpb25zKTtcbn1cblxudmFyIFZBTElEQVRPUlMgPSB7XG4gICcqJzogZnVuY3Rpb24gXygpIHtcbiAgICByZXR1cm4gW107XG4gIH0sXG4gICdhcnJheSc6IHZhbGlkYXRlQXJyYXksXG4gICdib29sZWFuJzogdmFsaWRhdGVCb29sZWFuLFxuICAnbnVtYmVyJzogdmFsaWRhdGVOdW1iZXIsXG4gICdjb2xvcic6IHZhbGlkYXRlQ29sb3IsXG4gICdjb25zdGFudHMnOiB2YWxpZGF0ZUNvbnN0YW50cyxcbiAgJ2VudW0nOiB2YWxpZGF0ZUVudW0sXG4gICdmaWx0ZXInOiB2YWxpZGF0ZUZpbHRlcixcbiAgJ2Z1bmN0aW9uJzogdmFsaWRhdGVGdW5jdGlvbixcbiAgJ2xheWVyJzogdmFsaWRhdGVMYXllcixcbiAgJ29iamVjdCc6IHZhbGlkYXRlT2JqZWN0LFxuICAnc291cmNlJzogdmFsaWRhdGVTb3VyY2UsXG4gICdsaWdodCc6IHZhbGlkYXRlTGlnaHQsXG4gICd0ZXJyYWluJzogdmFsaWRhdGVUZXJyYWluLFxuICAnZm9nJzogdmFsaWRhdGVGb2csXG4gICdzdHJpbmcnOiB2YWxpZGF0ZVN0cmluZyxcbiAgJ2Zvcm1hdHRlZCc6IHZhbGlkYXRlRm9ybWF0dGVkLFxuICAncmVzb2x2ZWRJbWFnZSc6IHZhbGlkYXRlSW1hZ2Vcbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMpIHtcbiAgdmFyIHZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgdmFyIHZhbHVlU3BlYyA9IG9wdGlvbnMudmFsdWVTcGVjO1xuICB2YXIgc3R5bGVTcGVjID0gb3B0aW9ucy5zdHlsZVNwZWM7XG5cbiAgaWYgKHZhbHVlU3BlYy5leHByZXNzaW9uICYmIGlzRnVuY3Rpb24kMSh1bmJ1bmRsZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlRnVuY3Rpb24ob3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAodmFsdWVTcGVjLmV4cHJlc3Npb24gJiYgaXNFeHByZXNzaW9uKGRlZXBVbmJ1bmRsZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlRXhwcmVzc2lvbihvcHRpb25zKTtcbiAgfSBlbHNlIGlmICh2YWx1ZVNwZWMudHlwZSAmJiBWQUxJREFUT1JTW3ZhbHVlU3BlYy50eXBlXSkge1xuICAgIHJldHVybiBWQUxJREFUT1JTW3ZhbHVlU3BlYy50eXBlXShvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdmFsaWQgPSB2YWxpZGF0ZU9iamVjdChleHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgIHZhbHVlU3BlYzogdmFsdWVTcGVjLnR5cGUgPyBzdHlsZVNwZWNbdmFsdWVTcGVjLnR5cGVdIDogdmFsdWVTcGVjXG4gICAgfSkpO1xuICAgIHJldHVybiB2YWxpZDtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUdseXBoc1VSTChvcHRpb25zKSB7XG4gIHZhciB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcbiAgdmFyIGVycm9ycyA9IHZhbGlkYXRlU3RyaW5nKG9wdGlvbnMpO1xuICBpZiAoZXJyb3JzLmxlbmd0aCkgcmV0dXJuIGVycm9ycztcblxuICBpZiAodmFsdWUuaW5kZXhPZigne2ZvbnRzdGFja30nKSA9PT0gLTEpIHtcbiAgICBlcnJvcnMucHVzaChuZXcgVmFsaWRhdGlvbkVycm9yKGtleSwgdmFsdWUsICdcImdseXBoc1wiIHVybCBtdXN0IGluY2x1ZGUgYSBcIntmb250c3RhY2t9XCIgdG9rZW4nKSk7XG4gIH1cblxuICBpZiAodmFsdWUuaW5kZXhPZigne3JhbmdlfScpID09PSAtMSkge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3Ioa2V5LCB2YWx1ZSwgJ1wiZ2x5cGhzXCIgdXJsIG11c3QgaW5jbHVkZSBhIFwie3JhbmdlfVwiIHRva2VuJykpO1xuICB9XG5cbiAgcmV0dXJuIGVycm9ycztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdHlsZU1pbihzdHlsZSkge1xuICB2YXIgc3R5bGVTcGVjID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB2ODtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KHZhbGlkYXRlKHtcbiAgICBrZXk6ICcnLFxuICAgIHZhbHVlOiBzdHlsZSxcbiAgICB2YWx1ZVNwZWM6IHN0eWxlU3BlYy4kcm9vdCxcbiAgICBzdHlsZVNwZWM6IHN0eWxlU3BlYyxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgb2JqZWN0RWxlbWVudFZhbGlkYXRvcnM6IHtcbiAgICAgIGdseXBoczogdmFsaWRhdGVHbHlwaHNVUkwsXG4gICAgICAnKic6IGZ1bmN0aW9uIF8oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcblxuICBpZiAoc3R5bGUuY29uc3RhbnRzKSB7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZUNvbnN0YW50cyh7XG4gICAgICBrZXk6ICdjb25zdGFudHMnLFxuICAgICAgdmFsdWU6IHN0eWxlLmNvbnN0YW50cyxcbiAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgIHN0eWxlU3BlYzogc3R5bGVTcGVjXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIHNvcnRFcnJvcnMoZXJyb3JzKTtcbn1cblxudmFsaWRhdGVTdHlsZU1pbi5zb3VyY2UgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVTb3VyY2UpO1xudmFsaWRhdGVTdHlsZU1pbi5saWdodCA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZUxpZ2h0KTtcbnZhbGlkYXRlU3R5bGVNaW4udGVycmFpbiA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZVRlcnJhaW4pO1xudmFsaWRhdGVTdHlsZU1pbi5mb2cgPSB3cmFwQ2xlYW5FcnJvcnModmFsaWRhdGVGb2cpO1xudmFsaWRhdGVTdHlsZU1pbi5sYXllciA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZUxheWVyKTtcbnZhbGlkYXRlU3R5bGVNaW4uZmlsdGVyID0gd3JhcENsZWFuRXJyb3JzKHZhbGlkYXRlRmlsdGVyKTtcbnZhbGlkYXRlU3R5bGVNaW4ucGFpbnRQcm9wZXJ0eSA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZVBhaW50UHJvcGVydHkpO1xudmFsaWRhdGVTdHlsZU1pbi5sYXlvdXRQcm9wZXJ0eSA9IHdyYXBDbGVhbkVycm9ycyh2YWxpZGF0ZUxheW91dFByb3BlcnR5KTtcblxuZnVuY3Rpb24gc29ydEVycm9ycyhlcnJvcnMpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChlcnJvcnMpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5saW5lIC0gYi5saW5lO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gd3JhcENsZWFuRXJyb3JzKGlubmVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTcgPSAwOyBfa2V5NyA8IF9sZW40OyBfa2V5NysrKSB7XG4gICAgICBhcmdzW19rZXk3XSA9IGFyZ3VtZW50c1tfa2V5N107XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvcnRFcnJvcnMoaW5uZXIuYXBwbHkodGhpcywgYXJncykpO1xuICB9O1xufVxuLyogcGFyc2VyIGdlbmVyYXRlZCBieSBqaXNvbiAwLjQuMTUgKi9cblxuXG52YXIganNvbmxpbnQgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gIC8qXG4gICAgUmV0dXJucyBhIFBhcnNlciBvYmplY3Qgb2YgdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gIFxuICAgIFBhcnNlcjoge1xuICAgICAgeXk6IHt9XG4gICAgfVxuICBcbiAgICBQYXJzZXIucHJvdG90eXBlOiB7XG4gICAgICB5eToge30sXG4gICAgICB0cmFjZTogZnVuY3Rpb24oKSxcbiAgICAgIHN5bWJvbHNfOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gbnVtYmVyfSxcbiAgICAgIHRlcm1pbmFsc186IHthc3NvY2lhdGl2ZSBsaXN0OiBudW1iZXIgPT0+IG5hbWV9LFxuICAgICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAgICAgIHBlcmZvcm1BY3Rpb246IGZ1bmN0aW9uIGFub255bW91cyh5eXRleHQsIHl5bGVuZywgeXlsaW5lbm8sIHl5LCB5eXN0YXRlLCAkJCwgXyQpLFxuICAgICAgdGFibGU6IFsuLi5dLFxuICAgICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCksXG4gIFxuICAgICAgbGV4ZXI6IHtcbiAgICAgICAgICBFT0Y6IDEsXG4gICAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICAgICAgICBzZXRJbnB1dDogZnVuY3Rpb24oaW5wdXQpLFxuICAgICAgICAgIGlucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICAgICAgICAgIG1vcmU6IGZ1bmN0aW9uKCksXG4gICAgICAgICAgbGVzczogZnVuY3Rpb24obiksXG4gICAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgICAgc2hvd1Bvc2l0aW9uOiBmdW5jdGlvbigpLFxuICAgICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4KSxcbiAgICAgICAgICBuZXh0OiBmdW5jdGlvbigpLFxuICAgICAgICAgIGxleDogZnVuY3Rpb24oKSxcbiAgICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAgICAgICAgICBwb3BTdGF0ZTogZnVuY3Rpb24oKSxcbiAgICAgICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbigpLFxuICAgICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICAgIHB1c2hTdGF0ZTogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAgXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICByYW5nZXM6IGJvb2xlYW4gICAgICAgICAgIChvcHRpb25hbDogdHJ1ZSA9PT4gdG9rZW4gbG9jYXRpb24gaW5mbyB3aWxsIGluY2x1ZGUgYSAucmFuZ2VbXSBtZW1iZXIpXG4gICAgICAgICAgICAgIGZsZXg6IGJvb2xlYW4gICAgICAgICAgICAgKG9wdGlvbmFsOiB0cnVlID09PiBmbGV4LWxpa2UgbGV4aW5nIGJlaGF2aW91ciB3aGVyZSB0aGUgcnVsZXMgYXJlIHRlc3RlZCBleGhhdXN0aXZlbHkgdG8gZmluZCB0aGUgbG9uZ2VzdCBtYXRjaClcbiAgICAgICAgICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuICAob3B0aW9uYWw6IHRydWUgPT0+IGxleGVyIHJlZ2V4ZXMgYXJlIHRlc3RlZCBpbiBvcmRlciBhbmQgZm9yIGVhY2ggbWF0Y2hpbmcgcmVnZXggdGhlIGFjdGlvbiBjb2RlIGlzIGludm9rZWQ7IHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUpXG4gICAgICAgICAgfSxcbiAgXG4gICAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpLFxuICAgICAgICAgIHJ1bGVzOiBbLi4uXSxcbiAgICAgICAgICBjb25kaXRpb25zOiB7YXNzb2NpYXRpdmUgbGlzdDogbmFtZSA9PT4gc2V0fSxcbiAgICAgIH1cbiAgICB9XG4gIFxuICBcbiAgICB0b2tlbiBsb2NhdGlvbiBpbmZvIChAJCwgXyQsIGV0Yy4pOiB7XG4gICAgICBmaXJzdF9saW5lOiBuLFxuICAgICAgbGFzdF9saW5lOiBuLFxuICAgICAgZmlyc3RfY29sdW1uOiBuLFxuICAgICAgbGFzdF9jb2x1bW46IG4sXG4gICAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl0gICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgcmVndWxhciB6ZXJvLWJhc2VkKVxuICAgIH1cbiAgXG4gIFxuICAgIHRoZSBwYXJzZUVycm9yIGZ1bmN0aW9uIHJlY2VpdmVzIGEgJ2hhc2gnIG9iamVjdCB3aXRoIHRoZXNlIG1lbWJlcnMgZm9yIGxleGVyIGFuZCBwYXJzZXIgZXJyb3JzOiB7XG4gICAgICB0ZXh0OiAgICAgICAgKG1hdGNoZWQgdGV4dClcbiAgICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpXG4gICAgICBsaW5lOiAgICAgICAgKHl5bGluZW5vKVxuICAgIH1cbiAgICB3aGlsZSBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBtZW1iZXJzLCBpLmUuIHBhcnNlciBlcnJvcnMgZGVsaXZlciBhIHN1cGVyc2V0IG9mIGF0dHJpYnV0ZXM6IHtcbiAgICAgIGxvYzogICAgICAgICAoeXlsbG9jKVxuICAgICAgZXhwZWN0ZWQ6ICAgIChzdHJpbmcgZGVzY3JpYmluZyB0aGUgc2V0IG9mIGV4cGVjdGVkIHRva2VucylcbiAgICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgaGFzIGEgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAgICB9XG4gICovXG4gIHZhciBwYXJzZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG8gPSBmdW5jdGlvbiBvKGssIHYsIF9vLCBsKSB7XG4gICAgICBmb3IgKF9vID0gX28gfHwge30sIGwgPSBrLmxlbmd0aDsgbC0tOyBfb1trW2xdXSA9IHYpIHtcbiAgICAgICAgO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX287XG4gICAgfSxcbiAgICAgICAgJFYwID0gWzEsIDEyXSxcbiAgICAgICAgJFYxID0gWzEsIDEzXSxcbiAgICAgICAgJFYyID0gWzEsIDldLFxuICAgICAgICAkVjMgPSBbMSwgMTBdLFxuICAgICAgICAkVjQgPSBbMSwgMTFdLFxuICAgICAgICAkVjUgPSBbMSwgMTRdLFxuICAgICAgICAkVjYgPSBbMSwgMTVdLFxuICAgICAgICAkVjcgPSBbMTQsIDE4LCAyMiwgMjRdLFxuICAgICAgICAkVjggPSBbMTgsIDIyXSxcbiAgICAgICAgJFY5ID0gWzIyLCAyNF07XG5cbiAgICB2YXIgcGFyc2VyID0ge1xuICAgICAgdHJhY2U6IGZ1bmN0aW9uIHRyYWNlKCkge30sXG4gICAgICB5eToge30sXG4gICAgICBzeW1ib2xzXzoge1xuICAgICAgICBcImVycm9yXCI6IDIsXG4gICAgICAgIFwiSlNPTlN0cmluZ1wiOiAzLFxuICAgICAgICBcIlNUUklOR1wiOiA0LFxuICAgICAgICBcIkpTT05OdW1iZXJcIjogNSxcbiAgICAgICAgXCJOVU1CRVJcIjogNixcbiAgICAgICAgXCJKU09OTnVsbExpdGVyYWxcIjogNyxcbiAgICAgICAgXCJOVUxMXCI6IDgsXG4gICAgICAgIFwiSlNPTkJvb2xlYW5MaXRlcmFsXCI6IDksXG4gICAgICAgIFwiVFJVRVwiOiAxMCxcbiAgICAgICAgXCJGQUxTRVwiOiAxMSxcbiAgICAgICAgXCJKU09OVGV4dFwiOiAxMixcbiAgICAgICAgXCJKU09OVmFsdWVcIjogMTMsXG4gICAgICAgIFwiRU9GXCI6IDE0LFxuICAgICAgICBcIkpTT05PYmplY3RcIjogMTUsXG4gICAgICAgIFwiSlNPTkFycmF5XCI6IDE2LFxuICAgICAgICBcIntcIjogMTcsXG4gICAgICAgIFwifVwiOiAxOCxcbiAgICAgICAgXCJKU09OTWVtYmVyTGlzdFwiOiAxOSxcbiAgICAgICAgXCJKU09OTWVtYmVyXCI6IDIwLFxuICAgICAgICBcIjpcIjogMjEsXG4gICAgICAgIFwiLFwiOiAyMixcbiAgICAgICAgXCJbXCI6IDIzLFxuICAgICAgICBcIl1cIjogMjQsXG4gICAgICAgIFwiSlNPTkVsZW1lbnRMaXN0XCI6IDI1LFxuICAgICAgICBcIiRhY2NlcHRcIjogMCxcbiAgICAgICAgXCIkZW5kXCI6IDFcbiAgICAgIH0sXG4gICAgICB0ZXJtaW5hbHNfOiB7XG4gICAgICAgIDI6IFwiZXJyb3JcIixcbiAgICAgICAgNDogXCJTVFJJTkdcIixcbiAgICAgICAgNjogXCJOVU1CRVJcIixcbiAgICAgICAgODogXCJOVUxMXCIsXG4gICAgICAgIDEwOiBcIlRSVUVcIixcbiAgICAgICAgMTE6IFwiRkFMU0VcIixcbiAgICAgICAgMTQ6IFwiRU9GXCIsXG4gICAgICAgIDE3OiBcIntcIixcbiAgICAgICAgMTg6IFwifVwiLFxuICAgICAgICAyMTogXCI6XCIsXG4gICAgICAgIDIyOiBcIixcIixcbiAgICAgICAgMjM6IFwiW1wiLFxuICAgICAgICAyNDogXCJdXCJcbiAgICAgIH0sXG4gICAgICBwcm9kdWN0aW9uc186IFswLCBbMywgMV0sIFs1LCAxXSwgWzcsIDFdLCBbOSwgMV0sIFs5LCAxXSwgWzEyLCAyXSwgWzEzLCAxXSwgWzEzLCAxXSwgWzEzLCAxXSwgWzEzLCAxXSwgWzEzLCAxXSwgWzEzLCAxXSwgWzE1LCAyXSwgWzE1LCAzXSwgWzIwLCAzXSwgWzE5LCAxXSwgWzE5LCAzXSwgWzE2LCAyXSwgWzE2LCAzXSwgWzI1LCAxXSwgWzI1LCAzXV0sXG4gICAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZVxuICAgICAgLyogYWN0aW9uWzFdICovXG4gICAgICAsICQkXG4gICAgICAvKiB2c3RhY2sgKi9cbiAgICAgICwgXyRcbiAgICAgIC8qIGxzdGFjayAqL1xuICAgICAgKSB7XG4gICAgICAgIC8qIHRoaXMgPT0geXl2YWwgKi9cbiAgICAgICAgdmFyICQwID0gJCQubGVuZ3RoIC0gMTtcblxuICAgICAgICBzd2l0Y2ggKHl5c3RhdGUpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAvLyByZXBsYWNlIGVzY2FwZWQgY2hhcmFjdGVycyB3aXRoIGFjdHVhbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBTdHJpbmcoeXl0ZXh0LnJlcGxhY2UoL1xcXFwoXFxcXHxcIikvZywgXCIkXCIgKyBcIjFcIikucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpLnJlcGxhY2UoL1xcXFxyL2csICdcXHInKS5yZXBsYWNlKC9cXFxcdC9nLCAnXFx0JykucmVwbGFjZSgvXFxcXHYvZywgJ1xcdicpLnJlcGxhY2UoL1xcXFxmL2csICdcXGYnKS5yZXBsYWNlKC9cXFxcYi9nLCAnXFxiJykpO1xuICAgICAgICAgICAgdGhpcy4kLl9fbGluZV9fID0gdGhpcy5fJC5maXJzdF9saW5lO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLiQgPSBuZXcgTnVtYmVyKHl5dGV4dCk7XG4gICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMuJCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRoaXMuJCA9IG5ldyBCb29sZWFuKHRydWUpO1xuICAgICAgICAgICAgdGhpcy4kLl9fbGluZV9fID0gdGhpcy5fJC5maXJzdF9saW5lO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0aGlzLiQgPSBuZXcgQm9vbGVhbihmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLiQuX19saW5lX18gPSB0aGlzLl8kLmZpcnN0X2xpbmU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiQgPSAkJFskMCAtIDFdO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHRoaXMuJCA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuJCwgJ19fbGluZV9fJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5fJC5maXJzdF9saW5lLFxuICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwIC0gMV07XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy4kLCAnX19saW5lX18nLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiB0aGlzLl8kLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIHRoaXMuJCA9IFskJFskMCAtIDJdLCAkJFskMF1dO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgdGhpcy4kID0ge307XG4gICAgICAgICAgICB0aGlzLiRbJCRbJDBdWzBdXSA9ICQkWyQwXVsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHRoaXMuJCA9ICQkWyQwIC0gMl07XG4gICAgICAgICAgICAkJFskMCAtIDJdWyQkWyQwXVswXV0gPSAkJFskMF1bMV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICB0aGlzLiQgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLiQsICdfX2xpbmVfXycsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuXyQuZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgdGhpcy4kID0gWyQkWyQwXV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICB0aGlzLiQgPSAkJFskMCAtIDJdO1xuICAgICAgICAgICAgJCRbJDAgLSAyXS5wdXNoKCQkWyQwXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRhYmxlOiBbe1xuICAgICAgICAzOiA1LFxuICAgICAgICA0OiAkVjAsXG4gICAgICAgIDU6IDYsXG4gICAgICAgIDY6ICRWMSxcbiAgICAgICAgNzogMyxcbiAgICAgICAgODogJFYyLFxuICAgICAgICA5OiA0LFxuICAgICAgICAxMDogJFYzLFxuICAgICAgICAxMTogJFY0LFxuICAgICAgICAxMjogMSxcbiAgICAgICAgMTM6IDIsXG4gICAgICAgIDE1OiA3LFxuICAgICAgICAxNjogOCxcbiAgICAgICAgMTc6ICRWNSxcbiAgICAgICAgMjM6ICRWNlxuICAgICAgfSwge1xuICAgICAgICAxOiBbM11cbiAgICAgIH0sIHtcbiAgICAgICAgMTQ6IFsxLCAxNl1cbiAgICAgIH0sIG8oJFY3LCBbMiwgN10pLCBvKCRWNywgWzIsIDhdKSwgbygkVjcsIFsyLCA5XSksIG8oJFY3LCBbMiwgMTBdKSwgbygkVjcsIFsyLCAxMV0pLCBvKCRWNywgWzIsIDEyXSksIG8oJFY3LCBbMiwgM10pLCBvKCRWNywgWzIsIDRdKSwgbygkVjcsIFsyLCA1XSksIG8oWzE0LCAxOCwgMjEsIDIyLCAyNF0sIFsyLCAxXSksIG8oJFY3LCBbMiwgMl0pLCB7XG4gICAgICAgIDM6IDIwLFxuICAgICAgICA0OiAkVjAsXG4gICAgICAgIDE4OiBbMSwgMTddLFxuICAgICAgICAxOTogMTgsXG4gICAgICAgIDIwOiAxOVxuICAgICAgfSwge1xuICAgICAgICAzOiA1LFxuICAgICAgICA0OiAkVjAsXG4gICAgICAgIDU6IDYsXG4gICAgICAgIDY6ICRWMSxcbiAgICAgICAgNzogMyxcbiAgICAgICAgODogJFYyLFxuICAgICAgICA5OiA0LFxuICAgICAgICAxMDogJFYzLFxuICAgICAgICAxMTogJFY0LFxuICAgICAgICAxMzogMjMsXG4gICAgICAgIDE1OiA3LFxuICAgICAgICAxNjogOCxcbiAgICAgICAgMTc6ICRWNSxcbiAgICAgICAgMjM6ICRWNixcbiAgICAgICAgMjQ6IFsxLCAyMV0sXG4gICAgICAgIDI1OiAyMlxuICAgICAgfSwge1xuICAgICAgICAxOiBbMiwgNl1cbiAgICAgIH0sIG8oJFY3LCBbMiwgMTNdKSwge1xuICAgICAgICAxODogWzEsIDI0XSxcbiAgICAgICAgMjI6IFsxLCAyNV1cbiAgICAgIH0sIG8oJFY4LCBbMiwgMTZdKSwge1xuICAgICAgICAyMTogWzEsIDI2XVxuICAgICAgfSwgbygkVjcsIFsyLCAxOF0pLCB7XG4gICAgICAgIDIyOiBbMSwgMjhdLFxuICAgICAgICAyNDogWzEsIDI3XVxuICAgICAgfSwgbygkVjksIFsyLCAyMF0pLCBvKCRWNywgWzIsIDE0XSksIHtcbiAgICAgICAgMzogMjAsXG4gICAgICAgIDQ6ICRWMCxcbiAgICAgICAgMjA6IDI5XG4gICAgICB9LCB7XG4gICAgICAgIDM6IDUsXG4gICAgICAgIDQ6ICRWMCxcbiAgICAgICAgNTogNixcbiAgICAgICAgNjogJFYxLFxuICAgICAgICA3OiAzLFxuICAgICAgICA4OiAkVjIsXG4gICAgICAgIDk6IDQsXG4gICAgICAgIDEwOiAkVjMsXG4gICAgICAgIDExOiAkVjQsXG4gICAgICAgIDEzOiAzMCxcbiAgICAgICAgMTU6IDcsXG4gICAgICAgIDE2OiA4LFxuICAgICAgICAxNzogJFY1LFxuICAgICAgICAyMzogJFY2XG4gICAgICB9LCBvKCRWNywgWzIsIDE5XSksIHtcbiAgICAgICAgMzogNSxcbiAgICAgICAgNDogJFYwLFxuICAgICAgICA1OiA2LFxuICAgICAgICA2OiAkVjEsXG4gICAgICAgIDc6IDMsXG4gICAgICAgIDg6ICRWMixcbiAgICAgICAgOTogNCxcbiAgICAgICAgMTA6ICRWMyxcbiAgICAgICAgMTE6ICRWNCxcbiAgICAgICAgMTM6IDMxLFxuICAgICAgICAxNTogNyxcbiAgICAgICAgMTY6IDgsXG4gICAgICAgIDE3OiAkVjUsXG4gICAgICAgIDIzOiAkVjZcbiAgICAgIH0sIG8oJFY4LCBbMiwgMTddKSwgbygkVjgsIFsyLCAxNV0pLCBvKCRWOSwgWzIsIDIxXSldLFxuICAgICAgZGVmYXVsdEFjdGlvbnM6IHtcbiAgICAgICAgMTY6IFsyLCA2XVxuICAgICAgfSxcbiAgICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgICAgIGlmIChoYXNoLnJlY292ZXJhYmxlKSB7XG4gICAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGFyc2U6IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHN0YWNrID0gWzBdLFxuICAgICAgICAgICAgdnN0YWNrID0gW251bGxdLFxuICAgICAgICAgICAgbHN0YWNrID0gW10sXG4gICAgICAgICAgICB0YWJsZSA9IHRoaXMudGFibGUsXG4gICAgICAgICAgICB5eXRleHQgPSAnJyxcbiAgICAgICAgICAgIHl5bGluZW5vID0gMCxcbiAgICAgICAgICAgIHl5bGVuZyA9IDAsXG4gICAgICAgICAgICBURVJST1IgPSAyLFxuICAgICAgICAgICAgRU9GID0gMTtcbiAgICAgICAgdmFyIGFyZ3MgPSBsc3RhY2suc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgbGV4ZXIgPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgICAgICB2YXIgc2hhcmVkU3RhdGUgPSB7XG4gICAgICAgICAgeXk6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLnl5KSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnl5LCBrKSkge1xuICAgICAgICAgICAgc2hhcmVkU3RhdGUueXlba10gPSB0aGlzLnl5W2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxleGVyLnNldElucHV0KGlucHV0LCBzaGFyZWRTdGF0ZS55eSk7XG4gICAgICAgIHNoYXJlZFN0YXRlLnl5LmxleGVyID0gbGV4ZXI7XG4gICAgICAgIHNoYXJlZFN0YXRlLnl5LnBhcnNlciA9IHRoaXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBsZXhlci55eWxsb2MgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICAgICAgbHN0YWNrLnB1c2goeXlsb2MpO1xuICAgICAgICB2YXIgcmFuZ2VzID0gbGV4ZXIub3B0aW9ucyAmJiBsZXhlci5vcHRpb25zLnJhbmdlcztcblxuICAgICAgICBpZiAodHlwZW9mIHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFyc2VFcnJvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5wYXJzZUVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgICB0b2tlbiA9IGxleGVyLmxleCgpIHx8IEVPRjtcblxuICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzeW1ib2wsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIHIsXG4gICAgICAgICAgICB5eXZhbCA9IHt9LFxuICAgICAgICAgICAgcCxcbiAgICAgICAgICAgIGxlbixcbiAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3ltYm9sID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICd1bmRlZmluZWQnIHx8ICFhY3Rpb24ubGVuZ3RoIHx8ICFhY3Rpb25bMF0pIHtcbiAgICAgICAgICAgIHZhciBlcnJTdHIgPSAnJztcbiAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAocCBpbiB0YWJsZVtzdGF0ZV0pIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMudGVybWluYWxzX1twXSAmJiBwID4gVEVSUk9SKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQucHVzaCgnXFwnJyArIHRoaXMudGVybWluYWxzX1twXSArICdcXCcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGV4ZXIuc2hvd1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6XFxuJyArIGxleGVyLnNob3dQb3NpdGlvbigpICsgJ1xcbkV4cGVjdGluZyAnICsgZXhwZWN0ZWQuam9pbignLCAnKSArICcsIGdvdCBcXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXFwnJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6IFVuZXhwZWN0ZWQgJyArIChzeW1ib2wgPT0gRU9GID8gJ2VuZCBvZiBpbnB1dCcgOiAnXFwnJyArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgJ1xcJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBhcnNlRXJyb3IoZXJyU3RyLCB7XG4gICAgICAgICAgICAgIHRleHQ6IGxleGVyLm1hdGNoLFxuICAgICAgICAgICAgICB0b2tlbjogdGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sLFxuICAgICAgICAgICAgICBsaW5lOiBsZXhlci55eWxpbmVubyxcbiAgICAgICAgICAgICAgbG9jOiB5eWxvYyxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWN0aW9uWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6ICcgKyBzdGF0ZSArICcsIHRva2VuOiAnICsgc3ltYm9sKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKGFjdGlvblswXSkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICAgIHZzdGFjay5wdXNoKGxleGVyLnl5dGV4dCk7XG4gICAgICAgICAgICAgIGxzdGFjay5wdXNoKGxleGVyLnl5bGxvYyk7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTtcbiAgICAgICAgICAgICAgc3ltYm9sID0gbnVsbDtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHl5bGVuZyA9IGxleGVyLnl5bGVuZztcbiAgICAgICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm8gPSBsZXhlci55eWxpbmVubztcbiAgICAgICAgICAgICAgICB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBsZW4gPSB0aGlzLnByb2R1Y3Rpb25zX1thY3Rpb25bMV1dWzFdO1xuICAgICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGggLSBsZW5dO1xuICAgICAgICAgICAgICB5eXZhbC5fJCA9IHtcbiAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgbGFzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHl5dmFsLl8kLnJhbmdlID0gW2xzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0ucmFuZ2VbMF0sIGxzdGFja1tsc3RhY2subGVuZ3RoIC0gMV0ucmFuZ2VbMV1dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgciA9IHRoaXMucGVyZm9ybUFjdGlvbi5hcHBseSh5eXZhbCwgW3l5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgc2hhcmVkU3RhdGUueXksIGFjdGlvblsxXSwgdnN0YWNrLCBsc3RhY2tdLmNvbmNhdChhcmdzKSk7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4gKiAyKTtcbiAgICAgICAgICAgICAgICB2c3RhY2sgPSB2c3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pO1xuICAgICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgICAgbHN0YWNrLnB1c2goeXl2YWwuXyQpO1xuICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDJdXVtzdGFja1tzdGFjay5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3U3RhdGUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8qIGdlbmVyYXRlZCBieSBqaXNvbi1sZXggMC4zLjQgKi9cblxuICAgIHZhciBsZXhlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBsZXhlciA9IHtcbiAgICAgICAgRU9GOiAxLFxuICAgICAgICBwYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgICAgICAgIGlmICh0aGlzLnl5LnBhcnNlcikge1xuICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3RyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJlc2V0cyB0aGUgbGV4ZXIsIHNldHMgbmV3IGlucHV0XG4gICAgICAgIHNldElucHV0OiBmdW5jdGlvbiBzZXRJbnB1dChpbnB1dCwgeXkpIHtcbiAgICAgICAgICB0aGlzLnl5ID0geXkgfHwgdGhpcy55eSB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgICAgIHRoaXMuX21vcmUgPSB0aGlzLl9iYWNrdHJhY2sgPSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxlbmcgPSAwO1xuICAgICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IDAsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IDEsXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogMFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwgMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyBjb25zdW1lcyBhbmQgcmV0dXJucyBvbmUgY2hhciBmcm9tIHRoZSBpbnB1dFxuICAgICAgICBpbnB1dDogZnVuY3Rpb24gaW5wdXQoKSB7XG4gICAgICAgICAgdmFyIGNoID0gdGhpcy5faW5wdXRbMF07XG4gICAgICAgICAgdGhpcy55eXRleHQgKz0gY2g7XG4gICAgICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgICAgICB0aGlzLm9mZnNldCsrO1xuICAgICAgICAgIHRoaXMubWF0Y2ggKz0gY2g7XG4gICAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuICAgICAgICAgIHZhciBsaW5lcyA9IGNoLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcblxuICAgICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubysrO1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlWzFdKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcbiAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHVuc2hpZnRzIG9uZSBjaGFyIChvciBhIHN0cmluZykgaW50byB0aGUgaW5wdXRcbiAgICAgICAgdW5wdXQ6IGZ1bmN0aW9uIHVucHV0KGNoKSB7XG4gICAgICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDtcbiAgICAgICAgICB2YXIgbGluZXMgPSBjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcbiAgICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMueXl0ZXh0LnN1YnN0cigwLCB0aGlzLnl5dGV4dC5sZW5ndGggLSBsZW4pOyAvL3RoaXMueXlsZW5nIC09IGxlbjtcblxuICAgICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcbiAgICAgICAgICB2YXIgb2xkTGluZXMgPSB0aGlzLm1hdGNoLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvZyk7XG4gICAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guc3Vic3RyKDAsIHRoaXMubWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgICBpZiAobGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubyAtPSBsaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByID0gdGhpcy55eWxsb2MucmFuZ2U7XG4gICAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLnl5bGluZW5vICsgMSxcbiAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID8gKGxpbmVzLmxlbmd0aCA9PT0gb2xkTGluZXMubGVuZ3RoID8gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIDogMCkgKyBvbGRMaW5lc1tvbGRMaW5lcy5sZW5ndGggLSBsaW5lcy5sZW5ndGhdLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCA6IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbclswXSwgclswXSArIHRoaXMueXlsZW5nIC0gbGVuXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIGNhY2hlcyBtYXRjaGVkIHRleHQgYW5kIGFwcGVuZHMgaXQgb24gbmV4dCBhY3Rpb25cbiAgICAgICAgbW9yZTogZnVuY3Rpb24gbW9yZSgpIHtcbiAgICAgICAgICB0aGlzLl9tb3JlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIHNpZ25hbHMgdGhlIGxleGVyIHRoYXQgdGhpcyBydWxlIGZhaWxzIHRvIG1hdGNoIHRoZSBpbnB1dCwgc28gdGhlIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbiAgICAgICAgcmVqZWN0OiBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKSArICcuIFlvdSBjYW4gb25seSBpbnZva2UgcmVqZWN0KCkgaW4gdGhlIGxleGVyIHdoZW4gdGhlIGxleGVyIGlzIG9mIHRoZSBiYWNrdHJhY2tpbmcgcGVyc3Vhc2lvbiAob3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIgPSB0cnVlKS5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHJldGFpbiBmaXJzdCBuIGNoYXJhY3RlcnMgb2YgdGhlIG1hdGNoXG4gICAgICAgIGxlc3M6IGZ1bmN0aW9uIGxlc3Mobikge1xuICAgICAgICAgIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGRpc3BsYXlzIGFscmVhZHkgbWF0Y2hlZCBpbnB1dCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbiBwYXN0SW5wdXQoKSB7XG4gICAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gJy4uLicgOiAnJykgKyBwYXN0LnN1YnN0cigtMjApLnJlcGxhY2UoL1xcbi9nLCBcIlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gZGlzcGxheXMgdXBjb21pbmcgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgICAgIHVwY29taW5nSW5wdXQ6IGZ1bmN0aW9uIHVwY29taW5nSW5wdXQoKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuXG4gICAgICAgICAgaWYgKG5leHQubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyKDAsIDIwIC0gbmV4dC5sZW5ndGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwgMjApICsgKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJyA6ICcnKSkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBkaXNwbGF5cyB0aGUgY2hhcmFjdGVyIHBvc2l0aW9uIHdoZXJlIHRoZSBsZXhpbmcgZXJyb3Igb2NjdXJyZWQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG4gICAgICAgIHNob3dQb3NpdGlvbjogZnVuY3Rpb24gc2hvd1Bvc2l0aW9uKCkge1xuICAgICAgICAgIHZhciBwcmUgPSB0aGlzLnBhc3RJbnB1dCgpO1xuICAgICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgICByZXR1cm4gcHJlICsgdGhpcy51cGNvbWluZ0lucHV0KCkgKyBcIlxcblwiICsgYyArIFwiXlwiO1xuICAgICAgICB9LFxuICAgICAgICAvLyB0ZXN0IHRoZSBsZXhlZCB0b2tlbjogcmV0dXJuIEZBTFNFIHdoZW4gbm90IGEgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gdG9rZW5cbiAgICAgICAgdGVzdF9tYXRjaDogZnVuY3Rpb24gdGVzdF9tYXRjaChtYXRjaCwgaW5kZXhlZF9ydWxlKSB7XG4gICAgICAgICAgdmFyIHRva2VuLCBsaW5lcywgYmFja3VwO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgY29udGV4dFxuICAgICAgICAgICAgYmFja3VwID0ge1xuICAgICAgICAgICAgICB5eWxpbmVubzogdGhpcy55eWxpbmVubyxcbiAgICAgICAgICAgICAgeXlsbG9jOiB7XG4gICAgICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgIGZpcnN0X2NvbHVtbjogdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB5eXRleHQ6IHRoaXMueXl0ZXh0LFxuICAgICAgICAgICAgICBtYXRjaDogdGhpcy5tYXRjaCxcbiAgICAgICAgICAgICAgbWF0Y2hlczogdGhpcy5tYXRjaGVzLFxuICAgICAgICAgICAgICBtYXRjaGVkOiB0aGlzLm1hdGNoZWQsXG4gICAgICAgICAgICAgIHl5bGVuZzogdGhpcy55eWxlbmcsXG4gICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgIF9tb3JlOiB0aGlzLl9tb3JlLFxuICAgICAgICAgICAgICBfaW5wdXQ6IHRoaXMuX2lucHV0LFxuICAgICAgICAgICAgICB5eTogdGhpcy55eSxcbiAgICAgICAgICAgICAgY29uZGl0aW9uU3RhY2s6IHRoaXMuY29uZGl0aW9uU3RhY2suc2xpY2UoMCksXG4gICAgICAgICAgICAgIGRvbmU6IHRoaXMuZG9uZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgICAgYmFja3VwLnl5bGxvYy5yYW5nZSA9IHRoaXMueXlsbG9jLnJhbmdlLnNsaWNlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpbmVzID0gbWF0Y2hbMF0ubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuXG4gICAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID8gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1xccj9cXG4/LylbMF0ubGVuZ3RoIDogdGhpcy55eWxsb2MubGFzdF9jb2x1bW4gKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoWzBdO1xuICAgICAgICAgIHRoaXMubWF0Y2ggKz0gbWF0Y2hbMF07XG4gICAgICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICs9IHRoaXMueXlsZW5nXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZShtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTtcbiAgICAgICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHRoaXMsIHRoaXMueXksIHRoaXMsIGluZGV4ZWRfcnVsZSwgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKTtcblxuICAgICAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAvLyByZWNvdmVyIGNvbnRleHRcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYmFja3VwKSB7XG4gICAgICAgICAgICAgIHRoaXNba10gPSBiYWNrdXBba107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIHRoZSBuZXh0IHJ1bGUgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcmV0dXJuIG5leHQgbWF0Y2ggaW4gaW5wdXRcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdG9rZW4sIG1hdGNoLCB0ZW1wTWF0Y2gsIGluZGV4O1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl9tb3JlKSB7XG4gICAgICAgICAgICB0aGlzLnl5dGV4dCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBydWxlcyA9IHRoaXMuX2N1cnJlbnRSdWxlcygpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xuXG4gICAgICAgICAgICBpZiAodGVtcE1hdGNoICYmICghbWF0Y2ggfHwgdGVtcE1hdGNoWzBdLmxlbmd0aCA+IG1hdGNoWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJhY2t0cmFja19sZXhlcikge1xuICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKHRlbXBNYXRjaCwgcnVsZXNbaV0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyBhIHJ1bGUgTUlTbWF0Y2guXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKG1hdGNoLCBydWxlc1tpbmRleF0pO1xuXG4gICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH0gLy8gZWxzZTogdGhpcyBpcyBhIGxleGVyIHJ1bGUgd2hpY2ggY29uc3VtZXMgaW5wdXQgd2l0aG91dCBwcm9kdWNpbmcgYSB0b2tlbiAoZS5nLiB3aGl0ZXNwYWNlKVxuXG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5faW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gVW5yZWNvZ25pemVkIHRleHQuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gcmV0dXJuIG5leHQgbWF0Y2ggdGhhdCBoYXMgYSB0b2tlblxuICAgICAgICBsZXg6IGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xuXG4gICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG4gICAgICAgIGJlZ2luOiBmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb24gc3RhY2tcbiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgICAgICAgIHZhciBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBwcm9kdWNlIHRoZSBsZXhlciBydWxlIHNldCB3aGljaCBpcyBhY3RpdmUgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZVxuICAgICAgICBfY3VycmVudFJ1bGVzOiBmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAmJiB0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbnNbdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdXS5ydWxlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1tcIklOSVRJQUxcIl0ucnVsZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyByZXR1cm4gdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlOyB3aGVuIGFuIGluZGV4IGFyZ3VtZW50IGlzIHByb3ZpZGVkIGl0IHByb2R1Y2VzIHRoZSBOLXRoIHByZXZpb3VzIGNvbmRpdGlvbiBzdGF0ZSwgaWYgYXZhaWxhYmxlXG4gICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbiB0b3BTdGF0ZShuKSB7XG4gICAgICAgICAgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMSAtIE1hdGguYWJzKG4gfHwgMCk7XG5cbiAgICAgICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1tuXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiSU5JVElBTFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gYWxpYXMgZm9yIGJlZ2luKGNvbmRpdGlvbilcbiAgICAgICAgcHVzaFN0YXRlOiBmdW5jdGlvbiBwdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICAgICAgdGhpcy5iZWdpbihjb25kaXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICAvLyByZXR1cm4gdGhlIG51bWJlciBvZiBzdGF0ZXMgY3VycmVudGx5IG9uIHRoZSBzdGFja1xuICAgICAgICBzdGF0ZVN0YWNrU2l6ZTogZnVuY3Rpb24gc3RhdGVTdGFja1NpemUoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zOiB7fSxcbiAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5LCB5eV8sICRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsIFlZX1NUQVJUKSB7XG4gICAgICAgICAgc3dpdGNoICgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIC8qIHNraXAgd2hpdGVzcGFjZSAqL1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICByZXR1cm4gNjtcblxuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB5eV8ueXl0ZXh0ID0geXlfLnl5dGV4dC5zdWJzdHIoMSwgeXlfLnl5bGVuZyAtIDIpO1xuICAgICAgICAgICAgICByZXR1cm4gNDtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXR1cm4gMTc7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgcmV0dXJuIDE4O1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHJldHVybiAyMztcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICByZXR1cm4gMjQ7XG5cbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgcmV0dXJuIDIyO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHJldHVybiAyMTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICByZXR1cm4gMTA7XG5cbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHJldHVybiAxMTtcblxuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgcmV0dXJuIDg7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHJldHVybiAxNDtcblxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEJztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bGVzOiBbL14oPzpcXHMrKS8sIC9eKD86KC0/KFswLTldfFsxLTldWzAtOV0rKSkoXFwuWzAtOV0rKT8oW2VFXVstK10/WzAtOV0rKT9cXGIpLywgL14oPzpcIig/OlxcXFxbXFxcXFwiYmZucnQvXXxcXFxcdVthLWZBLUYwLTldezR9fFteXFxcXFxcMC1cXHgwOVxceDBhLVxceDFmXCJdKSpcIikvLCAvXig/OlxceykvLCAvXig/OlxcfSkvLCAvXig/OlxcWykvLCAvXig/OlxcXSkvLCAvXig/OiwpLywgL14oPzo6KS8sIC9eKD86dHJ1ZVxcYikvLCAvXig/OmZhbHNlXFxiKS8sIC9eKD86bnVsbFxcYikvLCAvXig/OiQpLywgL14oPzouKS9dLFxuICAgICAgICBjb25kaXRpb25zOiB7XG4gICAgICAgICAgXCJJTklUSUFMXCI6IHtcbiAgICAgICAgICAgIFwicnVsZXNcIjogWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzXSxcbiAgICAgICAgICAgIFwiaW5jbHVzaXZlXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gbGV4ZXI7XG4gICAgfSgpO1xuXG4gICAgcGFyc2VyLmxleGVyID0gbGV4ZXI7XG5cbiAgICBmdW5jdGlvbiBQYXJzZXIoKSB7XG4gICAgICB0aGlzLnl5ID0ge307XG4gICAgfVxuXG4gICAgUGFyc2VyLnByb3RvdHlwZSA9IHBhcnNlcjtcbiAgICBwYXJzZXIuUGFyc2VyID0gUGFyc2VyO1xuICAgIHJldHVybiBuZXcgUGFyc2VyKCk7XG4gIH0oKTtcblxuICBpZiAodHlwZW9mIGNvbW1vbmpzUmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgJ29iamVjdCcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgZXhwb3J0cy5QYXJzZXIgPSBwYXJzZXIuUGFyc2VyO1xuXG4gICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBwYXJzZXIucGFyc2UuYXBwbHkocGFyc2VyLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiByZWFkU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycgfHwgc3R5bGUgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGpzb25saW50LnBhcnNlKHN0eWxlLnRvU3RyaW5nKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBQYXJzaW5nRXJyb3IkMShlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3R5bGUoc3R5bGUpIHtcbiAgdmFyIHN0eWxlU3BlYyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdjg7XG4gIHZhciBzID0gc3R5bGU7XG5cbiAgdHJ5IHtcbiAgICBzID0gcmVhZFN0eWxlKHMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIFtlXTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZVN0eWxlTWluKHMsIHN0eWxlU3BlYyk7XG59XG5cbnZhciBTVVBQT1JURURfU1BFQ19WRVJTSU9OID0gODtcbnZhciBNQVhfU09VUkNFU19JTl9TVFlMRSA9IDE1O1xuXG5mdW5jdGlvbiBpc1ZhbGlkKHZhbHVlLCByZWdleCkge1xuICBpZiAoIXZhbHVlIHx8IGdldFR5cGUodmFsdWUpICE9PSAnc3RyaW5nJykgcmV0dXJuIHRydWU7XG4gIHJldHVybiAhIXZhbHVlLm1hdGNoKHJlZ2V4KTtcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlQ291bnQoc291cmNlKSB7XG4gIGlmIChzb3VyY2UudXJsKSB7XG4gICAgcmV0dXJuIHNvdXJjZS51cmwuc3BsaXQoJywnKS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWxsb3dlZEtleUVycm9ycyhvYmosIGtleXMsIHBhdGgpIHtcbiAgdmFyIGFsbG93ZWQgPSBuZXcgU2V0KGtleXMpO1xuICB2YXIgZXJyb3JzID0gW107XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGlmICghYWxsb3dlZC5oYXMoaykpIHtcbiAgICAgIHZhciBwcm9wID0gcGF0aCA/IFwiXCIuY29uY2F0KHBhdGgsIFwiLlwiKS5jb25jYXQoaykgOiBudWxsO1xuICAgICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihwcm9wLCBvYmpba10sIFwiVW5zdXBwb3J0ZWQgcHJvcGVydHkgXFxcIlwiLmNvbmNhdChrLCBcIlxcXCJcIikpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VFcnJvcnMoc291cmNlLCBpKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIHNvdXJjZUtleXMgPSBbJ3R5cGUnLCAndXJsJywgJ3RpbGVTaXplJ107XG4gIGVycm9ycy5wdXNoLmFwcGx5KGVycm9ycywgX3RvQ29uc3VtYWJsZUFycmF5KGdldEFsbG93ZWRLZXlFcnJvcnMoc291cmNlLCBzb3VyY2VLZXlzLCAnc291cmNlJykpKTtcbiAgdmFyIHNvdXJjZVVybFBhdHRlcm4gPSAvXm1hcGJveDpcXC9cXC8oW14vXSopJC87XG5cbiAgaWYgKCFpc1ZhbGlkKHNvdXJjZS51cmwsIHNvdXJjZVVybFBhdHRlcm4pKSB7XG4gICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcihcInNvdXJjZXNbXCIuY29uY2F0KGksIFwiXVwiKSwgc291cmNlLnVybCwgJ1NvdXJjZSB1cmwgbXVzdCBiZSBhIHZhbGlkIE1hcGJveCB0aWxlc2V0IHVybCcpKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvcnM7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZXNFcnJvcnMoc291cmNlcykge1xuICB2YXIgZXJyb3JzID0gW107XG4gIHZhciBjb3VudCA9IDA7XG4gIE9iamVjdC5rZXlzKHNvdXJjZXMpLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICB2YXIgc291cmNlRXJyb3JzID0gZ2V0U291cmNlRXJyb3JzKHNvdXJjZXNbc10sIGkpO1xuXG4gICAgaWYgKCFzb3VyY2VFcnJvcnMubGVuZ3RoKSB7XG4gICAgICBjb3VudCA9IGNvdW50ICsgZ2V0U291cmNlQ291bnQoc291cmNlc1tzXSk7XG4gICAgfVxuXG4gICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBfdG9Db25zdW1hYmxlQXJyYXkoc291cmNlRXJyb3JzKSk7XG4gIH0pO1xuXG4gIGlmIChjb3VudCA+IE1BWF9TT1VSQ0VTX0lOX1NUWUxFKSB7XG4gICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcignc291cmNlcycsIG51bGwsIFwiU3R5bGVzIG11c3QgY29udGFpbiBcIi5jb25jYXQoTUFYX1NPVVJDRVNfSU5fU1RZTEUsIFwiIG9yIGZld2VyIHNvdXJjZXNcIikpKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvcnM7XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RFcnJvcnMoc3R5bGUsIHNwZWNLZXlzKSB7XG4gIHZhciBlcnJvcnMgPSBbXTtcbiAgdmFyIG9wdGlvbmFsUm9vdFByb3BlcnRpZXMgPSBbJ293bmVyJywgJ2lkJywgJ2NhY2hlQ29udHJvbCcsICdkcmFmdCcsICdjcmVhdGVkJywgJ21vZGlmaWVkJywgJ3Zpc2liaWxpdHknXTtcbiAgdmFyIGFsbG93ZWRLZXlFcnJvcnMgPSBnZXRBbGxvd2VkS2V5RXJyb3JzKHN0eWxlLCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHNwZWNLZXlzKSwgb3B0aW9uYWxSb290UHJvcGVydGllcykpO1xuICBlcnJvcnMucHVzaC5hcHBseShlcnJvcnMsIF90b0NvbnN1bWFibGVBcnJheShhbGxvd2VkS2V5RXJyb3JzKSk7XG5cbiAgaWYgKHN0eWxlLnZlcnNpb24gPiBTVVBQT1JURURfU1BFQ19WRVJTSU9OIHx8IHN0eWxlLnZlcnNpb24gPCBTVVBQT1JURURfU1BFQ19WRVJTSU9OKSB7XG4gICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcigndmVyc2lvbicsIHN0eWxlLnZlcnNpb24sIFwiU3R5bGUgdmVyc2lvbiBtdXN0IGJlIFwiLmNvbmNhdChTVVBQT1JURURfU1BFQ19WRVJTSU9OKSkpO1xuICB9XG5cbiAgdmFyIGdseXBoVXJsUGF0dGVybiA9IC9ebWFwYm94OlxcL1xcL2ZvbnRzXFwvKFteL10qKVxcL3tmb250c3RhY2t9XFwve3JhbmdlfS5wYmYkLztcblxuICBpZiAoIWlzVmFsaWQoc3R5bGUuZ2x5cGhzLCBnbHlwaFVybFBhdHRlcm4pKSB7XG4gICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcignZ2x5cGhzJywgc3R5bGUuZ2x5cGhzLCAnU3R5bGVzIG11c3QgcmVmZXJlbmNlIGdseXBocyBob3N0ZWQgYnkgTWFwYm94JykpO1xuICB9XG5cbiAgdmFyIHNwcml0ZVVybFBhdHRlcm4gPSAvXm1hcGJveDpcXC9cXC9zcHJpdGVzXFwvKFteL10qKVxcLyhbXi9dKilcXC8/KFteL10qKT8kLztcblxuICBpZiAoIWlzVmFsaWQoc3R5bGUuc3ByaXRlLCBzcHJpdGVVcmxQYXR0ZXJuKSkge1xuICAgIGVycm9ycy5wdXNoKG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3Nwcml0ZScsIHN0eWxlLnNwcml0ZSwgJ1N0eWxlcyBtdXN0IHJlZmVyZW5jZSBzcHJpdGVzIGhvc3RlZCBieSBNYXBib3gnKSk7XG4gIH1cblxuICB2YXIgdmlzaWJpbGl0eVBhdHRlcm4gPSAvXihwdWJsaWN8cHJpdmF0ZSkkLztcblxuICBpZiAoIWlzVmFsaWQoc3R5bGUudmlzaWJpbGl0eSwgdmlzaWJpbGl0eVBhdHRlcm4pKSB7XG4gICAgZXJyb3JzLnB1c2gobmV3IFZhbGlkYXRpb25FcnJvcigndmlzaWJpbGl0eScsIHN0eWxlLnZpc2liaWxpdHksICdTdHlsZSB2aXNpYmlsaXR5IG11c3QgYmUgcHVibGljIG9yIHByaXZhdGUnKSk7XG4gIH1cblxuICByZXR1cm4gZXJyb3JzO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1hcGJveEFwaVN1cHBvcnRlZChzdHlsZSkge1xuICB2YXIgcyA9IHN0eWxlO1xuXG4gIHRyeSB7XG4gICAgcyA9IHJlYWRTdHlsZShzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBbZV07XG4gIH1cblxuICB2YXIgZXJyb3JzID0gdmFsaWRhdGVTdHlsZU1pbihzLCB2OCkuY29uY2F0KGdldFJvb3RFcnJvcnMocywgT2JqZWN0LmtleXModjguJHJvb3QpKSk7XG5cbiAgaWYgKHMuc291cmNlcykge1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZ2V0U291cmNlc0Vycm9ycyhzLnNvdXJjZXMpKTtcbiAgfVxuXG4gIHJldHVybiBlcnJvcnM7XG59XG5cbnZhciBleHByZXNzaW9uJDEgPSB7XG4gIFN0eWxlRXhwcmVzc2lvbjogU3R5bGVFeHByZXNzaW9uLFxuICBpc0V4cHJlc3Npb246IGlzRXhwcmVzc2lvbixcbiAgaXNFeHByZXNzaW9uRmlsdGVyOiBpc0V4cHJlc3Npb25GaWx0ZXIsXG4gIGNyZWF0ZUV4cHJlc3Npb246IGNyZWF0ZUV4cHJlc3Npb24sXG4gIGNyZWF0ZVByb3BlcnR5RXhwcmVzc2lvbjogY3JlYXRlUHJvcGVydHlFeHByZXNzaW9uLFxuICBub3JtYWxpemVQcm9wZXJ0eUV4cHJlc3Npb246IG5vcm1hbGl6ZVByb3BlcnR5RXhwcmVzc2lvbixcbiAgWm9vbUNvbnN0YW50RXhwcmVzc2lvbjogWm9vbUNvbnN0YW50RXhwcmVzc2lvbixcbiAgWm9vbURlcGVuZGVudEV4cHJlc3Npb246IFpvb21EZXBlbmRlbnRFeHByZXNzaW9uLFxuICBTdHlsZVByb3BlcnR5RnVuY3Rpb246IFN0eWxlUHJvcGVydHlGdW5jdGlvblxufTtcbnZhciBzdHlsZUZ1bmN0aW9uID0ge1xuICBjb252ZXJ0RnVuY3Rpb246IGNvbnZlcnRGdW5jdGlvbixcbiAgY3JlYXRlRnVuY3Rpb246IGNyZWF0ZUZ1bmN0aW9uLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uJDFcbn07XG52YXIgdmlzaXQgPSB7XG4gIGVhY2hTb3VyY2U6IGVhY2hTb3VyY2UsXG4gIGVhY2hMYXllcjogZWFjaExheWVyLFxuICBlYWNoUHJvcGVydHk6IGVhY2hQcm9wZXJ0eVxufTtcbnZhbGlkYXRlU3R5bGUucGFyc2VkID0gdmFsaWRhdGVTdHlsZTtcbnZhbGlkYXRlU3R5bGUubGF0ZXN0ID0gdmFsaWRhdGVTdHlsZTtcbmV4cG9ydCB7IENvbG9yLCBQYXJzaW5nRXJyb3IkMSBhcyBQYXJzaW5nRXJyb3IsIFZhbGlkYXRpb25FcnJvciwgY29tcG9zaXRlLCBjb252ZXJ0RmlsdGVyJDEgYXMgY29udmVydEZpbHRlciwgZGVyZWZMYXllcnMsIGRpZmZTdHlsZXMgYXMgZGlmZiwgZXhwcmVzc2lvbiQxIGFzIGV4cHJlc3Npb24sIGNyZWF0ZUZpbHRlciBhcyBmZWF0dXJlRmlsdGVyLCBmb3JtYXQsIHN0eWxlRnVuY3Rpb24gYXMgZnVuY3Rpb24sIHY4IGFzIGxhdGVzdCwgbWlncmF0ZSwgdjgsIHZhbGlkYXRlU3R5bGUgYXMgdmFsaWRhdGUsIHZhbGlkYXRlTWFwYm94QXBpU3VwcG9ydGVkLCB2aXNpdCB9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3022\n')}}]);